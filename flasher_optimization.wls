#!/usr/bin/env wolframscript
(* ::Package:: *)

$TessellaticaLoadStartTime=SessionTime[];
ShowExample[expr_]:=If[$ShowExample,expr,Null]
SetAttributes[ShowExample,HoldAllComplete];
$ShowExample=False;
ShowExample[Print["ShowExample is turned on"]]
ShowErrorExample[expr_]:=If[$ShowErrorExample,expr,Null]
SetAttributes[ShowErrorExample,HoldAllComplete];
$ShowErrorExample=False;
ShowErrorExample[Print["ShowErrorExample is turned on"]]
$ExamplesDir="~/Desktop/tessellatica-examples";
ExamplesDir::nocreate="Tessellatica was unsable to create the examples directory at `1`.";
ExamplesDir[]:=Module[{path,dir},
path=$ExamplesDir;
If[DirectoryQ[path],
path<>"/",
dir=CreateDirectory[path];
If[dir===$Failed,Message[];Abort[]];
path<>"/"]]
Module[{},
ExamplesDir[]
]//ShowExample
PrintThis[expr_]:=With[{y=expr},Print[HoldForm[expr]," = ",y];y]
SetAttributes[PrintThis,HoldFirst];
Module[{foo=1},
PrintThis[++foo]
]//ShowExample
Off[General::spell,General::spell1];
SetOptions[Graphics,PlotRange->All,AspectRatio->Automatic];
SetOptions[Graphics3D,Boxed->False, AspectRatio->Automatic, PlotRange->All,Lighting->"Neutral", ViewProjection -> "Orthographic"];
AllColors={
Red, (* =RGBColor[1,0,0] *)
Green, (* = RGBColor[0,1,0] *)
Blue, (* = RGBColor[0,0,1] *)
Cyan,
Magenta,
Orange, (* = RGBColor[1,.5,0] *)
White, (* =GrayLevel[1] *)
LightGray ,(* =GrayLevel[.75] *)
Gray, (* = GrayLevel[.5] *)
DarkGray=GrayLevel[.25],
Black (* = GrayLevel[0] *)
};
Show[Graphics[Table[{AllColors[[i]],Polygon[#],Black,Line[Append[#,#[[1]]]]}&[{{i,0},{i+1,0},{i+1,1},{i,1}}],{i,Length[AllColors]}]]
]//ShowExample
AllColorsCMYK={
RedCMYK=ColorConvert[Red,"CMYK"],
GreenCMYK=ColorConvert[Green,"CMYK"],
BlueCMYK=ColorConvert[Blue,"CMYK"],
CyanCMYK=ColorConvert[Cyan,"CMYK"],
MagentaCMYK=ColorConvert[Magenta,"CMYK"],
OrangeCMYK=ColorConvert[Orange,"CMYK"],
WhiteCMYK=ColorConvert[White,"CMYK"],
LightGrayCMYK=ColorConvert[LightGray,"CMYK"],
GrayCMYK=ColorConvert[Gray,"CMYK"],
DarkGrayCMYK=ColorConvert[DarkGray,"CMYK"],
BlackCMYK=ColorConvert[Black,"CMYK"]
};
Show[Graphics[Table[{AllColorsCMYK[[i]],Polygon[#],Black,Line[Append[#,#[[1]]]]}&[{{i,0},{i+1,0},{i+1,1},{i,1}}],{i,Length[AllColors]}]]
]//ShowExample
Rainbow[n_]:=Table[Hue[.75(i-1)/(n-1)],{i,n}]
Rainbow[7]//ShowExample
Mod4[n_]:=Mod[n,4,1]
ListEmptyQ[list_List]:=Length[list]==0
NotListEmptyQ[list_List]:=Length[list]!=0
IntersectingQ[{a,b,c},{d,e}]//ShowExample
IntersectingQ[{a,b,c},{a,e}]//ShowExample
MemberQ[{a,b,c},a]//ShowExample
MemberQ[{a,b,c},d]//ShowExample
CyclicSameQ[l1_,l2_]:=Or@@(SameQ[l1,#]&/@Table[RotateLeft[l2,n],{n,Length[l2]}])
CyclicSameQ[{1,2,3,4},{3,4,1,5}]//ShowExample
DeleteItem[expr_,pattern_]:=Delete[expr,Position[expr,pattern]]
DeleteItems[expr_,patterns_List]:=Delete[expr ,Flatten[Position[expr,#]&/@patterns,1]]
DropFirst[list_List]:=Drop[list,1]
DropLast[list_List]:=Drop[list,-1]
DropEnds[list_List]:=Drop[Drop[list,1],-1]
AppendFirst[list_]:=Append[list,list[[1]]]
AppendFirst[{a,b,c,d}]//ShowExample
GraphicsRow[{Graphics[{}]}];
(*SetAttributes[JoinTo,HoldFirst];*)
(*JoinTo[list1_,list2___]:=(list1=Join[Evaluate[list1],list2])*)
Module[{list1,list2,list3},
list1={a,b,c};
list2={d,e,f};
list3={g,h,i};
JoinTo[list1,list2,list3];
list1]//ShowExample
HasRuleQ[list_List,lhs_]:=MemberQ[list,lhs->_]
HasRuleQ[{a->1,b->2},a]//ShowExample
HasRuleQ[{a->1,b->2},c]//ShowExample
RulePositionFirst[list_List, lhs_]:=Module[{pos},
pos=Position[list,lhs->_,{1},1];
If[ListEmptyQ[pos],0,pos[[1,1]]]]
RulePositionFirst[{a->1,b->2,b->3},b]//ShowExample
RulePositionFirst[{a->1,b->2,b->3},c]//ShowExample
ReplaceRule[list_List,lhs_->rhs_]:=list/.(lhs->_)->(lhs->rhs)
ReplaceRule[{a->1,b->2,c->3},b->4]//ShowExample
ReplaceRule[{a->1,b->2,c->3},d->4]//ShowExample
ReplaceOrAppendRule[list_,lhs_->rhs_]:=If[HasRuleQ[list,lhs],ReplaceRule[list,lhs->rhs],Append[list,lhs->rhs]]
ReplaceOrAppendRule[{a->1,b->2,c->3},b->4]//ShowExample
ReplaceOrAppendRule[{a->1,b->2,c->3},d->4]//ShowExample
ReplaceOrPrependRule[list_,lhs_->rhs_]:=If[HasRuleQ[list,lhs],ReplaceRule[list,lhs->rhs],Prepend[list,lhs->rhs]]
ReplaceOrPrependRule[{a->1,b->2,c->3},b->4]//ShowExample
ReplaceOrPrependRule[{a->1,b->2,c->3},d->4]//ShowExample
DeleteRule[list_List,lhs_]:=DeleteCases[list,lhs->_,{1}]
DeleteRule[{a->1,b->2,c->3},b]//ShowExample
MoveRule::norule="List `1` does not contain a rule with lhs `2`.";
MoveRule[list_List, lhs_, n_]:=Module[{pos},
pos=RulePositionFirst[list,lhs];
If[pos==0,Message[MoveRule::norule,list,lhs];Abort[]];
Insert[DeleteRule[list,lhs],list[[pos]],n]]
MoveRule[{a->1,b->2,c->3},b,1]//ShowExample
MoveRule[{a->1,b->2,c->3},b,-1]//ShowExample
MoveRule[{a->1,b->2,c->3},d,1]//ShowErrorExample
AppendToInRule::nolhs="A rule for `1` does not exist in `2`.";
AppendToInRule::notlist="The rule `1` does not specify a List.";
AppendToInRule[list_List,lhs_,elem_]:=Module[{pos,rhs},
pos=RulePositionFirst[list,lhs];
If[pos==0,Message[AppendToInRule::nolhs,lhs,list];Abort[]];
rhs=lhs/.list[[pos]];
If[!Head[rhs]===List,Message[AppendToInRule::notlist,lhs->rhs];Abort[]];
ReplaceRule[list,lhs->Append[rhs,elem]]]
AppendToInRule[{a->1,b->{2,3,4},c->5},b,6]//ShowExample
AppendToInRule[{a->1,b->{2,3,4},c->5},d,6]//ShowErrorExample
AppendToInRule[{a->1,b->2,c->5},b,6]//ShowErrorExample
FunctionTransform[g_,f_]:=Module[{point,line,polygon,sphere,tube,text,arrow,g1,g2},
g1=g/.GraphicsComplex[verts_,expr_]:>GraphicsComplex[f/@verts,expr/.{
Point[x_]:>point[x],
Line[x_]:>line[x],
Polygon[x_]:>polygon[x],
Sphere[x___]:>sphere[x],
Tube[x_]:>tube[x],
Arrow[x___]:>arrow[x],
Text[x___]:>text[x]
}];
g2=g1/.{
Point[x_]:>Point[f[x]],
Line[x_]:>Line[f/@x],
Polygon[x_]:>Polygon[f/@x],
Sphere[x_,y___]:>Sphere[f[x],y],
Arrow[Tube[x_,r___],y___]:>Arrow[Tube[f/@x,r],y],
Tube[x_]:>Tube[f/@x],
Arrow[x_,y___]:>Arrow[f/@x,y],
Text[x_,y_,z___]:>Text[x,f[y],z]
};
g2/.{
point[x_]:>Point[x],
line[x_]:>Line[x],
polygon[x_]:>Polygon[x],
sphere[x___]:>Sphere[x],
tube[x___]:>Tube[x],
arrow[x___]:>Arrow[x],
text[x___]:>Text[x]
}]
Module[{g},
g={Point[{1,0}],GraphicsComplex[{{0,0},{0,1}},Line[{1,2}]]};
FunctionTransform[g,2#&]
]//ShowExample
MatrixTransform[g_,m_]:=FunctionTransform[g,m . #&]
Hav[\[Xi]_]:=(1/2)(1-Cos[\[Xi]])
Plot[Hav[\[Xi] \[Degree]],{\[Xi],0,360}]//ShowExample
ArcHav[x_]:=ArcCos[1-2x]
Plot[ArcHav[x]/\[Degree],{x,0,1}]//ShowExample
ArcTanAlt[x_,y_]:=2 ArcTan[y/(Sqrt[x^2+y^2]+x)]
Module[{x,y},
{x,y}={1,0};Print[{x,y,ArcTanAlt[x,y]}];
{x,y}={0,1};Print[{x,y,ArcTanAlt[x,y]}];
{x,y}={1,1};Print[{x,y,ArcTanAlt[x,y]}//Simplify];
{x,y}={0,-1};Print[{x,y,ArcTanAlt[x,y]}];
{x,y}={-1,-1};Print[{x,y,ArcTanAlt[x,y]}//Simplify];
]//ShowExample
Simplification::usage="Simplification is an option to various functions that specifies the form of simplification to use on intermediate results within the function.";
Options[Simplification]={
Simplification->None,
Assumptions->$Assumptions
};
Module[{si,as,sfn,opts},
opts=Sequence[Simplification->None];
si=Simplification/.{opts}/.Options[Simplification];
as=Assumptions/.{opts}/.Options[Simplification];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
PrintThis[sfn];
(x-1)(x+1)(x^2+1)+1//sfn
]//ShowExample
Module[{si,as,sfn,opts},
opts=Sequence[Simplification->Simplify];
si=Simplification/.{opts}/.Options[Simplification];
as=Assumptions/.{opts}/.Options[Simplification];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
PrintThis[sfn];
(x-1)(x+1)(x^2+1)+1//sfn
]//ShowExample
CombineSquareRootsInProducts[expr_]:=Module[{combi},
combi[times_]:=Module[{sr,nsr},
sr=Select[times,MatchQ[#,Power[_,Rational[1,2]]]&];nsr=Select[times,!MatchQ[#,Power[_,Rational[1,2]]]&];
If[Length[sr]>1,Power[Times@@(First/@sr),Rational[1,2]]Times@@nsr,times]];
expr/.prod_Times:>combi[prod]]
Block[{x,y,z,expr},
expr=2 * Sqrt[x]* y * Sqrt[z];
Print["expr = ",expr];
Print["FullSimplify[expr] = ",FullSimplify[expr]];
expr=CombineSquareRootsInProducts[expr];
Print["CombineSquareRootsInProducts[expr] = ",expr]
]//ShowExample
SlotCount[f_Function]:=Module[{sls},
sls=Sort[Union[Cases[f,Slot[_],\[Infinity]]]];
If[ListEmptyQ[sls],0,sls[[-1,1]]]]
SlotCount[{}&]//ShowExample
SlotCount[{#}&]//ShowExample
SlotCount[{#1,#2}&]//ShowExample
SlotCount[{#2}&]//ShowExample
Functionize[x_,expr_]:=Functionize[{x},expr]
Functionize[vars_List,expr_]:=Module[{fs,vr,sl,fn},
(* rules to substitute Slot[i] for variables *)
vr=MapIndexed[#1->sl[#2[[1]]]&,Flatten[vars]]/.sl->Slot;
(* replace variables with Slot[i] and wrap with Function *)
fn[expr/.vr]/.fn->Function]
Module[{f},
f=1+x^2;
Functionize[f,x]
]//ShowExample
Module[{f},
f=x^2+2 x y + y^2;
Functionize[f,{x,y}]
]//ShowExample
Module[{x,expr,f1,f2},
expr=x^2;
f1=Function[x,expr];
PrintThis[f1];
f2=Functionize[x,expr];
PrintThis[f2];
]//ShowExample
Module[{x,f1,f2},
f1=Function[x,2+2x^2-1-x^2];
PrintThis[f1];
f2=Functionize[x,2+x^2-1-x^2];
PrintThis[f2];
]//ShowExample
FunctionizeOld[expr_,x_]:=FunctionizeOld[expr,{x}]
FunctionizeOld[expr_,vars_List]:=Module[{fs,vr,sl,fn},
(* rules to substitute Slot[i] for variables *)
vr=MapIndexed[#1->sl[#2[[1]]]&,Flatten[vars]]/.sl->Slot;
(* replace variables with Slot[i] and wrap with Function *)
fn[expr/.vr]/.fn->Function]
Module[{f},
f=1+x^2;
FunctionizeOld[f,x]
]//ShowExample
Module[{f},
f=x^2+2 x y + y^2;
FunctionizeOld[f,{x,y}]
]//ShowExample
PrettyParameters::badvars="There are not enough variables in `1` to cover `2` function slots.";
PrettyParameters[expr_,vars_List:{}]:=Module[{ppfn},
ppfn[f_]:=Module[{sls,sn},
sn=SlotCount[f];
Which[
sn==0,f[],
sn==1,If[ListEmptyQ[vars],
f["t"],
f@@Take[vars,1]],
sn>=2,If[ListEmptyQ[vars],
If[sn>6,Message[PrettyParameters::badvars,"the default list",sn];Abort[]];
f@@Take[{"u","v","w","x","y","z"},sn],
If[sn>Length[vars],Message[PrettyParameters::badvars,vars,sn];Abort[]];
f@@Take[vars,sn]],
True,f]];
expr/.{ff_Function:>ppfn[ff]}]
{}&//PrettyParameters//ShowExample
{#}&//PrettyParameters//ShowExample
{#2,#1,#2^2 Sin[#1]}&//PrettyParameters//ShowExample
{#2,#3,#2^2 Sin[#3]}&//PrettyParameters//ShowExample
{{}&,
{#}&,
{#2,#1,#2^2 Sin[#1]}&,
{#2,#3,#2^2 Sin[#3]}&}//PrettyParameters//ColumnForm//ShowExample
{#2,#3,#2^2 Sin[#3]}&//PrettyParameters[#,{"a","b","c"}]&//ShowExample
Module[{t,fn,t0,t1,fni},
fn=#^2&;
{t0,t1}={0,1};
fni=FunctionInterpolation[D[fn[t],t],{t,t0,t1}];
]//ShowErrorExample
Module[{t,fn,t0,t1,fni,fopts},
fn=#^2&;
{t0,t1}={0,1};
fni=With[{fnt=D[fn[t],t]},FunctionInterpolation[fnt,{t,t0,t1}]];
]//ShowExample
Module[{t,fn,t0,t1,fni,fopts},
fn=#^2&;
{t0,t1}={0,1};
fopts=Sequence[InterpolationPoints->20];
fni=FunctionInterpolation[fn[t],{t,t0,t1},fopts];
]//ShowErrorExample
Module[{t,fn,t0,t1,fni,fopts},
fn=#^2&;
{t0,t1}={0,1};
fopts=Sequence[InterpolationPoints->20];
fni=FunctionInterpolation[fn[t],{t,t0,t1},Evaluate[fopts]];
]//ShowExample
Module[{s,f0,f1,f2,f3},
f0=ListInterpolation[{1,4,2,5,3}//N,{0,1}];
PrintThis[f0];
f1=Functionize[s,f0'[s]];
PrintThis[f1];
f2=Functionize[s,f1'[s]];
PrintThis[f2];
GraphicsRow[{
Plot[f0[s],{s,0,1},PlotLabel->"f0"],
Plot[f1[s],{s,0,1},PlotLabel->"f1"],
Plot[f2[s],{s,0,1},PlotLabel->"f2"]}]
]//ShowExample
Module[{s,f0,f1,f1a,f2,f3},
f0=ListInterpolation[{1,4,2,5,3}//N,{0,1}];
PrintThis[f0];
f1=Functionize[s,f0'[s]];
PrintThis[f1];
f1a=FunctionInterpolation[f1[s],{s,0,1}];
PrintThis[f1a];
f2=Functionize[s,f1a'[s]];
PrintThis[f2];
GraphicsRow[{
Plot[f0[s],{s,0,1},PlotLabel->"f0"],
Plot[{f1[s],f1a[s]},{s,0,1},PlotLabel->"f1,f1a"],
Plot[f2[s],{s,0,1},PlotLabel->"f2"]}]
]//ShowExample
Module[{s,f0,f1,f1a,f1b,f2,f3},
f0=ListInterpolation[{1,4,2,5,3}//N,{0,1}];
PrintThis[f0];
f1=Functionize[s,f0'[s]];
PrintThis[f1];
f1a=FunctionInterpolation[f1[s],{s,0,1}];
f1b=ListInterpolation[Table[f1[s],{s,0,1,1/10}],{0,1},InterpolationOrder->4];
f2=Functionize[s,f1b'[s]];
PrintThis[f2];
GraphicsRow[{
Plot[f0[s],{s,0,1},PlotLabel->"f0"],
Plot[{f1[s],f1a[s],f1b[s]},{s,0,1},PlotLabel->"f1,f1a,f1b"],
Plot[f2[s],{s,0,1},PlotLabel->"f2"]}]
]//ShowExample
Resample::usage="Resample is an option to FunctionInterpolationAlt that specifies whether to sample the function evenly and use just the sampled values, rather than using the default adaptive algorithm.";
Options[FunctionInterpolationAlt]={
Resample->False,
InterpolationPoints->Automatic
};
FunctionInterpolationAlt::baddom="`1` is a bad domain specification for FunctionInterpolationAlt.";
FunctionInterpolationAlt[expr_,domain_List,opts___]:=Module[{rs,fopts,ip,liopts,n,fns,t,t0,t1,vals,flist},
rs=Resample/.{opts}/.Options[FunctionInterpolationAlt];
fopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
If[Length[domain]!=3,Message[FunctionInterpolationAlt::baddom,domain];Abort[]];
If[rs,
(* Resample *)
ip=InterpolationPoints/.{opts}/.Options[FunctionInterpolationAlt];
If[ip===Automatic,ip=InterpolationPoints/.Options[FunctionInterpolation]];
liopts=Sequence@@FilterRules[{opts},Options[ListInterpolation]];
{t,t0,t1}=domain;
vals=Table[expr/.{t->t0+i/ip (t1-t0)},{i,0,ip}];
If[Head[expr]===List,
(* resample, vector-valued function *)
vals=Transpose[vals];
flist=ListInterpolation[#,{t0,t1},liopts]&/@vals;
Functionize[t,#[t]&/@flist],
(* resample, scalar-valued function *)
ListInterpolation[vals,{t0,t1},liopts]],
(* Use FunctionInterpolation *)
If[Head[expr]===List,
(* interpolated, vector-valued function *)
n=Length[expr];
fns=Table[FunctionInterpolation[expr[[i]],domain,Evaluate[fopts]],{i,n}];
Functionize[t,#[t]&/@fns],
(* interpolated, scalar-valued function *)
FunctionInterpolation[expr,domain,Evaluate[fopts]]]]]
Module[{x,x0,x1,f,f1,f2},
{x0,x1}={0,1};
f=Functionize[x,1+.5x^2-.5x^3];
f1=FunctionInterpolationAlt[f[x],{x,x0,x1}];
f2=FunctionInterpolationAlt[f[x],{x,x0,x1},Resample->True];
GraphicsRow[{
Plot[f[x],{x,x0,x1}],
Plot[f1[x],{x,x0,x1}],
Plot[f2[x],{x,x0,x1}]}]
]//ShowExample
Module[{x,x0,x1,f,f1,f2},
{x0,x1}={0,\[Pi]};
f=Functionize[x,{Cos[x],Sin[x]}];
f1=FunctionInterpolationAlt[f[x],{x,x0,x1}];
f2=FunctionInterpolationAlt[f[x],{x,x0,x1},Resample->True];
GraphicsRow[{
ParametricPlot[f[x],{x,x0,x1}],
ParametricPlot[f1[x],{x,x0,x1}],
ParametricPlot[f2[x],{x,x0,x1}]}]
]//ShowExample
FunctionInterpolationAlt::badip="`1` is not a valid specification for InterpolationPoints.";
FunctionInterpolationAlt[expr_,domain1_List,domain2_List,opts___]:=Module[{rs,fopts,ip,ip1,ip2,liopts,n,fns,u,u0,u1,v,v0,v1,vals,flist},
rs=Resample/.{opts}/.Options[FunctionInterpolationAlt];
fopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
If[Length[domain1]!=3,Message[FunctionInterpolationAlt::baddom,domain1];Abort[]];
If[Length[domain2]!=3,Message[FunctionInterpolationAlt::baddom,domain2];Abort[]];
If[rs,
(* Resample *)
ip=InterpolationPoints/.{opts}/.Options[FunctionInterpolationAlt];
Which[
ip==Automatic,ip1=ip2=InterpolationPoints/.Options[FunctionInterpolation],
Head[ip]===List,If[Length[ip]!=2,Message[FunctionInterpolationAlt::badip,ip];Abort[],{ip1,ip2}=ip],
True,ip1=ip2=ip];
liopts=Sequence@@FilterRules[{opts},Options[ListInterpolation]];
{u,u0,u1}=domain1;
{v,v0,v1}=domain2;
vals=Table[expr/.{u->u0+i/ip1 (u1-u0),v->v0+j/ip2 (v1-v0)},{i,0,ip1},{j,0,ip2}];
If[Head[expr]===List,
(* resample, vector-valued function *)
vals=Transpose[vals,{2,3,1}];
flist=ListInterpolation[#,{{u0,u1},{v0,v1}},liopts]&/@vals;
Functionize[{u,v},#[u,v]&/@flist],
(* resample, scalar-valued function *)
ListInterpolation[vals,{{u0,u1},{v0,v1}},liopts]],
(* Use FunctionInterpolation *)
If[Head[expr]===List,
(* interpolated, vector-valued function *)
n=Length[expr];
fns=Table[FunctionInterpolation[expr[[i]],domain1,domain2,Evaluate[fopts]],{i,n}];
Functionize[{u,v},#[u,v]&/@fns],
(* interpolated, scalar-valued function *)
FunctionInterpolation[expr,domain1,domain2,opts]]]]
Module[{u,u0,u1,v,v0,v1,f,f1,f2},
{u0,u1}={0,1};
{v0,v1}={0,1};
f=Functionize[{u,v},u(1-u)-.5v(1-v)];
f1=FunctionInterpolationAlt[f[u,v],{u,u0,u1},{v,v0,v1}];
f2=FunctionInterpolationAlt[f[u,v],{u,u0,u1},{v,v0,v1},Resample->True];
GraphicsRow[{
Plot3D[f[u,v],{u,u0,u1},{v,v0,v1}],
Plot3D[f1[u,v],{u,u0,u1},{v,v0,v1}],
Plot3D[f2[u,v],{u,u0,u1},{v,v0,v1}]}]
]//ShowExample
Module[{u,u0,u1,v,v0,v1,f,f1,f2},
{u0,u1}={0,1};
{v0,v1}={0,1};
f=Functionize[{u,v},{u(1-u),-v(1-v)}];
f1=FunctionInterpolationAlt[f[u,v],{u,u0,u1},{v,v0,v1}];
f2=FunctionInterpolationAlt[f[u,v],{u,u0,u1},{v,v0,v1},Resample->True];
GraphicsRow[{
Plot3D[f[u,v],{u,u0,u1},{v,v0,v1}],
Plot3D[f1[u,v],{u,u0,u1},{v,v0,v1}],
Plot3D[f2[u,v],{u,u0,u1},{v,v0,v1}]}]
]//ShowExample
InterpolatingFunctionCount[expr_]:=Count[expr,_InterpolatingFunction|_InterpolatingFunction[___],{0,\[Infinity]}]
Block[{s,f,g},
f=FunctionInterpolation[1+s^2,{s,0,1}];
PrintThis[InterpolatingFunctionCount[f]];
g=Function@@{s,#/Sqrt[# . #]&[{1,f[s]}]};
PrintThis[g];
PrintThis[InterpolatingFunctionCount[g]];
]//ShowExample
ContainsInterpolatingFunctionQ[expr_]:=InterpolatingFunctionCount[expr]>0
ExtrapolatingInterpolatingFunction[f_InterpolatingFunction]:=Module[{x0,x1,f0,f1,fp0,fp1,fx,x,xs,fn,wh,pa,fr},
{x0,x1}=f[[1,1]];
fp0=f'[x0];
fp1=f'[x1];
fn[wh[(#<x0 &&x0<x1)||(#>x0&&x0>x1),f[x0]+(#-x0)fp0,
(#>x1&&x0<x1)||(#<x1&&x0>x1),f[x1]+(#-x1)fp1,
True,f[#]]]/.{fn->Function,wh->Which}]
Block[{f,g,x0,x1},
f=ListInterpolation[{1,2,3,5,8}/2];
g=ExtrapolatingInterpolatingFunction[f];
{x0,x1}=f[[1,1]];
Show[ParametricPlot[{x,f[x]},{x,x0,x1},PlotStyle->Cyan,PlotRange->All],ParametricPlot[{x,g[x]},{x,x0-1,x1+1},PlotStyle->{Dotted,Red}]]
]//ShowExample
Block[{f,g,x0,x1},
f=ListInterpolation[-{1,2,3,5,8}/2];
g=ExtrapolatingInterpolatingFunction[f];
{x0,x1}=f[[1,1]];
Show[ParametricPlot[{x,f[x]},{x,x0,x1},PlotStyle->Cyan,PlotRange->All],ParametricPlot[{x,g[x]},{x,x0-1,x1+1},PlotStyle->{Dotted,Red}]]
]//ShowExample
InterpolatingFunctionInverse[f_InterpolatingFunction]:=Module[{x0,x1,f0,f1,xs,fn,pa,fr},
{x0,x1}=f[[1,1]];
{f0,f1}=f/@{x0,x1};
fn[pa[fr[f[xs]==#,{xs,x0+(#-f0)/(f1-f0) (x1-x0)}],1,2]]/.{fn->Function,pa->Part,fr->FindRoot}]
Block[{f,g,x0,x1,f0,f1,fs},
f=ListInterpolation[{1,2,3,5,8}];
g=InterpolatingFunctionInverse[f];
PrintThis[g];
PrintThis[{g[4],f[g[4]],g[f[4]]}];
{x0,x1}=f[[1,1]];
Show[
ParametricPlot[{x,f[x]},{x,x0,x1},PlotStyle->Cyan],ParametricPlot[{g[y],y},{y,f[x0],f[x1]},PlotStyle->{Red,Dotted}]]
]//ShowExample
ExtrapolatingInterpolatingFunctionInverse[f_InterpolatingFunction]:=Module[{x0,x1,f0,f1,fp0,fp1,fx,x,xs,fn,wh,pa,fr},
{x0,x1}=f[[1,1]];
{f0,f1}=f/@{x0,x1};
fp0=f'[x0];
fp1=f'[x1];
fn[wh[(f0<f1&&#<f0)||(f0>f1&&#>f0),x0-(f0-#)/fp0,
(f0<f1&&#>f1)||(f0>f1&&#<f1),x1+(#-f1)/fp1,
True,pa[fr[f[xs]==#,{xs,x0+(#-f0)/(f1-f0) (x1-x0)}],1,2]]]/.{fn->Function,wh->Which,pa->Part,fr->FindRoot}]
Block[{f,g,x0,x1,f0,f1,fs},
f=ListInterpolation[{1,2,3,5,8}];
g=ExtrapolatingInterpolatingFunctionInverse[f];
PrintThis[g];
PrintThis[{g[4],f[g[4]],g[f[4]]}];
PrintThis[{g[0],g[1],g[8],g[9]}];
{x0,x1}=f[[1,1]];
Show[ParametricPlot[{x,f[x]},{x,x0,x1},PlotStyle->Cyan,PlotRange->All],ParametricPlot[{g[y],y},{y,f[x0]-1,f[x1]+1},PlotStyle->{Dotted,Red}]]
]//ShowExample
Block[{f,g,x0,x1,f0,f1,fs},
f=ListInterpolation[{8,5,3,2,1}];
g=ExtrapolatingInterpolatingFunctionInverse[f];
PrintThis[g];
PrintThis[{g[4],f[g[4]],g[f[4]]}];
PrintThis[{g[0],g[1],g[8],g[9]}];
{x0,x1}=f[[1,1]];
Show[ParametricPlot[{x,f[x]},{x,x0,x1},PlotStyle->Cyan,PlotRange->All],ParametricPlot[{g[y],y},{y,f[x0]+1,f[x1]-1},PlotStyle->{Dotted,Red}]]
]//ShowExample
FunctionPlot[f_Function|f_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{f0,n,s,flist},
f0=f[u0];
If[Head[f0]===List,
n=Length[f0];
flist=f[s][[#]]&/@Range[n];
Plot[flist,{s,u0,u1},opts],
Plot[f[s],{s,u0,u1},opts]]]
Module[{},
GraphicsRow[{
FunctionPlot[#^2&,{-1,1},PlotLabel->"\!\(\*SuperscriptBox[\(x\), \(2\)]\)"],
FunctionPlot[{Cos[#],Sin[#],#/2}&,{0,\[Pi]},PlotLabel->"c"]}]
]//ShowExample
StrictArguments[name_Symbol]:=Module[{},
name::badargs="`1` does not fit any defined pattern for arguments.";
name[args___]:=Module[{},Message[name::badargs,{args}];Abort[]]];
Mag2=(# . #)&;
Module[{f1=(Plus@@(#^2))&,f2=(# . #)&,if},
(* They give the same result for a real vector *)
Print[{f1[{2,1}],f2[{2,1}]}];
(* And the give the same result for an evaluated interpolating function. *)
if=Interpolation[{{0,{0,0}},{2,{4,2}}},InterpolationOrder->1];
Print[{f1[if[1]],f2[if[1]]}];
(* But they differ if we have a parameter that delays evaluation of the interpolation *)
Print[{f1[if[x]],f2[if[x]]}/.x->1];
]//ShowExample
Mag=Sqrt[# . #]&;
NormalizeReal=#/Mag[#]&;
Module[{v},
v={a,b,c};
Print["Normalize[v] = ",Normalize[v]];
Print["NormalizeReal[v] = ",NormalizeReal[v]];
]//ShowExample
Reflect[p_List,u_List]:=p-2(p . u)u/(u . u)
Module[{p,u,pp,R},
p={1,0};
u={1,1};
pp=Reflect[p,u];
R={{0,1},{-1,0}};
Graphics[{
Style[Line[{R . u,-R . u}],Black],
Style[Point[p],PointSize[.02],Red],
Style[Point[pp],PointSize[.02],Green]
},Axes->True]]//ShowExample
Reflectu[p_List,u_List]:=p-2(p . u)u
Module[{p,u,pp,R},
p={1,0};
u=NormalizeReal[{1,1}];
pp=Reflectu[p,u];
R={{0,1},{-1,0}};
Graphics[{
Style[Line[{R . u,-R . u}],Black],
Style[Point[p],PointSize[.02],Red],
Style[Point[pp],PointSize[.02],Green]
},Axes->True]]//ShowExample
Reflect[p_List,q_List,u_List]:=p-2((p-q) . u)u/(u . u)
Module[{p,q,u,pp,R},
p={1,0};
q={0,1/4};
u={1,1};
pp=Reflect[p,q,u];
R={{0,1},{-1,0}};
Graphics[{
Style[Line[{q+R . u,q-R . u}],Black],
Style[Point[q],PointSize[.02],Gray],
Style[Point[p],PointSize[.02],Red],
Style[Point[pp],PointSize[.02],Green]
},Axes->True]]//ShowExample
Reflectu[p_List,q_List,u_List]:=p-2((p-q) . u)u
Module[{p,q,u,pp,R},
p={1,0};
q={0,1/4};
u=NormalizeReal[{1,1}];
pp=Reflectu[p,q,u];
R={{0,1},{-1,0}};
Graphics[{
Style[Line[{q+R . u,q-R . u}],Black],
Style[Point[q],PointSize[.02],Gray],
Style[Point[p],PointSize[.02],Red],
Style[Point[pp],PointSize[.02],Green]
},Axes->True]]//ShowExample
LinePlaneInt[{p1_List, p2_List},{q_List,qn_List}]:=With[{t=(q-p1) . qn/(p2-p1) . qn},p1+t(p2-p1)]
Module[{p1,p2,q,qn,r},
p1={0,0,0};
p2={1,.2,.3};
q={.5,0,0};
qn={1,0,0};
r=LinePlaneInt[{p1,p2},{q,qn}];
Graphics3D[{
Style[Line[{p1,p2}],Red],
Style[{Point[p1],Point[p2]},Darker[Red],PointSize[.01]],
Style[Point[q],Darker[Green]],
Style[Polygon[q+.3#&/@{{0,-1,-1},{0,-1,1},{0,1,1},{0,1,-1}}],Opacity[.25],EdgeForm[],Green],
Style[Point[r],Blue,PointSize[.02]],
{}},Axes->True]
]//ShowExample
PointPointMedialInfo[p_List,q_List]:=With[{r=(p+q)/2},{r,Mag[r-p]}]
PointPointMedialInfo[{0,0},{1,1}]//ShowExample
PointLineMedialInfo::badline="Points `1` and `2` must be distinct.";
PointLineMedialInfo[p_List,{q1_List,q2_List}]:=Module[{pq,dq,tq,rq,r},
dq=q2-q1;
If[Chop[Mag[dq]]==0,Message[PointLineMedialInfo::badline,q1,q2];Abort[]];
pq=p-q1;
tq=(pq . dq)/(dq . dq);
rq=q1+tq dq;(* pt of closest approach on line *)
r=(p+rq)/2;
{r,Mag[r-p],tq}]
Module[{p,q1,q2,r,d,tq},
p={0,1};
{q1,q2}={{-1,0},{2,0}};
{r,d,tq}=PointLineMedialInfo[p,{q1,q2}];
Graphics[{
Style[Line[{2q1-q2,2q2-q1}],Red],
Style[{Point[q1],Point[q2]},Darker[Red],PointSize[.02]],
Style[Point[p],Darker[Green],PointSize[.02]],
Style[Point[r],Darker[Blue],PointSize[.02]]
}]//Print;
{r,d,tq}
]//ShowExample
PointSegmentMedialInfo::badline="Points `1` and `2` must be distinct.";
PointSegmentMedialInfo[p_List,{q1_List,q2_List}]:=Module[{pq,dq,tq,rq,r},
dq=q2-q1;
If[Chop[Mag[dq]]==0,Message[PointSegmentMedialInfo::badline,q1,q2];Abort[]];
pq=p-q1;
tq=(pq . dq)/(dq . dq);
rq=Which[
tq<0,q1,
tq>1,q2,
True,q1+tq dq];
r=(p+rq)/2;
{r,Mag[r-p],tq}]
Module[{p,q1,q2,r,d,tq},
p={0,1};
{q1,q2}={{-1,0},{2,0}};
{r,d,tq}=PointSegmentMedialInfo[p,{q1,q2}];
Graphics[{
Style[Line[{q1,q2}],Red],
Style[{Point[q1],Point[q2]},Darker[Red],PointSize[.02]],
Style[Point[p],Darker[Green],PointSize[.02]],
Style[Point[r],Darker[Blue],PointSize[.02]]
}]//Print;
{r,d,tq}
]//ShowExample
Module[{p,q1,q2,r,d,tq},
p={2,1};
{q1,q2}={{-1,0},{1,0}};
{r,d,tq}=PointSegmentMedialInfo[p,{q1,q2}];
Graphics[{
Style[Line[{q1,q2}],Red],
Style[{Point[q1],Point[q2]},Darker[Red],PointSize[.02]],
Style[Point[p],Darker[Green],PointSize[.02]],
Style[Point[r],Darker[Blue],PointSize[.02]]
}]//Print;
{r,d,tq}
]//ShowExample
LineLineMedialInfo::badline="Points `1` and `2` must be distinct.";
LineLineMedialInfo[{p1_List,p2_List},{q1_List,q2_List}]:=Module[{dq,dp,dqp,dpdp,dpdq,dqdq,det,dpdqp,dqdqp,tp,tq,rp,rq,r},
dp=p2-p1;
If[Chop[Mag[dp]]==0,Message[LineLineMedialInfo::badline,p1,p2];Abort[]];
dq=q2-q1;
If[Chop[Mag[dq]]==0,Message[LineLineMedialInfo::badline,q1,q2];Abort[]];
dpdp=dp . dp;
dpdq=dp . dq;
dqdq=dq . dq;
det=dpdq^2-dpdp dqdq;
If[Chop[det]!=0,
(* lines are non-parallel *)
dqp=q1-p1;
dpdqp=dp . dqp;
dqdqp=dq . dqp;
tp=(dpdq dqdqp-dpdqp dqdq)/det;
tq=(dpdp dqdqp-dpdq dpdqp)/det;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
r=(rp+rq)/2;
{r,Mag[r-rp],{tp,tq}},
(* lines are parallel *)
r=((q1+q2)+(p1+p2))/4;
tp=(r-p1) . dp/dpdp;
tq=(r-q1) . dq/dqdq;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
{r,Mag[r-rp],{tp,tq}}]]
Module[{p1,p2,q1,q2,r,d,tpair,tp,tq},
{p1,p2}={{-1,0},{2,0}};
{q1,q2}={{0,-1},{0,1}};
{r,d,tpair}=LineLineMedialInfo[{p1,p2},{q1,q2}];
{tp,tq}=tpair;
Graphics[{
Style[Line[{p1,p2}],Red],
Style[Line[{q1,q2}],Green],
Style[Point/@{p1,p2},Darker[Red],PointSize[.02]],
Style[Point/@{q1,q2},Darker[Green],PointSize[.02]],
Style[Point[r],Blue,PointSize[.02]]}]//Print;
{r,d,{tp,tq}}
]//ShowExample
Module[{p1,p2,q1,q2,r,d,tpair,tp,tq,rp,rq},
{p1,p2}={{-1,0,0},{2,0,0}};
{q1,q2}={{0,-1,1},{0,1,1}};
{r,d,tpair}=LineLineMedialInfo[{p1,p2},{q1,q2}];
{tp,tq}=tpair;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
Graphics3D[{
Style[Line[{p1,p2}],Red],
Style[Line[{q1,q2}],Green],
Style[Line[{rp,rq}],Cyan],
Style[Point/@{p1,p2},Darker[Red],PointSize[.02]],
Style[Point/@{q1,q2},Darker[Green],PointSize[.02]],
Style[Point/@{rp,rq},Darker[Cyan],PointSize[.02]],
Style[Point[r],Blue,PointSize[.02]]}]//Print;
{r,d,{tp,tq}}
]//ShowExample
Module[{p1,p2,q1,q2,r,d,tpair,tp,tq},
{p1,p2}={{-1,0},{0,0}};
{q1,q2}={{1,1},{3,1}};
{r,d,tpair}=LineLineMedialInfo[{p1,p2},{q1,q2}];
{tp,tq}=tpair;
Graphics[{
Style[Line[{p1,p2}],Red],
Style[Line[{q1,q2}],Green],
Style[Point/@{p1,p2},Darker[Red],PointSize[.02]],
Style[Point/@{q1,q2},Darker[Green],PointSize[.02]],
Style[Point[r],Blue,PointSize[.02]]}]//Print;
{r,d,{tp,tq}}
]//ShowExample
LineSegmentMedialInfo::badline="Points `1` and `2` must be distinct.";
LineSegmentMedialInfo[{p1_List,p2_List},{q1_List,q2_List}]:=Module[{dq,dp,dqp,dpdp,dpdq,dqdq,det,tpq1,tpq2,dpdqp,dqdqp,tp,tq,rp,rq,r,clist},
dp=p2-p1;
If[Chop[dp]==Table[0,{Length[dp]}],Message[LineSegmentMedialInfo::badline,p1,p2];Abort[]];
dq=q2-q1;
If[Chop[dq]==Table[0,{Length[dq]}],Message[LineSegmentMedialInfo::badline,q1,q2];Abort[]];
dpdp=dp . dp;
dpdq=dp . dq;
dqdq=dq . dq;
det=dpdq^2-dpdp dqdq;
If[Chop[det]==0,
(* lines are parallel, return soln for midpoints of the segment *)
tq=1/2;
rq=(q1+q2)/2;
tp=(rq-p1) . dp/dpdp;
rp=p1+tp(p2-p1);
r=(rp+rq)/2;
Return[{r,Mag[r-rp],{tp,tq}}],
(* lines are not parallel, construct line-line solution *)
dqp=q1-p1;
dpdqp=dp . dqp;
dqdqp=dq . dqp;
tp=(dpdq dqdqp-dpdqp dqdq)/det;
tq=(dpdp dqdqp-dpdq dpdqp)/det;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
r=(rp+rq)/2;
clist={{r,Mag[r-rp],{tp,tq}}}];
JoinTo[clist,{
{#[[1]],#[[2]],{#[[3]],0}}&@PointLineMedialInfo[q1,{p1,p2}],
{#[[1]],#[[2]],{#[[3]],1}}&@PointLineMedialInfo[q2,{p1,p2}]}];
clist=Select[clist,#[[3,2]]>=0&&#[[3,2]]<=1&];
clist=Sort[clist,#1[[2]]<#2[[2]]&];
clist[[1]]]
Module[{p1,p2,q1,q2,r,d,tpair,tp,tq,rp,rq},
{p1,p2}={{0,0},{1,0}};
{q1,q2}={{.8,1},{1.5,1}};
{r,d,tpair}=LineSegmentMedialInfo[{p1,p2},{q1,q2}];
{tp,tq}=tpair;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
Graphics[{
Style[Line[{2p1-p2,2p2-p1}],Red],
Style[Line[{q1,q2}],Green],
Style[Line[{rp,rq}],Cyan],
Style[Point/@{p1,p2},Darker[Red],PointSize[.02]],
Style[Point/@{q1,q2},Darker[Green],PointSize[.02]],
Style[Point/@{rp,rq},Darker[Cyan],PointSize[.02]],
Style[Point[r],Blue,PointSize[.02]]}]//Print;
{r,d,{tp,tq}}
]//ShowExample
Module[{glist,p1,p2,q1,q2,r,d,tpair,tp,tq,rp,rq},
SeedRandom[1];
glist=Table[
{p1,p2}={{Random[],Random[]},{Random[],Random[]}};
{q1,q2}={{Random[],Random[]},{Random[],Random[]}};
{r,d,tpair}=LineSegmentMedialInfo[{p1,p2},{q1,q2}];
{tp,tq}=tpair;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
Graphics[{
Style[Line[{2p1-p2,2p2-p1}],Red],
Style[Line[{q1,q2}],Green],
Style[Line[{rp,rq}],Cyan],
Style[Point/@{p1,p2},Darker[Red],PointSize[.02]],
Style[Point/@{q1,q2},Darker[Green],PointSize[.02]],
Style[Point/@{rp,rq},Darker[Cyan],PointSize[.02]],
Style[Point[r],Blue,PointSize[.04]]},PlotRange->All],
{12}];
GraphicsGrid[Partition[glist,4]]
]//ShowExample
SegmentSegmentMedialInfo::badline="Points `1` and `2` must be distinct.";
SegmentSegmentMedialInfo[{p1_List,p2_List},{q1_List,q2_List}]:=Module[{dq,dp,dqp,dpdp,dpdq,dqdq,det,tpq1,tpq2,dpdqp,dqdqp,tp,tq,rp,rq,r,clist},
dp=p2-p1;
If[Chop[dp]==Table[0,{Length[dp]}],Message[SegmentSegmentMedialInfo::badline,p1,p2];Abort[]];
dq=q2-q1;
If[Chop[dq]==Table[0,{Length[dq]}],Message[SegmentSegmentMedialInfo::badline,q1,q2];Abort[]];
dpdp=dp . dp;
dpdq=dp . dq;
dqdq=dq . dq;
det=dpdq^2-dpdp dqdq;
If[Chop[det]==0,
(* lines are parallel, construct overlap interval *)
tpq1=(q1-p1) . dp/dpdp;
tpq2=(q2-p1) . dp/dpdp;
{tpq1,tpq2}={Min[tpq1,tpq2],Max[tpq1,tpq2]};
If[tpq1<=1&&tpq2>=0,
(* there's overlap, return soln for midpoints of the overlap *)
tpq1=Max[tpq1,0];
tpq2=Min[tpq2,1];
tp=(tpq1+tpq2)/2;
rp=p1+tp(p2-p1);
tq=(rp-q1) . dq/dqdq;
rq=q1+tq(q2-q1);
r=(rp+rq)/2;
Return[{r,Mag[r-rp],{tp,tq}}],
clist={}],
(* lines are not parallel, construct line-line solution *)
dqp=q1-p1;
dpdqp=dp . dqp;
dqdqp=dq . dqp;
tp=(dpdq dqdqp-dpdqp dqdq)/det;
tq=(dpdp dqdqp-dpdq dpdqp)/det;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
r=(rp+rq)/2;
clist={{r,Mag[r-rp],{tp,tq}}}];
JoinTo[clist,{
{#[[1]],#[[2]],{0,0}}&@PointPointMedialInfo[p1,q1],
{#[[1]],#[[2]],{0,1}}&@PointPointMedialInfo[p1,q2],
{#[[1]],#[[2]],{1,0}}&@PointPointMedialInfo[p2,q1],
{#[[1]],#[[2]],{1,1}}&@PointPointMedialInfo[p2,q2],
{#[[1]],#[[2]],{0,#[[3]]}}&@PointLineMedialInfo[p1,{q1,q2}],
{#[[1]],#[[2]],{1,#[[3]]}}&@PointLineMedialInfo[p2,{q1,q2}],
{#[[1]],#[[2]],{#[[3]],0}}&@PointLineMedialInfo[q1,{p1,p2}],
{#[[1]],#[[2]],{#[[3]],1}}&@PointLineMedialInfo[q2,{p1,p2}]}];
clist=Select[clist,#[[3,1]]>=0&&#[[3,1]]<=1&&#[[3,2]]>=0&&#[[3,2]]<=1&];
clist=Sort[clist,#1[[2]]<#2[[2]]&];
clist[[1]]]
Module[{p1,p2,q1,q2,r,d,tpair,tp,tq,rp,rq},
{p1,p2}={{0,0},{1,0}};
{q1,q2}={{.8,1},{1.5,1}};
{r,d,tpair}=SegmentSegmentMedialInfo[{p1,p2},{q1,q2}];
{tp,tq}=tpair;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
Graphics[{
Style[Line[{p1,p2}],Red],
Style[Line[{q1,q2}],Green],
Style[Line[{rp,rq}],Cyan],
Style[Point/@{p1,p2},Darker[Red],PointSize[.02]],
Style[Point/@{q1,q2},Darker[Green],PointSize[.02]],
Style[Point/@{rp,rq},Darker[Cyan],PointSize[.02]],
Style[Point[r],Blue,PointSize[.02]]}]//Print;
{r,d,{tp,tq}}
]//ShowExample
Module[{p1,p2,q1,q2,r,d,tpair,tp,tq,rp,rq},
{p1,p2}={{0,0},{1,0}};
{q1,q2}={{1.5,1},{2.5,1}};
{r,d,tpair}=SegmentSegmentMedialInfo[{p1,p2},{q1,q2}];
{tp,tq}=tpair;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
Graphics[{
Style[Line[{p1,p2}],Red],
Style[Line[{q1,q2}],Green],
Style[Line[{rp,rq}],Cyan],
Style[Point/@{p1,p2},Darker[Red],PointSize[.02]],
Style[Point/@{q1,q2},Darker[Green],PointSize[.02]],
Style[Point/@{rp,rq},Darker[Cyan],PointSize[.02]],
Style[Point[r],Blue,PointSize[.02]]}]//Print;
{r,d,{tp,tq}}
]//ShowExample
Module[{glist,p1,p2,q1,q2,r,d,tpair,tp,tq,rp,rq},
SeedRandom[1];
glist=Table[
{p1,p2}={{Random[],Random[]},{Random[],Random[]}};
{q1,q2}={{Random[],Random[]},{Random[],Random[]}};
{r,d,tpair}=SegmentSegmentMedialInfo[{p1,p2},{q1,q2}];
{tp,tq}=tpair;
rp=p1+tp(p2-p1);
rq=q1+tq(q2-q1);
Graphics[{
Style[Line[{p1,p2}],Red],
Style[Line[{q1,q2}],Green],
Style[Line[{rp,rq}],Cyan],
Style[Point/@{p1,p2},Darker[Red],PointSize[.02]],
Style[Point/@{q1,q2},Darker[Green],PointSize[.02]],
Style[Point/@{rp,rq},Darker[Cyan],PointSize[.02]],
Style[Point[r],Blue,PointSize[.04]]},PlotRange->All],
{12}];
GraphicsGrid[Partition[glist,4]]
]//ShowExample
PointLineDistance[p_,{q1_,q2_}]:=Module[{dq,tq},
dq=q2-q1;
tq=((p-q1) . dq)/(dq . dq);
Mag[p-(q1+tq dq)]]
Module[{p,q1,q2},
p={0.5,0.5,.5};
q1={0,0,0};
q2={1,.5,1};
Print[Graphics3D[{
Style[Point[p],Red,PointSize[.02]],
Style[Line[{q1,q2}],Green]},Axes->True,Boxed->True]];
PointLineDistance[p,{q1,q2}]
]//ShowExample
PointSegmentDistance[p1_,{q1_,q2_}]:=Module[{dq,tq},
dq=q2-q1;
tq=((p1-q1) . dq)/(dq . dq);
Min[Mag[p1-q1],Mag[p1-q2],If[tq>0&&tq<1,Mag[p1-(q1+tq dq)],\[Infinity]]]]
PointTriangleDistance[p_,{q1_,q2_,q3_}]:=Module[{dist2,x,y},
dist2=Mag2[p-(q1+x(q2-q1)+y(q3-q1))];
{x,y}={x,y}/.Solve[{D[dist2,x]==0,D[dist2,y]==0},{x,y}][[1]];
Min[If[x>=0&&y>=0&&x+y<=1,Sqrt[dist2],\[Infinity]],PointSegmentDistance[p,{q1,q2}],PointSegmentDistance[p,{q1,q3}],PointSegmentDistance[p,{q2,q3}]]]
DynamicModule[{p,q1,q2,q3,dist},
Manipulate[
p={r,.5,.4};
{q1,q2,q3}={{0,0,0},{1,0,0},{0,1,0}};
dist=PointTriangleDistance[p,{q1,q2,q3}];
Graphics3D[{
Style[Polygon[{q1,q2,q3}],LightGray],
Style[Point/@{q1,q2,q3},Black,PointSize[.01]],
Style[Point[p],Red,PointSize[.01]],
{}},PlotRange->{{-.5,1},All,All},PlotLabel->"d = "<>ToString[dist]],{{r,.4},-.5,1}]
]//ShowExample
LineLineDistance[{p1_,p2_},{q1_,q2_}]:=Module[{r,d,tpair},
{r,d,tpair}=LineLineMedialInfo[{p1,p2},{q1,q2}];
2d]
Module[{p1,p2,q1,q2},
p1={0,0,0};
p2={1,0,0};
q1={1.5,-.5,1};
q2={1.5,.5,1};
Print[Graphics3D[{Red,Line[{p1,p2}],Line[{q1,q2}]},Axes->True,Boxed->True]];
LineLineDistance[{p1,p2},{q1,q2}]
]//ShowExample
SegmentSegmentDistance[{p1_,p2_},{q1_,q2_}]:=Module[{r,d,tpair},
{r,d,tpair}=LineLineMedialInfo[{p1,p2},{q1,q2}];
Min[If[tpair[[1]]>=0&&tpair[[1]]<=1&&tpair[[2]]>=0&&tpair[[2]]<=1,2d,\[Infinity]],
PointSegmentDistance[p1,{q1,q2}],
PointSegmentDistance[p2,{q1,q2}],
PointSegmentDistance[q1,{p1,p2}],
PointSegmentDistance[q2,{p1,p2}]]]
Module[{p1,p2,q1,q2},
p1={0,0,0};
p2={1,0,0};
q1={.5,-.5,1};
q2={.5,.5,1};
Print[Graphics3D[{Red,Line[{p1,p2}],Line[{q1,q2}]},Axes->True,Boxed->True]];
SegmentSegmentDistance[{p1,p2},{q1,q2}]
]//ShowExample
Module[{p1,p2,q1,q2},
p1={0,0,0};
p2={1,0,0};
q1={1.5,-.5,1};
q2={1.5,.5,1};
Print[Graphics3D[{Red,Line[{p1,p2}],Line[{q1,q2}]},Axes->True,Boxed->True]];
SegmentSegmentDistance[{p1,p2},{q1,q2}]
]//ShowExample
PtOnPtTolerance::usage="PtOnPtTolerance is an option to PtOnPtQ that specifies how close two points can be to be considered the same point.";
Options[PtOnPtQ]={
PtOnPtTolerance->10^-6
};
PtOnPtQ[p__List,q__List,opts___]:=Module[{tol},
tol=PtOnPtTolerance/.{opts}/.Options[PtOnPtQ];
Plus@@((p-q)^2)<=tol^2]
Module[{report},
report[p_,q_]:=Print[{p,q,PtOnPtQ[p,q]}];
report[{0,0},{0.000001,0}];
report[{0,0},{0.0000011,0}];
]//ShowExample
PtOnLineTolerance::usage="PtOnLineTolerance is an option to PtOnLineQ that specifies how close a point can be to a line to be considered on the line.";
Options[PtOnLineQ]={
PtOnLineTolerance->10^-6
};
PtOnLineQ[p_List,{q_List,r_List},opts___]:=Module[{tol},
tol=PtOnLineTolerance/.{opts}/.Options[PtOnLineQ];
PointLineDistance[p,{q,q+r}]<=tol]
Module[{report},
report[p_,{q_,r_}]:=Print[{p,q,PtOnLineQ[p,{q,r}]}];
report[{0,0},{{0.000001,0},{0,1}}];
report[{0,0},{{0.0000011,0},{0,1}}];
]//ShowExample
ShortestAngle[a_,b_]:=ArcCos[a . b/(Mag[a]Mag[b])]
Module[{p},
p={2,0,0};
{ShortestAngle[p,{1,0,0}],
ShortestAngle[p,{-1,0,0}],
ShortestAngle[p,{0,0,1}],
ShortestAngle[p,{1,.1,.1}]}//ShowExample
]
TriangulatePolygon::badpoly="Polygon `1` has fewer than 3 vertices.";
TriangulatePolygon[verts_List, face_List]:=Module[{n,edges,faces,wpoly,wi,acos,work,idrop},
n=Length[face];
If[n<3,Message[TriangulatePolygon::badpoly,face];Abort[]];
If[n==3,Return[{{},{face}}]];
faces=edges={};
wpoly=face;(* working polygon *)
(* modulo indexing into working polygon *)
wi[i_]:=Mod[i,Length[wpoly],1];
(* angle cosine of ith vertex of working polygon *)
acos[i_]:=NormalizeReal[verts[[wpoly[[wi[i+1]]]]]-verts[[wpoly[[i]]]]] . NormalizeReal[verts[[wpoly[[i]]]]-verts[[wpoly[[wi[i-1]]]]]];
(* table matching working face index with its corner angle *)
work=Table[{i,face[[i]],acos[i]},{i,n}];
Do[
idrop=Sort[work,#1[[-1]]<#2[[-1]]&][[1,1]];
AppendTo[edges,{wpoly[[wi[idrop-1]]],wpoly[[wi[idrop+1]]]}];
AppendTo[faces,{wpoly[[wi[idrop-1]]],wpoly[[idrop]],wpoly[[wi[idrop+1]]]}];
wpoly=Drop[wpoly,{idrop}];
work=Drop[work,{idrop}];
Do[work[[i,1]]=i,{i,Length[work]}];
With[{i=wi[idrop-1]},work[[i,-1]]=acos[i]];
With[{i=wi[idrop]},work[[i,-1]]=acos[i]];
,{n-3}];
AppendTo[faces,wpoly];
{edges,faces}]
Module[{verts,mr,face,edges,faces},
verts={{0,0},{1,0},{2,.1},{2,1},{1.2,1.5},{0,1}};
face={1,2,3,4,5,6};
{edges,faces}=TriangulatePolygon[verts,face];
Print["new edges = ",edges];
Print["new faces = ",faces];
GraphicsRow[{Graphics[{Style[GraphicsComplex[verts,Polygon[face]],LightGray],Table[Text[i,verts[[i]]],{i,Length[verts]}]}],
Graphics[{
Style[GraphicsComplex[verts,Polygon/@faces],LightGray],
Style[GraphicsComplex[verts,Line/@edges],Red],
Table[Text[i,verts[[i]]],{i,Length[verts]}]}]}]
]//ShowExample
Module[{verts,mr,face,edges,faces},
verts={{0,0,0},{1,0,0},{2,.1,0},{2,1,0},{1.2,1.5,0},{0,1,0}};
face={1,2,3,4,5,6};
{edges,faces}=TriangulatePolygon[verts,face];
Print["new edges = ",edges];
Print["new faces = ",faces];
GraphicsRow[{Graphics3D[{Style[GraphicsComplex[verts,Polygon[face]],LightGray],Table[Text[i,verts[[i]]],{i,Length[verts]}]}],
Graphics3D[{
Style[GraphicsComplex[verts,Polygon/@faces],LightGray],
Style[GraphicsComplex[verts,Line/@edges],Red],
Table[Text[i,verts[[i]]],{i,Length[verts]}]}]}]
]//ShowExample
TriangulatePolygons[verts_List,faces_List]:=Module[{nedges,nfaces},
{nedges,nfaces}={{},{}};
(JoinTo[nedges,#[[1]]];JoinTo[nfaces,#[[2]]])&/@(TriangulatePolygon[verts,#]&/@faces);
{Union[nedges,SameTest->(#1==#2||#1==Reverse[#2]&)],nfaces}]
Module[{verts,edges,faces,nedges,nfaces},
verts={{0,0},{1,0},{2,0},{2,1},{1.2,1.5},{0,1},{1,-1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,1},{1,7},{7,3}};
faces={{1,2,3,4,5,6},{1,7,3,2}};
{nedges,nfaces}=TriangulatePolygons[verts,faces];
Print["new edges = ",nedges];
Print["new faces = ",nfaces];
GraphicsRow[{Graphics[{Style[GraphicsComplex[verts,Polygon/@faces],LightGray],Style[GraphicsComplex[verts,Line/@edges],Red],
Table[Text[i,verts[[i]]],{i,Length[verts]}]}],
Graphics[{
Style[GraphicsComplex[verts,Polygon/@nfaces],LightGray],
Style[GraphicsComplex[verts,Line/@edges],Red],
Style[GraphicsComplex[verts,Line/@nedges],Green],
Table[Text[i,verts[[i]]],{i,Length[verts]}]}]}]
]//ShowExample
TriangulateGC[gc_GraphicsComplex]:=Module[{verts},
verts=gc[[1]];
gc/.Polygon[pl_]:>Polygon/@TriangulatePolygon[verts,pl][[2]]]
Module[{gc},
gc=GraphicsComplex[{{0,0},{1,0},{1,1},{0,1}},Polygon[{1,2,3,4}]];
TriangulateGC[gc]
]//ShowExample
TriangulateGCs[expr_]:=expr/.gc_GraphicsComplex:>TriangulateGC[gc]
Module[{expr},
expr={GraphicsComplex[{{0,0},{1,0},{1,1},{0,1}},Polygon[{1,2,3,4}]],GraphicsComplex[{{2,0},{3,0},{3,1},{2,1}},Polygon[{1,2,3,4}]]};
TriangulateGCs[expr]
]//ShowExample
U[\[Phi]_]:={Cos[\[Phi]],Sin[\[Phi]]}
U[\[Phi]list___]:=Plus@@(U/@{\[Phi]list})
U[\[Pi]/3]//ShowExample
U[\[Pi]/3,\[Pi]/3]//ShowExample
LineInt2D[a1_,d1_,a2_,d2_]:=a1+d1 Det[{a2-a1,d2}]/Det[{d1,d2}]
LineInt2Di[a1_,d1_,a2_,d2_]:=Module[{ddet},
ddet=Det[{d1,d2}];
If[ddet==0,{Indeterminate,Indeterminate},a1+d1 Det[{a2-a1,d2}]/ddet]]
LineInt2D1[p1_,p2_,q1_,q2_]:=p1+(p2-p1) Det[{q1-p1,q2-q1}]/Det[{p2-p1,q2-q1}]
LineInt2D1i[p1_,p2_,q1_,q2_]:=Module[{ddet},
ddet=Det[{p2-p1,q2-q1}];
If[ddet==0,{Indeterminate,Indeterminate},p1+(p2-p1) Det[{q1-p1,q2-q1}]/ddet]]
LineInt2D1[{0,0},{1,1},{0,1},{1,0}]//ShowExample
RayCircleInt2D::baddir="Line `1` does not intersect the circle with center `2` and radius `3`.";
RayCircleInt2D[a_,d_,ctr_, r_]:=Module[{t},
If[Abs[(a-ctr) . ({{0,1},{-1,0}} . d)/Mag[d]]>r,Message[RayCircleInt2D::baddir,{a,d},ctr,r];Abort[]];
a+d Max[t/.Solve[Plus@@((a-ctr+d t)^2)==r^2]]]
Module[{a,d,ctr,r,p},
a={1,1};
d={1,0.5};
ctr={0.5,0};
r=3.0;
p=RayCircleInt2D[a,d,ctr,r];
Graphics[{
Style[Circle[ctr,r],Gray],
Style[Line[{a,p}],Red],
Style[Point[a],Red,PointSize[.02]],
Style[Point[ctr],Black,PointSize[.02]],
Style[Point[p],Green,PointSize[.02]]},Axes->True]
]//ShowExample
Module[{a,d,ctr,r,p},
a={-2,1};
d={1,0};
ctr={0.5,0};
r=1.5;
p=RayCircleInt2D[a,d,ctr,r];
Graphics[{
Style[Circle[ctr,r],Gray],
Style[Line[{a,p}],Red],
Style[Point[a],Red,PointSize[.02]],
Style[Point[ctr],Black,PointSize[.02]],
Style[Point[p],Green,PointSize[.02]]},Axes->True]
]//ShowExample
TriangleSemiperimeter[a_,b_,c_]:=1/2 (a+b+c)
TriangleAreaSquared[a_,b_,c_]:=Module[{s},
s=TriangleSemiperimeter[a,b,c];
s(s-a)(s-b)(s-c)]
TriangleAreaSquared[1,1,1]//ShowExample
TriangleExistsQ[a_,b_,c_]:=TriangleAreaSquared[a,b,c]>=0
Module[{},
{TriangleExistsQ[1,1,1],
TriangleExistsQ[1,1/2,1/2],
TriangleExistsQ[1,1/2,1/3]}
]//ShowExample
TriangleArea[a_,b_,c_]:=Sqrt[TriangleAreaSquared[a,b,c]]
TriangleArea[1,1,1]
TriangleArea[a,b,c]//FullSimplify//ShowExample
TriangleInradius[a_,b_,c_]:=TriangleArea[a,b,c]/TriangleSemiperimeter[a,b,c]
TriangleInradius[a,b,c]//FullSimplify//ShowExample
TriangleSinA[a_,b_,c_]:=(\[Sqrt]((a+b-c) (a-b+c) (-a+b+c) (a+b+c)))/(2 b c)
TriangleCosA[a_,b_,c_]:=(-a^2+b^2+c^2)/(2 b c)
TriangleTanA[a_,b_,c_]:=-((\[Sqrt]((a+b-c) (a-b+c) (-a+b+c) (a+b+c)))/(a^2-b^2-c^2))
TriangleVertices[a_,b_,c_]:={{0,0},{1,0},{(a^2-b^2+c^2)/(2 a),(\[Sqrt](-(a-b-c) (a+b-c) (a-b+c) (a+b+c)))/(2 a)}}
Module[{verts},
verts=TriangleVertices[1,0.6,0.8];
Graphics[{Style[Polygon[verts],LightGray]},Axes->True]
]//ShowExample
Solve[{Mag2[{cx,cy}-{0,0}]==a^2,Mag2[{cx,cy}-{bx,0}]==b^2},{cx,cy}]//FullSimplify//ShowExample
TriangleExistsQ[{pa_List,a_},{pb_List,b_}]:=TriangleExistsQ[Mag[pa-pb],a,b]
TriangleVertex::baddir="`1` must be \[PlusMinus]1.";
TriangleVertex[{pa_List,a_},{pb_List,b_},dir_:1]:=Module[{xx,yy,bx,cx,cy},
If[dir!=1&&dir!=-1,Message[TriangleVertex::baddir,dir];Abort[]];
xx=NormalizeReal[pb-pa];
yy={{0,-1},{1,0}} . xx;
bx=Mag[pb-pa];
cx=(a^2-b^2+bx^2)/(2 bx);
cy=(\[Sqrt](-(a-b-bx) (a+b-bx) (a-b+bx) (a+b+bx)))/(2 bx);
pa+cx xx + dir cy yy]
Module[{pa,pb,rm,of,pc},
pa={0,0};
pb={1,0};
rm=With[{\[Phi]=10\[Degree]},{{Cos[\[Phi]],-Sin[\[Phi]]},{Sin[\[Phi]],Cos[\[Phi]]}}];
of={1,1/2};
pa=of+rm . pa;
pb=of+rm . pb;
pc=TriangleVertex[{pa,1},{pb,1},+1];
Graphics[Line[{pa,pb,pc,pa}],Axes->True]
]//ShowExample
TriangleSignedArea2D[p_List,q_List,r_List]:=(1/2)Det[{q-p,r-p}]
TriangleSignedArea2D[{0,0},{2,0},{2,1}]//ShowExample
TriangleArea2D[p_List,q_List,r_List]:=Abs[TriangleSignedArea2D[p,q,r]]
TriangleIncenter2D[p_List,q_List,r_List]:=Module[{pp,qq,rr},
pp=Mag[r-q];qq=Mag[r-p];rr=Mag[p-q];(* sides of the triangles, pp is opposite p *)
(pp p + qq q + rr r)/(pp+qq+rr)]
Module[{p,q,r,c},
{p,q,r}={{0,0},{1,0},{.6,.7}};
c=TriangleIncenter2D[p,q,r];
Graphics[{
Point[c],
Line[{p,q,r,p}],
Circle[c,TriangleInradius[Mag[r-q],Mag[q-p],Mag[p-r]]]
}]
]//ShowExample
TriangleAngles2D[p_List,q_List,r_List]:=Module[{pq ,qr,rp},
pq=q-p;qr=r-q;rp=p-r;
{ArcTan[-rp . pq,Rotate90[rp] . pq],
ArcTan[-pq . qr,Rotate90[pq] . qr],
ArcTan[-qr . rp,Rotate90[qr] . rp]}]
Module[{p,q,r},
{p,q,r}={{0,0},{1,0},{.6,.7}};
Print["Angles/\[Degree] = ",TriangleAngles2D[p,q,r]/\[Degree]];
Graphics[Line[{p,q,r,p}]]
]//ShowExample
RotationAngleSin2D[p_List,q_List,r_List]:=2(TriangleSignedArea2D[p,q,r]/(Mag[q-p]Mag[r-p]))
RotationAngleSin2D[{0,0},{2,0},{2,1}]//ShowExample
RotationAngleCos2D[p_List,q_List,r_List]:=(q-p) . (r-p)/(Mag[q-p]Mag[r-p])
RotationAngleCos2D[{0,0},{2,0},{2,1}]//ShowExample
UnnormalizedRotationMatrix2D[p_,q_,r_]:=Module[{r1,r2,c,s},
r1=q-p;
r2=r-p;
c=r1 . r2;
s=r1 . {{0,1},{-1,0}} . r2;
{{c,-s},{s,c}}]
UnnormalizedRotationMatrix2D[{0,0},{2,0},{0,2}]//ShowExample
RotationMatrix2D[p_,q_,r_]:=Module[{c,s},
c=RotationAngleCos2D[p,q,r];
s=RotationAngleSin2D[p,q,r];
{{c,-s},{s,c}}]
RotationMatrix2D[{0,0},{2,0},{0,2}]//ShowExample
RotationMatrix2D[\[Phi]_]:=RotationMatrix[\[Phi]]
RotationMatrix2D[\[Pi]/2]={{0,-1},{1,0}};
RotationMatrix2D[-\[Pi]/2]={{0,1},{-1,0}};
RotationMatrix2D[{c_,s_}]:={{c,-s},{s,c}}
RotationMatrix[\[Phi]]//ShowExample
Rotate90={{0,-1},{1,0}} . #&;
Rotate90[{1,0}]//ShowExample
RotateSegment90[{p1_,p2_}]:=With[{s=(p1+p2)/2,r=Rotate90[(p2-p1)/2]},{s-r,s+r}]
RotateSegment90[{{1,1},{2,2}}]//ShowExample
AbsoluteAngle[r_List]:=ArcTan@@r
N[AbsoluteAngle[{1,1}]/\[Degree]]//ShowExample
RotationAngle[r1_List,r2__List]:=ArcTan[r1 . r2,Rotate90[r1] . r2]
RotationAngle[{2.,0},{-1,1}]/\[Degree]//ShowExample
RotationAngle[{2.,0},{-1,-1}]/\[Degree]//ShowExample
RotationAngle[{1,0},{-1,0}]//ShowExample
RotationAngle[p_List,q_List,r_List]:=RotationAngle[q-p,r-p]
RotationAngle[{1.,1.},{2,1},{0,2}]/\[Degree]//ShowExample
RotationAngle[{p1_List,p2_List},{q1_List,q2_List}]:=RotationAngle[p2-p1,q2-q1]
RotationAngle[{{1,0},{2,1}},{{0,0},{-1,1}}]//ShowExample
RotationAnglePositive[r1_List,r2_List]:=Mod[RotationAngle[r1,r2],2\[Pi]]
RotationAngle[{2.,0},{-1,-1}]/\[Degree]//ShowExample
RotationAnglePositive[{2.,0},{-1,-1}]/\[Degree]//ShowExample
RotationAnglePositive[p_List,q_List,r_List]:=Mod[RotationAngle[p,q,r],2\[Pi]]
RotationAngle[{0.1, 0.2}, {2.,0},{-1,-1}]/\[Degree]//ShowExample
RotationAnglePositive[{0.1, 0.2}, {2.,0},{-1,-1}]/\[Degree]//ShowExample
RotationAnglePositive[{p1_List,p2_List},{q1_List,q2_List}]:=Mod[RotationAngle[{p1,p2},{q1,q2}],2\[Pi]]
RotationAngle[{{1.,0.},{2,0}},{{0,0},{-1,-1}}]/\[Degree]//ShowExample
RotationAnglePositive[{{1.,0.},{2,0}},{{0,0},{-1,-1}}]/\[Degree]//ShowExample
AbsoluteAngles[p_List,plist_List]:=AbsoluteAngle[#-p]&/@plist
Module[{p,plist},
p={0,0};
plist={{1,0},{1,1},{-1,1},{0,-1}};
Graphics[{
Style[Line[{p,#}]&/@plist,Gray],
Style[Point[p],Black],Style[Point/@plist,Red]}]//Print;
N[AbsoluteAngles[p,plist]/\[Degree]]
]//ShowExample
RotationAngles[p_List,plist_List]:=Mod[#,2\[Pi]]&/@(RotateLeft[#,1]-#&@AbsoluteAngles[p,plist])
Module[{p,plist},
p={0,0};
plist={{1,0},{1,1},{-1,1},{0,-1}};
Graphics[{
Style[Line[{p,#}]&/@plist,Gray],
Style[Point[p],Black],Style[Point/@plist,Red]}]//Print;
N[RotationAngles[p,plist]/\[Degree]]
]//ShowExample
ScaleRotationOffset[{p1_,p2_},{q1_,q2_}]:=Module[{rp,rq,offset,scale,rotation},
rp=p2-p1;
rq=q2-q1;
rotation=ArcTan[rp . rq,Rotate90[rp] . rq];
scale=Mag[rq]/Mag[rp];
offset=q1-(scale RotationMatrix2D[rotation] . p1);
{scale, rotation, offset}]
Module[{p1,p2,q1,q2},
p1={0,0};p2={1,0};
q1={1/2,1/2};q2={3/2,3/2};
Print["{scale, rotation, offset} = ",ScaleRotationOffset[{p1,p2},{q1,q2}]];
Graphics[{
Style[Line[{p1,p2}],Red],
Style[Line[{q1,q2}],Blue]
},Frame->True]
]//ShowExample
ScaleRotationOffsetFixedPoint[{scale_, rotation_, offset_}]:=Module[{x,y},
{x,y}/.Solve[{x,y}==scale(RotationMatrix2D[rotation] . {x,y})+offset,{x,y}][[1]]]
Module[{p1,p2,q1,q2,s,r,o,ctr},
{p1,p2,q1,q2}={{0,0},{1,0},{.5,.5},{.5,1}};
{s,r,o}=ScaleRotationOffset[{p1,p2},{q1,q2}];
ctr=ScaleRotationOffsetFixedPoint[{s,r,o}];
PrintThis[ctr];
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green],Style[Point[ctr],Black]}]
]
ScaleRotationOffsetFixedPoint[{p1_, p2_}, {q1_, q2_}]:=Module[{s,r,o},
{s,r,o}=ScaleRotationOffset[{p1,p2},{q1,q2}];
ScaleRotationOffsetFixedPoint[{s,r,o}]]
SimilarityPair2D[{p1_,p2_},{q1_,q2_}]:=Module[{rm},
rm=(Mag[q2-q1]/Mag[p2-p1])*RotationMatrix2D[p1,p2,p1+(q2-q1)];
{rm,q1-rm . p1}]
Module[{p1,p2,q1,q2,rm,offset},
p1={0,0};p2={1,0};
q1={1/2,1/2};q2={3/2,3/2};
{rm,offset}=SimilarityPair2D[{p1,p2},{q1,q2}];
Print["{rm, offset} = ",{MatrixForm[rm],offset}];
Graphics[{
Style[Line[{p1,p2}],Red],
Style[Point[p2],Darker[Red],PointSize[.02]],
Style[Line[{q1,q2}],Blue],
Style[Point[offset+(rm . p2)],Darker[Blue],PointSize[.02]]
},Frame->True]
]//ShowExample
Reflect2D[p_List,{q1_List,q2_List}]:=With[{u={{0,-1},{1,0}} . (q2-q1)},q1+(p-q1)-2 u ((p-q1) . u)/(u . u)]
Module[{p,q1,q2,pp},
q1={1,0};
q2={2,0.5};
p={1.5,0.1};
pp=Reflect2D[p,{q1,q2}];
Graphics[{
MapThread[Text[#1,#2,{3,0}]&,{{"p","q1","q2","pp"},{p,q1,q2,pp}}],
Style[Line[{q1,q2}],Gray],
Style[Line[{p,pp}],Black],
Style[Point[p],Red,PointSize[.02]],
Style[Point[q1],Green,PointSize[.02]],
Style[Point[q2],Green,PointSize[.02]],
Style[Point[pp],Blue,PointSize[.02]],
{}},Axes->True]]//ShowExample
ReflectionXMatrix2D={{1,0},{0,-1}};
ReflectionYMatrix2D={{-1,0},{0,1}};
ArcDivisions::usage="ArcDivisions is an option to PolygonalEllipseArc2D that specifies the number of points to use in approximating the circular arc.";
ArcMaximumAngle::usage="ArcMaximumAngle is an option to PolygonalEllipseArc2D that specifies the minimum angle quantization.";
ArcMethod::usage="ArcMethod is an option to PolygonalEllipseArc2D that specifies whether to inscribe or circumscribe in creating the arc.";
InscribedArc::usage="InscribedArc is a value of option ArcMethod that specifies to use an inscribed polygon in creating the arc.";
CircumscribedArc::usage="CircumscribedArc is a value of option ArcMethod that specifies to use a circumscribed polygon in creating the arc.";
ArcDirection::usage="ArcDirection is an option to PolygonalEllipseArc2D that specifies the direction of the arc.";
CCW::usage="CCW specifies a counterclockwise rotational direction.";
CW::usage = "CW specifies a clockwise rotational direction.";
PolygonalEllipseArc2D::badmet="ArcMethod\[Rule]`1` is not a valid option.";
PolygonalEllipseArc2D::baddiv="The value of ArcDivisions (`1`) must be \[GreaterEqual]1";
PolygonalEllipseArc2D::baddir="ArcDirection\[Rule]`1` is not a valid option.";
Options[PolygonalEllipseArc2D]={
ArcDivisions->1,
ArcMaximumAngle->5\[Degree],(* this looks smooth visually *)
ArcMethod->InscribedArc,
ArcDirection->CCW
};
PolygonalEllipseArc2D[p1_List, p2_List,opts___]:=Module[{n,ama,am,ad,m1,m2,a1,a2,dw,w,r},
n=ArcDivisions/.{opts}/.Options[PolygonalEllipseArc2D];
ama=ArcMaximumAngle/.{opts}/.Options[PolygonalEllipseArc2D];
am=ArcMethod/.{opts}/.Options[PolygonalEllipseArc2D];
ad=ArcDirection/.{opts}/.Options[PolygonalEllipseArc2D];
If[n<1,Message[PolygonalEllipseArc2D::baddiv,n];Abort[]];
If[!MemberQ[{InscribedArc,CircumscribedArc},am],Message[PolygonalEllipseArc2D::badmet,am];Abort[]];
If[!MemberQ[{CCW,CW},ad],Message[PolygonalEllipseArc2D::baddir,ad];Abort[]];
m1=Mag[p1];
m2=Mag[p2];
a1=ArcTan@@p1;
a2=ArcTan@@p2;
If[ad===CCW,If[a2<a1,a2+=2\[Pi]],If[a2>a1,a2-=2\[Pi]]];
n=Max[n,Ceiling[N[Abs[a2-a1]]/ama]];
dw=1/n;
Switch[am,
InscribedArc,Join[{p1},Table[m1^(1-w) m2^(w) U[a1(1-w)+a2 w],{w,dw,1-dw,dw}],{p2}],
CircumscribedArc,r=Sec[Abs[a1-a2]/(2n)];Join[{p1},Table[r m1^(1-w) m2^(w) U[a1(1-w)+a2 w],{w,dw/2,1-dw/2,dw}],{p2}]]
]
Module[{p1,p2,n,circle,gfn},
p1={1,1};
p2={-1,1};
n=4;
circle={Style[Circle[{0,0},\[Sqrt]2],Gray],Style[{Point[p1],Point[p2]},AbsolutePointSize[5],Black]};
gfn[opts___]:=Graphics[{circle,Line[PolygonalEllipseArc2D[p1,p2,opts]]},Axes->True];
GraphicsGrid[{{
gfn[ArcDirection->CCW],
gfn[ArcDivisions->n,ArcMaximumAngle->\[Infinity],ArcDirection->CCW],
gfn[ArcDivisions->n,ArcMaximumAngle->\[Infinity],ArcMethod->InscribedArc,ArcDirection->CCW],
gfn[ArcDivisions->n,ArcMaximumAngle->\[Infinity],ArcMethod->CircumscribedArc,ArcDirection->CCW]
},{
gfn[ArcDirection->CW],
gfn[ArcDivisions->n,ArcMaximumAngle->\[Infinity],ArcDirection->CW],
gfn[ArcDivisions->n,ArcMaximumAngle->\[Infinity],ArcMethod->InscribedArc,ArcDirection->CW],
gfn[ArcDivisions->n,ArcMaximumAngle->\[Infinity],ArcMethod->CircumscribedArc,ArcDirection->CW]
}}]
]//ShowExample
Centroid[plist_]:=Plus@@plist/Length[plist]
Centroid[{{0,0},{1,0},{0,1}}]//ShowExample
ConcyclicTolerance::usage="ConcyclicTolerance is an option used in testing for Concyclicity, points lying on a common circle.";
Options[ConcyclicInfo]={
ConcyclicTolerance->10^-6
};
ConcyclicInfo::badlen="List is empty.";
ConcyclicInfo[{}]:=Module[{},Message[ConcyclicInfo::badlen];Abort[]]
ConcyclicInfo[{p1_}]:={p1,0,True,{0}}
ConcyclicInfo[{p1_,p2_}]:=Module[{r},
r=Mag[p1-p2]/2;
{(p1+p2)/2,r,True,{r,r}}]
ConcyclicInfo[{p1_,p2_,p3_}]:=Module[{x,y,r},
{x,y}={x,y}/.Solve[{Mag2[{x,y}-p1]==Mag2[{x,y}-p2],Mag2[{x,y}-p2]==Mag2[{x,y}-p3]},{x,y}][[1]];
r=Mag[{x,y}-p1];
{{x,y},r,True,{r,r,r}}]
ConcyclicInfo[{p1_,p2_,p3_}]:=Module[{q,r},
q=LineInt2D[(p1+p2)/2,Rotate90[p2-p1],(p2+p3)/2,Rotate90[p3-p2]];
r=Mag[q-p1];
{q,r,True,{r,r,r}}]
ConcyclicInfo[plist_,opts___]:=Module[{tol,n,triples,crlist,crlist1,ctr,r,dlist},
tol=ConcyclicTolerance/.{opts}/.Options[ConcyclicInfo];
n=Length[plist];
triples=Flatten[Table[{i,j,k},{i,n-2},{j,i+1,n-1},{k,j+1,n}],2];
crlist=Take[ConcyclicInfo[plist[[#]]],2]&/@triples; (* {ctr, r} for each triple *)
crlist1=Select[crlist,Function[cr,And@@(Mag[cr[[1]]-#]<=cr[[2]]&/@plist)]];(* circle must contain all pts *)
{ctr,r}=Sort[crlist1,#1[[2]]<#2[[2]]&][[1]]; (* pick the one with smallest radius *)
dlist=Mag[#-ctr]&/@plist;
{ctr,r,And@@(Abs[#-r]<=tol&/@dlist),dlist}]
ConcyclicInfo[{{0,0}}]//ShowExample
ConcyclicInfo[{{0,0},{1,0}}]//ShowExample
ConcyclicInfo[{{0,0},{1,0},{0,1}}]//ShowExample
ConcyclicInfo[{{0,0},{1,0},{0,1},{1/3,1/3}}]//ShowExample
Module[{plist,ccinfo},
plist=Table[{Random[],Random[]},{7}];
ccinfo=ConcyclicInfo[plist];
Print[ccinfo];
Graphics[{
Style[Point/@plist,AbsolutePointSize[4],Red],
Style[Point[ccinfo[[1]]],AbsolutePointSize[6],Black],
Style[Circle[ccinfo[[1]],ccinfo[[2]]],Gray]
}]
]//ShowExample
Options[ConcyclicQ]={
ConcyclicTolerance->10^-6
};
ConcyclicQ[plist_,opts___]:=ConcyclicInfo[plist,opts][[3]]
ConcyclicQ[{{0,0},{1,0},{0,1},{1,1.00001}},ConcyclicTolerance->10^-6]//ShowExample
Circumcenter[plist_]:=ConcyclicInfo[plist][[1]]
Circumcenter[{{0,0},{1,0},{0,1},{1,1.00001}}]//ShowExample
Circumradius[plist_]:=ConcyclicInfo[plist][[2]]
Circumradius[{{0,0},{1,0},{0,1},{1,1.00001}}]//ShowExample
ConcyclicConditions[plist_List]:=Module[{n,ctr,r2},
n=Length[plist];
If[n<4,{},
ctr=LineInt2D[(plist[[1]]+plist[[2]])/2,Rotate90[plist[[2]]-plist[[1]]],(plist[[2]]+plist[[3]])/2,Rotate90[plist[[3]]-plist[[2]]]];
r2=Mag2[ctr-plist[[1]]];
Mag2[ctr-#]-r2&/@Drop[plist,3]]]
ConcyclicConditions[{{0,0},{1,0},{1,1},{x,y}}]//ShowExample
BrocardPointPositive[{q1a_,q1b_},{q2a_,q2b_},{q3a_,q3b_}]:=Module[{s1,s2,s3,ii,rpm,rt,p12,p23,p31,t12,t23,t31,u2,u3},
s1=q1a-q1b;
s2=q2a-q2b;
s3=q3a-q3b;
rpm=RotationMatrix2D[(-\[Pi])/2];
ii=IdentityMatrix[2];
rt={{rpm,-ii},{ii,rpm}};
p12=(q2a-q1a) . rt;
p23=(q3a-q2a) . rt;
p31=(q1a-q3a) . rt;
t12=LineInt2D[q1a,(s2 . p12) . s1,q2a,(s1 . p12) . s2];t23=LineInt2D[q2a,(s3 . p23) . s2,q3a,(s2 . p23) . s3];
t31=LineInt2D[q3a,(s1 . p31) . s3,q1a,(s3 . p31) . s1];
u2=rpm . (t12-t23);(* direction vector of line from q2b to intersection pt *)
u3=rpm . (t31-t23);(* direction vector of line from q3b to intersection pt *)
LineInt2D[q2a,u2,q3a,u3]]
Module[{pts,q1a,q1b,q2a,q2b,q3a,q3b,c},
pts={{0,0},{1,-.5},{1.8,-0.2},{1.5,0.7},{0.6,.5}};
{q1a,q1b,q2a,q2b,q3a,q3b}={pts[[1]],pts[[2]],pts[[2]],pts[[3]],pts[[4]],pts[[5]]};
c=BrocardPointPositive[{q1a,q1b},{q2a,q2b},{q3a,q3b}];
Graphics[{
AbsolutePointSize[5],
Style[Line[AppendFirst[pts]],LightGray],
Style[{Line[{q1a,q1b}],Line[{q2a,q2b}],Line[{q3a,q3b}]},Gray],
Style[{Line[{c,q1a}],Line[{c,q2a}],Line[{c,q3a}]},Red],
Style[Point[c],Darker[Red]],
Style[Point/@pts,Black],
Style[{
Text["q1a",q1a,{-2,0}],
Text["q1b",q1b,{2,0}],
Text["q2a",q2a,{-2,0}],
Text["q2b",q2b,{2,0}],
Text["q3a",q3a,{-2,0}],
Text["q3b",q3b,{2,0}],
Text["c",c,{-2,0}]
},Black]
}]
]//ShowExample
BrocardPointNegative[{q1a_,q1b_},{q2a_,q2b_},{q3a_,q3b_}]:=BrocardPointPositive[{q1b, q1a}, {q2b, q2a}, {q3b, q3a}]
Module[{pts,q1a,q1b,q2a,q2b,q3a,q3b,c},
pts={{0,0},{1,-.5},{1.8,-0.2},{1.5,0.7},{0.6,.5}};
{q1a,q1b,q2a,q2b,q3a,q3b}={pts[[1]],pts[[2]],pts[[2]],pts[[3]],pts[[4]],pts[[5]]};
c=BrocardPointNegative[{q1a,q1b},{q2a,q2b},{q3a,q3b}];
Graphics[{
AbsolutePointSize[5],
Style[Line[AppendFirst[pts]],LightGray],
Style[{Line[{q1a,q1b}],Line[{q2a,q2b}],Line[{q3a,q3b}]},Gray],
Style[{Line[{c,q1b}],Line[{c,q2b}],Line[{c,q3b}]},Green],
Style[Point[c],Darker[Green]],
Style[Point/@pts,Black],
Style[{
Text["q1a",q1a,{-2,0}],
Text["q1b",q1b,{2,0}],
Text["q2a",q2a,{-2,0}],
Text["q2b",q2b,{2,0}],
Text["q3a",q3a,{-2,0}],
Text["q3b",q3b,{2,0}],
Text["c",c,{-2,0}]
},Black]
}]
]//ShowExample
RotationAngles[verts_List]:=RotationAngle@@#&/@Transpose[{RotateRight[#],#}&@Transpose[{verts,RotateLeft[verts]}]]
Module[{verts},
verts={{0,0},{1,0},{1,1/2},{1/2,1},{0,1/2}};
Print[Graphics[Line[Append[verts,verts[[1]]]]]];
RotationAngles[verts]
]//ShowExample
PolygonAngles[verts_List]:=\[Pi]-#&/@RotationAngles[verts]
Module[{verts},
verts={{0,0},{1,0},{1,1/2},{1/2,1},{0,1/2}};
Print[Graphics[Line[Append[verts,verts[[1]]]]]];
PolygonAngles[verts]
]//ShowExample
CompletePolygonAngles[angles_List]:=Module[{n},
n=1+Length[angles];
Append[angles,(Plus@@(\[Pi]-#&/@angles))-\[Pi]]]
CompletePolygonAngles[{90\[Degree],90\[Degree],89\[Degree]}]/\[Degree]//N//ShowExample
CompletePolygonAngles[{108\[Degree],108\[Degree],108\[Degree],109\[Degree]}]/\[Degree]//N//ShowExample
ConcyclicCenterAngles[angles_]:=Module[{a,n,inv},
n=Length[angles];
a=CompletePolygonAngles[Drop[angles,-1]];
inv=Table[Which[i<j,(-1)^(i+j-1),i>j,(-1)^(i+j),True,1],{i,n},{j,n}];
\[Pi]-#&/@(inv . a)]/;OddQ[Length[angles]]
ConcyclicCenterAngles[{40\[Degree],60\[Degree],0}]/\[Degree]//N
ConcyclicCenterAngles[{98\[Degree],108\[Degree],118\[Degree],128\[Degree],0}]/\[Degree]//N
ConcyclicCenterAngles[angles_]:=Module[{n,sum,diff,a,inv},
n=Length[angles];
sum=Plus@@(Drop[angles,-2]);
diff=Plus@@Table[(-1)^(i-1) angles[[i]],{i,Length[angles]-2}];
a=Join[Drop[angles,-2],{((n-2)\[Pi]-sum-diff)/2,((n-2)\[Pi]-sum+diff)/2}];
inv=Table[(-1)^(i+j-1) 2(Mod[i-j+1/2,n]-n/2),{i,n},{j,n}]/n;(* pseudoinverse *)
inv . (\[Pi]-a)]/;EvenQ[Length[angles]]
ConcyclicCenterAngles[{80\[Degree],90\[Degree],0,0}]/\[Degree]//N
ConcyclicCenterAngles[{128\[Degree],119\[Degree],118\[Degree],115\[Degree],0,0}]/\[Degree]//N
PolygonSides[verts_List]:=Mag/@(RotateLeft[verts]-verts)
PolygonSides[{{0,0},{1,0},{16/25,12/25}}]//ShowExample
PolygonPerimeter[verts_List]:=Plus@@(Mag/@(RotateLeft[verts]-verts))
Module[{verts},
verts={{1,1},{-1,1},{-1,-1},{1,-1}};
PolygonPerimeter[verts]
]//ShowExample
PolygonSignedArea2D[verts_List]:=Module[{ctr},
ctr=Centroid[verts];
Plus@@MapThread[TriangleSignedArea2D,{verts,RotateLeft[verts],Table[ctr,{Length[verts]}]}]]
Module[{verts},
verts={{1,1},{-1,1},{-1,-1},{1,-1}};
PolygonSignedArea2D[verts]
]//ShowExample
UnitTriangleVertices[angles_]:=Module[{A,B,C,b},
{A,B}=Take[angles,2];
C=\[Pi]-(A+B);
b=Sin[B]/Sin[C];
{{0,0},{1,0},b{Cos[A],Sin[A]}}
]
Module[{pa,pb,pc},
{pa,pb,pc}=UnitTriangleVertices[{40\[Degree],60\[Degree],80\[Degree]}];
Graphics[Line[{pa,pb,pc,pa}]]
]//ShowExample
UnitTriangleConcyclicInfo[angles_List]:=Module[{verts,cinfo},
verts=UnitTriangleVertices[angles];
cinfo=ConcyclicInfo[verts];
{verts,cinfo[[1]],cinfo[[2]]}]
UnitTriangleConcyclicInfo[{40\[Degree],60\[Degree],80\[Degree]}]//N//ShowExample
UnitCyclicQuadrilateralConcyclicInfo[angles_List,side_, is_:2]:=Module[{v,v3x,v3y,v4x,v4y,c,cy,r,eqns,vars,soln},
v={{0,0},{1,0},{v3x,v3y},{v4x,v4y}};
c={1/2,cy};
r=Mag[c];
eqns=Join[Table[With[{r1=v[[Mod[i-1,4,1]]]-v[[i]],r2=v[[Mod[i+1,4,1]]]-v[[i]]},r1 . r2/(Mag[r1]Mag[r2])]==Cos[angles[[i]]],{i,2}],
{Mag[v[[3]]-c]==r,Mag[v[[4]]-c]==r,Mag[v[[Mod[1+is,4,1]]]-v[[is]]]==side}];
vars={{cy,1/2},{v3x,1},{v3y,1},{v4x,0},{v4y,1}};
soln=FindRoot@@{eqns,vars};
Chop[{v,c,r}/.soln]]
Module[{angles,plist,ctr,r},
angles={95\[Degree],100\[Degree],0,0};(* note last two are ignored *)
Print["Angles (input)/\[Degree] = ",N[angles/\[Degree]]];
{plist,ctr,r}=UnitCyclicQuadrilateralConcyclicInfo[angles,0.8,2];
Print["Angles (actual)/\[Degree] = ",N[PolygonAngles[plist]/\[Degree]]];
Graphics[{
Line[Append[plist,plist[[1]]]],
Point[ctr],
Circle[ctr,r]},Frame->True]
]//ShowExample
UnitCyclicQuadrilateralVertices[angles_List,side_,is_:2]:=First[UnitCyclicQuadrilateralConcyclicInfo[angles,side,is]]
UnitCyclicPolygonConcyclicInfo[angles_List,side_:1,is_:2]:=Module[{n,a,\[Zeta],c,r,\[Phi],v},
n=Length[angles];
a=ConcyclicCenterAngles[angles]+If[EvenQ[n], Table[(-1)^(i-1) \[Zeta],{i,n}],0];
c=(1/2){1,Cot[a[[1]]/2]};
r=(1/2)Csc[a[[1]]/2];
\[Phi]=Drop[FoldList[Plus,-\[Pi]/2-a[[1]]/2,a],-1];
v=Join[{{0,0},{1,0}},Table[c+r U[\[Phi][[i]]],{i,3,n}]];
If[EvenQ[n],\[Zeta]=\[Zeta]/.FindRoot[Mag2[v[[Mod[is+1,n,1]]]-v[[is]]]==side^2,{\[Zeta],0}]];
{v,c,r}]
Module[{angles,verts,ctr,r,fooverts,fooctr,foorad},
angles={40\[Degree],60\[Degree],80\[Degree]};
{fooverts,fooctr,foorad}=UnitTriangleConcyclicInfo[angles];
Print["Input angles)/\[Degree] = ",N[angles/\[Degree]]];
{verts,ctr,r}=UnitCyclicPolygonConcyclicInfo[angles];
Print["Corner angles/\[Degree] = ",N[PolygonAngles[verts]/\[Degree]]];
Graphics[{
Line[Append[verts,verts[[1]]]],
Point[ctr],
Circle[ctr,r]},Frame->True]
]//ShowExample
Module[{angles,verts,ctr,r},
angles={100\[Degree],80\[Degree],0,0};
Print["Input angles)/\[Degree] = ",N[angles/\[Degree]]];
{verts,ctr,r}=UnitCyclicPolygonConcyclicInfo[angles,1,2];
Print["Corner angles/\[Degree] = ",N[PolygonAngles[verts]/\[Degree]]];
Graphics[{
Line[Append[verts,verts[[1]]]],
Point[ctr],
Circle[ctr,r]},Frame->True]
]//ShowExample
Module[{angles,verts,ctr,r},
angles={98\[Degree],108\[Degree],118\[Degree],128\[Degree],0};
Print["Input angles)/\[Degree] = ",N[angles/\[Degree]]];
{verts,ctr,r}=UnitCyclicPolygonConcyclicInfo[angles];
Print["Corner angles/\[Degree] = ",N[PolygonAngles[verts]/\[Degree]]];
Graphics[{
Line[Append[verts,verts[[1]]]],
Point[ctr],
Circle[ctr,r]},Frame->True]
]//ShowExample
Module[{angles,verts,ctr,r},
angles={110\[Degree],120\[Degree],131\[Degree],135\[Degree],0,0};
Print["Input angles)/\[Degree] = ",N[angles/\[Degree]]];
{verts,ctr,r}=UnitCyclicPolygonConcyclicInfo[angles];
Print["Corner angles/\[Degree] = ",N[PolygonAngles[verts]/\[Degree]]];
Graphics[{
Line[Append[verts,verts[[1]]]],
Point[ctr],
Circle[ctr,r]},Frame->True]
]//ShowExample
UnitCyclicPolygonVertices[angles_List, side_:1, is_:2]:=UnitCyclicPolygonConcyclicInfo[angles,side,is][[1]]
Options[UnitBrocardPolygonInfo]={
BrocardAngle->Automatic
};
UnitBrocardPolygonInfoCCW::badangle="Brocard angle `1` must be in the range (0,\[Pi]/2).";
UnitBrocardPolygonInfoCCW[angles_List,opts___]:=Module[{ta,n,\[Theta],\[Alpha],eqn,soln,r1,ctr,r,\[Phi],verts},
ta=BrocardAngle/.{opts}/.Options[UnitBrocardPolygonInfo];
n=Length[angles];
\[Theta]=CompletePolygonAngles[Take[angles,Length[angles]-1]];
If[ta===Automatic,
(* numerically solve for Brocard angle *)
If[NumericQ[ta]&&(ta<=0||ta>=\[Pi]/2),Message[UnitBrocardPolygonInfoCCW::badangle,ta];Abort[]];
eqn=Times@@(Sin[#-\[Alpha]]&/@\[Theta])==Sin[\[Alpha]]^n;
soln=NSolve[{eqn,\[Alpha]>0,\[Alpha]<\[Pi]/2},\[Alpha]];
\[Alpha]=\[Alpha]/.soln[[1]],
(* Brocard angle provided *)
\[Alpha]=ta];
(* now construct unit polygon vertices *)
r1=Sin[\[Alpha]]/Sin[\[Theta][[1]]];(* radius from center to vertex 1 *) 
ctr=r1 U[\[Theta][[1]]-\[Alpha]];(* center of closure *)
r=FoldList[(Sin[#2-\[Alpha]]/Sin[\[Alpha]])#1&,r1,Drop[\[Theta],-1]];
\[Phi]=\[Pi]-\[Theta];(* exterior angles *)
\[Phi]=Mod[FoldList[Plus,\[Theta][[1]]-\[Alpha]-\[Pi],Drop[\[Phi],-1]],2\[Pi]];(* absolute angles to vertices *)
verts=MapThread[ctr+#1 U[#2]&,{r,\[Phi]}];
verts[[1]]={0,0};verts[[2]]={1,0};(* set these to exact values *)
{verts,ctr,\[Alpha]}]
Module[{angles,info,gfn},
angles={120\[Degree],100\[Degree],85\[Degree],55\[Degree]};
info=UnitBrocardPolygonInfoCCW[angles];
Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Black],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]]]
]//ShowExample
UnitBrocardPolygonInfoCW::badangle="Brocard angle `1` must be in the range (\[Pi]/2,\[Pi]).";
UnitBrocardPolygonInfoCW[angles_List,opts___]:=Module[{ta,n,\[Theta],\[Alpha],eqn,soln,r1,ctr,r,\[Phi],verts},
ta=BrocardAngle/.{opts}/.Options[UnitBrocardPolygonInfo];
n=Length[angles];
\[Theta]=CompletePolygonAngles[Take[angles,Length[angles]-1]];
If[ta===Automatic,
(* numerically solve for Brocard angle *)
If[NumericQ[ta]&&(ta<=\[Pi]/2||ta>=\[Pi]),Message[UnitBrocardPolygonInfoCW::badangle,ta];Abort[]];
eqn=Times@@(Sin[#-(\[Pi]-\[Alpha])]&/@\[Theta])==Sin[\[Alpha]]^n;
soln=NSolve[{eqn,\[Alpha]>\[Pi]/2,\[Alpha]<\[Pi]},\[Alpha]];
\[Alpha]=\[Alpha]/.soln[[1]],
(* Brocard angle provided *)
\[Alpha]=ta];
(* now construct unit polygon vertices *)
r1=Sin[\[Theta][[2]]-(\[Pi]-\[Alpha])]/Sin[\[Theta][[2]]];(* radius from center to vertex 1 *) 
ctr=r1 U[\[Pi]-\[Alpha]];(* center of closure *)
r=FoldList[(Sin[\[Pi]-\[Alpha]]/Sin[#2-(\[Pi]-\[Alpha])])#1&,r1,Drop[\[Theta],1]];
\[Phi]=\[Pi]-RotateLeft[\[Theta]];(* interior angles *)
\[Phi]=Mod[FoldList[Plus,-\[Alpha],Drop[\[Phi],-1]],2\[Pi]];(* absolute angles to vertices *)
verts=MapThread[ctr+#1 U[#2]&,{r,\[Phi]}];
verts[[1]]={0,0};verts[[2]]={1,0};(* set these to exact values *)
{verts,ctr,\[Alpha]}]
Module[{angles,info,gfn},
angles={120\[Degree],100\[Degree],85\[Degree],55\[Degree]};
info=UnitBrocardPolygonInfoCW[angles];
Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Black],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]]]
]//ShowExample
BrocardAngle::usage="BrocardAngle is an option in twists that specifies the Brocard angle of the central polygon.";
TwistDirection::usage="TwistDirection is an option in twists that specifies the direction of rotation of the central polygon in going from the crease pattern to the folded form.";
UnitBrocardPolygonInfo::inconst="Specified Brocard angle `1` and twist direction `2` are inconsistent.";
UnitBrocardPolygonInfo::baddir="Twist direction `1` must be CCW or CW.";
Options[UnitBrocardPolygonInfo]={
BrocardAngle->Automatic,
TwistDirection->CCW
};
UnitBrocardPolygonInfo[angles_List,opts___]:=Module[{ta,td,n,\[Theta],\[Alpha],eqn,soln,r1,ctr,r,\[Phi],verts},
ta=BrocardAngle/.{opts}/.Options[UnitBrocardPolygonInfo];
td=TwistDirection/.{opts}/.Options[UnitBrocardPolygonInfo];
If[NumericQ[ta],
If[(td===CCW&&(ta<=0||ta>=\[Pi]/2))||(td===CW&&(ta<=\[Pi]/2||ta>=\[Pi])),Message[UnitBrocardPolygonInfo::inconst,ta,td];Abort[]]];
Switch[td,
CCW,UnitBrocardPolygonInfoCCW[angles,opts],
CW,UnitBrocardPolygonInfoCW[angles,opts],
_,Message[UnitBrocardPolygonInfo::baddir,td];Abort[]]]
Module[{angles,info1,info2,gfn},
angles={120\[Degree],100\[Degree],85\[Degree],55\[Degree]};
info1=UnitBrocardPolygonInfo[angles,TwistDirection->CCW];
info2=UnitBrocardPolygonInfo[angles,TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Black],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
Module[{angles,info1,info2,gfn},
angles={120\[Degree],120\[Degree],60\[Degree],60\[Degree]};
info1=UnitBrocardPolygonInfo[angles,TwistDirection->CCW];
info2=UnitBrocardPolygonInfo[angles,TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Gray],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
Module[{angles,info1,info2,gfn},
angles={60\[Degree],120\[Degree],60\[Degree],120\[Degree]};
info1=UnitBrocardPolygonInfo[angles,TwistDirection->CCW];
info2=UnitBrocardPolygonInfo[angles,TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Gray],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
Module[{angles,info1,info2,gfn},
angles={90\[Degree],120\[Degree],100\[Degree],120\[Degree],110\[Degree]};
info1=UnitBrocardPolygonInfo[angles,TwistDirection->CCW];
info2=UnitBrocardPolygonInfo[angles,TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Gray],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
UnitBrocardTrapezoidInfo::baddir="Twist direction `1` must be CCW or CW.";
Options[UnitBrocardTrapezoidInfo]={
TwistDirection->CCW
};
UnitBrocardTrapezoidInfo[\[Delta]_, opts___]:=Module[{td,s,verts,ctr,\[Alpha]},
td=TwistDirection/.{opts}/.Options[UnitBrocardTrapezoidInfo];
(* length of a diagonal side *)
s=-Cos[\[Delta]]+\[Sqrt](2-Sin[\[Delta]]^2);(* length of a diagonal side *)
Switch[td,
CCW,
ctr={(1/2) (Sin[\[Delta]]^2+Cos[\[Delta]] \[Sqrt](2-Sin[\[Delta]]^2)),(1/2) Sin[\[Delta]] (-Cos[\[Delta]]+\[Sqrt](2-Sin[\[Delta]]^2))};
\[Alpha]=ArcSin[Sin[\[Delta]]/(\[Sqrt]2)],
CW,
ctr={(1/4) (3+Cos[2 \[Delta]]-\[Sqrt]2 Cos[\[Delta]] \[Sqrt](3+Cos[2 \[Delta]])),(1/2) Sin[\[Delta]] (-Cos[\[Delta]]+\[Sqrt](2-Sin[\[Delta]]^2))};
\[Alpha]=\[Pi]-ArcSin[Sin[\[Delta]]/(\[Sqrt]2)],
_,Message[UnitBrocardTrapezoidInfo::baddir,td];Abort[]];
verts={{0,0},{1,0},{1-s Cos[\[Delta]],s Sin[\[Delta]]},{s Cos[\[Delta]],s Sin[\[Delta]]}};
{verts,ctr,\[Alpha]}]
Module[{\[Delta],info1,info2,gfn},
\[Delta]=60\[Degree];
info1=UnitBrocardTrapezoidInfo[\[Delta],TwistDirection->CCW];
info2=UnitBrocardTrapezoidInfo[\[Delta],TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Gray],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]//N]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
UnitBrocardParallelogramInfo::baddir="Twist direction `1` must be CCW or CW.";
Options[UnitBrocardParallelogramInfo]={
TwistDirection->CCW
};
UnitBrocardParallelogramInfo[\[Delta]_, opts___]:=Module[{td,s,verts,ctr,\[Alpha]},
td=TwistDirection/.{opts}/.Options[UnitBrocardParallelogramInfo];
(* length of a diagonal side *)
Switch[td,
CCW,
s=-Cos[\[Delta]]+\[Sqrt](2-Sin[\[Delta]]^2);(* length of a diagonal side *)
ctr={(1/2) (Sin[\[Delta]]^2+Cos[\[Delta]] \[Sqrt](2-Sin[\[Delta]]^2)),(1/2) Sin[\[Delta]] (-Cos[\[Delta]]+\[Sqrt](2-Sin[\[Delta]]^2))};
\[Alpha]=ArcSin[Sin[\[Delta]]/(\[Sqrt]2)],
CW,
s=Cos[\[Delta]]+\[Sqrt](2-Sin[\[Delta]]^2);(* length of a diagonal side *)
ctr={(1/4) (3+Cos[2 \[Delta]]+\[Sqrt]2 Cos[\[Delta]] \[Sqrt](3+Cos[2 \[Delta]])),(1/2) Sin[\[Delta]] (Cos[\[Delta]]+\[Sqrt](2-Sin[\[Delta]]^2))};
\[Alpha]=\[Pi]-ArcSin[Sin[\[Delta]]/(\[Sqrt]2)],
_,Message[UnitBrocardParallelogramInfo::baddir,td];Abort[]];
verts={{0,0},{1,0},{1+s Cos[\[Delta]],s Sin[\[Delta]]},{s Cos[\[Delta]],s Sin[\[Delta]]}};
{verts,ctr,\[Alpha]}]
Module[{\[Delta],info1,info2,gfn},
\[Delta]=60\[Degree];
info1=UnitBrocardParallelogramInfo[\[Delta],TwistDirection->CCW];
info2=UnitBrocardParallelogramInfo[\[Delta],TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Gray],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]//N]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
UnitBrocardTriangleInfo::baddir="Twist direction `1` must be CCW or CW.";
Options[UnitBrocardTriangleInfo]={
TwistDirection->CCW
};
UnitBrocardTriangleInfo[angles_, opts___]:=Module[{td,\[Theta]1,\[Theta]2,\[Theta]3,\[Alpha],verts,ctr,a},
td=TwistDirection/.{opts}/.Options[UnitBrocardTriangleInfo];
{\[Theta]1,\[Theta]2,\[Theta]3}=angles;
\[Theta]3=\[Pi]-\[Theta]1-\[Theta]2;
a=ArcTan[(Sin[\[Theta]1]Sin[\[Theta]2]Sin[\[Theta]3])/(1+Cos[\[Theta]1]Cos[\[Theta]2]Cos[\[Theta]3])];
Switch[td,
CCW,
verts={{0,0},{1,0},{1+Cos[\[Theta]2] (-Cot[a]+Cot[\[Theta]1]) Sin[\[Theta]2],(Cot[a]-Cot[\[Theta]1]) Sin[\[Theta]2]^2}};
ctr={Sin[a] (Cos[a] Cot[\[Theta]1]+Sin[a]),-Csc[\[Theta]1] Sin[a] Sin[a-\[Theta]1]};
\[Alpha]=a,
CW,
verts={{0,0},{1,0},{Csc[\[Theta]2] (Cos[a+\[Theta]1] Csc[a+\[Theta]1+\[Theta]2] Sin[a]^2-Cos[a] Sin[a-\[Theta]2]),Csc[a+\[Theta]1+\[Theta]2] Sin[a] Sin[\[Theta]1+\[Theta]2]}};
ctr={Cos[a] (Cos[a]-Cot[\[Theta]2] Sin[a]),-Csc[\[Theta]2] Sin[a] Sin[a-\[Theta]2]};
\[Alpha]=\[Pi]-a,
_,Message[UnitBrocardTriangleInfo::baddir,td];Abort[]];
{verts,ctr,\[Alpha]}]
Module[{angles,info1,info2,gfn},
angles={40\[Degree],60\[Degree],80\[Degree]};
info1=UnitBrocardTriangleInfo[angles,TwistDirection->CCW];
info2=UnitBrocardTriangleInfo[angles,TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[Append[info[[1]],info[[1,1]]]],Gray],
Style[Line[{#,info[[2]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Black]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[3]]/\[Degree]//N]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
BrocardTriangleInfo::baddir="Twist direction `1` must be CCW or CW.";
Options[BrocardTriangleInfo]={
TwistDirection->CCW
};
BrocardTriangleInfo[verts_List, opts___]:=Module[{td,sides,angles,tverts,ctr,weights,\[Alpha],s,r,o},
td=TwistDirection/.{opts}/.Options[BrocardTriangleInfo];
sides=PolygonSides[verts];
weights = sides^-2/Plus@@(sides^-2);
Switch[td,
CCW,ctr=Plus@@(weights verts);\[Alpha]=RotationAngle[ctr-verts[[2]],verts[[1]]-verts[[2]]],
CW,ctr=Plus@@(RotateRight[weights] verts);\[Alpha]=RotationAngle[ctr-verts[[1]],verts[[1]]-verts[[2]]],
_,Message[BrocardTriangleInfo::baddir,td];Abort[]];
{verts,ctr,\[Alpha]}]
Module[{verts,ctr,info},
verts={{0,1},{3/2,0},{2,5/3}};
info=BrocardTriangleInfo[verts,TwistDirection->CCW]//Simplify;
PrintThis[info];
Print["Brocard angle/\[Degree] = ",info[[3]]/\[Degree]//N];
ctr=info[[2]];
Print["CCW angles/\[Degree] = ",{
RotationAngle[ctr-verts[[2]],verts[[1]]-verts[[2]]],
RotationAngle[ctr-verts[[3]],verts[[2]]-verts[[3]]],
RotationAngle[ctr-verts[[1]],verts[[3]]-verts[[1]]]}/\[Degree]//N];
Print["CW angles/\[Degree] = ",{
RotationAngle[verts[[2]]-verts[[1]],ctr-verts[[1]]],
RotationAngle[verts[[3]]-verts[[2]],ctr-verts[[2]]],
RotationAngle[verts[[1]]-verts[[3]],ctr-verts[[3]]]}/\[Degree]//N];
Graphics[{Style[Line[AppendFirst[verts]],Gray],Style[Point[ctr],Black]},Frame->True]
]//ShowExample
UnitCyclicBrocardTriangleInfo[angles_List,opts___]:=Module[{td,\[Theta]1,\[Theta]2,ba,verts,bctr,cctr,r},
{\[Theta]1,\[Theta]2}=Take[angles,2];
{verts,bctr,ba}=UnitBrocardTriangleInfo[angles,opts];
{cctr,r}=Take[ConcyclicInfo[Take[verts,3]],2];
{verts,cctr,r,{\[Theta]1,\[Theta]2,\[Pi]-\[Theta]1-\[Theta]2},bctr,ba}]
Module[{\[Theta]1,\[Theta]2,angles,info1,info2,gfn},
\[Theta]1=60\[Degree];
\[Theta]2=75\[Degree];
angles={\[Theta]1,\[Theta]2,Null};
info1=UnitCyclicBrocardTriangleInfo[angles,TwistDirection->CCW];
info2=UnitCyclicBrocardTriangleInfo[angles,TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[AppendFirst[info[[1]]]],Black],
Style[Circle[info[[2]],info[[3]]],Green],
Style[Line[{#,info[[5]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Darker[Green]],
Style[Point[info[[5]]],Darker[Red]]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[6]]/\[Degree]//N]<>"\r"<>"Corner angles/\[Degree] = "<>ToString[info[[4]]/\[Degree]//N]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
UnitCyclicBrocardQuadrilateralInfo[angles_List,opts___]:=Module[{td,\[Theta]1,\[Theta]2,ba,verts,bctr,cctr,r},
td=TwistDirection/.{opts}/.Options[UnitBrocardPolygonInfo];
{\[Theta]1,\[Theta]2}=Take[angles,2];
ba=ArcTan[(Sin[\[Theta]1]Sin[\[Theta]2])/(\[Sqrt](1-Cos[\[Theta]1]^2 Cos[\[Theta]2]^2))];(* analytic solution for Brocard angle *)
Switch[td,
CCW,Null,
CW,ba=\[Pi]-ba,
_,Message[UnitBrocardPolygonInfo::baddir,td];Abort[]];
{verts,bctr}=Take[UnitBrocardPolygonInfo[{\[Theta]1,\[Theta]2,\[Pi]-\[Theta]1,\[Pi]-\[Theta]2},BrocardAngle->ba,opts],2];
{cctr,r}=Take[ConcyclicInfo[Take[verts,3]],2];
{verts,cctr,r,{\[Theta]1,\[Theta]2,\[Pi]-\[Theta]1,\[Pi]-\[Theta]2},bctr,ba}]
Module[{\[Theta]1,\[Theta]2,angles,info1,info2,gfn},
\[Theta]1=60\[Degree];
\[Theta]2=90\[Degree];
angles={\[Theta]1,\[Theta]2,Null,Null};
info1=UnitCyclicBrocardQuadrilateralInfo[angles,TwistDirection->CCW];
info2=UnitCyclicBrocardQuadrilateralInfo[angles,TwistDirection->CW];
gfn[info_]:=Graphics[{
Style[Line[AppendFirst[info[[1]]]],Black],
Style[Circle[info[[2]],info[[3]]],Green],
Style[Line[{#,info[[5]]}]&/@info[[1]],Red],
Style[Point[info[[2]]],Darker[Green]],
Style[Point[info[[5]]],Darker[Red]]},Frame->False,PlotLabel-> "Brocard angle/\[Degree] = "<>ToString[info[[6]]/\[Degree]//N]<>"\r"<>"Corner angles/\[Degree] = "<>ToString[info[[4]]/\[Degree]//N]];
GraphicsRow[{gfn[info1],gfn[info2]}]
]//ShowExample
UnitCyclicBrocardPolygonInfoCCW[n_,angle1_,angle2_,i1_:1,i2_:2]:=Module[{q,\[Theta],\[Alpha],eqn,r1,bctr,br,\[Phi],verts,cctr,cr,eqns,vars,addineq,qmin,qmax,soln},
\[Theta]=CompletePolygonAngles[Table[q[i],{i,n-1}]];(* angle variables *)
eqn=Times@@(Sin[#-\[Alpha]]&/@\[Theta])==Sin[\[Alpha]]^n;
(* now construct unit polygon vertices *)
r1=Sin[\[Alpha]]/Sin[\[Theta][[1]]];(* radius from center to vertex 1 *) 
bctr=r1 U[\[Theta][[1]]-\[Alpha]];(* center of closure *)
br=FoldList[(Sin[#2-\[Alpha]]/Sin[\[Alpha]])#1&,r1,Drop[\[Theta],-1]];
(* angles to vertices from bctr *)
\[Phi]=FoldList[Plus,\[Theta][[1]]-\[Alpha]-\[Pi],\[Pi]-Drop[\[Theta],-1]];verts=MapThread[bctr+#1 U[#2]&,{br,\[Phi]}];
verts[[1]]={0,0};verts[[2]]={1,0};(* set these to exact values *)
(* find circumcenter and radius *)
{cctr,cr}=Take[ConcyclicInfo[Take[verts,3]],2];
eqns=Flatten[{eqn,Table[Mag2[verts[[i]]-cctr]==cr^2,{i,4,n}],q[i1]==angle1,q[i2]==angle2}];
vars=Prepend[Table[{q[i],\[Pi]-(2\[Pi])/n},{i,n-1}],{\[Alpha],\[Pi]/2-\[Pi]/n}];(* start with regular n-gon *)
soln=FindRoot@@Join[{eqns},vars];
{verts,cctr,cr,\[Theta],bctr,\[Alpha]}/.soln]
Module[{\[Theta]1,\[Theta]2,i1,i2,verts,cctr,cr,\[Theta],bctr,\[Alpha]},
\[Theta]1=110\[Degree];
\[Theta]2=140\[Degree];
i1=1;
i2=3;
{verts,cctr,cr,\[Theta],bctr,\[Alpha]}=UnitCyclicBrocardPolygonInfoCCW[6,\[Theta]1,\[Theta]2,i1,i2];
\[Theta]=Mod[\[Theta],2\[Pi],-\[Pi]];
Print[ "Brocard angle/\[Degree] = ",ToString[\[Alpha]/\[Degree]//N]];
Print["Corner angles/\[Degree] = ",ToString[\[Theta]/\[Degree]//N]];
Graphics[{
Style[Line[AppendFirst[verts]],Black],
Style[Circle[cctr,cr],Lighter[Blue]],
Style[Line[{#,cctr}]&/@verts,Lighter[Blue]],
Style[Line[{#,bctr}]&/@verts,Red],
Style[Point[cctr],Darker[Blue]],
Style[Point[bctr],Darker[Red]]},Frame->False,Axes->True]
]//ShowExample
UnitCyclicBrocardPolygonInfoCW[n_,angle1_,angle2_,i1_:1,i2_:2]:=Module[{q,\[Theta],\[Alpha],eqn,r1,bctr,br,\[Phi],verts,cctr,cr,eqns,vars,addineq,qmin,qmax,soln},
\[Theta]=CompletePolygonAngles[Table[q[i],{i,n-1}]];(* angle variables *)
eqn=Times@@(Sin[#-(\[Pi]-\[Alpha])]&/@\[Theta])==Sin[\[Alpha]]^n;
(* now construct unit polygon vertices *)
r1=Sin[\[Theta][[2]]-(\[Pi]-\[Alpha])]/Sin[\[Theta][[2]]];(* radius from center to vertex 1 *) 
bctr=r1 U[\[Pi]-\[Alpha]];(* center of closure *)
br=FoldList[(Sin[\[Pi]-\[Alpha]]/Sin[#2-(\[Pi]-\[Alpha])])#1&,r1,Drop[\[Theta],1]];
(* absolute angles to vertices from bctr *)
\[Phi]=FoldList[Plus,-\[Alpha],\[Pi]-Drop[RotateLeft[\[Theta]],-1]];
verts=MapThread[bctr+#1 U[#2]&,{br,\[Phi]}];
verts[[1]]={0,0};verts[[2]]={1,0};(* set these to exact values *)
(* find circumcenter and radius *)
{cctr,cr}=Take[ConcyclicInfo[Take[verts,3]],2];
eqns=Flatten[{eqn,Table[Mag2[verts[[i]]-cctr]==cr^2,{i,4,n}],q[i1]==angle1,q[i2]==angle2}];
vars=Prepend[Table[{q[i],\[Pi]-(2\[Pi])/n},{i,n-1}],{\[Alpha],\[Pi]/2+\[Pi]/n}];(* start with regular n-gon *)
soln=FindRoot@@Join[{eqns},vars];
{verts,cctr,cr,\[Theta],bctr,\[Alpha]}/.soln]
Module[{\[Theta]1,\[Theta]2,i1,i2,angles,verts,cctr,cr,\[Theta],bctr,\[Alpha]},
\[Theta]1=110\[Degree];
\[Theta]2=140\[Degree];
i1=1;
i2=3;
{verts,cctr,cr,\[Theta],bctr,\[Alpha]}=UnitCyclicBrocardPolygonInfoCW[6,\[Theta]1,\[Theta]2,i1,i2];
\[Theta]=Mod[\[Theta],2\[Pi],-\[Pi]];
Print[ "Brocard angle/\[Degree] = ",ToString[\[Alpha]/\[Degree]//N]];
Print["Corner angles/\[Degree] = ",ToString[\[Theta]/\[Degree]//N]];
Graphics[{
Style[Line[AppendFirst[verts]],Black],
Style[Circle[cctr,cr],Lighter[Blue]],
Style[Line[{#,cctr}]&/@verts,Lighter[Blue]],
Style[Line[{#,bctr}]&/@verts,Red],
Style[Point[cctr],Darker[Blue]],
Style[Point[bctr],Darker[Red]]},Frame->False,Axes->True]
]//ShowExample
UnitCyclicBrocardPolygonInfo::baddir="Twist direction `1` must be CCW or CW.";
UnitCyclicBrocardPolygonInfo[n_,angle1_,angle2_,i1_:1,i2_:2,opts___]:=Module[{td},
td=TwistDirection/.{opts}/.Options[UnitBrocardPolygonInfo];
Switch[td,
CCW,UnitCyclicBrocardPolygonInfoCCW[n,angle1,angle2,i1,i2],
CW,UnitCyclicBrocardPolygonInfoCW[n,angle1,angle2,i1,i2],
_,Message[UnitCyclicBrocardPolygonInfo::baddir,td];Abort[]]]
Module[{\[Theta]1,\[Theta]2,i1,i2,gfn},
\[Theta]1=110\[Degree];
\[Theta]2=140\[Degree];
i1=1;
i2=3;
gfn[dir_]:=Module[{verts,cctr,cr,\[Theta],bctr,\[Alpha]},
{verts,cctr,cr,\[Theta],bctr,\[Alpha]}=UnitCyclicBrocardPolygonInfo[5,\[Theta]1,\[Theta]2,i1,i2,TwistDirection->dir];
\[Theta]=Mod[\[Theta],2\[Pi],-\[Pi]];
Print[ ToString[dir],": Brocard angle/\[Degree] = ",ToString[\[Alpha]/\[Degree]//N]];
Print[ToString[dir],": Corner angles/\[Degree] = ",ToString[\[Theta]/\[Degree]//N]];
Graphics[{
Style[Line[AppendFirst[verts]],Black],
Style[Circle[cctr,cr],Lighter[Blue]],
Style[Line[{#,cctr}]&/@verts,Lighter[Blue]],
Style[Line[{#,bctr}]&/@verts,Red],
Style[Point[cctr],Darker[Blue]],
Style[Point[bctr],Darker[Red]]},Frame->False,Axes->True,PlotLabel->ToString[dir]]];
GraphicsRow[{gfn[CCW],gfn[CW]}]
]//ShowExample
EquilateralPolygonClosure[angles_List]:=Module[{ba,aa,verts},
ba=\[Pi]-#&/@angles;(* bend angles *)
aa=FoldList[Plus,0,RotateRight[ba]];(* absolute angles *)
verts=FoldList[#1+U[#2]&,{0,0},Drop[aa,-1]];(* vertices of a unit polygon *)
verts[[-1]]-verts[[1]]]
Module[{angles,verts},
angles={108\[Degree],108\[Degree],108\[Degree],108\[Degree],108\[Degree]};
Simplify[EquilateralPolygonClosure[angles]]
]//ShowExample
foovals=Module[{angles,verts},
angles=CompletePolygonAngles[{\[Delta]1,\[Delta]2,\[Delta]3,\[Pi]-\[Delta]1}];
Simplify[EquilateralPolygonClosure[angles]]
]//ShowExample
UnitEquilateralPolygonVertices[angles_List]:=Module[{ba,aa},
ba=\[Pi]-#&/@Drop[angles,1];(* bend angles *)
aa=FoldList[Plus,0,ba];(* absolute angles *)
FoldList[#1+U[#2]&,{0,0},Drop[aa,-1]]]
Module[{angles,verts},
angles={108\[Degree],108\[Degree],108\[Degree],108\[Degree],108\[Degree]};
verts=UnitEquilateralPolygonVertices[angles];
Graphics[Line[AppendFirst[verts]]]
]//ShowExample
UnitRegularPolygonCenter[n_]:=(1/2){1, Cot[\[Pi]/n]};
UnitRegularPolygonInteriorAngle[n_] :=\[Pi]/2- \[Pi]/n;
UnitRegularPolygonRotationAngle[n_] := (2\[Pi])/n;
UnitRegularPolygonInradius[n_]:=UnitRegularPolygonInradius[n]=(1/2)Cot[\[Pi]/n];
UnitRegularPolygonCircumradius[n_]:=UnitRegularPolygonCircumradius[n]=(1/2) Csc[\[Pi]/n];
UnitRegularPolygonVertex[j_, n_]:=With[{c=UnitRegularPolygonCenter[n]},c-RotationMatrix2D[((2\[Pi])/n)(j-1)] . c];
UnitRegularPolygonVertices[n_]:=UnitRegularPolygonVertices[n]=Table[UnitRegularPolygonVertex[j,n],{j,n}];
UnitRegularStarPolygonCenter[n_,\[Alpha]_]:={1,0}+(Sin[\[Alpha]/2]/Sin[\[Pi]/n])U[\[Alpha]/2+\[Pi]/n];
UnitRegularStarPolygonPointRadius[n_, \[Alpha]_]:=Sin[\[Pi]-\[Alpha]/2-\[Pi]/n]/Sin[\[Pi]/n];
UnitRegularStarPolygonOtherRadius[n_, \[Alpha]_]:=Sin[\[Alpha]/2]/Sin[\[Pi]/n];
UnitRegularStarPolygonInradius[n_, \[Alpha]_]:=Min[UnitRegularStarPolygonPointRadius[n,\[Alpha]],UnitRegularStarPolygonOtherRadius[n,\[Alpha]]]
UnitRegularStarPolygonCircumradius[n_, \[Alpha]_]:=Max[UnitRegularStarPolygonPointRadius[n,\[Alpha]],UnitRegularStarPolygonOtherRadius[n,\[Alpha]]]
UnitRegularStarPolygonVertex[j_, n_, \[Alpha]_]:=With[{c=UnitRegularStarPolygonCenter[n,\[Alpha]]},c-If[OddQ[j],UnitRegularStarPolygonPointRadius[n,\[Alpha]],UnitRegularStarPolygonOtherRadius[n,\[Alpha]]]U[(j-1)\[Pi]/n+\[Alpha]/2]]
UnitRegularStarPolygonVertices[n_, \[Alpha]_]:=With[{c=UnitRegularStarPolygonCenter[n,\[Alpha]],ro=UnitRegularStarPolygonPointRadius[n,\[Alpha]],ri=UnitRegularStarPolygonOtherRadius[n,\[Alpha]]},Table[c-If[OddQ[j],ro,ri]U[(j-1)\[Pi]/n+\[Alpha]/2],{j,1,2n}]]
Module[{n,\[Alpha],ctr},
n=5;
\[Alpha]=36\[Degree];
ctr=UnitRegularStarPolygonCenter[n,\[Alpha]];
Graphics[{
Style[Point[ctr],PointSize[.02]],
Style[Line[AppendFirst[UnitRegularStarPolygonVertices[n,\[Alpha]]]],Blue],
Style[Circle[ctr,UnitRegularStarPolygonPointRadius[n,\[Alpha]]],Red],
Style[Circle[ctr,UnitRegularStarPolygonOtherRadius[n,\[Alpha]]],Green],
Style[Table[Text[ToString[j],UnitRegularStarPolygonVertex[j,n,\[Alpha]],{-2,0}],{j,2n}],Black],
{}},Axes->True]
]//ShowExample
UnitQuadrilateralVertices::badis="Side length specifier `1` must be 2, 3, or 4.";
UnitQuadrilateralVertices[angles_List, side_, is_]:=Module[{verts,s2,s3,s4,v3,v4a,v4b,eqns},
v3={1,0}+s2 U[\[Pi]-angles[[2]]];
v4a=v3+s3 U[2\[Pi]-angles[[2]]-angles[[3]]];
v4b=s4 U[angles[[1]]];
eqns=Append[#==0&/@(v4a-v4b),Switch[is,
2,s2==side,
3,s3==side,
4,s4==side,
_,Message[UnitQuadrilateralVertices::badis,is];Abort[]]];
{{0,0},{1,0},v3,v4a}/.Solve[eqns,{s2,s3,s4}][[1]]]
Module[{verts},
verts=UnitQuadrilateralVertices[{90\[Degree],80\[Degree],110\[Degree],0},.6,2];
PrintThis[verts];
Graphics[Line[AppendFirst[verts]],Frame->True]
]//ShowExample
NiceUnitQuadrilateralVertices[alist_List]:=Module[{p1,p2,p3,p4,a1,a2,a3,l2,l3,l4,soln},
{a1,a2,a3}=Take[alist,3];
p1={0,0};
p2={1,0};
p3=p2+l2 U[\[Pi]-a2];
p4=LineInt2D[p3,U[\[Pi]-a2+\[Pi]-a3],p1,U[a1]];
l3=Mag[p4-p3];
l4=Mag[p4-p1];
soln=FindMinimum[{(l2-1)^2+(l3-1)^2+(l4-1)^2,p4[[2]]>0},{{l2,0}}];
{p1,p2,p3,p4}/.soln[[2]]]
Module[{alist,plist},
alist={90.\[Degree],95.\[Degree],88.\[Degree]};
plist=NiceUnitQuadrilateralVertices[alist];
Graphics[Line[AppendFirst[plist]],Axes->True]
]//ShowExample
TriangleStarTwistTriangle::badlen="List `1` must contain exactly six 2D points.";
TriangleStarTwistTriangle[plist_List,dir_:1]:=Module[{p1,p2,p3,p4,p5,p6,u1,u3,u5,r1,r3,r5,c,r1max,r3max,r5max,r1min,r3min,r5min,q1,q3,q5,s2,s4,s6,soln},
If[Length[plist]!=6,Message[TriangleStarTwistTriangle::badlen,plist];Abort[]];
{p1,p2,p3,p4,p5,p6}=plist;
u1=NormalizeReal[(p6+p2)/2-p1];
u3=NormalizeReal[(p2+p4)/2-p3];
u5=NormalizeReal[(p4+p6)/2-p5];
(* parameterized points along bisectors of sharp points to form central triangle *)
q1=p1+r1 u1;
q3=p3+r3 u3;
q5=p5+r5 u5;
(* max values of r come from the intersection point of any two bisectors *)
c=LineInt2D[p1,u1,p3,u3];
r1max=(c-p1) . u1;
r3max=(c-p3) . u3;
r5max=(c-p5) . u5;
(* minimum values come from twist direction; dir=+1 is CCW, dir=-1 is CW *)
If[dir==+1,
(* CCW twist *)
r1min=Max[0,(LineInt2D1[p1,p1+u1,p5,p6]-p1) . u1];
r3min=Max[0,(LineInt2D1[p3,p3+u3,p1,p2]-p3) . u3];
r5min=Max[0,(LineInt2D1[p5,p5+u5,p3,p4]-p5) . u5],
(* CW twist *)
r1min=Max[0,(LineInt2D1[p1,p1+u1,p3,p2]-p1) . u1];
r3min=Max[0,(LineInt2D1[p3,p3+u3,p5,p4]-p3) . u3];
r5min=Max[0,(LineInt2D1[p5,p5+u5,p1,p6]-p5) . u5]];
(* Reflect reflex corners through sides of central triangle *)
s2=Reflect2D[p2,{q1,q3}];s4=Reflect2D[p4,{q3,q5}];s6=Reflect2D[p6,{q5,q1}];
(* Minimize the area of the resulting triangle. Should be very close to zero. Suppress warning messages about tolerance.*)
soln=Quiet[FindMinimum[{Det[{s6-s4,s2-s4}]^2,{r1<r1max,r3<r3max,r5<r5max,r1>r1min,r3>r3min,r5>r5min}},{{r1,0},{r3,0},{r5,0}}],FindMinimum::lstol];
{q1,q3,q5}/.soln[[2]]]
Module[{p1,p2,p3,p4,p5,p6,plist,q1,q3,q5,qlist,s},
p2={0,0};p4={1.4,1};p6={-.3,1.4};
p1=1.5RotationMatrix2D[\[Pi]/2] . (p6-p2)+(p6+p2)/2;
p3=1.2RotationMatrix2D[\[Pi]/2] . (p2-p4)+(p2+p4)/2;
p5=1.4RotationMatrix2D[\[Pi]/2] . (p4-p6)+(p4+p6)/2;
plist={p1,p2,p3,p4,p5,p6};
qlist=TriangleStarTwistTriangle[plist,+1];
{q1,q3,q5}=qlist;
s=Reflect2D[p2,{q1,q3}];
Graphics[{
MapThread[Text[#1,#2,{2,0}]&,{{"p1","p2","p3","p4","p5","p6"},plist}],
MapThread[Text[#1,#2,{2,0}]&,{{"q1","q3","q5"},qlist}],
Text["s",s,{2,0}],
Line[AppendFirst[plist]],
Style[{Line[{p1,q1}],Line[{p3,q3}],Line[{p5,q5}],Line[{q1,q3,q5,q1}]},Red],
Style[{Line[{q1,s}],Line[{q3,s}],Line[{q5,s}]},LightGray],
Style[{Line[{q1,p2}],Line[{q3,p4}],Line[{q5,p6}]},LightGray],
Style[{Line[{q1,p6}],Line[{q3,p2}],Line[{q5,p4}]},Blue],
Point/@plist,
Point/@qlist,
Point[s],
{}},Axes->True]
]//ShowExample
Module[{p1,p2,p3,p4,p5,p6,plist,q1,q3,q5,qlist,s},
p2={0,0};p4={1.4,1};p6={-.3,1.4};
p1=1.5RotationMatrix2D[\[Pi]/2] . (p6-p2)+(p6+p2)/2;
p3=1.2RotationMatrix2D[\[Pi]/2] . (p2-p4)+(p2+p4)/2;
p5=1.4RotationMatrix2D[\[Pi]/2] . (p4-p6)+(p4+p6)/2;
plist={p1,p2,p3,p4,p5,p6};
qlist=TriangleStarTwistTriangle[plist,-1];
{q1,q3,q5}=qlist;
s=Reflect2D[p2,{q1,q3}];
Graphics[{
MapThread[Text[#1,#2,{2,0}]&,{{"p1","p2","p3","p4","p5","p6"},plist}],
MapThread[Text[#1,#2,{2,0}]&,{{"q1","q3","q5"},qlist}],
Text["s",s,{2,0}],
Line[AppendFirst[plist]],
Style[{Line[{p1,q1}],Line[{p3,q3}],Line[{p5,q5}],Line[{q1,q3,q5,q1}]},Red],
Style[{Line[{q1,s}],Line[{q3,s}],Line[{q5,s}]},LightGray],
Style[{Line[{q1,p2}],Line[{q3,p4}],Line[{q5,p6}]},Blue],
Style[{Line[{q1,p6}],Line[{q3,p2}],Line[{q5,p4}]},LightGray],
Point/@plist,
Point/@qlist,
Point[s],
{}},Axes->True]
]//ShowExample
DiscreteCircle[m_,r_:1, \[Phi]_:0]:=
Table[{r Cos[\[Psi]],r Sin[\[Psi]]},{\[Psi],\[Phi],\[Phi]+2\[Pi]-2\[Pi]/m,2\[Pi]/m}]
Module[{m,r,\[Phi],pts},
m=6;
r=1;
\[Phi]=0\[Degree];
pts=DiscreteCircle[m,r,\[Phi]];
PrintThis[pts];
Graphics[{Style[Line[AppendFirst[pts]],Black],Style[Point[pts[[1]]],PointSize[.02],Red]},Axes->True]
]//ShowExample
Module[{m,r,\[Phi],pts},
m=12;
r=2.;
\[Phi]=45\[Degree];
pts=DiscreteCircle[m,r,\[Phi]];
Graphics[{Style[Line[AppendFirst[pts]],Black],Style[Point[pts[[1]]],PointSize[.02],Red]},Axes->True]
]//ShowExample
Module[{x,y,soln},
x=r Cos[\[Psi]];
y=r Sin[\[Psi]];
soln=Solve[x^2/a^2+y^2/b^2==1,r];
FullSimplify[{x,y}/.soln[[2]]]
]//ShowExample
DiscreteEllipseEquiaxial[m_,{a_,b_},\[Phi]_:0,\[Theta]_:0]:=Module[{rm},
rm=RotationMatrix2D[\[Theta]];
Table[rm . {Cos[\[Psi]]/(\[Sqrt](Cos[\[Psi]]^2/a^2+Sin[\[Psi]]^2/b^2)),Sin[\[Psi]]/(\[Sqrt](Cos[\[Psi]]^2/a^2+Sin[\[Psi]]^2/b^2))},{\[Psi],\[Phi],\[Phi]+2\[Pi],2\[Pi]/m}]]
Module[{m,a,b,\[Phi],\[Theta],pts},
m=16;
a=GoldenRatio;
b=1.;
\[Phi]=45\[Degree];
\[Theta]=45\[Degree];
pts=DiscreteEllipseEquiaxial[m,{a,b},\[Phi],\[Theta]];
Graphics[{Style[Line[AppendFirst[pts]],Black],Style[Point[pts[[1]]],PointSize[.02],Red]},Axes->True]
]//ShowExample
DiscreteEllipseEquilateral[m_,{a_,b_},\[Phi]_:0,\[Theta]_:0]:=Module[{pts,\[Psi],vars,vars0,eqns,d,soln,rm},
pts=Table[{Cos[\[Psi][j]]/(\[Sqrt](Cos[\[Psi][j]]^2/a^2+Sin[\[Psi][j]]^2/b^2)),Sin[\[Psi][j]]/(\[Sqrt](Cos[\[Psi][j]]^2/a^2+Sin[\[Psi][j]]^2/b^2))},{j,0,m-1}];
\[Psi][0]=\[Phi];
vars=Table[\[Psi][j],{j,0,m-1}];
vars[[1]]=d;
vars0=Table[\[Psi],{\[Psi],\[Phi],\[Phi]+2\[Pi]-2\[Pi]/m,2\[Pi]/m}];
vars0[[1]]=\[Pi] (a+b)/m;
eqns=Table[Mag[pts[[j]]-pts[[Mod[1+j,m,1]]]]==d,{j,m}];
soln=FindRoot@@{eqns,Transpose[{vars,vars0}]};
rm=RotationMatrix2D[\[Theta]];
rm . #&/@(pts/.soln)]
Module[{m,a,b,\[Phi],\[Theta],pts},
m=16;
a=GoldenRatio;
b=1.;
\[Phi]=45\[Degree];
\[Theta]=45\[Degree];
pts=DiscreteEllipseEquilateral[m,{a,b},\[Phi],\[Theta]];
Graphics[{Style[Line[AppendFirst[pts]],Black],Style[Point[pts[[1]]],PointSize[.02],Red]},Axes->True]
]//ShowExample
Module[{m,a,b,\[Phi],\[Theta],pts1,pts2},
m=16;
a=GoldenRatio;
b=1.;
\[Phi]=0\[Degree];
\[Theta]=0\[Degree];
pts1=DiscreteEllipseEquiaxial[m,{a,b},\[Phi],\[Theta]];
pts2=DiscreteEllipseEquilateral[m,{a,b},\[Phi],\[Theta]];
Graphics[{
Style[Line[AppendFirst[pts1]],Red],
Style[Line[AppendFirst[pts2]],Green],Style[Point/@pts1,PointSize[.025],Darker[Red]],
Style[Point/@pts2,PointSize[.015],Darker[Green]],
{}},Axes->True]
]//ShowExample
DiscreteEllipseEquiangular[m_,{a_,b_},\[Phi]_:0,\[Theta]_:0]:=Module[{pts,\[Psi],vars,vars0,v1,v2,r90,err,eqns,cd,soln,rm},
pts=Table[{Cos[\[Psi][j]]/(\[Sqrt](Cos[\[Psi][j]]^2/a^2+Sin[\[Psi][j]]^2/b^2)),Sin[\[Psi][j]]/(\[Sqrt](Cos[\[Psi][j]]^2/a^2+Sin[\[Psi][j]]^2/b^2))},{j,0,m-1}];
\[Psi][0]=\[Phi];
vars=Table[\[Psi][j],{j,0,m-1}];
vars[[1]]=cd;
vars0=Table[\[Psi],{\[Psi],\[Phi],\[Phi]+2\[Pi]-2\[Pi]/m,2\[Pi]/m}];
vars0[[1]]=Sin[2\[Pi]/m];
r90=RotationMatrix2D[\[Pi]/2];
err=Table[
v1=r90 . NormalizeReal[pts[[j]]-pts[[Mod[j-1,m,1]]]];
v2=NormalizeReal[pts[[Mod[j+1,m,1]]]-pts[[j]]];
v1 . v2-cd ,{j,m}];
soln=FindRoot@@{#==0&/@err,Transpose[{vars,vars0}]};
PrintThis[Chop[err/.soln]]//Hold;
rm=RotationMatrix2D[\[Theta]];
rm . #&/@(pts/.soln)]
Module[{m,a,b,\[Phi],\[Theta],pts},
m=24;
a=GoldenRatio;
b=1.;
\[Phi]=45\[Degree];
\[Theta]=45\[Degree];
pts=DiscreteEllipseEquiangular[m,{a,b},\[Phi],\[Theta]];
Graphics[{Style[Line[AppendFirst[pts]],Black],Style[Point[pts[[1]]],PointSize[.02],Red]},Axes->True]
]//ShowExample
Module[{m,a,b,\[Phi],\[Theta],pts1,pts2,pts3},
m=24;
a=GoldenRatio;
b=1.;
\[Phi]=0\[Degree];
\[Theta]=0\[Degree];
pts1=DiscreteEllipseEquiaxial[m,{a,b},\[Phi],\[Theta]];
pts2=DiscreteEllipseEquilateral[m,{a,b},\[Phi],\[Theta]];
pts3=DiscreteEllipseEquiangular[m,{a,b},\[Phi],\[Theta]];
Graphics[{
Style[Line[AppendFirst[pts1]],Red],
Style[Line[AppendFirst[pts2]],Green],
Style[Line[AppendFirst[pts3]],Blue],Style[Point/@pts1,PointSize[.025],Darker[Red]],
Style[Point/@pts2,PointSize[.015],Darker[Green]],
Style[Point/@pts3,PointSize[.005],Darker[Blue]],
{}},Axes->True]
]//ShowExample
PleatDirection::usage="PleatDirection is an option to PleatReducePolygon the specifies the direction that the pleats point in the reduction.";
Options[PleatReducePolygon]={
PleatDirection->CCW
};
PleatReducePolygon[pts_List,r_,opts___]:=Module[{pd,rp,rm},
pd=PleatDirection/.{opts}/.Options[PleatReducePolygon];
rp=(1+r)/2;
rm=(1-r)/2;
If[pd===CCW,
RotateRight[Flatten[MapThread[{r #1,r #1+rp(#2-#1)}&,{pts,RotateLeft[pts]}],1],1],
Flatten[MapThread[{r #2+rp(#1-#2),r #2}&,{pts,RotateLeft[pts]}],1]]]
Module[{pts,pts1,pts2},
pts=DiscreteCircle[4]//N;
pts1=PleatReducePolygon[pts,0.5];
pts2=PleatReducePolygon[pts,0.5,PleatDirection->CW];
GraphicsRow[{
Graphics[{
Style[Line[AppendFirst[pts1]],Gray],
Style[Line[Take[pts1,3]],Black,Thickness[.01]],
Style[Point[pts1[[1]]],Red,PointSize[.04]],
Style[Point[pts1[[2]]],Green,PointSize[.04]],
Style[Point[pts1[[3]]],Blue,PointSize[.04]]}],
Graphics[{
Style[Line[AppendFirst[pts2]],Gray],
Style[Line[Take[pts2,3]],Black,Thickness[.01]],
Style[Point[pts2[[1]]],Red,PointSize[.04]],
Style[Point[pts2[[2]]],Green,PointSize[.04]],
Style[Point[pts2[[3]]],Blue,PointSize[.04]]}]}]
]//ShowExample
Module[{pts,pts1,pts2},
pts=DiscreteCircle[5]//N;
pts1=PleatReducePolygon[pts,0.667];
pts2=PleatReducePolygon[pts,0.333,PleatDirection->CW];
PrintThis[PolygonPerimeter[pts]];
PrintThis[PolygonPerimeter[pts1]];
PrintThis[PolygonPerimeter[pts2]];
Graphics[{
Style[Line[AppendFirst[pts]],Red],
Style[Point/@pts,Darker[Red],PointSize[.02]],
Style[Line[AppendFirst[pts1]],Green],
Style[Point/@pts1,Darker[Green],PointSize[.02]],
Style[Line[AppendFirst[pts2]],Blue],
Style[Point/@pts2,Darker[Blue],PointSize[.02]],
{}}]
]//ShowExample
RectVertices[{w_,h_}]:={{0,0},{w,0},{w,h},{0,h}}
RectVertices[{px_,py_},{qx_,qy_}]:=Module[{xmin,xmax,ymin,ymax},
xmin=Min[px,qx];xmax=Max[px,qx];
ymin=Min[py,qy];ymax=Max[py,qy];
{{xmin,ymin},{xmax,ymin},{xmax,ymax},{xmin,ymax}}]
RectVertices[{1,2},{3,4}]//ShowExample
SquareVertices[r_]:={{0,0},{r,0},{r,r},{0,r}}
SquareVertices[p_List,r_]:=p+#&/@{{0,0},{r,0},{r,r},{0,r}}
BoundingBox[plist_List]:={Min[#],Max[#]}&/@Transpose[plist]
BoundingBox[{{0,-.5},{1,0},{0.5,1.5}}]
BoundingBoxExtent[plist_]:=#[[2]]-#[[1]]&/@BoundingBox[plist]
BoundingBoxExtent[{{0,-.5},{1,0},{0.5,1.5}}]
IntersectionTolerance::usage="IntersectionTolerance is an option to BoundingBoxesIntersectQ (and others) that specifies a distance tolerance for intersections.";
Options[BoundingBoxesIntersectQ]={
IntersectionTolerance -> 0
};
BoundingBoxesIntersectQ[pbox_List, qbox_List,opts___]:=Module[{itol},
itol=IntersectionTolerance/.{opts}/.Options[BoundingBoxesIntersectQ];
!Or[pbox[[1,2]]<qbox[[1,1]]-itol,qbox[[1,2]]<pbox[[1,1]]-itol,pbox[[2,2]]<qbox[[2,1]]-itol,qbox[[2,2]]<pbox[[2,1]]-itol]]
Module[{pbox,qbox,pverts,qverts,int},
pbox={{0,1},{0,1}};
qbox={{.5,1.5},{.5,1.5}};
pverts=RectVertices@@Transpose[pbox];
qverts=RectVertices@@Transpose[qbox];
int=BoundingBoxesIntersectQ[pbox,qbox];
Graphics[{Style[Line[AppendFirst[pverts]],Red],Style[Line[AppendFirst[qverts]],Green]},PlotLabel->If[int,"intersects","no intersection"]]
]//ShowExample
Module[{pbox,qbox,pverts,qverts,int},
pbox={{0,1},{0,1}};
qbox={{-.2,1.2},{.2,.8}};
pverts=RectVertices@@Transpose[pbox];
qverts=RectVertices@@Transpose[qbox];
int=BoundingBoxesIntersectQ[pbox,qbox];
Graphics[{Style[Line[AppendFirst[pverts]],Red],Style[Line[AppendFirst[qverts]],Green]},PlotLabel->If[int,"intersects","no intersection"]]
]//ShowExample
Module[{pbox,qbox,pverts,qverts,int},
pbox={{0,1},{0,1}};
qbox={{1.5,2.5},{.5,1.5}};
pverts=RectVertices@@Transpose[pbox];
qverts=RectVertices@@Transpose[qbox];
int=BoundingBoxesIntersectQ[pbox,qbox];
Graphics[{Style[Line[AppendFirst[pverts]],Red],Style[Line[AppendFirst[qverts]],Green]},PlotLabel->If[int,"intersects","no intersection"]]
]//ShowExample
Module[{pbox,qbox,itol,pverts,qverts,p1verts,q1verts,int},
pbox={{0,1},{0,1}};
qbox={{1.05,2.05},{.5,1.5}};
itol=0.07;
pverts=RectVertices@@Transpose[pbox];
qverts=RectVertices@@Transpose[qbox];
int=BoundingBoxesIntersectQ[pbox,qbox,IntersectionTolerance->itol];
p1verts=RectVertices@@Transpose[pbox+{{-itol,itol},{-itol,itol}}/2];
q1verts=RectVertices@@Transpose[qbox+{{-itol,itol},{-itol,itol}}/2];
Graphics[{
Style[Line[AppendFirst[pverts]],Red],
Style[Line[AppendFirst[qverts]],Green],
Style[Line[AppendFirst[p1verts]],Lighter[Red]],
Style[Line[AppendFirst[q1verts]],Lighter[Green]],
{}},PlotLabel->If[int,"intersects","no intersection"]]
]//ShowExample
Orientation::usage="Orientation is an option to MinimumBoundingBoxRotationAngle that specifies the desired orientation of the rotated bounding box.";
Options[MinimumBoundingBoxRotationAngle]={
Orientation->Automatic
};
MinimumBoundingBoxRotationAngle::badorien="`1` is an invalid option for Orientation.";
MinimumBoundingBoxRotationAngle[verts_,opts___]:=Module[{or,rverts,\[Alpha],w,h,eqns,soln},
or=Orientation/.{opts}/.Options[MinimumBoundingBoxRotationAngle];
rverts=RotationMatrix2D[\[Alpha]] . #&/@verts;
{w,h}=BoundingBoxExtent[rverts];
eqns=Join[{w h},Switch[or,Horizontal,{\[Alpha]>-\[Pi]/2,\[Alpha]<=\[Pi]/2,w>=h},Vertical,{\[Alpha]>-\[Pi]/2,\[Alpha]<=\[Pi]/2,w<=h},Automatic,{\[Alpha]>-\[Pi]/4,\[Alpha]<=\[Pi]/4},_,Message[MinimumBoundingBoxRotationAngle::badorien];Abort[]]];
soln=NMinimize[eqns,{\[Alpha]}];
\[Alpha]/.soln[[2]]]
Module[{verts,bbox,\[Alpha],rverts,gfn},
SeedRandom[0];
verts=Table[2.Random[]{1,1}+3. Random[]{1,-1},{20}];
\[Alpha]=MinimumBoundingBoxRotationAngle[verts,Orientation->Automatic];
Print["\[Alpha]/\[Degree] = ",\[Alpha]/\[Degree]];
rverts=RotationMatrix2D[\[Alpha]] . #&/@verts;
gfn[pts_]:=Graphics[{Style[Point/@pts,PointSize[.02]],Style[Line[AppendFirst[RectVertices@@Transpose[BoundingBox[pts]]]],Red]},Frame->True];
GraphicsRow[{gfn[verts],gfn[rverts]}]
]//ShowExample
PtInHalfPlaneQ[q_,{p1_,p2_,p3_}]:=Module[{r=Rotate90[p2-p1]},(q-p1) . r==0||Sign[(q-p1) . r]==Sign[(p3-p1) . r]]
Module[{pts,halfplane},
pts=Table[{Random[],.5-Random[]},{40}];
halfplane={{0,0},{1,0},{.5,.5}};
Graphics[{Line[halfplane[[{1,2}]]],PointSize[.04],Point[halfplane[[3]]],PointSize[.02],Gray,Point/@pts,Red,Point/@Select[pts,PtInHalfPlaneQ[#,halfplane]&]}]
]//ShowExample
PtNotInHalfPlaneQ[q_,{p1_,p2_,p3_}]:=!PtInHalfPlaneQ[q,{p1,p2,p3}]
Module[{pts,halfplane},
pts=Table[{Random[],.5-Random[]},{40}];
halfplane={{0,0},{1,0},{.5,.5}};
Graphics[{Line[halfplane[[{1,2}]]],PointSize[.04],Point[halfplane[[3]]],PointSize[.02],Gray,Point/@pts,Red,Point/@Select[pts,PtNotInHalfPlaneQ[#,halfplane]&]}]
]//ShowExample
PtInWedgeQ[q_,{p0_,p1_,p2_}]:=Module[{fq=ArcTan@@(q-p0),f1=ArcTan@@(p1-p0),f2=ArcTan@@(p2-p0)},Mod[fq-f1,2\[Pi]]<=Mod[f2-f1,2\[Pi]]]
Module[{pts,wedge},
pts=Table[{1-1.5Random[],1-1.5Random[]},{40}];
wedge={{0,0},{1,0},{0,1}};
Graphics[{Line[wedge[[{2,1,3}]]],PointSize[.02],Gray,Point/@pts,Red,Point/@Select[pts,PtInWedgeQ[#,wedge]&]}]
]//ShowExample
PtInTriangleQ[p_,{a_,b_,c_}]:=Module[{x,y},{x,y}=Transpose[Inverse[{b-a,c-a}]] . (p-a);x>0&&x<1&&y>0&&y<1&&x+y<1]
Graphics[{PointSize[.02],Module[{a={.1,.1},b={.9,.2},c={.4,.8},p},{RGBColor[1,.5,0],Line[{a,b,c,a}],Table[p={Random[],Random[]};{If[PtInTriangleQ[p,{a,b,c}],Red,Blue],Point[p]},{60}]}]}]//ShowExample
PtInTrianglesQ[p_,tlist_List]:=Catch[If[PtInTriangleQ[p,#],Throw[True]]&/@tlist;False]
Module[{tlist,p},
tlist={{{0,0},{0,1},{-1,.5}},{{0,0},{0,1},{1,.5}}};
Graphics[{Style[Line[AppendFirst[#]],Orange]&/@tlist,Table[p={2.4Random[]-1.2,Random[]};Style[Point[p],If[PtInTrianglesQ[p,tlist],Red,Blue],PointSize[.02]],{60}]}]
]//ShowExample
PtInConvexPolygonQ[q_,poly_List]:=Module[{ctr},
ctr=Centroid[poly];
Catch[MapThread[If[PtNotInHalfPlaneQ[q,{#1,#2,ctr}],Throw[False]]&,{poly,RotateLeft[poly]}];
Throw[True]]]
Module[{q,poly},
q={0.5,0.5};
poly={{0,0},{1,0},{1,1},{0,1}};
Print[Graphics[{Style[Point[q],Black,AbsolutePointSize[5]],Style[Line[AppendFirst[poly]],Gray]}]];
PtInConvexPolygonQ[q,poly]
]//ShowExample
Module[{q,poly},
q={0.5,0.5};
poly={{1,0},{1,0},{1,1},{0,1}};
Print[Graphics[{Style[Point[q],Black,AbsolutePointSize[5]],Style[Line[AppendFirst[poly]],Gray]}]];
PtInConvexPolygonQ[q,poly]
]//ShowExample
Module[{q,poly},
q={1.5,0.5};
poly={{0,0},{1,0},{1,1},{0,1}};
Print[Graphics[{Style[Point[q],Black,AbsolutePointSize[5]],Style[Line[AppendFirst[poly]],Gray]}]];
PtInConvexPolygonQ[q,poly]
]//ShowExample
IncludeCollinear::usage="IncludeCollinear is an options to SegmentsIntersectQ that specifies whether overlapping collinear segments should be considered to overlap.";
Options[SegmentsIntersectQ]={
IncludeCollinear->True,
IntersectionTolerance->0
};
SegmentsIntersectQ[{p1_,p2_}, {q1_,q2_},opts___]:=Module[{ic,itol,ssmi},
ic=IncludeCollinear/.{opts}/.Options[SegmentsIntersectQ];
itol=IntersectionTolerance/.{opts}/.Options[SegmentsIntersectQ];
(* First check bounding boxes to eliminate the easy cases *)
If[!BoundingBoxesIntersectQ[BoundingBox[{p1,p2}],BoundingBox[{q1,q2}],opts],Return[False]];
(* And if we're not including collinear and these are collinear, that's an easy answer. *)
If[!ic&&Chop[Det[{p2-p1,q1-q2}]]==0&&Chop[Abs[({{0,-1},{1,0}} . NormalizeReal[p2-p1]) . (q1-p1)]]<=itol,Return[False]];
(* All other cases, find the medial point between the segments and use its distance from both *)
ssmi=SegmentSegmentMedialInfo[{p1,p2},{q1,q2}];
Chop[ssmi[[2]]]<=itol/2]
Module[{p1,p2,q1,q2},
{p1,p2,q1,q2}={{0,0},{1,0},{.4,.1},{.4,.5}};
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2}],"intersect","no intersection"]]
]//ShowExample
Module[{p1,p2,q1,q2},
{p1,p2,q1,q2}={{0,0},{1,0},{.4,-.3},{.4,.3}};
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2}],"intersect","no intersection"]]
]//ShowExample
Module[{p1,p2,q1,q2},
{p1,p2,q1,q2}={{0,0},{1,0},{0,-.3},{0,.3}};
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2}],"intersect","no intersection"]]
]//ShowExample
Module[{p1,p2,q1,q2,itol},
{p1,p2,q1,q2}={{0.02,0},{1,0},{0,-.3},{0,.3}};
itol=0.03;
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2},IntersectionTolerance->itol],"intersect","no intersection"]]
]//ShowExample
Module[{p1,p2,q1,q2},
{p1,p2,q1,q2}={{0,0},{1,0},{.5,.5},{1.5,.5}};
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2}],"intersect","no intersection"]]
]//ShowExample
Module[{p1,p2,q1,q2},
{p1,p2,q1,q2}={{0,0},{1,0},{1.5,0},{2.5,0}};
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2}],"intersect","no intersection"]]
]//ShowExample
Module[{p1,p2,q1,q2},
{p1,p2,q1,q2}={{0,0},{1,0},{0.5,0},{1.5,0}};
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2}],"intersect","no intersection"]]
]//ShowExample
Module[{p1,p2,q1,q2},
{p1,p2,q1,q2}={{0,0},{1,0},{-0.5,0},{1.5,0}};
Graphics[{Style[Line[{p1,p2}],Red,Thickness[.01]],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2}],"intersect","no intersection"]]
]//ShowExample
Module[{p1,p2,q1,q2},
{p1,p2,q1,q2}={{0,0},{1,0},{0.5,0},{1.5,0}};
Graphics[{Style[Line[{p1,p2}],Red],Style[Line[{q1,q2}],Green]},PlotLabel->If[SegmentsIntersectQ[{p1,p2},{q1,q2},IncludeCollinear->False],"intersect","no intersection"]]
]//ShowExample
QuasiConvexPolygonIntersectionInfo::badpoly="The polygon `1` has more than 1 reflex vertex.";
QuasiConvexPolygonIntersectionInfo[poly_List]:=Module[{bbox,angles,nsp,nsm,rpos,convex,tverts},
(* bounding box *)
bbox={{Min[#[[1]]],Max[#[[1]]]},{Min[#[[2]]],Max[#[[2]]]}}&[Transpose[poly]];
(* triangulation *)
angles=RotationAngles[poly];
nsp=Count[#>0&/@angles,True];(* # of strictly positive angles *)
nsm=Count[#<0&/@angles,True];(* # of strictly negative angles *)
rpos=Flatten[If[nsp>nsm,
Position[#>=0&/@angles,False],
Position[#<=0&/@angles,False]]];(* position(s) of opposite-sign angles *)
Switch[Length[rpos],
0,(* no reflex vertices, triangulate from first non-flat vertex *)
convex=True;
rpos=Flatten[Position[#!=0&/@angles,True]][[1]],
1,(* one reflex vertex, triangulate from that vertex *)
convex=False;
rpos=rpos[[1]],
_,(* more than one reflex vertex, can't handle yet. Show the error *)
Print[Graphics[{Style[Line[AppendFirst[poly]],Red],Style[Point/@poly,Black,Thickness[.01]]}]];
Message[QuasiConvexPolygonIntersectionInfo::badpoly,poly];Abort[]];
tverts=poly[[#]]&/@Mod[Table[{rpos,rpos+i,rpos+i+1},{i,Length[poly]-2}],Length[poly],1];
{poly,bbox,convex,tverts}]
Module[{poly,info},
poly={{0,0},{1,0},{1.5,.5},{.5,1.2}};
info=QuasiConvexPolygonIntersectionInfo[poly];
Print[Graphics[{
Style[Line[AppendFirst[poly]],LightGray,AbsoluteThickness[10]],(* polygon *)
Style[Line[AppendFirst[RectVertices@@Transpose[info[[2]]]]],Green],(* bounding box *)
Style[Line[AppendFirst[#]],Red]&/@info[[4]]},PlotLabel->If[info[[3]],"convex","nonconvex"]]](* triangulation *)
]//ShowExample
Module[{poly,info},
poly={{0,0},{0.5,.1},{1,0},{1.5,.5},{.5,1.2}};
info=QuasiConvexPolygonIntersectionInfo[poly];
Print[Graphics[{
Style[Line[AppendFirst[poly]],LightGray,AbsoluteThickness[10]],(* polygon *)
Style[Line[AppendFirst[RectVertices@@Transpose[info[[2]]]]],Green],(* bounding box *)
Style[Line[AppendFirst[#]],Red]&/@info[[4]]},PlotLabel->If[info[[3]],"convex","nonconvex"]]](* triangulation *)
]//ShowExample
Module[{poly,info},
poly={{0,0},{0.5,.1},{1,0},{1.5,.5},{1,.6},{.5,1.2}};
info=QuasiConvexPolygonIntersectionInfo[poly];
Print[Graphics[{
Style[Line[AppendFirst[poly]],LightGray,AbsoluteThickness[10]],(* polygon *)
Style[Line[AppendFirst[RectVertices@@Transpose[info[[2]]]]],Green],(* bounding box *)
Style[Line[AppendFirst[#]],Red]&/@info[[4]]},PlotLabel->If[info[[3]],"convex","nonconvex"]]](* triangulation *)
]//ShowErrorExample
QuasiConvexPolygonsIntersectQ::badinfo="The intersection information list `1` is not a length-4 list.";
QuasiConvexPolygonsIntersectQ[pinfo_List, qinfo_List]:=Module[{pverts,pbox,pconv,ptverts,qverts,qbox,qconv,qtverts,psegs,qsegs},
If[Length[pinfo]!=4,Message[QuasiConvexPolygonsIntersectQ::badinfo,pinfo];Abort[]];
If[Length[qinfo]!=4,Message[QuasiConvexPolygonsIntersectQ::badinfo,qinfo];Abort[]];
{pverts,pbox,pconv,ptverts}=pinfo;
{qverts,qbox,qconv,qtverts}=qinfo;
Catch[
(* first and simplest check is to see if their bounding boxes are disjoint *)
If[!BoundingBoxesIntersectQ[pbox,qbox],Throw[False]];
(* next check is to see if any of the vertices of poly is contained in qverts. *)
If[qconv,
If[PtInConvexPolygonQ[#,qverts],Throw[True]],
If[PtInTrianglesQ[#,qtverts],Throw[True]]]&/@pverts;
(* last check is to see if any line segments of poly intersect any line segment of qpoly *)
psegs=Transpose[{pverts,RotateLeft[pverts]}];
qsegs=Transpose[{qverts,RotateLeft[qverts]}];
Outer[If[SegmentsIntersectQ[#1,#2],Throw[True]]&,psegs,qsegs,1];
(* if we never found anything, they don't intersect. *)
Throw[False]]]
Module[{ppoly,qpoly,pinfo,qinfo,int},
ppoly={{0,0},{1,0},{1,1},{0,1}};
pinfo=QuasiConvexPolygonIntersectionInfo[ppoly];
qpoly={0.9,0.2}+#&/@{{0,0},{1,0},{1,1},{0,1}};
qinfo=QuasiConvexPolygonIntersectionInfo[qpoly];
int=QuasiConvexPolygonsIntersectQ[pinfo,qinfo];
Graphics[{Style[Line[Append[ppoly,ppoly[[1]]]],Red],Style[Line[Append[qpoly,qpoly[[1]]]],Green]},PlotLabel->If[int,"intersecting","non-intersecting"]]
]//ShowExample
Module[{ppoly,qpoly,pinfo,qinfo,int},
ppoly={{0,0},{1,0},{1,1},{0,1}};
pinfo=QuasiConvexPolygonIntersectionInfo[ppoly];
qpoly={1.1,0.2}+#&/@{{0,0},{1,0},{1,1},{0,1}};
qinfo=QuasiConvexPolygonIntersectionInfo[qpoly];
int=QuasiConvexPolygonsIntersectQ[pinfo,qinfo];
Graphics[{Style[Line[Append[ppoly,ppoly[[1]]]],Red],Style[Line[Append[qpoly,qpoly[[1]]]],Green]},PlotLabel->If[int,"intersecting","non-intersecting"]]
]//ShowExample
Module[{ppoly,qpoly,pinfo,qinfo,int},
ppoly={{0,0},{1,0},{1,1},{.5,.7},{0,1}};
pinfo=QuasiConvexPolygonIntersectionInfo[ppoly];
qpoly={0.9,0.2}+#&/@{{0,0},{1,0},{1,1},{.5,.7},{0,1}};
qinfo=QuasiConvexPolygonIntersectionInfo[qpoly];
int=QuasiConvexPolygonsIntersectQ[pinfo,qinfo];
Graphics[{Style[Line[Append[ppoly,ppoly[[1]]]],Red],Style[Line[Append[qpoly,qpoly[[1]]]],Green]},PlotLabel->If[int,"intersecting","non-intersecting"]]
]//ShowExample
Module[{ppoly,qpoly,pinfo,qinfo,int},
ppoly={{0,0},{1,0},{1,1},{.5,.7},{0,1}};
pinfo=QuasiConvexPolygonIntersectionInfo[ppoly];
qpoly={1.1,0.2}+#&/@{{0,0},{1,0},{1,1},{.5,.7},{0,1}};
qinfo=QuasiConvexPolygonIntersectionInfo[qpoly];
int=QuasiConvexPolygonsIntersectQ[pinfo,qinfo];
Graphics[{Style[Line[Append[ppoly,ppoly[[1]]]],Red],Style[Line[Append[qpoly,qpoly[[1]]]],Green]},PlotLabel->If[int,"intersecting","non-intersecting"]]
]//ShowExample
Module[{ppoly,qpoly,pinfo,qinfo,int},
ppoly={{0,0},{1,0},{1,1},{0,1}};
pinfo=QuasiConvexPolygonIntersectionInfo[ppoly];
qpoly={{-.2,.2},{1.2,.2},{1.2,.8},{-.2,.8}};
qinfo=QuasiConvexPolygonIntersectionInfo[qpoly];
int=QuasiConvexPolygonsIntersectQ[pinfo,qinfo];
Graphics[{Style[Line[Append[ppoly,ppoly[[1]]]],Red],Style[Line[Append[qpoly,qpoly[[1]]]],Green]},PlotLabel->If[int,"intersecting","non-intersecting"]]
]//ShowExample
ClipSegmentToHalfPlane[{q1_,q2_,t0_,t1_},{p1_,p2_,p3_}]:=Module[{detq,rp,t},
If[Mag[q2-q1]==0,Return[{q1,q2,t0,t1}]]; (* q1\[Equal]q2, so return what was passed in; it's already clipped *)
detq=Det[{q2-q1,p2-p1}];
If[detq==0 (* p-line and q-line are parallel *),
rp=Rotate90[p2-p1] (* rp is perpendicular to both lines *);
If[Sign[rp . (p3-p1)]==Sign[rp . (q1-p1)],
{q1,q2,t0,t1} (* q-line is on the p3 side of p-line *),
{q1,q2,t0,t0}(* q-line is NOT on the p3 side of p-line *)
],
(* p-line, q-line are not parallel, so compute their intersection parameter t *)
t= Det[{p1-q1,p2-p1}]/detq;
If[PtInHalfPlaneQ[q1,{p1,p2,p3}] ,
(* q1 is in halfplane *)
If[PtInHalfPlaneQ[q2,{p1,p2,p3}],{q1,q2,t0,t1},{q1,q2,t0,Min[t,t1]}],
(* q1 is not in halfplane *)
If[PtInHalfPlaneQ[q2,{p1,p2,p3}],{q1,q2,Max[t0,t],t1},{q1,q2,t1,t1}]]]]
Module[{halfplane,randsegs,allsegs,clipsegs},
halfplane={{0,0},{1,0},{.5,.5}};
randsegs=Join[#,{0,1}]&/@Partition[Table[{2-3Random[],1-2Random[]},{30}],2]; (* random ones for testing *)
allsegs=Join[{
{{0,1/4},{1,1/4},0,1},
{{0,-1/4},{1,-1/4},0,1}
},randsegs];
clipsegs=ClipSegmentToHalfPlane[#,halfplane]&/@allsegs;
Graphics[{
Green,Thickness[0.003],Line[halfplane[[{1,2}]]],
Darker[Green],PointSize[.02],Point[halfplane[[3]]],
Gray,Line[Take[#,2]]&/@allsegs,
Red,Thickness[.008],Line[{#[[1]]+#[[3]](#[[2]]-#[[1]]),#[[1]]+#[[4]](#[[2]]-#[[1]])}]&/@clipsegs}]
]//ShowExample
ClipSegmentToHalfPlane[{q1_,q2_},{p1_,p2_,p3_}]:=Module[{q1a,q2a,t0,t1},
{q1a,q2a,t0,t1}=ClipSegmentToHalfPlane[{q1,q2,0,1},{p1,p2,p3}];
{q1+t0(q2-q1),q1+t1(q2-q1)}
]
Module[{halfplane,segments},
halfplane={{0,0},{1,0},{.5,.5}};segments=Join[{{{-1,-.25},{2,-.25}},{{-1,.25},{2,.25}},{{0,-1},{0,1}},{{1,-1},{1,1}}},Partition[Table[{2-3Random[],1-2Random[]},{30}],2]];
Graphics[{Green,Line[halfplane[[{1,2}]]],PointSize[.03],Point[halfplane[[3]]],Gray,Line/@segments,Red,Thickness[.01],Line/@(ClipSegmentToHalfPlane[#,halfplane]&/@segments)}]
]//ShowExample
ClipSegmentToConvexPolygon[{q1_,q2_},poly_List]:=Module[{cn=Plus@@poly/Length[poly],tl},
tl=Transpose[{poly,RotateLeft[poly],Table[cn,{Length[poly]}]}];
Fold[ClipSegmentToHalfPlane,{q1,q2},tl]]
Module[{poly,segments},
poly={{0,0},{1,0},{1,1},{.5,1.5},{0,1}};
segments=Join[{{{-1,-.2},{2,-.2}},{{-1,0},{2,0}},{{-1,.25},{2,.25}},{{-1,.5},{.3,.5}},{{.7,.5},{2,.5}}},Partition[Table[{2-3Random[],2.5-3Random[]},{40}],2]];
Graphics[{LightGray,Polygon[poly],Gray,Line/@segments,Red,Thickness[.01],Line/@(ClipSegmentToConvexPolygon[#,poly]&/@segments)}]
]//ShowExample
ClipSegmentToSegmentExterior[{q1_,q2_},{p1_,p2_,p3_}]:=Module[{r=Rotate90[q2-q1],tp,tq,q12},
If[r . (p2-p1)==0,Return[{q1,q2}]];
tq= Det[{p1-q1,p2-p1}]/Det[{q2-q1,p2-p1}];tp= Det[{q1-p1,q2-q1}]/Det[{p2-p1,q2-q1}];If[tp<=0||tp>=1||tq<=0||tq>=1,Return[{q1,q2}]];
If[tq==0,If[PtInHalfPlaneQ[q2,{p1,p2,p3}],Return[{q1,q1}],Return[{q1,q2}]]];
If[tq==1,If[PtInHalfPlaneQ[q1,{p1,p2,p3}],Return[{q2,q2}],Return[{q1,q2}]]];
q12=q1+tq(q2-q1);
If[PtInHalfPlaneQ[q2,{p1,p2,p3}],{q1,q12},{q12,q2}]]
Module[{halfplane,segments},
halfplane={{0,0},{1,0},{.5,.5}};
segments=Join[{{{-1,-.25},{2,-.25}},{{-1,.25},{2,.25}},{{0,-1},{0,1}},{{1,-1},{1,1}}},Partition[Table[{2-3Random[],1-2Random[]},{40}],2]];
Graphics[{Green,Line[halfplane[[{1,2}]]],PointSize[.05],Point[halfplane[[3]]],Gray,Line/@segments,Red,Thickness[.01],Line/@(ClipSegmentToSegmentExterior[#,halfplane]&/@segments)}]
]//ShowExample
ClipSegmentToConvexPolygonExterior[{q1_,q2_},poly_List]:=Module[{ctrd=Plus@@poly/Length[poly],pedges},
pedges=Transpose[{poly,RotateLeft[poly],Table[ctrd,{Length[poly]}]}]; 
Fold[ClipSegmentToSegmentExterior,{q1,q2},pedges]]
Module[{poly,segments},
poly={{0,0},{1,0},{1,1},{.5,1.5},{0,1}};
segments=Join[{{{-1,-.2},{2,-.2}},{{-1,0},{2,0}},{{-1,.25},{2,.25}},{{-1,.5},{.3,.5}},{{.7,.5},{2,.5}}},Partition[Table[{2-3Random[],2.5-3Random[]},{50}],2]];
Graphics[{LightGray,Polygon[poly],Gray,Line/@segments,Red,Thickness[.01],Line/@(ClipSegmentToConvexPolygonExterior[#,poly]&/@segments)}]
]//ShowExample
IntervalSetValidQ[is_]:=Module[{dim,nums},
If[ListEmptyQ[is],Return[True]];
dim=Dimensions[is];
If[Length[dim]!=2,Return[False]];
If[dim[[2]]!=2, Return[False]];
nums=Flatten[is];
And@@MapThread[Less,{Drop[nums,-1],Drop[nums,1]}]
]
Module[{},
PrintThis[IntervalSetValidQ[{}]];
PrintThis[IntervalSetValidQ[{{1,2},{3,4},{5,6}}]];
PrintThis[IntervalSetValidQ[{{1,2},{2,4},{5,6}}]];
]//ShowExample
IntervalSetCleanup[is_]:=Select[is,Chop[#[[2]]-#[[1]]]!=0&]
IntervalSetCleanup[{{0,0},{0,.4},{.5,.5},{.6,1},{1,1}}]
IntervalSetIntersect[is_,{}]:={}
IntervalSetIntersect[is_,{s_,t_}]:=Module[{ret={},ss,tt},
If[ListEmptyQ[is],Return[{}]];
Function[iss,
ss=Max[iss[[1]],s];
tt=Min[iss[[2]],t];
If[tt>ss,AppendTo[ret,{ss,tt}]]]/@is;
IntervalSetCleanup[ret]]/;Length[Dimensions[{s,t}]]==1
Module[{},
PrintThis[IntervalSetIntersect[{{1,2},{3,4}},{-1,5}]];
PrintThis[IntervalSetIntersect[{{1,2},{3,4}},{1.5,3.5}]];
]//ShowExample
IntervalSetMinus[is_,{}]:=is
IntervalSetMinus[is_,{s_,t_}]:=Module[{ret={}},
Function[iss,
Which[
s>iss[[1]]&&t<iss[[2]],AppendTo[ret,{iss[[1]],s}];AppendTo[ret,{t,iss[[2]]}],(* within this interval *)
s>iss[[2]]||t<iss[[1]],AppendTo[ret,iss],(* entirely outside the interval *)
s<=iss[[1]]&&t>=iss[[2]],Null,(* covers the interval *)
s<=iss[[1]],AppendTo[ret,{t,iss[[2]]}],(* overlap at beginning *)
t>=iss[[2]],AppendTo[ret,{iss[[1]],s}] (* overlap at end *)
]]/@is;
IntervalSetCleanup[ret]]/;Length[Dimensions[{s,t}]]==1
Module[{},
PrintThis[IntervalSetMinus[{{0.2,0.4},{0.6,0.8}},{.3,.31}]];
PrintThis[IntervalSetMinus[{{0.2,0.4},{0.6,0.8}},{0,.3}]];
PrintThis[IntervalSetMinus[{{0.2,0.4},{0.6,0.8}},{.7,1}]];
PrintThis[IntervalSetMinus[{{0,1}},{0.2,0.4}]];
PrintThis[IntervalSetMinus[{{0,1}},{0,0.4}]];
PrintThis[IntervalSetMinus[{{0,1}},{.6,1}]];
PrintThis[IntervalSetMinus[{{0,0.2},{0.4,1}},{0.6,0.8}]];
]//ShowExample
IntervalSetMinus[is1_,is2_]:=Module[{ret=is1},
(ret=IntervalSetMinus[ret,#])&/@is2;
IntervalSetCleanup[ret]]/;Length[Dimensions[is2]]==2
Module[{},
PrintThis[IntervalSetMinus[{{0,1}},{{0.2,0.4},{0.6,0.8}}]];
PrintThis[IntervalSetMinus[{{0,1}},{{0,0.4},{0.6,0.8}}]];
]//ShowExample
SegmentSetLine[{q1_,q2_,is_}]:=If[#[[1]]==#[[2]],{},Line[#]]&/@Map[(1-#)q1+# q2&,is,{2}]
SegmentSetLine[{q1_,q2_,is_}]:=Line/@Map[(1-#)q1+# q2&,is,{2}]
Module[{q1,q2,is},
q1={0,0};
q2={1,.5};
is={{.1,.1},{.2,.4},{.6,.8}};
SegmentSetLine[{q1,q2,is}]
]//ShowExample
Module[{q1,q2,is},
q1={0,0};
q2={1,.5};
is={{.1,.1},{.2,.4},{.6,.8}};
Graphics[SegmentSetLine[{q1,q2,is}],Axes->True]
]//ShowExample
SegmentSetLines[{q1_,q2_,is_}]:=Module[{isc},
isc=IntervalSetMinus[{{0,1}},is];(* complement interval set *)
{SegmentSetLine[{q1,q2,is}],
SegmentSetLine[{q1,q2,isc}]}
]
Module[{q1,q2,is,ssl1,ssl2},
q1={0,0};
q2={1,.5};
is={{.2,.4},{.6,.8}};
{ssl1,ssl2}=SegmentSetLines[{q1,q2,is}];
Graphics[{
Style[ssl1,Green,AbsoluteThickness[2]],
Style[ssl2,Red,AbsoluteThickness[2]]
},Axes->True]
]//ShowExample
SegmentsFromHalfPlane::badsegs="Segment set points `1` and `2` are not distinct.";
SegmentsFromHalfPlane::badplane="Half-plane points `1` and `2` are not distinct.";
SegmentsFromHalfPlane::badp3="The point `1` that should define the half-plane lies on the line through `2` and `3`.";
SegmentSetFromHalfPlane[{q1_,q2_},{p1_,p2_,p3_}]:=Module[{detq,rp,t,t0},
If[Mag[q1-q2]==0,Message[SegmentsFromHalfPlane::badsegs,q1,q2];Abort[]];
If[Mag[p1-p2]==0,Message[SegmentsFromHalfPlane::badplane,p1,p2];Abort[]];
rp=Rotate90[p2-p1]; (* rp is perpendicular to the half-plane line *)
If[rp . (p3-p1)==0,Message[SegmentsFromHalfPlane::badp3,p3,p1,p2];Abort[]];
detq=Det[{q2-q1,p2-p1}];
If[Chop[detq]==0, (* p-line and q-line are parallel *)
If[Sign[rp . (p3-p1)]==Sign[rp . (q1-p1)],
Return[{q1,q2,{{-\[Infinity],\[Infinity]}}}],(* q-line is on the p3 side of p-line *)
Return[{q1,q2,{}}](* q-line is NOT on the p3 side of p-line or lies on the half-plane boundary *)
]];
(* p-line, q-line are not parallel, so compute their intersection parameter t *)
t= Det[{p1-q1,p2-p1}]/detq;
t0=t-1;(* a test value *)
If[PtInHalfPlaneQ[(1-t0)q1+t0 q2,{p1,p2,p3}] ,
{q1,q2,{{-\[Infinity],t}}},
{q1,q2,{{t,\[Infinity]}}}]
]
Module[{},
PrintThis[SegmentSetFromHalfPlane[{{0,0},{2,2}},{{1,0},{0,1},{.2,.1}}]];
PrintThis[SegmentSetFromHalfPlane[{{1,1},{2,2}},{{1,0},{0,1},{.2,.1}}]];
PrintThis[SegmentSetFromHalfPlane[{{0,-1},{-1,-0}},{{1,0},{0,1},{.2,.1}}]];
]//ShowExample
ClipSegmentSetToHalfPlane[{q1_,q2_,is_},{p1_,p2_,p3_}]:=Module[{ss},
If[ListEmptyQ[is],Return[{q1,q2,{}}]];(* it's already empty *)
ss=SegmentSetFromHalfPlane[{q1,q2},{p1,p2,p3}];
If[NotListEmptyQ[ss[[3]]],
{q1,q2,IntervalSetIntersect[is,ss[[3,1]]]},
{q1,q2,{}}]
]
Module[{halfplane,segments,csegments},
halfplane={{0,0},{1,0},{.5,.5}};
segments=Join[
{{{-1,-.25},{2,-.25},{{0,1}}},{{-1,.25},{2,.25},{{0,1}}},{{0,-1},{0,1},{{0,1}}},{{1,-1},{1,1},{{0,1}}}},Table[{{2-3Random[],1-2Random[]},{2-3Random[],1-2Random[]},Partition[Sort[Table[Random[],{8}]],2]},{20}]];
csegments=ClipSegmentSetToHalfPlane[#,halfplane]&/@segments;
Graphics[{
Green,Line[halfplane[[{1,2}]]],
PointSize[.03],Point[halfplane[[3]]],
Gray,SegmentSetLine/@segments,
Red,Thickness[.01],SegmentSetLine/@csegments},Frame->True]
]//ShowExample
ClipSegmentSetToConvexPolygon[{q1_, q2_, is_}, poly_]:=Module[{ctr},
ctr=Plus@@poly/Length[poly];
Fold[ClipSegmentSetToHalfPlane[#1,{#2[[1]],#2[[2]],ctr}]&,{q1,q2,is},Transpose[{poly,RotateLeft[poly]}]]]
Module[{poly,segments,csegments},
poly={{0,0},{1,0},{1,1},{.5,1.5},{0,1}};
segments=Join[
{{{-1,-.25},{2,-.25},{{0,1}}},{{-1,.25},{2,.25},{{0,1}}},{{0,-1},{0,1},{{0,1}}},{{1,-1},{1,1},{{0,1}}}},Table[{{2-3Random[],1-2Random[]},{2-3Random[],1-2Random[]},Partition[Sort[Table[Random[],{8}]],2]},{30}]];
csegments=ClipSegmentSetToConvexPolygon[#,poly]&/@segments;
Graphics[{
LightGray,Polygon[poly],
Gray,SegmentSetLine/@segments,
Red,Thickness[.01],SegmentSetLine/@csegments},Frame->True]
]//ShowExample
ClipSegmentSetToConvexPolygonExterior[{q1_, q2_, is_}, poly_]:=Module[{ss},
ss=ClipSegmentSetToConvexPolygon[{q1,q2,{{-\[Infinity],\[Infinity]}}},poly];
{q1,q2,IntervalSetMinus[is,ss[[3]]]}]
Module[{poly,segments,csegments},
poly={{0,0},{1,0},{1,1},{.5,1.5},{0,1}};
segments=Join[
{{{-1,-.25},{2,-.25},{{0,1}}},{{-1,.25},{2,.25},{{0,1}}},{{0,-1},{0,1},{{0,1}}},{{1,-1},{1,1},{{0,1}}}},Table[{{2-3Random[],1.5-2.5Random[]},{2-3Random[],1.5-2.5Random[]},Partition[Sort[Table[Random[],{8}]],2]},{30}]];
csegments=ClipSegmentSetToConvexPolygonExterior[#,poly]&/@segments;
Graphics[{
LightGray,Polygon[poly],
Gray,SegmentSetLine/@segments,
Red,Thickness[.01],SegmentSetLine/@csegments},Frame->True]
]//ShowExample
Module[{poly,segments,csegments},
poly={{0,0},{1,0},{1,1},{.5,.6},{0,1}};
segments=Join[
{{{-1,-.25},{2,-.25},{{0,1}}},{{-1,.25},{2,.25},{{0,1}}},{{0,-1},{0,1},{{0,1}}},{{1,-1},{1,1},{{0,1}}}},Table[{{2-3Random[],1.5-2.5Random[]},{2-3Random[],1.5-2.5Random[]},Partition[Sort[Table[Random[],{8}]],2]},{30}]];
csegments=ClipSegmentSetToConvexPolygonExterior[#,poly]&/@segments;
Graphics[{
LightGray,Polygon[poly],
Gray,SegmentSetLine/@segments,
Red,Thickness[.01],SegmentSetLine/@csegments},Frame->True]
]//ShowExample
ClipSegmentSetToQuasiConvexPolygonExterior[{q1_, q2_, is_}, poly_]:=Module[{iinfo,ss},
iinfo=QuasiConvexPolygonIntersectionInfo[poly];(* {verts, bbox, convex, triangles *)
If[iinfo[[3]],
(* is convex *)
ss=ClipSegmentSetToConvexPolygon[{q1,q2,{{-\[Infinity],\[Infinity]}}},poly];
{q1,q2,IntervalSetMinus[is,ss[[3]]]},
(* has a reflex vertex *)
Fold[ClipSegmentSetToConvexPolygonExterior,{q1,q2,is},iinfo[[4]]]]]
Module[{poly,segments,csegments},
poly={{0,0},{1,0},{1,1},{.5,1.2},{0,1}};
segments={{{-1,0.75},{2,0.75},{{0,1}}}};
csegments=ClipSegmentSetToQuasiConvexPolygonExterior[#,poly]&/@segments;
Graphics[{
LightGray,Polygon[poly],
Gray,SegmentSetLine/@segments,
Red,Thickness[.01],SegmentSetLine/@csegments},Frame->True]
]//ShowExample
Module[{poly,segments,csegments},
poly={{0,0},{1,0},{1,1},{.5,.5},{0,1}};
segments={{{-1,0.75},{2,0.75},{{0,1}}}};
csegments=ClipSegmentSetToQuasiConvexPolygonExterior[#,poly]&/@segments;
Graphics[{
LightGray,Polygon[poly],
Gray,SegmentSetLine/@segments,
Red,Thickness[.01],SegmentSetLine/@csegments},Frame->True]
]//ShowExample
Module[{poly,segments,csegments},
poly={{0,0},{1,0},{1,1},{.5,.6},{0,1}};
segments=Join[
{{{-1,-.25},{2,-.25},{{0,1}}},{{-1,.25},{2,.25},{{0,1}}},{{0,-1},{0,1},{{0,1}}},{{1,-1},{1,1},{{0,1}}}},Table[{{2-3Random[],1.5-2.5Random[]},{2-3Random[],1.5-2.5Random[]},Partition[Sort[Table[Random[],{8}]],2]},{30}]];
csegments=ClipSegmentSetToQuasiConvexPolygonExterior[#,poly]&/@segments;
Graphics[{
LightGray,Polygon[poly],
Gray,SegmentSetLine/@segments,
Red,Thickness[.01],SegmentSetLine/@csegments},Frame->True]
]//ShowExample
UnnormalizedFlatFoldabilityCondition::oddverts="The list of vertices `1` fed to UnnormalizedFlatFoldabilityCondition has an odd number of entries.";
UnnormalizedFlatFoldabilityCondition[p_,qlist_List]:=Module[{},
If[Mod[Length[qlist],2]!=0,Message[UnnormalizedFlatFoldabilityCondition::oddverts,qlist];Abort[]];
(Dot@@MapThread[UnnormalizedRotationMatrix2D,Transpose[Prepend[#,p]&/@Partition[qlist,2]]])[[1,2]]
]
Module[{p,qlist},
p={0,0};
qlist={U[0\[Degree]],U[135\[Degree]],U[225\[Degree]],U[270\[Degree]]};
Print[Graphics[{Point[p],Line[{p,#}]&/@qlist}]];
UnnormalizedFlatFoldabilityCondition[p,qlist]
]//ShowExample
Module[{p,qlist},
p={0,0};
qlist={U[0\[Degree]],U[135\[Degree]],U[225\[Degree]],U[271\[Degree]]};
Print[Graphics[{Point[p],Line[{p,#}]&/@qlist}]];
UnnormalizedFlatFoldabilityCondition[p,qlist]//N
]//ShowExample
Module[{p,qlist},
p={1,0};
qlist={{1,0}+U[0\[Degree]],{1,0}+U[135\[Degree]],{1,0}+U[225\[Degree]],{1,0}+U[270\[Degree]]};
Print[Graphics[{Point[p],Line[{p,#}]&/@qlist},Axes->True]];
UnnormalizedFlatFoldabilityCondition[p,qlist]
]//ShowExample
Module[{p,qlist},
p={0,0};
qlist={U[0\[Degree]],U[135\[Degree]],U[45\[Degree]],U[90\[Degree]]};
Print[Graphics[{Point[p],Line[{p,#}]&/@qlist}]];
UnnormalizedFlatFoldabilityCondition[p,qlist]
]//ShowExample
UnnormalizedFlatFoldabilityCondition[{0,0},{{Subscript[x, 1],Subscript[y, 1]},{Subscript[x, 2],Subscript[y, 2]},{Subscript[x, 3],Subscript[y, 3]},{Subscript[x, 4],Subscript[y, 4]}}]//ShowExample
Module[{p0={10,0},p1={11,0},p2={10.5,1},p3={9,-.2},p4,x4,y4,ke,soln,gg},
p4={10+x4,y4};
ke=UnnormalizedFlatFoldabilityCondition[p0,{p1,p2,p3,p4}];
soln=Flatten[NSolve[{ke==0,y4==-.8},{x4,y4}]];
gg={Gray,Line[{p0,#}]&/@{p1,p2,p3},Red, Line[{p0,p4}],Black,Text["p0",p0],Text["p1",p1],Text["p2",p2],Text["p3",p3],Text["p4",p4]}/.soln;
Graphics[gg,Frame->True,PlotRange->All]
]//ShowExample
Module[{p0={0,0},p1={1,0},p2={0.5,0.6},p3={-0.8,0.3},p4,x4,y4,ke,soln,gg},
p4={x4,y4};
ke=UnnormalizedFlatFoldabilityCondition[p0,{p1,p2,p3,p4}];
Print[Simplify[ke==0]];
soln=Flatten[NSolve[{ke==0,y4==-.8},{x4,y4}]];
gg={Gray,Line[{p0,#}]&/@{p1,p2,p3},Red, Line[{p0,p4}],Black,Text["p0",p0],Text["p1",p1],Text["p2",p2],Text["p3",p3],Text["p4",p4]}/.soln;
Graphics[gg,Frame->True,PlotRange->All]
]//ShowExample
Collect[UnnormalizedFlatFoldabilityCondition[{0,0},{{Subscript[x, 1],Subscript[y, 1]},{Subscript[x, 2],Subscript[y, 2]},{Subscript[x, 3],Subscript[y, 3]},{Subscript[x, 4],Subscript[y, 4]}}],{Subscript[x, 4],Subscript[y, 4]}]//ShowExample
FlatFoldabilityCondition::oddverts="The list of vertices `1` fed to UnnormalizedFlatFoldabilityCondition has an odd number of entries.";
FlatFoldabilityCondition[p_,qlist_List]:=Module[{},
If[Mod[Length[qlist],2]!=0,Message[FlatFoldabilityCondition::oddverts,qlist];Abort[]];
(Dot@@MapThread[RotationMatrix2D,Transpose[Prepend[#,p]&/@Partition[qlist,2]]])[[1,2]]
]
N[FlatFoldabilityCondition[{0,0},{U[0\[Degree]],U[135\[Degree]],U[225\[Degree]],U[270\[Degree]]}]]//ShowExample
N[FlatFoldabilityCondition[{0,0},{U[0\[Degree]],U[135\[Degree]],U[225\[Degree]],U[271\[Degree]]}]]//ShowExample
FlatFoldabilityExcess[p_List,qlist_List]:=Mod[Plus@@(RotationAngle[#[[1]],#[[2]]]&/@Partition[#-p&/@qlist,2])-\[Pi],2\[Pi],-\[Pi]]
Module[{p,qlist},
p={0,0};
qlist={U[0\[Degree]],U[135\[Degree]],U[225\[Degree]],U[270\[Degree]]};
Print[Graphics[{Point[p],Line[{p,#}]&/@qlist}]];
FlatFoldabilityExcess[p,qlist]
]//ShowExample
Module[{p,qlist},
p={0,0};
qlist={U[0\[Degree]],U[135\[Degree]],U[225\[Degree]],U[271\[Degree]]};
Print[Graphics[{Point[p],Line[{p,#}]&/@qlist}]];
FlatFoldabilityExcess[p,qlist]/\[Degree]//N
]//ShowExample
Degree4LastFoldDirection[{x1_,y1_},{x2_,y2_},{x3_,y3_}]:=NormalizeReal[-({{x2,y2},{-y2,x2}} . {{x3,-y3},{y3,x3}}) . {x1,y1}]
Module[{r1,r2,r3,r4},
r1=U[30\[Degree]];
r2=U[120\[Degree]];
r3=U[180\[Degree]];
r4=Degree4LastFoldDirection[r1,r2,r3];
Graphics[{
Style[{Line[{{0,0},r1}],Line[{{0,0},r2}],Line[{{0,0},r3}]},Black],
Style[{Line[{{0,0},r4}]},Red]}]
]//ShowExample
Block[{x1,y1,x2,y2,x3,y3,r4},
r4=Degree4LastFoldDirection[{x1,y1},{x2,y2},{x3,y3}]//Simplify
]//ShowExample
MakeDevelopableAngles[sectorangles_List]:=Append[sectorangles,2\[Pi]-(Plus@@sectorangles)]
MakeDevelopableAngles[{\[Pi]/2,\[Pi]/2,\[Pi]/4}]//ShowExample
DevelopabilityExcess[sectorangles_List]:=(Plus@@sectorangles)-2\[Pi]
Module[{sectorangles},
sectorangles={90\[Degree],90\[Degree],90\[Degree],95\[Degree]};
DevelopabilityExcess[sectorangles]/\[Degree]//N
]//ShowExample
DevelopableTolerance::usage="DevelopableTolerance is an option used in DevelopableAnglesQ to determine whether a vertex is developable.";
Options[DevelopableAnglesQ]={
DevelopableTolerance->10^-6
};
DevelopableAnglesQ[sectorangles_List,opts___]:=Module[{tol},
tol=DevelopableTolerance/.{opts}/.Options[DevelopableAnglesQ];
Abs[DevelopabilityExcess[sectorangles]//N]<=tol]
{DevelopableAnglesQ[{30\[Degree],60\[Degree],120\[Degree],150\[Degree]}],DevelopableAnglesQ[{30\[Degree],60\[Degree],120\[Degree],150.0001\[Degree]}]}//ShowExample
FlatFoldabilityExcess[sectorangles_List]:=Plus@@Flatten[{1,-1}*Transpose[Partition[sectorangles,2]]]
Module[{sectorangles},
sectorangles={80\[Degree],90\[Degree],100\[Degree],90\[Degree]};
FlatFoldabilityExcess[sectorangles]/\[Degree]
]//ShowExample
FlatFoldableTolerance::usage="FlatFoldableTolerance is an option used in FlatFoldableAnglesQ to determine whether a vertex is flat-foldable.";
Options[FlatFoldableAnglesQ]={
FlatFoldableTolerance->10^-6
};
FlatFoldableAnglesQ::oddsecs="Sector angles `1` do not have an even number of entries.";
FlatFoldableAnglesQ[sectorangles_List, opts___]:=Module[{tol,n},
tol=FlatFoldableTolerance/.{opts}/.Options[FlatFoldableAnglesQ];
n=Length[sectorangles];
If[Mod[n,2]==1,Message[FlatFoldableAnglesQ::oddsecs,sectorangles];Abort[]];
Abs[FlatFoldabilityExcess[sectorangles]//N]<=tol]
{FlatFoldableAnglesQ[{60\[Degree],30\[Degree],120\[Degree],150\[Degree]}],FlatFoldableAnglesQ[{30\[Degree],60\[Degree],120\[Degree],150\[Degree]}]}//ShowExample
Rotate2D[g_,\[Phi]_]:=MatrixTransform[g,RotationMatrix2D[\[Phi]]]
Translate2D[g_,v_]:=FunctionTransform[g,#+v&]
DupReflect2D[g_]:={g,MatrixTransform[g,ReflectionXMatrix2D]}
DupRotate2D[g_,m_]:=Table[MatrixTransform[g,RotationMatrix2D[2\[Pi] i/m]],{i,0,m-1}]
DupReflectAndRotate2D[g_,m_]:=Module[{gg={g,MatrixTransform[g,ReflectionXMatrix2D]}},Table[MatrixTransform[gg,RotationMatrix2D[2\[Pi] i/m]],{i,0,m-1}]]
U3D[\[Phi]_]:={Cos[\[Phi]],Sin[\[Phi]],0};
Normals3D[p_List]:=Module[{wl,q},
wl=Sort[{Mag[p . #],#}&/@IdentityMatrix[3],#1[[1]]<#2[[1]]&];
q=wl[[1,2]];
q=NormalizeReal[q-((p . q)p)/Mag2[p]];
{q,p\[Cross]q}]
Module[{p,q,r},
p={1,.9,1};
{q,r}=Normals3D[p];
Graphics3D[{
Style[Line[{{0,0,0},p}],Red,Thickness[.05]],
Style[Line[{{0,0,0},q}],Green,Thickness[.03]],
Style[Line[{{0,0,0},r}],Blue,Thickness[.03]]},Boxed->True,Axes->True]
]//ShowExample
PlanePlaneInt3D[{p_List,pn_List},{q_List,qn_List}]:=Module[{tp,tq},
{tp,tq}=Inverse[{{pn . pn,pn . qn},{pn . qn,qn . qn}}] . {pn . (p-q),qn . (q-p)}/2;
{(p+q)/2+tp pn+tq qn,pn\[Cross]qn}]
Module[{p,pn,q,qn,r,s},
p={1,0,0};
pn={.5,0,0};
q={0,1,0};
qn={0,1,0};
{r,s}=PlanePlaneInt3D[{p,pn},{q,qn}];
Graphics3D[{
Style[Point[p],Red,PointSize[.01]],
Style[Cylinder[{p,p+.01pn},2],Red,Opacity[.25]],
Style[Point[q],Green,PointSize[.01]],
Style[Cylinder[{q,q+.01qn},2],Green,Opacity[.25]],
Style[Line[{r-s,r+s}],Blue,Thickness[.01]]},Axes->True]
]//ShowExample
RotationAxis::usage="RotationAxis is an option to PolygonalEllipseArc3D that specifies the axis of rotation when creating the arc.";
PolygonalEllipseArc3D::badmet="ArcMethod\[Rule]`1` is not a valid option.";
PolygonalEllipseArc3D::baddiv="The value of ArcDivisions (`1`) must be \[GreaterEqual]1";
PolygonalEllipseArc3D::misrot="Points `1` and `2` are diametrically opposite; you must provide a value for option RotationAxis.";
PolygonalEllipseArc3D::badrot="RotationAxis\[Rule]`1` is not perpendicular to directions `2` and `3`.";
Options[PolygonalEllipseArc3D]={
ArcDivisions->1,
ArcMaximumAngle->5\[Degree],
ArcMethod->InscribedArc,
ArcDirection->CCW,
RotationAxis->Automatic
};
PolygonalEllipseArc3D[p1_List, p2_List,opts___]:=Module[{n,ama,am,ad,ra,m1,m2,x,y,u,z,a,dw,w,r},
n=ArcDivisions/.{opts}/.Options[PolygonalEllipseArc3D];
ama=ArcMaximumAngle/.{opts}/.Options[PolygonalEllipseArc3D];
am=ArcMethod/.{opts}/.Options[PolygonalEllipseArc3D];
ad=ArcDirection/.{opts}/.Options[PolygonalEllipseArc3D];
ra=RotationAxis/.{opts}/.Options[PolygonalEllipseArc3D];
If[n<1,Message[PolygonalEllipseArc3D::baddiv,n];Abort[]];
If[!MemberQ[{InscribedArc,CircumscribedArc},am],Message[PolygonalEllipseArc3D::badmet,am];Abort[]];
m1=Mag[p1];
m2=Mag[p2];
x=p1/m1;
If[ra===Automatic,
(* calculate RotationAxis *)
u=x\[Cross]p2;
If[Mag[u]==0 ,Message[PolygonalEllipseArc3D::misrot,p1,p2];Abort[]];
z=NormalizeReal[u],
(* RotationAxis was explicitly provided *)
If[ Chop[ra . x]!=0 || Chop[ra . p2]!=0,Message[PolygonalEllipseArc3D::badrot,ra,p1,p2];Abort[]];
z=NormalizeReal[ra]];
y=z\[Cross]x;
a=ArcTan[x . p2,y . p2];
If[!(ra===Automatic),
If[ad===CCW,
a=Mod[a,2\[Pi]],
a=Mod[a,2\[Pi],-2\[Pi]]]];
n=Max[n,Ceiling[N[Abs[a]]/ama]];
dw=1/n;
Switch[am,
InscribedArc,Join[{p1},Table[m1^(1-w) m2^(w) U[w a] . {x,y},{w,dw,1-dw,dw}],{p2}],
CircumscribedArc,r=Sec[a dw/2];Join[{p1},Table[r m1^(1-w) m2^(w) U[w a] . {x,y},{w,dw/2,1-dw/2,dw}],{p2}],
_,Message[PolygonalEllipseArc3D::badmet,am];Abort[]]
]
Module[{o,p1,p2,p3,gfn},
o={0,0,0};
p1={1,0,0};
p2={0,0,1};
p3={0,1,0};
gfn[p_,q_,opts___]:=Graphics3D[{
Style[Line[{o,p1}],Red],
Style[Line[{o,p2}],Green],
Style[Line[{o,p3}],Blue],
Style[Sphere[{0,0,0},1],Opacity[0.4]],AbsoluteThickness[4],
Line[PolygonalEllipseArc3D[p,q,opts]]
}];
GraphicsGrid[{{
gfn[p1,p2,ArcMethod->CircumscribedArc],
gfn[p1,p2,ArcDivisions->1,ArcMaximumAngle->\[Infinity],ArcMethod->CircumscribedArc],
gfn[p1,p2,ArcDivisions->3,ArcMaximumAngle->\[Infinity],ArcMethod->CircumscribedArc],
gfn[p1,p2,ArcDivisions->9,ArcMaximumAngle->\[Infinity],ArcMethod->CircumscribedArc,RotationAxis->p3]
},{
gfn[p1,p2,ArcMethod->InscribedArc],
gfn[p1,p2,ArcDivisions->1,ArcMaximumAngle->\[Infinity],ArcMethod->InscribedArc],
gfn[p1,p2,ArcDivisions->3,ArcMaximumAngle->\[Infinity],ArcMethod->InscribedArc],
gfn[p1,p2,ArcDivisions->9,ArcMaximumAngle->\[Infinity],ArcMethod->InscribedArc,RotationAxis->p3,ArcDirection->CW]
}}]]//ShowExample
SphericalEllipseVector3D[p1_,p2_,p3_,\[Alpha]_,\[Beta]_]:=Module[{bx,by,bz,e,A,B,y,z,x},
(* a local coordinate system *)
bx=NormalizeReal[(p1+p3)/2-p2];
bz=NormalizeReal[(p1-p2)\[Cross](p3-p2)];
by=bz\[Cross]bx;
e=ArcCos[(p1-p2) . bx/Mag[(p1-p2)]];(* eccentricity *)
A=Sin[\[Alpha]/2];
B=\[Sqrt]((Cos[2 e]-Cos[\[Alpha]])/2) Sec[e];
y=A Cos[\[Beta]];
z=B Sin[\[Beta]];
x=\[Sqrt](1-y^2-z^2);
x bx + y by + z bz]
DynamicModule[{p1,p2,p3,amin,\[Alpha],r},
p1={-.5,-1.5,0};
p2={0,0,0};
p3={+.4,-1.5,0};
amin=OrientedAngle3D[p1-p2,p3-p2,{0,0,1}];
\[Alpha]=80.\[Degree]; (* must be larger than the minimum angle, which is twice the spherical eccentricity *)
Manipulate[
r=SphericalEllipseVector3D[p1,p2,p3,\[Alpha],\[Beta]];
Graphics3D[{
Style[Sphere[p2,1],Opacity[0.2]],
Point[p1],Text["p1",p1,{-2,0}],
Point[p2],Text["p2",p2,{-2,0}],
Point[p3],Text["p3",p3,{-2,0}],
Style[Line[{p1,p2,p3}],Black],
Style[Line[{p2,r}],Gray],
Style[{Polygon[Append[PolygonalEllipseArc3D[NormalizeReal[p1-p2],r-p2],p2]],Polygon[Append[PolygonalEllipseArc3D[NormalizeReal[p3-p2],r-p2],p2]]},Lighter[Red],Opacity[0.2]],
Style[{
Line[PolygonalEllipseArc3D[NormalizeReal[p1-p2],r-p2]],
Line[PolygonalEllipseArc3D[NormalizeReal[p3-p2],r-p2]]
},Red],
Style[Point[r],Darker[Red]]
},PlotLabel->"Min angle (\[Degree]) = "<>ToString[amin/\[Degree]]],{\[Beta],0,2\[Pi]}]
]//ShowExample
TriangleArea3D[p_, q_, r_]:=(1/2)Mag[(q-p)\[Cross](r-p)]
TriangleArea3D[{0,0,0},{2,0,0},{2,1,0}]//ShowExample
TriangleBasis3D[p_,q_,r_]:=Module[{x,y,z},
x=NormalizeReal[q-p];
z=NormalizeReal[x\[Cross](r-p)];
y=z\[Cross]x;
{x,y,z}]
Module[{p,q,r,x,y,z},
p={1,1,1};
q={3,1.3,1.5};
r={2,2,2};
{x,y,z}=TriangleBasis3D[p,q,r];
Graphics3D[{
Text["p",p,{0,2}],Text["q",q,{0,1}],Text["r",r,{1,-1}],
Style[Polygon[{p,q,r}],Gray,Opacity[0.25]],
Style[Point[p],PointSize[.05],Black],
Style[Arrow[{p,p+x}],Red,Thickness[0.02]],
Style[Arrow[{p,p+y}],Green,Thickness[0.02]],
Style[Arrow[{p,p+z}],Blue,Thickness[0.02]]
},Axes->True]
]//ShowExample
Module[{p,q,r,m,x,y,z,pp,qq,rr},
p={1,1,1};
q={3,1.3,1.5};
r={2,2,2};
m=TriangleBasis3D[p,q,r];
{x,y,z}=m;
{pp,qq,rr}=m . #&/@{p-p,q-p,r-p};
GraphicsRow[{Graphics3D[{
Text["p",p,{0,2}],Text["q",q,{0,1}],Text["r",r,{1,-1}],
Style[Polygon[{p,q,r}],Gray,Opacity[0.25]],
Style[Point[p],PointSize[.05],Black],
Style[Arrow[{p,p+x}],Red,Thickness[0.02]],
Style[Arrow[{p,p+y}],Green,Thickness[0.02]],
Style[Arrow[{p,p+z}],Blue,Thickness[0.02]]
},Axes->True],
Graphics3D[{
Text["p'",pp,{0,2}],Text["q'",qq,{0,1}],Text["r'",rr,{1,-1}],
Style[Polygon[{pp,qq,rr}],Gray,Opacity[0.25]]
},Axes->True]}]
]//ShowExample
TriangleNormal3D[p_,q_,r_]:=NormalizeReal[(q-p)\[Cross](r-p)]
Module[{p,q,r,x,y,z},
p={1,1,1};
q={3,1,1};
r={2,2,2};
{x,y,z}=TriangleBasis3D[p,q,r];
Graphics3D[{
Text["p",p,{0,2}],Text["q",q,{0,1}],Text["r",r,{1,-1}],
Style[Polygon[{p,q,r}],Gray,Opacity[0.25]],
Style[Point[p],PointSize[.05],Black],
Style[Arrow[{p,p+z}],Blue,Thickness[0.02]]
},Axes->True]]//ShowExample
Module[{p,q,r,s,a,b,c,d,e,f},
p={0,-1/2,0};
q={0,1/2,0};
r={1/\[Sqrt]2,0,-1/2};
s={1/\[Sqrt]2,0,1/2};
Graphics3D[{
Style[{Polygon[{p,q,r}],Polygon[{p,q,s}],Polygon[{p,r,s}],Polygon[{q,r,s}]},Opacity[0.9]],
Style[Point/@{p,q,r,s},AbsolutePointSize[5]],
Style[{Text["p",p,{2,0}],Text["q",q,{1,-1.5}],Text["r",r,{2,1}],Text["s",s,{-2,0}]},FontSize->14],
Style[{Text["a",(p+q)/2],Text["b",(p+s)/2],Text["c",(s+q)/2],Text["d",(p+r)/2],Text["e",(r+q)/2],Text["f",(r+s)/2]},FontSize->14]
},Lighting->Automatic,Boxed->True,Axes->True]
]//ShowExample
TetrahedronVolumeSquared[a_,b_,c_,d_,e_,f_]:=(1/288)Det[{{0,1,1,1,1},{1,0,a^2,d^2,b^2},{1,a^2,0,e^2,c^2},{1,d^2,e^2,0,f^2},{1,b^2,c^2,f^2,0}}]
TetrahedronExistsQ[a_,b_,c_,d_,e_,f_]:=TetrahedronVolumeSquared[a,b,c,d,e,f]>=0
TetrahedronVolume[a_,b_,c_,d_,e_,f_]:=\[Sqrt]TetrahedronVolumeSquared[a,b,c,d,e,f]
TetrahedronVolume[1,1,1,1,1,1]
TetrahedronSinA[a_, b_, c_, d_, e_, f_]:=(2 a \[Sqrt](-b^4 e^2-a^4 f^2+a^2 ((-b^2+c^2) (d-e) (d+e)+(b^2+c^2+d^2+e^2) f^2-f^4)-d^2 (c^4+e^2 f^2+c^2 (d^2-e^2-f^2))+b^2 (c^2 (d^2+e^2-f^2)+e^2 (d^2-e^2+f^2))))/(\[Sqrt](-(a-b-c) (a+b-c) (a-b+c) (a+b+c)) \[Sqrt](-(a-d-e) (a+d-e) (a-d+e) (a+d+e)))
TetrahedronSinA[1,1,1,1,1,1]
TetrahedronCosA[a_, b_, c_, d_, e_, f_]:=(-a^4-(b^2-c^2) (d^2-e^2)+a^2 (b^2+c^2+d^2+e^2-2 f^2))/(\[Sqrt]((a+b-c) (a-b+c) (-a+b+c) (a+b+c)) \[Sqrt]((a+d-e) (a-d+e) (-a+d+e) (a+d+e)))
TetrahedronCosA[1,1,1,1,1,1]
Module[{pa,pb,pc,pd},
pa={0,0,0};
pb={1,0,0};
pc={1/2,\[Sqrt]3/2,0};
pd={1/2,1/(2 \[Sqrt]3),\[Sqrt](2/3)};
Graphics3D[{
Style[{Polygon[{pa,pb,pc}],Polygon[{pa,pb,pd}],Polygon[{pa,pc,pd}],Polygon[{pb,pc,pd}]},Opacity[0.9]],
Style[Point/@{pa,pb,pc,pd},AbsolutePointSize[5]],
Style[{Text["\!\(\*SubscriptBox[\(p\), \(a\)]\)",pa,{2,0}],Text["\!\(\*SubscriptBox[\(p\), \(b\)]\)",pb,{1,-1.5}],Text["\!\(\*SubscriptBox[\(p\), \(c\)]\)",pc,{2,1}],Text["\!\(\*SubscriptBox[\(p\), \(d\)]\)",pd,{-2,0}]},FontSize->14],
Style[{Text["a",(pa+pd)/2],Text["b",(pb+pd)/2],Text["c",(pc+pd)/2]},FontSize->14]
},Lighting->Automatic,Boxed->True,Axes->True]
]//ShowExample
TetrahedronVolumeSquared[{pa_List,a_},{pb_List,b_},{pc_List,c_}]:=Module[{d12,d23,d31,d14,d24,d34},
d12=Mag2[pa-pb];
d23=Mag2[pb-pc];
d31=Mag2[pc-pa];
d14=a^2;
d24=b^2;
d34=c^2;
(1/288)Det[{{0,1,1,1,1},{1,0,d12,d31,d14},{1,d12,0,d23,d24},{1,d31,d23,0,d34},{1,d14,d24,d34,0}}]]
Module[{pa,pb,pc,rm,of,pd},
(* An equilateral triangle *)
pa={0,0,0};
pb={1,0,0};
pc={1/2,\[Sqrt]3/2,0};
TetrahedronVolumeSquared[{pa,1},{pb,1},{pc,1}]
]//ShowExample
Module[{pa,pb,pc,rm,of,pd},
(* An equilateral triangle *)
pa={0,0,0};
pb={1,0,0};
pc={1/2,\[Sqrt]3/2,0};
TetrahedronVolumeSquared[{pa,1/2},{pb,1/2},{pc,1/2}]
]//ShowExample
TetrahedronExistsQ[{pa_List,a_},{pb_List,b_},{pc_List,c_}]:=TetrahedronVolumeSquared[{pa,a},{pb,b},{pc,c}]>=0
Module[{pa,pb,pc,pd,eqns,soln},
pa={0,0,0};
pb={bx,0,0};
pc={cx,cy,0};
pd={dx,dy,dz};
eqns={
Mag2[pd-pa]==a^2,
Mag2[pd-pb]==b^2,
Mag2[pd-pc]==c^2};
soln=Solve[eqns,pd]//FullSimplify;
(* Show our algebraic solution *)
Print[soln];
(* example: a regular tetrahedron *)
soln/.{bx->1,cx->1/2,cy->\[Sqrt]3/2,a->1,b->1,c->1}
]//ShowExample
TetrahedronVertex::baddir="`1` must be \[PlusMinus]1.";
TetrahedronVertex[{pa_List,a_},{pb_List,b_},{pc_List,c_},dir_:1]:=Module[{xx,yy,zz,bx,cx,cy,dx,dy,dz},
If[dir!=1&&dir!=-1,Message[TetrahedronVertex::baddir,dir];Abort[]];
(* Build a local coordinate system *)
xx=NormalizeReal[pb-pa];
zz=NormalizeReal[(pb-pa)\[Cross](pc-pa)];
yy=zz\[Cross]xx;
(* Compute local parameters of the triangle *)
bx=(pb-pa) . xx;
cx=(pc-pa) . xx;
cy=(pc-pa) . yy;
(* Construct 4th point in local coordinate system *)
dx=(a^2-b^2+bx^2)/(2 bx);
dy=(a^2 (bx-cx)+b^2 cx+bx (-c^2-bx cx+cx^2+cy^2))/(2 bx cy);
dz=(1/(2 bx cy))\[Sqrt](-(a^2 (bx-cx)+b^2 cx-bx (c^2+(bx-cx) cx))^2-(a^4+b^4+2 b^2 bx (-bx+cx)-2 a^2 (b^2+bx cx)+bx^2 (bx^2-2 c^2-2 bx cx+2 cx^2)) cy^2-bx^2 cy^4);
(* construct the point in original coordinate system *)
pa+dx xx + dy yy +dir dz zz]
Module[{pa,pb,pc,gg},
(* An equilateral triangle *)
pa={0,0,0};
pb={1,0,0};
pc={1/2,\[Sqrt]3/2,0};
(* compute the 4th point *)
(* show the full tetrahedron *)
gg[dir_]:=Module[{pd},
pd=TetrahedronVertex[{pa,1},{pb,1},{pc,1},dir];
Graphics3D[{
Text["A",pa,{-2,0}],
Text["B",pb,{-2,0}],
Text["C",pc,{-2,0}],
Text["D",pd,{-2,0}],
Polygon[{pa,pb,pc}],
Polygon[{pa,pb,pd}],
Polygon[{pb,pc,pd}],
Polygon[{pc,pa,pd}]},Axes->True]];
GraphicsRow[{gg[+1],gg[-1]}]
]//ShowExample
Module[{pa,pb,pc,rm,of,pd},
(* An equilateral triangle *)
pa={0,0,0};
pb={1,0,0};
pc={1/2,\[Sqrt]3/2,0};
(* rotate and offset it by some amounts *)
rm=RotationMatrix3Du[20.\[Degree],{Cos[30.\[Degree]],Sin[30.\[Degree]],0}];
of={.1,.2,.3};
pa=of+rm . pa;
pb=of+rm . pb;
pc=of+rm . pc;
(* compute the 4th point *)
pd=TetrahedronVertex[{pa,1},{pb,1},{pc,1}];
(* show the full tetrahedron *)
Graphics3D[{
Text["A",pa,{-2,0}],
Text["B",pb,{-2,0}],
Text["C",pc,{-2,0}],
Text["D",pd,{-2,0}],
Polygon[{pa,pb,pc}],
Polygon[{pa,pb,pd}],
Polygon[{pb,pc,pd}],
Polygon[{pc,pa,pd}]},Axes->True]
]//ShowExample
TetrahedronSignedVolume[p_List,q_List,r_List,s_List]:=(s-r) . ((q-r)\[Cross](p-r))/6
Module[{p,q,r,s},
p={0,-1/2,0};
q={0,1/2,0};
r={1/\[Sqrt]2,0,-1/2};
s={1/\[Sqrt]2,0,1/2};
Print[Graphics3D[{
Style[Line[{p,q}],Red],Style[Line[{p,r}],Green],Style[Line[{p,s}],Blue],Style[Line[{q,r}],Cyan],Style[Line[{q,s}],Magenta],Style[Line[{r,s}],Yellow],Text["p",p],Text["q",q],Text["r",r],Text["s",s]}]];
TetrahedronSignedVolume[p,q,r,s]
]//ShowExample
TetrahedronVolume[p_List,q_List,r_List,s_List]:=Abs[TetrahedronSignedVolume[p, q, r, s]]
Module[{p,q,r,s},
p={0,-1/2,0};
q={0,1/2,0};
r={1/\[Sqrt]2,0,-1/2};
s={1/\[Sqrt]2,0,1/2};
TetrahedronVolume[p,q,r,s]
]//ShowExample
TetrahedronSkewDistance[p_List,q_List,r_List,s_List]:=(6TetrahedronVolume[p,q,r,s])/Mag[(q-p)\[Cross](r-s)]
Module[{p,q,r,s},
p={0,-1/2,0};
q={0,1/2,0};
r={1/\[Sqrt]2,0,-1/2};
s={1/\[Sqrt]2,0,1/2};
TetrahedronSkewDistance[p,q,r,s]
]//ShowExample
TetrahedronSinA[p_, q_, r_, s_] :=(Mag[q-p](s-r) . ((r-p)\[Cross](q-r)))/(Mag[(q-p)\[Cross](r-p)]Mag[(q-p)\[Cross](s-p)])
Module[{p,q,r,s},
p={0,-1/2,0};
q={0,1/2,0};
r={1/\[Sqrt]2,0,-1/2};
s={1/\[Sqrt]2,0,1/2};
Print[Graphics3D[{
Style[Line[{p,q}],Red],Style[Line[{p,r}],Green],Style[Line[{p,s}],Blue],Style[Line[{q,r}],Cyan],Style[Line[{q,s}],Magenta],Style[Line[{r,s}],Yellow],Text["p",p],Text["q",q],Text["r",r],Text["s",s]}]];
TetrahedronSinA[p,q,r,s]
]//ShowExample
TetrahedronCosA[p_, q_, r_, s_] :=((p-s)\[Cross](q-s)/Mag[(p-s)\[Cross](q-s)]) . ((p-r)\[Cross](q-r)/Mag[(p-r)\[Cross](q-r)])
Module[{p,q,r,s},
p={0,-1/2,0};
q={0,1/2,0};
r={1/\[Sqrt]2,0,-1/2};
s={1/\[Sqrt]2,0,1/2};
Print[Graphics3D[{
Style[Line[{p,q}],Red],Style[Line[{p,r}],Green],Style[Line[{p,s}],Blue],Style[Line[{q,r}],Cyan],Style[Line[{q,s}],Magenta],Style[Line[{r,s}],Yellow],Text["p",p],Text["q",q],Text["r",r],Text["s",s]}]];
TetrahedronCosA[p,q,r,s]
]//ShowExample
SkewQuadrilateralAngle[p_,q_,r_,s_]:=Module[{qp,rp,sp},
{qp,rp,sp}={q-p,r-p,s-p};
ArcTan[(qp\[Cross]rp) . (rp\[Cross]sp),(qp\[Cross]rp)\[Cross](rp\[Cross]sp) . rp/Mag[rp]]]
Module[{p,q,r,s},
p={0,0,0};
q={1,0,0};
r={1,1,0};
s={.5,.5,.707};
Print[Graphics3D[{
Polygon[{p,q,r}],Polygon[{p,r,s}],
Style[Line[{p,q,r,s,p}],Black],
Style[Line[{p,r}],Red]}]];
SkewQuadrilateralAngle[p,q,r,s]/\[Degree]
]//ShowExample
SkewQuadrilateralAngleAlt[p_,q_,r_,s_]:=Module[{qp,rp,sp},
{qp,rp,sp}={q-p,r-p,s-p};
ArcTanAlt[(qp\[Cross]rp) . (rp\[Cross]sp),(qp\[Cross]rp)\[Cross](rp\[Cross]sp) . rp/Mag[rp]]]
Module[{p,q,r,s},
p={0,0,0};
q={1,0,0};
r={1,1,0};
s={.5,.5,.707};
Print[Graphics3D[{
Polygon[{p,q,r}],Polygon[{p,r,s}],
Style[Line[{p,q,r,s,p}],Black],
Style[Line[{p,r}],Red]}]];
SkewQuadrilateralAngleAlt[p,q,r,s]/\[Degree]
]//ShowExample
PlanarTolerance::usage="PlanarTolerance is an option used in Polygon3DPlanarQ to specify the tolerance on whether the points in a polygon are planar";
Options[Polygon3DPlanarQ]={
PlanarTolerance->10^-6
};
Polygon3DPlanarQ[poly_List, opts___]:=Module[{ptol,p,z},
ptol=PlanarTolerance/.{opts}/.Options[Polygon3DPlanarQ];
If[Length[poly]<3,Return[False]];
If[Length[poly]==3,Return[True]];
z=Normalize[(poly[[1]]-poly[[-1]])\[Cross](poly[[2]]-poly[[1]])];
p=poly[[1]];
Return[And@@(Abs[(#-p) . z]<=ptol&/@Drop[poly,1])]]
Module[{pts},
pts={
{{0,0,0},{1,0,0},{1,1,0},{0,1,0}},
{{0,0,0},{0,1,0},{1,1,0},{1,0,0}},
{{0,0,0},{1,0,0},{1,1,0},{0,1,0.01}},
{{0,0,0},{0.01,.5,0},{0,1,0},{1,1,0},{1,0,0}},
{{0,0,0},{0.5,-.01,0},{1,0,0},{1,1,0},{0,1,0}}};
GraphicsRow[Graphics3D[{Polygon[#],MapIndexed[Text[#2[[1]],#1]&,#]},PlotLabel->Polygon3DPlanarQ[#]]&/@pts]
]//ShowExample
ConvexTolerance::usage="ConvexTolerance is an option to Polygon3DPlanarAndConvexQ that determines how close to collinear angles are acceptable.";
Options[Polygon3DPlanarAndConvexQ]={
PlanarTolerance->10.^-6,
ConvexTolerance->10.^-6
};
Polygon3DPlanarAndConvexQ[poly_List, opts___]:=Module[{ptol,ctol,prev,next,z,prevout,angles},
If[!Polygon3DPlanarQ[poly],Return[False]];
ptol=PlanarTolerance/.{opts}/.Options[Polygon3DPlanarAndConvexQ];
ctol=ConvexTolerance/.{opts}/.Options[Polygon3DPlanarAndConvexQ];
If[Length[poly]<3,Return[False]];
prev=Normalize/@(poly-RotateRight[poly]);
next=RotateLeft[prev];
z=Normalize[(poly[[1]]-poly[[-1]])\[Cross](poly[[2]]-poly[[1]])];
If[Mag[z]==0,Return[False]];
angles=MapThread[DirectedAngle3D[#1,#2,z]&,{prev,next},1];
((And@@((#>=-ctol)&/@angles))&&(And@@((#<=\[Pi]+ctol)&/@angles)))||
((And@@((#<=ctol)&/@angles))&&(And@@((#>=-\[Pi]-ctol)&/@angles)))]
Module[{pts},
pts={
{{0,0,0},{1,0,0},{1,1,0},{0,1,0}}, 
{{0,0,0},{0,1,0},{1,1,0},{1,0,0}},
{{0,0,0},{1,0,0},{1,1,0},{0,1,0.001}},
{{0,0,0},{0,.5,0},{0,1,0},{1,1,0},{1,0,0}},
{{0,0,0},{0.5,0,0},{1,0,0},{1,1,0},{0,1,0}}};
GraphicsRow[Graphics3D[{Polygon[#],MapIndexed[Text[#2[[1]],#1]&,#]},PlotLabel->Polygon3DPlanarAndConvexQ[#]]&/@pts]
]//ShowExample
Options[Polygon3DPlanarAndStrictlyConvexQ]={
PlanarTolerance->10^-6,
ConvexTolerance->10^-6
};
Polygon3DPlanarAndStrictlyConvexQ[poly_List, opts___]:=Module[{ptol,ctol,prev,next,z,prevout,angles},
If[!Polygon3DPlanarQ[poly],Return[False]];
ptol=PlanarTolerance/.{opts}/.Options[Polygon3DPlanarAndStrictlyConvexQ];
ctol=ConvexTolerance/.{opts}/.Options[Polygon3DPlanarAndStrictlyConvexQ];
If[Length[poly]<3,Return[False]];
prev=Normalize/@(poly-RotateRight[poly]);
next=RotateLeft[prev];
z=Normalize[(poly[[1]]-poly[[-1]])\[Cross](poly[[2]]-poly[[1]])];
If[Mag[z]==0,Return[False]];
angles=MapThread[DirectedAngle3D[#1,#2,z]&,{prev,next},1];
((And@@((#>=ctol)&/@angles))&&(And@@((#<=\[Pi]-ctol)&/@angles)))||
((And@@((#<=-ctol)&/@angles))&&(And@@((#>=-\[Pi]+ctol)&/@angles)))
]
Module[{pts},
pts={{{0,0,0},{1,0,0},{1,1,0},{0,1,0}},
{{0,0,0},{0,1,0},{1,1,0},{1,0,0}},
{{0,0,0},{1,0,0},{1,1,0},{0,1,0.001}},
{{0,0,0},{0.0,.5,0},{0,1,0},{1,1,0},{1,0,0}},
{{0,0,0},{0.5,0,0},{1,0,0},{1,1,0},{0,1,0}}};
GraphicsRow[Graphics3D[{Polygon[#],MapIndexed[Text[#2[[1]],#1]&,#]},PlotLabel->Polygon3DPlanarAndStrictlyConvexQ[#]]&/@pts]
]//ShowExample
PolygonNormal3D[poly_List]:=Module[{c},
c=Plus@@poly/Length[poly];
NormalizeReal[(poly[[1]]-c)\[Cross](poly[[2]]-c)]]
Module[{poly,n},
poly={{0,0,0},{1,0,0},{1,1,0},{0,1,0}};
n=PolygonNormal3D[poly];
Graphics3D[{Polygon[poly],Arrow[{{0,0,0},n}]}]
]//ShowExample
PolygonNormal3DRobust[poly_List]:=Module[{trio,n,winding},
trio={poly,RotateLeft[poly],RotateLeft[poly,2]};
n=NormalizeReal[Sort[MapThread[(#2-#1)\[Cross](#3-#2)&,trio],Mag[#1]>Mag[#2]&]//First];
winding=Plus@@MapThread[ArcTan[(#2-#1) . (#3-#2) ,(#2-#1) . ((#3-#2)\[Cross]n)]&,trio];
n Sign[winding]]
Module[{poly,n},
poly={{0,0,0},{1,0,0},{1,1,0},{1/2,1/2,0},{0,1,0}};
n=PolygonNormal3DRobust[poly];
Graphics3D[{Polygon[poly],Arrow[{{0,0,0},n}]}]
]//ShowExample
Barycentric3D[p_List,{q_List,r_List,s_List}]:=Module[{z,qt,rt,st,zt,eqns,soln},
z=TriangleNormal3D[q,r,s];
eqns=#==0&/@Join[qt q + rt r + st s + zt z - p,{qt+rt+st-1}];
soln=Solve[eqns,{qt,rt,st,zt}][[1]];
{qt,rt,st,zt}/.soln]
Module[{p,q,r,s,qt,rt,st,zt,t},
q={0,0,0};
r={1,.1,.1};
s={.9,.8,.2};
p={.7,.2,.6};
{qt,rt,st,zt}=Barycentric3D[p,{q,r,s}];
Print["Barycentric triangle coordinates: ",{qt,rt,st,zt}];
t=qt q + rt r + st s;
Graphics3D[{
Style[Polygon[{q,r,s}],Opacity[.25],Gray],
Style[Point[q],Red,PointSize[.01]],
Style[Point[r],Green,PointSize[.01]],
Style[Point[s],Blue,PointSize[.01]],
Style[Point[p],Black,PointSize[.015]],
Style[Point[t],Orange,PointSize[.025]]},Axes->True]
]//ShowExample
BarycentricClosest3D[p_List,{q_List,r_List,s_List}]:=Take[Barycentric3D[p,{q,r,s}],3]
Module[{p,q,r,s,qt,rt,st,t},
q={0,0,0};
r={1,.1,.1};
s={.9,.8,.2};
p={.7,.2,.6};
{qt,rt,st}=BarycentricClosest3D[p,{q,r,s}];
Print["Barycentric coordinates: ",{qt,rt,st}];
t=qt q + rt r + st s;
Graphics3D[{
Style[Polygon[{q,r,s}],Opacity[.25],Gray],
Style[Point[q],Red,PointSize[.01]],
Style[Point[r],Green,PointSize[.01]],
Style[Point[s],Blue,PointSize[.01]],
Style[Point[p],Black,PointSize[.015]],
Style[Point[t],Orange,PointSize[.025]]},Axes->True]
]//ShowExample
BarycentricIntersection3D[{p1_List,p2_List},{q_List,r_List,s_List}]:=Module[{z,qt,rt,st,t,eqns,soln},
eqns=#==0&/@Join[qt q + rt r + st s  - (p1+t(p2-p1)),{qt+rt+st-1}];
soln=Solve[eqns,{qt,rt,st,t}][[1]];
{qt,rt,st}/.soln]
Module[{p1,p2,q,r,s,qt,rt,st,t},
q={0,0,0};
r={1,.1,.1};
s={.9,.8,.2};
p1={.7,.2,.6};
p2={.5,.2,-.6};
{qt,rt,st}=BarycentricIntersection3D[{p1,p2},{q,r,s}];
Print["Barycentric coordinates: ",{qt,rt,st}];
t=qt q + rt r + st s;
Graphics3D[{
Style[Polygon[{q,r,s}],Opacity[.25],Gray],
Style[Point[q],Red,PointSize[.01]],
Style[Point[r],Green,PointSize[.01]],
Style[Point[s],Blue,PointSize[.01]],
Style[{Point[p1],Point[p2]},Black,PointSize[.015]],
Style[Line[{p1,p2}],LightGray],
Style[Point[t],Orange,PointSize[.025]]},Axes->True]
]//ShowExample
RotationMatrix3D[\[Phi]_,w_]:=RotationMatrix[\[Phi],w]
RotationMatrix3D[\[Pi]/2,{0,0,1}]//ShowExample
Block[{\[Phi],x,y,z},LeafCount[RotationMatrix3D[\[Phi],{x,y,z}]]]//ShowExample
RodriguesMatrix[w_List]:={{0,-w[[3]],w[[2]]},{w[[3]],0,-w[[1]]},{-w[[2]],w[[1]],0}}
RotationMatrix3Du[\[Phi]_,w_]:=With[{W=RodriguesMatrix[w],I=IdentityMatrix[3]},
I+Sin[\[Phi]]W+(1-Cos[\[Phi]])(W . W)]
RotationMatrix3Du[\[Pi]/2,{0,0,1}]//ShowExample
Block[{\[Phi],x,y,z},LeafCount[RotationMatrix3Du[\[Phi],{x,y,z}]]]//ShowExample
RotationMatrix3Du[{c_,s_},w_]:=With[{W=RodriguesMatrix[w],I=IdentityMatrix[3]},
I+s W+(1-c)(W . W)]
RotationZMatrix3D[\[Phi]_]:={{Cos[\[Phi]],-Sin[\[Phi]],0},{Sin[\[Phi]],Cos[\[Phi]],0},{0,0,1}}
RotationXMatrix3D[\[Phi]_]:={{1,0,0},{0,Cos[\[Phi]],-Sin[\[Phi]]},{0, Sin[\[Phi]],Cos[\[Phi]]}}
RotationYMatrix3D[\[Phi]_]:={{Cos[\[Phi]],0,Sin[\[Phi]]},{0,1,0},{-Sin[\[Phi]],0,Cos[\[Phi]]}}
RotationMatrix3DTwixt[p_List,q_List]:=Module[{w,\[Phi]},
w=NormalizeReal[p\[Cross]q];
RotationMatrix3Du[ArcTan[p . q ,p . (q\[Cross]w)],w]]
Module[{o,p,q,r},
o={0,0,0};
p={1,0,0};
q={1,1,1};
r=RotationMatrix3DTwixt[p,q] . p;
Graphics3D[{
Style[Line[{o,p}],Red,Thickness[.01]],
Style[Line[{o,q}],Green,Thickness[.01]],
Style[Line[{o,r}],Blue,Thickness[.03]]}]
]//ShowExample
Rotate3D[p_List,\[Phi]_,w_List]:=RotationMatrix3D[\[Phi],w] . (p)
Rotate3D[p_List,\[Phi]_,w_List,q_List]:=q+Rotate3D[(p-q),\[Phi],w]
DynamicModule[{p1,q,w,p2},
p1={0,0,0};
q={1,0,0};
w={-1,1,0};
Manipulate[
p2=Rotate3D[p1,\[Phi],w,q];
Graphics3D[{
Style[Sphere[{.5,.5,0},.8],Opacity[0]],
Style[Sphere[p1,.1],Red],
Style[Sphere[q,.1],Green],
Style[Line[{q,q+w}],Black],
Style[Sphere[p2,.1],Blue],
{}},Axes->True,Boxed->True],{{\[Phi],\[Pi]},0,2\[Pi]}]
]//ShowExample
Rotate3Du[p_List,\[Phi]_,w_List]:=RotationMatrix3Du[\[Phi],w] . (p)
Rotate3Du[p_List,\[Phi]_,w_List,q_List]:=q+Rotate3Du[(p-q),\[Phi],w]
DynamicModule[{p1,q,w,p2},
p1={0,0,0};
q={1,0,0};
w=NormalizeReal[{-1,1,0}];
Manipulate[
p2=Rotate3Du[p1,\[Phi],w,q];
Graphics3D[{
Style[Sphere[{.5,.5,0},.8],Opacity[0]],
Style[Sphere[p1,.1],Red],
Style[Sphere[q,.1],Green],
Style[Line[{q,q+w}],Black],
Style[Sphere[p2,.1],Blue],
{}},Axes->True,Boxed->True],{{\[Phi],\[Pi]},0,2\[Pi]}]
]//ShowExample
ReflectionXYMatrix3D={{1,0,0},{0,1,0},{0,0,-1}};
ReflectionXZMatrix3D={{1,0,0},{0,-1,0},{0,0,1}};
ReflectionYZMatrix3D={{-1,0,0},{0,1,0},{0,0,1}};
SimilarityPair3D[{p1_,p2_,p3_},{q1_,q2_,q3_}]:=Module[{rmp,rmq,rm},
rmp=TriangleBasis3D[p1,p2,p3];
rmq=TriangleBasis3D[q1,q2,q3];
rm=(Mag[q2-q1]/Mag[p2-p1])Transpose[rmq] . rmp;
{rm,q1-rm . p1}]
Module[{o,p1,p2,p3,q1,q2,q3,rm,offset},
o={0,0,0};
p1={0,0,1};
p2={1.5,0,1};
p3={1.5,2,0.5};
{q1,q2,q3}={.2,.3,.4}+0.9 RotationMatrix3Du[\[Pi]/12,{1,0,0}] . RotationMatrix3Du[\[Pi]/8,{0,0,1}] . RotationMatrix3Du[\[Pi]/4,{0,-1,0}] . #&/@{p1,p2,p3};
{rm,offset}=SimilarityPair3D[{p1,p2,p3},{q1,q2,q3}];
Graphics3D[{
Style[Point[o],Black,PointSize[.02]],
Style[Line[{o,p1}],Red],
Style[Polygon[{p1,p2,p3}],Red,Opacity[.25]],
Style[Point[p2],Darker[Red],PointSize[.02]],
Style[Line[{o,q1}],Blue],
Style[Polygon[{q1,q2,q3}],Blue,Opacity[.25]],
Style[Point[offset+rm . p2],Darker[Blue],PointSize[.02]],
Style[{Text["p1",p1,{-2,0}],Text["p2",p2,{-2,0}],Text["p3",p3,{-2,0}]},Red],
Style[{Text["q1",q1,{-2,0}],Text["q2",q2,{-2,0}],Text["q3",q3,{-2,0}]},Blue],
{}},Axes->True]]//ShowExample
SimilarityPair2D3D[{p1_,p2_,p3_},{q1_,q2_,q3_}]:=Module[{rm,offset},
{rm,offset}=SimilarityPair3D[Append[#,0]&/@{p1,p2,p3},{q1,q2,q3}];
{Drop[#,-1]&/@rm,offset}]
Module[{o,p1,p2,p3,p1a,p2a,p3a,q1,q2,q3,rm,offset},
o={0,0,0};
p1={0,0,0};
p2={1.5,0,0};
p3={1.5,2,0};
{p1a,p2a,p3a}=Drop[#,-1]&/@{p1,p2,p3};
{q1,q2,q3}={.2,.3,.4}+0.9 RotationMatrix3Du[\[Pi]/12,{1,0,0}] . RotationMatrix3Du[\[Pi]/8,{0,0,1}] . RotationMatrix3Du[\[Pi]/4,{0,-1,0}] . #&/@{p1,p2,p3};
{rm,offset}=SimilarityPair2D3D[Drop[#,-1]&/@{p1,p2,p3},{q1,q2,q3}];
Graphics3D[{
Style[Point[o],Black,PointSize[.02]],
Style[Line[{o,p1}],Red],
Style[Polygon[{p1,p2,p3}],Red,Opacity[.25]],
Style[Point[p2],Darker[Red],PointSize[.02]],
Style[Line[{o,q1}],Blue],
Style[Polygon[{q1,q2,q3}],Blue,Opacity[.25]],
Style[Point[offset+rm . p2a],Darker[Blue],PointSize[.02]],
Style[{Text["p1",p1,{-2,0}],Text["p2",p2,{-2,0}],Text["p3",p3,{-2,0}]},Red],
Style[{Text["q1",q1,{-2,0}],Text["q2",q2,{-2,0}],Text["q3",q3,{-2,0}]},Blue],
{}},Axes->True]]//ShowExample
DirectedAngle3D[a_,b_,c_]:=ArcTan[a . b Mag[c],a . (b\[Cross]c)]
DirectedAngle3D[{1,0,0},{1,1,0.},{0,0,1.}]/\[Degree] //ShowExample
DirectedAngle3D[{1,0,0},{1,1,0.},{0,.1,1.}]/\[Degree] //ShowExample
OrientedAngle3D[a_,b_,c_]:=With[{d=a\[Cross]b},DirectedAngle3D[a,b,d Sign[c . d]]]
OrientedAngle3D[{1,0,0},{1,1,0.},{0,0,1.}]/\[Degree] //ShowExample
OrientedAngle3D[{1,0,0},{1,1,0.},{0,.1,1.}]/\[Degree] //ShowExample
ShortestAngle3D[a_,b_]:=ShortestAngle[a,b];
Module[{p},
p={2,0,0};
{ShortestAngle3D[p,{1,0,0}],
ShortestAngle3D[p,{-1,0,0}],
ShortestAngle3D[p,{0,0,1}],
ShortestAngle3D[p,{1,.1,.1}]}//ShowExample
]
RotateZ3D[g_,\[Phi]_]:=MatrixTransform[g,RotationZMatrix3D[\[Phi]]]
Translate3D[g_,v_]:=FunctionTransform[g,#+v&]
DupReflect3D[g_]:={g,MatrixTransform[g,ReflectionXZMatrix3D]}
DupRotate3D[g_,m_]:=Table[MatrixTransform[g,RotationZMatrix3D[2\[Pi] i/m]],{i,0,m-1}]
DupReflectAndRotate3D[g_,m_]:=Module[{gg={g,MatrixTransform[g,ReflectionXZMatrix3D]}},Table[MatrixTransform[gg,RotationZMatrix3D[2\[Pi] i/m]],{i,0,m-1}]]
DevelopabilityExcess3D[v_,plist_List]:=Module[{rr,angles},
rr=#-v&/@plist; (* vectors to each vertex *)
angles=MapThread[ShortestAngle3D,{rr,RotateLeft[rr]},1];
Plus@@angles-2\[Pi]]
DevelopabilityExcess3D[{0,0,0}, {{1,0,0},{0,1,0},{-.7,.7,0},{-1,0,.5},{-.7,-.7,0},{0,-1,0}}]/\[Degree]//ShowExample
DevelopabilityExcess3D[{0,0,0}, {{1,0,0},{0,0,1},{0,-1,0},{1,1,0}}]/\[Degree]//ShowExample
VertexConsistencyMatrix3D[foldangles_List,sectorangles_List]:=Module[{gmats,amats},
gmats=RotationXMatrix3D/@foldangles;
amats=RotationZMatrix3D/@sectorangles;
Dot@@Riffle[gmats,amats]
];
Module[{glist,alist},
glist={0.5235987755982988`,0.871136020378918`,-0.5235987755982974`,0.8711360203789182`};
Print["Fold angles = ",glist/\[Degree]];
alist={2.0943951023931953`,0.8726646259971648`,1.0471975511965976`,2.2689280275926285`};
Print["Sector angles = ",alist/\[Degree]];
Chop[VertexConsistencyMatrix3D[glist,alist]]//MatrixForm
]//ShowExample
Module[{glist,alist},
glist={0.5235987755982988`,0.871136020378918`,-0.5235987755982974`,0.8711360203789182`};
Print["Fold angles = ",glist/\[Degree]];
alist={2.`,0.8`,1.0`,2.2`};
Print["Sector angles = ",alist/\[Degree]];
Chop[VertexConsistencyMatrix3D[glist,alist]]//MatrixForm
]//ShowExample
Module[{glist1,glist2,alist},
glist1={90\[Degree],90\[Degree]};
glist2={90\[Degree],-90\[Degree]};
alist={180\[Degree],180\[Degree]};
Print["valid = ", VertexConsistencyMatrix3D[glist1,alist]//MatrixForm,", spurious = ",VertexConsistencyMatrix3D[glist2,alist]//MatrixForm]
]//ShowExample
Hat[a_]:=Which[a==\[Pi],\[Infinity],a==-\[Pi],-\[Infinity],True,Tan[(1/2)a]]
SetAttributes[Hat,Listable]
Hat[{-\[Pi],-\[Pi]/2,0,\[Pi]/2,\[Pi]}]//ShowExample
ArcHat[h_]:=Which[h==\[Infinity],\[Pi],h==-\[Infinity],-\[Pi],True,2 ArcTan[h]]
SetAttributes[ArcHat,Listable]
ArcHat[{-\[Infinity],-1,0,1,\[Infinity]}]//ShowExample
HatTransform[expr_,\[Xi]_,x_]:=(expr/.{Sin[\[Xi]]->(2x)/(1+x^2),Csc[\[Xi]]->(1+x^2)/(2x),Cos[\[Xi]]->(1-x^2)/(1+x^2),Sec[\[Xi]]->(1+x^2)/(1-x^2),Tan[\[Xi]]->(2x)/(1-x^2),Cot[\[Xi]]->(1-x^2)/(2x),Tan[\[Xi]/2]->x})/.{\[Xi]->2 ArcTan[x]}
HatTransform[{Sin[\[Xi]],Cos[\[Xi]],Tan[\[Xi]],Cot[\[Xi]+\[Phi]]},\[Xi],x]//ShowExample
HatTransform[expr_,angles_List,hats_List]:=Fold[HatTransform[#1,#2[[1]],#2[[2]]]&,expr,Transpose[{angles,hats}]]
HatTransform[{Sin[\[Xi]1],Cos[\[Xi]2],Tan[\[Xi]3],Cot[\[Xi]2+\[Phi]]},{\[Xi]1,\[Xi]2,\[Xi]3},{x1,x2,x3}]//ShowExample
TriangleHatA[a_,b_,c_]:=((a+b-c) (a-b+c))/(\[Sqrt](-(a-b-c) (a+b-c) (a-b+c) (a+b+c)))
RotationHat[r1_List,r2_List]:=(Mag[r1]Mag[r2]-r1 . r2)/({{0,-1},{1,0}} . r1) . r2
Module[{r1,r2},
r1={2,0};
r2={1,1};
RotationHat[r1,r2]//Simplify
]//ShowExample
RotationHat[p_List,q_List,r_List]:=RotationHat[q-p,r-p]
RotationHat[{p1_List,p2_List},{q1_List,q2_List}]:=RotationHat[p2-p1,q2-q1]
HatRotationDenominator[h_]:=(1+h^2)
HatRotationMatrix2DNumerator[h_]:=Module[{s,c},
s=2h;
c=(1-h^2);
{{c,-s},{s,c}}]
HatRotationMatrix2DNumerator[h] // MatrixForm // ShowExample
HatRotationMatrix2DDenominator[h_] := HatRotationDenominator[h] IdentityMatrix[2]
HatRotationMatrix2DDenominator[h] // MatrixForm // ShowExample
HatRotationMatrix2D[h_] := HatRotationMatrix2DNumerator[h]/HatRotationDenominator[h]
HatRotationMatrix2D[h] // MatrixForm // ShowExample
(*HatExcess:: usage="HatExcess is an option to HatRotationConditions2D that specifies the excess angle on the product of rotation matrices.";
HatMatrixSplit::usage="HatMatrixSplit is an option to HatRotationConditions2D that specifies to split the hat rotation matrix product into two parts.";
HatMatrixSign::usage="HatMatrixSign is an option to HatRotationConditions2D that specifies the sign of the RHS of the equation.";*)
Options[HatRotationConditions2D]={
HatExcess->0,
HatMatrixSplit->Automatic,
HatMatrixSign->1
};
HatRotationConditions2D::badsplit="The split distance `1` must be between 0 and `2` or None or Automatic.";
HatRotationConditions2D[hats_List, opts___]:=Module[{he,hms,hsg,ahats,nl,nr,lhats,rhats,lhs,rhs},
he=HatExcess/.{opts}/.Options[HatRotationConditions2D];
hms=HatMatrixSplit/.{opts}/.Options[HatRotationConditions2D];
hsg=HatMatrixSign/.{opts}/.Options[HatRotationConditions2D];
ahats=If[he==0,hats,Append[hats,-he]];
nl=Switch[hms,
Automatic,Ceiling[Length[ahats]/2],
None,Length[ahats],
_,hms];
nr=Length[ahats]-nl;
If[nl<0||nr<0,Message[HatRotationConditions2D::badsplit,hms,Length[ahats]];Abort[]];
lhats=Take[ahats,nl];
rhats=Take[-ahats,-nr];
lhs=(Times@@(HatRotationDenominator/@rhats))If[nl!=0,Dot@@(HatRotationMatrix2DNumerator/@lhats),IdentityMatrix[2]];
rhs=(Times@@(HatRotationDenominator/@lhats))If[nr!=0,Dot@@(HatRotationMatrix2DNumerator/@rhats),IdentityMatrix[2]];
lhs-hsg rhs]
Module[{h,m},
h=Hat[2\[Pi]/4];
m=HatRotationConditions2D[{h,h,h,h}];
m//MatrixForm//N//Chop
]//ShowExample
Module[{h,m},
h=Hat[90\[Degree]+5\[Degree]];
m=HatRotationConditions2D[{h,h,h,h},HatExcess->Hat[20\[Degree]]];
m//MatrixForm//N//Chop
]//ShowExample
Module[{h1,h2,h3,h4,m1,m2},
m1=HatRotationConditions2D[{h1,h2,h3,h4},HatMatrixSplit->None];
Print["LeafCount (None) = ",LeafCount[m1]];
m2=HatRotationConditions2D[{h1,h2,h3,h4},HatMatrixSplit->Automatic];
Print["LeafCount (Automatic) = ",LeafCount[m2]];
]//ShowExample;
Module[{h1,h2,h3,h4,m1,m2},
m1=HatRotationConditions2D[{h1,h2,h3,h4},HatMatrixSplit->None]//FullSimplify;
Print["LeafCount (None) = ",LeafCount[m1]];
m2=HatRotationConditions2D[{h1,h2,h3,h4},HatMatrixSplit->Automatic]//FullSimplify;
Print["LeafCount (Automatic) = ",LeafCount[m2]];
]//ShowExample;
HatVertexDevelopabilityConditions2D[sectorhats_List,opts___]:=
HatRotationConditions2D[sectorhats,opts]
Module[{h,m},
h=Hat[2\[Pi]/4];
m=HatVertexDevelopabilityConditions2D[{h,h,h,h}];
m//MatrixForm//N//Chop
]//ShowExample
Module[{h,m},
h=Hat[2\[Pi]/4+5\[Degree]];
m=HatVertexDevelopabilityConditions2D[{h,h,h,h},HatExcess->Hat[20\[Degree]]];
m//MatrixForm//N//Chop
]//ShowExample
Module[{m},
m=FullSimplify[HatVertexDevelopabilityConditions2D[{h,h,h,h},HatMatrixSplit->None]]//MatrixForm
]//ShowExample
Module[{fm},
fm=Flatten[HatVertexDevelopabilityConditions2D[{h,h,h,h},HatMatrixSplit->None]];
ColumnForm[Solve[#==0,h]&/@fm]
]//ShowExample
Module[{m},
m=Flatten[FullSimplify[HatVertexDevelopabilityConditions2D[{h1,h2,h3,h4},HatMatrixSplit->None]]]
]//ShowExample
Module[{m},
m=Flatten[FullSimplify[HatVertexDevelopabilityConditions2D[{h1,h2,h3,h4}]]]
]//ShowExample
HatVertexFlatFoldabilityConditions2D[sectorhats_List, opts___]:=Module[{shats},
shats=Table[If[OddQ[i],sectorhats[[i]],-sectorhats[[i]]],{i,Length[sectorhats]}];
HatRotationConditions2D[shats,opts]]
Module[{m},
m=HatVertexFlatFoldabilityConditions2D[Hat/@{90\[Degree],120\[Degree],90\[Degree],60\[Degree]}];
m//MatrixForm//N//Chop
]//ShowExample
Module[{m},
m=HatVertexFlatFoldabilityConditions2D[Hat/@{95\[Degree],115\[Degree],95\[Degree],55\[Degree]},HatExcess->Hat[20\[Degree]],HatMatrixSplit->None];
m//MatrixForm//N//Chop
]//ShowExample
HatFacePlanarityConditions2D[sectorhats_List, opts___]:=Module[{hsg},
hsg=If[EvenQ[Length[sectorhats]],1,-1];
HatRotationConditions2D[sectorhats,HatMatrixSign->hsg,opts]]
Module[{h,m},
h=Hat[90\[Degree]];
m=HatFacePlanarityConditions2D[{h,h,h,h}];
m//MatrixForm
]//ShowExample
Module[{h,m},
h=Hat[108\[Degree]];
m=HatFacePlanarityConditions2D[{h,h,h,h,h}];
m//MatrixForm//N//Chop
]//ShowExample
Module[{h,m},
h=Hat[90\[Degree]-5\[Degree]];
m=HatFacePlanarityConditions2D[{h,h,h,h},HatExcess->Hat[-20\[Degree]]];
m//MatrixForm//N//Chop
]//ShowExample
Module[{h,m},
h=Hat[108\[Degree]-4\[Degree]];
m=HatFacePlanarityConditions2D[{h,h,h,h,h},HatExcess->Hat[-20\[Degree]]];
m//MatrixForm//N//Chop
]//ShowExample
HatRotationMatrix3DNumerator[h_,w_List]:=Module[{wx,wy,wz,s,c,d},
{wx,wy,wz}=w;
s=2h;
c=(1-h^2);
d=(1+h^2);
c IdentityMatrix[3]+(d-c) Outer[Times,w,w]+s {{0,-wz,wy},{wz,0,-wx},{-wy,wx,0}}]
(HatRotationMatrix3DNumerator[h,#]//MatrixForm)&/@IdentityMatrix[3]//ShowExample
HatRotationMatrix3DDenominator[h_,w_List]:=HatRotationDenominator[h] IdentityMatrix[3]
(HatRotationMatrix3DDenominator[h,#]//MatrixForm)&/@IdentityMatrix[3]//ShowExample
HatRotationMatrix3D[h_,w_List]:=HatRotationMatrix3DNumerator[h,w]/HatRotationDenominator[h]
(HatRotationMatrix3D[h,#]//MatrixForm)&/@IdentityMatrix[3]//ShowExample
(RotationMatrix3Du[\[Eta],#]//MatrixForm)&/@IdentityMatrix[3]//ShowExample
Options[HatVertexConsistencyConditions3D]={
HatMatrixSplit->Automatic
};
HatVertexConsistencyConditions3D::badsplit="The split distance `1` must be between 0 and `2` or None or Automatic.";
HatVertexConsistencyConditions3D[foldhats_List, sectorhats_List,opts___]:=Module[{hms,gpairs,spairs,apairs,nl,nr,lpairs,rpairs,lnums,ldens,rnums,rdens,lhs,rhs},
hms=HatMatrixSplit/.{opts}/.Options[HatVertexConsistencyConditions3D];
gpairs={HatRotationMatrix3DNumerator[#,{1,0,0}],HatRotationDenominator[#]}&/@foldhats;
spairs={HatRotationMatrix3DNumerator[#,{0,0,1}],HatRotationDenominator[#]}&/@sectorhats;
apairs=Riffle[gpairs,spairs];
nl=Switch[hms,
Automatic,Ceiling[Length[apairs]/2],
None,Length[apairs],
_,hms];
nr=Length[apairs]-nl;
If[nl<0||nr<0,Message[HatRotationConditions2D::badsplit,hms,Length[apairs]];Abort[]];
lpairs=If[nl>0,Take[apairs,nl],{{IdentityMatrix[3],1}}];
rpairs=If[nr>0,{Transpose[#[[1]]],#[[2]]}&/@Reverse[Take[apairs,-nr]],{{IdentityMatrix[3],1}}];
{lnums,ldens}=Transpose[lpairs];
{rnums,rdens}=Transpose[rpairs];
lhs=(Times@@rdens) (Dot@@lnums);
rhs=(Times@@ldens) (Dot@@rnums);
lhs-rhs]
Module[{dhats,shats},
dhats=Hat[{90 \[Degree],2 ArcTan[2],-90 \[Degree],2 ArcTan[2]}];
shats=Hat[{120\[Degree],60\[Degree],60\[Degree],120\[Degree]}];
Print["Dihedral hats = ",dhats];
Print["Sector hats = ",shats];
HatVertexConsistencyConditions3D[dhats,shats]//N//Chop//MatrixForm
]//ShowExample
Module[{dhats,shats},
dhats=Hat[{90 \[Degree],2 ArcTan[2],-90 \[Degree],2 ArcTan[2]}];
shats=Hat[{120\[Degree],60\[Degree],60\[Degree],120\[Degree]}];
Print["Dihedral hats = ",dhats];
Print["Sector hats = ",shats];
HatVertexConsistencyConditions3D[dhats,shats,HatMatrixSplit->None]//N//Chop//MatrixForm
]//ShowExample
Module[{ahats},
ahats=Hat[{120\[Degree],60\[Degree],60\[Degree],120\[Degree]}];
(9/128) HatVertexConsistencyConditions3D[{g1,g2,g3,g4},ahats,HatMatrixSplit->None]//Diagonal//ExpandAll
]//ShowExample
Module[{m1,m2},
m1= HatVertexConsistencyConditions3D[{g1,g2,g3,g4},{a1,a2,a3,a4},HatMatrixSplit->None];
m2= HatVertexConsistencyConditions3D[{g1,g2,g3,g4},{a1,a2,a3,a4},HatMatrixSplit->Automatic];
Print["LeafCount (None) = ",LeafCount[m1]];
Print["LeafCount (Automatic) = ",LeafCount[m2]];

]//ShowExample;
Module[{m1,m2},
m1= HatVertexConsistencyConditions3D[{g1,g2,g3,g4},{a1,a2,a3,a4},HatMatrixSplit->None]//ExpandAll;
m2= HatVertexConsistencyConditions3D[{g1,g2,g3,g4},{a1,a2,a3,a4},HatMatrixSplit->Automatic]//ExpandAll;
Print["LeafCount (None) = ",LeafCount[m1]];
Print["LeafCount (Automatic) = ",LeafCount[m2]];

]//ShowExample;
Module[{m1,m2},
m1= HatVertexConsistencyConditions3D[{g1,g2,g3,g4},{a1,a2,a3,a4},HatMatrixSplit->None]//Simplify;
m2= HatVertexConsistencyConditions3D[{g1,g2,g3,g4},{a1,a2,a3,a4},HatMatrixSplit->Automatic]//Simplify;
Print["LeafCount (None) = ",LeafCount[m1]];
Print["LeafCount (Automatic) = ",LeafCount[m2]];

]//ShowExample;
ReversePolygons[expr_]:=expr/.Polygon[x_]:>Polygon[Reverse[x]]
Oval[{p_List,q_List},r_]:=Module[{\[Phi],pq,dr},
If[p==q,Circle[p,r],
pq=q-p;
\[Phi]=ArcTan@@pq;
dr=RotationMatrix2D[\[Pi]/2] . Normalize[pq];
{Circle[p,r,{\[Phi]+\[Pi]/2,\[Phi]+3\[Pi]/2}],
Line[{p+r dr,q+r dr}],
Line[{p-r dr,q-r dr}],
Circle[q,r,{\[Phi]-\[Pi]/2,\[Phi]+\[Pi]/2}]}]]
Module[{p,q,r},
p={0,0};
q={1,.5};
r=0.2;
Graphics[{
Style[Oval[{p,q},r],Red],
Style[{Point[p],Point[q]},Black,PointSize[.02]]}]
]//ShowExample
Oval::badrad="You cannot specify different radii `1` for an oval with the same points `2`.";
Oval[{p_List,q_List},{rp_,rq_}]:=Module[{\[Phi],pq,dr,\[Psi],fp1,fp2,fq1,fq2},
If[p==q,If[rp==rq,Circle[p,rp],Message[Oval::badrad,{rp,rq},{p,q}];Abort[]],
pq=q-p;
\[Phi]=ArcTan@@pq;
dr=RotationMatrix2D[\[Pi]/2] . Normalize[pq];
\[Psi]=ArcSin[(rq-rp)/Mag[pq]];
fp1=\[Phi]+\[Pi]/2+\[Psi];
fp2=\[Phi]+3\[Pi]/2-\[Psi];
fq1=\[Phi]-\[Pi]/2-\[Psi];
fq2=\[Phi]+\[Pi]/2+\[Psi];
{Line[{p+rp U[fp2],q+rq U[fq1]}],
Line[{p+rp U[fp1],q+rq U[fq2]}],
Circle[p,rp,{fp1,fp2}],
Circle[q,rq,{fq1,fq2}]}]]
Module[{p,q,rp,rq},
{p,q}={{0,0},{1,.5}};
{rp,rq}={.8,.4};
Graphics[{
Style[Oval[{p,q},{rp,rq}],Red],
Style[{Point[p],Point[q]},Black,PointSize[.02]]}]
]//ShowExample
BoundingBoxGC[expr_]:=Module[{gcs,pts},
gcs=Cases[expr,_GraphicsComplex,{0,\[Infinity]}];
pts=Join@@(First/@gcs);
BoundingBox[pts]]
Module[{test},
test={GraphicsComplex[{{0,0}},Point[1]],GraphicsComplex[{{-.5,.5},{-.6,.6}},Line[{1,2}]]};
BoundingBoxGC[test]
]//ShowExample
BoundingBoxExtentGC[expr_]:=Module[{gcs,pts},
gcs=Cases[expr,_GraphicsComplex,{0,\[Infinity]}];
pts=Join@@(First/@gcs);
BoundingBoxExtent[pts]]
GraphicsBoundingBox[expr_]:=Module[{pts},
pts={};
expr/.Point[x_]:>AppendTo[pts,x];
expr/.Line[x_]:>(AppendTo[pts,#]&/@x);
expr/.Polygon[x_]:>(AppendTo[pts,#]&/@x);
If[ListEmptyQ[pts],{},BoundingBox[pts]]]
Module[{glist,bbox,xmin,xmax,ymin,ymax},
glist={
PointSize[.02],
Point[{1.5,-0.5}],
Line[{{0,1},{2,2}}],
Line[{{4,1},{2,2}}],
Line[{{1,5},{2,2}}],
Polygon[{{2,3},{3,3},{5,4}}]};
bbox=GraphicsBoundingBox[glist];
{{xmin,xmax},{ymin,ymax}}=bbox;
Print[Graphics[{glist,Style[Line[{{xmin,ymin},{xmax,ymin},{xmax,ymax},{xmin,ymax},{xmin,ymin}}],Red]},Frame->True]];
bbox
]//ShowExample
GraphicsExtent[expr_]:=Module[{bbox,xmin,xmax,ymin,ymax},
bbox=GraphicsBoundingBox[expr];
If[ListEmptyQ[bbox],{0,0},
{{xmin,xmax},{ymin,ymax}}=GraphicsBoundingBox[expr];
{xmax-xmin,ymax-ymin}]]
Module[{glist,bbox,xmin,xmax,ymin,ymax},
glist={
Point[{1.5,-0.5}],
Line[{{0,1},{2,2}}],
Line[{{4,1},{2,2}}],
Line[{{1,5},{2,2}}],
Polygon[{{2,3},{3,3},{5,4}}]};
bbox=GraphicsBoundingBox[glist];
{{xmin,xmax},{ymin,ymax}}=bbox;
Print[Graphics[{glist,Style[Line[{{xmin,ymin},{xmax,ymin},{xmax,ymax},{xmin,ymax},{xmin,ymin}}],Red]},Frame->True]];
GraphicsExtent[glist]
]//ShowExample
Graphics3DBoundingBox[expr_]:=Module[{pts},
pts={};
expr/.Point[x_]:>AppendTo[pts,x];
expr/.Line[x_]:>(AppendTo[pts,#]&/@x);
expr/.Tube[x_,___]:>(AppendTo[pts,#]&/@x);
expr/.Polygon[x_]:>(AppendTo[pts,#]&/@x);
If[ListEmptyQ[pts],{},BoundingBox[pts]]]
Module[{glist,bbox,xmin,xmax,ymin,ymax,zmin,zmax},
glist={
PointSize[.02],
Point[{1.5,-0.5,0}],
Line[{{0,1,0},{2,2,1}}],
Line[{{4,1,2},{2,2,3}}],
Line[{{1,5,3},{2,2,0}}],
Polygon[{{2,3,4},{3,3,1},{5,4,2}}]};
bbox=Graphics3DBoundingBox[glist];
{{xmin,xmax},{ymin,ymax},{zmin,zmax}}=bbox;
Print[Graphics3D[{glist,Style[Line[{{xmin,ymin,zmin},{xmax,ymin,zmin},{xmax,ymax,zmin},{xmax,ymax,zmax},{xmin,ymax,zmax},{xmin,ymin,zmax}}],Red]},Boxed->True,Axes->True]];
bbox
]//ShowExample
Graphics3DExtent[expr_]:=Module[{bbox,xmin,xmax,ymin,ymax,zmin,zmax},
bbox=Graphics3DBoundingBox[expr];
If[ListEmptyQ[bbox],{0,0,0},
{{xmin,xmax},{ymin,ymax},{zmin,zmax}}=bbox;
{xmax-xmin,ymax-ymin,zmax-zmin}]]
Module[{glist,bbox,xmin,xmax,ymin,ymax,zmin,zmax},
glist={
PointSize[.02],
Point[{1.5,-0.5,0}],
Line[{{0,1,0},{2,2,1}}],
Line[{{4,1,2},{2,2,3}}],
Line[{{1,5,3},{2,2,0}}],
Polygon[{{2,3,4},{3,3,1},{5,4,2}}]};
bbox=Graphics3DBoundingBox[glist];
{{xmin,xmax},{ymin,ymax},{zmin,zmax}}=bbox;
Print[Graphics3D[{glist,Style[Line[{{xmin,ymin,zmin},{xmax,ymin,zmin},{xmax,ymax,zmin},{xmax,ymax,zmax},{xmin,ymax,zmax},{xmin,ymin,zmax}}],Red]},Boxed->True,Axes->True]];
Graphics3DExtent[glist]
]//ShowExample
PartitionedGraphicsGrid[glist_List, n_] := GraphicsGrid[Partition[glist,n,n,{1,1},{}]]
Module[{gfn,glist},
gfn=Graphics[{Style[Disk[{0,0}],#]}]&;
glist=gfn/@{Red,Green,Blue,Cyan,Magenta};
PartitionedGraphicsGrid[glist,3]
]//ShowExample
Module[{gfn,glist},
gfn=Graphics[{Style[Disk[{0,0}],#]}]&;
glist=gfn/@{Red,Green,Blue};
PartitionedGraphicsGrid[glist,4]
]//ShowExample
Spacing::usage="Spacing is an option to PlaceInRowGraphics that specifies the spacing to use between graphical objects.";
Options[PlaceInRowGraphics]={
Spacing->0.1
};
PlaceInRowGraphics[glist_List, opts___]:=Module[{sp,glist1,bbs,ctrs,wids,offs},
sp=Spacing/.{opts}/.Options[PlaceInRowGraphics];
glist1=glist/.{Graphics[obj_,___]:>obj};
bbs=GraphicsBoundingBox/@glist1;(* bounding boxes *)
ctrs=Function[bb,Plus@@#/2&/@bb]/@bbs;(* centers *)
wids=First/@Function[bb,-Subtract@@#&/@bb]/@bbs; (* widths *)
sp=sp*Plus@@wids/Length[wids];(* spacing in local units *)
offs=Drop[FoldList[#1+#2+sp&,0,wids],-1];(* offsets to each center *)
Graphics[MapThread[FunctionTransform[#1,Function[pt,pt-#2+{#3,0}]]&,{glist1,ctrs,offs}]]
]
Module[{tverts,g1,g2,g3},
(* 3 different sized triangles *)
tverts={{0,0},{1,0},{.5,1},{0,0}};
g1=Graphics[Style[Line[tverts],Red]];
g2=Graphics[Style[Line[{1,0}+#&/@(0.5 tverts)],Green]];
g3=Graphics[Style[Line[{0,1}+#&/@(0.2 tverts)],Blue]];
(* Here's what GraphicsRow would produce, rescaling each image *)
Print[GraphicsRow[{g1,g2,g3}]];
(* Here's the result of PlaceInRowGraphics *)
PlaceInRowGraphics[{g1,g2,g3}]
]//ShowExample
ScaleLines[expr_,r_]:=expr/.Line[x_]:>Line[x r]
LineLength[pts_List]:=0/;Length[pts]<2;
LineLength[pts_List]:=Plus@@(Mag/@(Drop[pts,1]-Drop[pts,-1]))
DashPattern::usage="DashPattern is an option to DashedLine that specifies the pattern to use for dashed lines.";
JustifyDashing::usage="JustifyDashing is an option to DashedLine that specifies whether to justify the dashes so that the pattern starts and stops on a full element of the pattern.";
MinimumDashLength::usage="MinimumDashLength is an options to DashedLine that specifies a minimum dash length for final dashes.";
DashCorners::usage="DashCorners is an option to DashedLine that specifies whether to include internal corners within dashes.";
Options[DashedLine]={
DashPattern->{{0.0667,False},{0.1333,True}},
JustifyDashing->True,
MinimumDashLength->0.001,
DashCorners->True
};
DashedLine[pts_List,opts___]:=Module[{dp,jd,mdl,dc,d1,d2,ll,nd,\[Alpha],curLinePt,pendingLinePts,dashPts,curDashPat,curDashNeeded,ret,idash,tryadd,seg,seglen},
dp=DashPattern/.{opts}/.Options[DashedLine];
jd=JustifyDashing/.{opts}/.Options[DashedLine];
mdl=MinimumDashLength/.{opts}/.Options[DashedLine];
dc=DashCorners/.{opts}/.Options[DashedLine];
If[jd,
(* Adjust the lengths of the pattern *)
ll=LineLength[pts];
d1=dp[[1,1]];
d2=Plus@@(First/@Drop[dp,1]);
nd=Max[1,Round[(ll-d1)/(d1+d2)]];
\[Alpha]=ll/(nd(d1+d2)+d1);
dp = {\[Alpha] #[[1]],#[[2]]}&/@dp;
];
curLinePt=First[pts];
pendingLinePts=Drop[pts,1];
dashPts={curLinePt};
curDashPat=dp[[1]];
curDashNeeded=curDashPat[[1]];
ret={};
idash=1;
(* add a dash to the collection if long enough *)
tryadd[dpts_]:=If[Mag[First[dpts]-Last[dpts]]>mdl,If[dc,AppendTo[ret,Line[dpts]],AppendTo[ret,Line[dpts[[{1,-1}]]]]]];
While[Length[pendingLinePts]>0,
seg=First[pendingLinePts]-curLinePt;
seglen=Mag[seg];
If[seglen>curDashNeeded,
 (* we have enough to complete the current dash *)
AppendTo[dashPts,Last[dashPts]+curDashNeeded * seg/seglen];
If[curDashPat[[2]],tryadd[dashPts]];
curLinePt=Last[dashPts];
dashPts={curLinePt};
idash+=1;
curDashPat=dp[[Mod[idash,Length[dp],1]]];
curDashNeeded=curDashPat[[1]];
,
(* we don't have enough to complete the current dash *)
curLinePt=pendingLinePts[[1]];
pendingLinePts=Drop[pendingLinePts,1];
AppendTo[dashPts,curLinePt];
curDashNeeded -= seglen;
(* if we're out of points, try writing whatever we have *)
If[Length[pendingLinePts]==0,If[curDashPat[[2]],tryadd[dashPts]]];
];
];
ret]
Show[Graphics[{
DashedLine[{{0,0},{1,0}}],
DashedLine[{{1,0},{1,1}}],
DashedLine[{{1,1},{0,1}}],
DashedLine[{{0,1},{0,0}}],Red,DashedLine[{{0,0},{1,1}},DashPattern->{{0.2,True},{0.2,False}}],Blue,
DashedLine[{{0,1},{1,0}},DashPattern->{{0.07,True},{0.05,False}}]}]
]//ShowExample
Graphics[DashedLine[{{0,0},{0,1},{1,0},{1,1},{2,0},{2,1}},DashPattern->{{0.05,False},{0.22,True}}]
]//ShowExample
Graphics[DashedLine[{{0,0},{0,1},{1,0},{1,1},{2,0},{2,1}},DashPattern->{{0.05,False},{0.22,True}},DashCorners->False]
]//ShowExample
Module[{nd},
nd=20;
Graphics[Table[DashedLine[{{0,i/nd},{1,i/nd}},DashPattern->{{0.2(i+1)/(nd+1),True},{0.2(i+1)/(nd+1),False}}],{i,0,nd}]]
]//ShowExample
Module[{nd},
nd=20;
Graphics[Table[DashedLine[{{0,i/nd},{1,i/nd}},DashPattern->{{0.2(i+1)/(nd+1),True},{0.2(i+1)/(nd+1),False}},JustifyDashing->False],{i,0,nd}]]
]//ShowExample
Module[{nd},
nd=20;
Graphics[Table[DashedLine[{{0,i/nd},{1,i/nd}},DashPattern->{{0.2(i+1)/(nd+1),True},{0.2(i+1)/(nd+1),False}},
MinimumDashLength->0.1(i+1)/(nd+1),JustifyDashing->False],{i,0,nd}]]
]//ShowExample
Dashify[obj_,opts___]:=obj/.Line[x_]:>DashedLine[x,opts]
DashifyByStyle[obj_,styles_List,opts___]:=obj/.(Style[x_,#]:>Style[x/.Line[y_]:>DashedLine[y,opts],#]&/@styles)
GapLength::usage="GapLength is an options to GapLine that specifies the gap length to leave at the beginning and/or end of a line.";
GapPosition::usage="GaphPosition is an option to GapLine that specifies which end of the line a gap should be placed at.";
Both::usage="Both is a value for option GapPosition that specifies to leave gaps at both ends of the line.";
Options[GapLine]={
GapLength->0.05,
GapPosition->Both
};
GapLine[pts_,opts___]:=Module[{gl,gp,p=pts,sl},
gl=GapLength/.{opts}/.Options[GapLine];
gp=GapPosition/.{opts}/.Options[GapLine];
If[gp===Front||gp===Both,
If[(sl=Mag[p[[1]]-p[[2]]])<gl,p=DropFirst[p],p=ReplacePart[p,1->p[[2]]+((sl-gl)/sl)(p[[1]]-p[[2]])]];
If[Length[p]<2,Return[{}]]];
If[gp===Back||gp===Both,
If[(sl=Mag[p[[-1]]-p[[-2]]])<gl,p=DropLast[p],p=ReplacePart[p,-1->p[[-2]]+((sl-gl)/sl)(p[[-1]]-p[[-2]])]];
If[Length[p]<2,Return[{}]]];
Return[Line[p]]]
Graphics[{
AbsoluteThickness[5],
Line[{{0,0},{.5,0},{1,0}}],
GapLine[{{0,.2},{.5,.2},{1,.2}},GapLength->0.2],
GapLine[{{0,.4},{.5,.4},{1,.4}},GapLength->0.3,GapPosition->Front],
GapLine[{{0,.6},{.5,.6},{1,.6}},GapLength->0.3,GapPosition->Back],
GapLine[{{0.45,.8},{0.55,.8}},GapLength->0.2],
Line[{{0,1},{.5,1},{1,1}}]
},Frame->True]//ShowExample

Gapify[obj_,opts___]:=obj/.Line[x_]:>GapLine[x,opts]
GapifyByStyle[obj_,styles_List,opts___]:=obj/.(Style[x_,#]:>Style[x/.Line[y_]:>GapLine[y,opts],#]&/@styles)
Module[{bin},
bin=Uncompress["1:eJztnUuS5Lpuho8f+3B4ByIl6rGEG+GRl+CBIzzy4HqRXpZPi/hA/ChldT2yujqPc9JsVUoUCQI/nqT+9T/++9//83//5Y8//v7Pf/zxx7/919//52//+Od/5u1s9uls1v1stn61tN4cvVnPppWzKTOP/9OfTa2rtXY9WVvk7tL7bUt/tvZ+d65+PFHsiWPvl9MaO1in2Cx97NtqtzbrYbJr62mzPy96W61+W28nGdWRXhF+a2u8xQhik+KB4+qB/tuqvwkVrBd9YNtvj2wXWra+Ym2TPpVaNT5wlIux0Mty8do2xz4PW5Yamz/XSgjr6zG9YYXn+hgNk6xT4i64qcZZKSlteew3W6X3N8dtYXqtcUGbLkTz3aOAYafIt982mCZX8/cORvCyTd87mE14pv0Og1Eo+fWDEfh+8YpfOxi4ZLtYrW9bpte0wScG0/+6Om7++DNKGuU87UmHLLGTSzNgn2/q9zhwUWM8OmwPbVXtX0mNXe019rfNSfOpbUN/V/h0q79zvv0W09mrLOu6ytUR/2jstLbYi4ndKhxnhh+/adfaZ4k8Yl03fXy9GJki9Sqv5QG5E9tCFMwmA7TOdPCYSbvcKeaVziFNusmd7eIWWz8IssY3MJUW35Dkar4QL5vtoex5w8YowjJNR7zJ+lwaaKUJm2dDGRF9m4ljkxt+QWiMHc0o3gQQfgtr7iPmX2CyJr993qGZrsGQBUmgmJ/adTVXgcF1l8vjUMSb1HdS/FFvJvkoV1CZPI88fN41p5GqsbxEfh5YH28pcUCD1zOTZy6OZJqOuCw+tMXc2soans161Rzpj93/Hb7PP/zZ9n+tszGQH3/sz+32x6Oef7TFsk4XU4L9+eoC1z3uSdlsj9BRp9Hv2a43/n4k5cnfZ7DgsOcOp+Y5Fnts7kQ1cplv2mx9TW+xIAvzr5Eohv2+vqI/WbNVe0DdzsZYbfHBdaLHvoyyti5Aq/3VNPwaKXvbj30vZ33cK75lenwUYLY0FlUAsNKWf40ydwPyznUX42XX3qZZqLRJ50cy+xz5dP5XdvE7333RbStv7tZWutKP8idxnu0GGXVqxcem6PV5prlyxj/ONOumA86WfB6ji8XV2r19CddslQyanz+v+udqK14uOtYrjNXtYvEvf1OjLMvQNJR2YOhvG17i/Bem4yRM+X4JSMFTx0Kux3vPYRyvCt723teWa+BKtk7yVd8ju6+D1j2F9Mbc7ySkGWVsPfCVTYhA30Nn+eoLXokRv8bW+5VDMgLjCElc3a3omF9d82t95z1cYI+Egd495uybFber45izor3iNc293D+y/pPF+XkHOmpiEqLr1rQ2Tcd7mWK5jP8p5Y0Yd5n+DcXzUUvqt3PVPuZkmUKR9NFXOlJVhGeXPNcq0U/D52p4Xc014HLu3pOmIQsrWKxt/N3cl9odsf7sYf+e9MBvM4GToaAyjGirzWnegpuBg7TYm/GMWvJZ0GRQd06MY89VS7AWHEp8nN3mj6Jtu9DbBKcZDVn0TWiHl8VCMgS7CxdxjhP7sVYMLADdZtMwl2+zUR7GZUY/i3HNsvgmZZ5J3mxp+svF7YdYVeGwNWEjloBctAXazPSyQRjf7Co0e4Sbme7JaSf3srmYng9NcAzydg686ZCQQpeZ81f8V9N3Np0RJ+ucYuw22WBXu81c+TJChwqK2DseR4GEnQeS428xBnv3fug7WHSNa1eiA0sKLLJOVUaITbwrri3WWgwBjVLMMe8vgvSzcj+TJgRktxN3NVOLh9Qhb0NketucgEGFV+ONWmKXuyT3DNadHNMReGztkDOCHmdvsFYV5nGoZS1NRIwhzLawSXLzDH/YfCwqAhHWIoi2nqMxJh1KCtQ8/zw5QcY03N6ZDTXhj5MOhiCrAgsCtCAFYNgSLQkTJ35cJoGufY2iSepk9Y76M1SdeFTqnMcimL57oE6le3GBCJbBygrYzLZRY2IoIpRbQWleuelamEAgdBgju2B7nVhZqbEpxizOqKnmBhIxP0C+6ETQPyzVBD9EcKkjABeoDmYUAb6GYgCFTaxbULFrjLmhSeamQ5o8x9cvvz/s9hML9ecdXLtQP7cVI4/dsA7pLCdKuW4CrvaQmQXmD5GZ+0uasuJeUxhyVU+FGv8aaxe1JKoGBF9oAPIgZYgHpXQFXVzwktGqAzWMPXtvExgody+O/+HmUu0h0/6LRIXqYZoraLyqwfs1/rFOEmI/GkbASfsU/gTCSbsuEVpMWRVMwvMnzAUgd/IpDLuxAHem9TBPac3SsmzDPIu+w6AzSW70YOrItGB4Hipiw6+pndQ8MAHahmHW2yJtndGWqV2wecBdtS2rI8As/cDR1ZUkagU7iP5KtBAmFO055AOtF3loCxbaDxYf2RwwEnXNSJfgs2EkNjwvQyr71dZmg8nRw8O2H3m1lK9OHBHnYxgO6bD04S2z5TEjWVdiMkukySIIAzERtx29OgVz6YdJ1icHQdxOHnxurOr3HgMj+6Cqj92Wpk8Butlt1EYcjgoIQoCeH50PMk4+ZNPj/RZMGwV8w1JzP7d0MwbOwr3gw0kr5G0R8cGzJCKnplVBZld/yGAuaiNMJi3z2RaENw7SY9S2ymYAYj9VhBkGB34FratBFW45GsBdAZOjKfbtZCJsYe7Lrt6NO56TF64JEMyZ73EnsYqNX5tM8/DgKpcjAWpzsyjNtusK8D60t3n3u1SykZM19q2mpKtapRCizDJD9CQWoi2j53PjyrsPYDLktQAC+FW9cyIGPOxCJpgfCmHCwzW4S2E47uRiYIuZ1Ib0hFGCEjy77cFH/MEVJ9yg/5u+YB0quA9r1vsoDFiKITKAFLAbeXXHfcRkeku6P8UaPI6xyHqNyYY3Yu6v6ojAvXCz2YAub9vA5qhskC9Q/cBUPNnJhqN8ggmMP2wLo5ULzoFZJdSIYPCr9XFINs+uXJj1BVRB2KruTGB3nBaFoXVyBMcSRCLh5vLZ6hF7rMb0DTlFw+Lpgh8p1Lhp9GRH0cRqCpBrUux2xvHVa1GgDkXHH7QYXRI82OuFBVEOJ5P1F+UYsZrnlzbLOvC6jxDzaSBRv8YcAWyHFMrfZ4/ZhaAIOURsU+ShREgcDT9GoIDvXZaa/yyix7jBxrpF6rFovj2h+SxPYhRUgSLZLn0X5xg1gCp1OHCKOUNliH8IcbnnROyjRDWxuJoIV1RNSsRqhV4ABYoZFtQ6KCpLVcnXUR3ZZ44dBCXmOLg6rLY432GCS/7dvPtdXV03/hel3T4CMDagCAd75kLQEImBSzC04I4ceR3mHzgpM2nqLKp9j6mJEkVk2A8GzAyLKEjx7NMN8XXN4ZR1CgoCxK+zO+Iy1dU9r2Ecw7DwFLpDR+YuUUNmWE+vRAuxZcdtteQp7x2Oh/DRJjQAOfW9vnpF5ceTRIwX9ETLERJVAll41gL6HiWJAVkMb6/LQwemPNm0xYdgNnOcHEYH3WErc2ckFceqjlR37+wAmo3hxoM7Jn3FGhLrwfRfp2A0KUZyTWouMdMIpyyhnzoc/5AuxIqglFKrvBuGR+/Oeq9A3nnPIpZhWSMXLNjL5v6799Ep0Jd0ie8KEdFBczOvV5zmgBpljkP0KA6WDikfFOsSF3vWxd6gZEDwZYhL5D+7Cbs7etngaKGf8/4tcsCooWcJAYFw065BF8+y6DQ97heGY44WOGgdsfXB08724MkaE2xj5sLZEMf0+QQGKb4vgndEReRxuT0gIBF/xGDE7iLgjrBXF/9J5GIPHhoJrzr0gw0pMJcNaB0Wjc23QxamG2RdfYh9RUZm8GWmlIfQK2aAs0SbWyHnGzfvyUQoSguIRc8MCzXfol4po/gZFTUW35PjBzih+npTQahOuvhC94UORHTzTqJwe9yjEy9Kp1P0cOXA/PsbJS/I69fwxyLpRUuFjpqEMOWqC8K4jM+K7PklZHp4kv6cgotR5NBNSvMwcAEolaBDHkElsmWroIlMENGqUfMRESfpl4oinNsQmzkSxG2nGvvYPMYeCum9wzlCMsI+OdKKWnORDUtCRVkRHkGAWQwbIOq9+AD764R3lxbKUDbZFwVHksJV8UaOpyWS30P5OFArcmNse/Z0ZDAxdRLZQ13/WpKxgG3l6SL93aswdGdI9a0MKvQYy0iMmOWH2NueTcYMrTF4Mi1xotsqj8wx0ImF5wWhjTU8O1ATgZcdTV5zqHW4D/MUOAw6EsEgRIiNNorlrMsAN0XsH4/4rX4t0/MtYPHSXek9IqjbmJ4Z7PMjLQORk78Phs8KqXtkMnfShzcZufnwnZhxGT0DXcXKQA8f/johMH6bBSccefqzvB8bZagj4Lj/XUuqgNIyID5q02OSl1jZkmUIiHGR/zAb2Gul4lzKGhGKtwGtvocy7JHZhDMZEKAzJevEM2p9nBNjiJccSbHGGVeCCGhA4qGHpIZGNZQszeyiYLgfRNcVsWwwxQTchMCeBkU9E72S4hGsB8NupsefvepuRCqgPdSWa9Q618vsL0WPBFjx4NfmvZ/zGQEL08X9LnGTqhv5fYAEZPHjF7n2bBBhdWJ06mrMangjUU3pq/VPODiLRDNY+knOgFlcWyM4YRmpHkIlHtLRnCp3GuM/WXoSELLckltzGmGveQMcZq7BzICGTsERXpRrahOl2svjmObyeIERabQq77A5HjplEvYEzx0rk+3MdRuAwPT1OjFt0vS4Idg2sygsl4hU7cZ1c9v8nEmBsc+rEWXtfQ1lYODRu5CiGTxk7k2VhLt7w1FhslWj+WWXApJIVZnSAwamv88XAlbDaKKPwNeAL2UHY11FZXh0fvbfjai2wIHEnlCfBvvKCDZJOvtl07t9q4nKwhQVLJyQwt8kQ7DYRpVZVAyehUUAhv3YO2M5S8SDRR1iPFZTtWlOFAUjmahD4j1a1+alNimXwLWbsBoox7V/gSTx0mVKJ+eRXJxdf8ek1+78Eb0dkeDQvUcvisLCBLREOa0l6HJSNFNk4eKmu8HfObGB/HGeq5j5FfCtsh7VbZXwlk1BHPkgKYSmPHzwXAff2fFwYeKm+MIQiXEBrc3hKiA/jtQi9TUqIh6R2IZyDM+iSmHNeQRw+9Oj0ki4kfB9ldt9p5QWsm2qCFzGPO+FtVLjJC1wbvuPwIN1hHmA4qBjt+EZ86ZgKLhCJkhRY9d1JDdP7pIzGdocl7+pbwnxtiTmmMbDcOstqmgU5nfar3rdFMgL5TzNbbygyctMOY/hebjF2d4moZckYuWcid1Din0KXl90Tl+rjTbR3J5SJ7NrAglOaWLbnT2tg6UwZ9M3TVKKeEhUoR0yOS/QgiMA7hRnXhNetrQ4VGZonQuXeEGTkB0j0e9KwbKSgol+rQlrD61ocTd6S8920Po3D/fioZIha9Fy+JHqMW1wNrOs1CHC60mxeYmWOBWsCDyefo1S0+TMB+wT8wOIrO7JmqhqLZYib/CdTaPeN9gxA6Ygne4qH6a+rCJmX4oo80oSm4fqABwYININvxEb7G/hPk3x4kaNvDK6ZYvLwSXVhB42D1ecOEJdaos/UpKZoHkVAcNDQpF5AHmX6+rhszXNCT9fS5IQ0bFzLfI31XBIgx+3Bo/2m1N5MKsSzq2QIbPpgVVK/oFvG0AXyIYkU6Xob9OZXl3geyL6m31/Kjf3u9JpGZiQdZfb6UwqA4MXFEaFx1SimuSAEN8PIiyMMGloVPd64Zi7vb6nVnc/kTb3VDYrMQ/lG9eT2nLJH+A56a2uMQ0aVh9I5Osi/EIR4eZx2P7XFgkJQLPNQ99XvAZbSy59V02V1UjaqHmJYNRcGG5eYFbB2P7sFC+HmcVmqHHCCiwmGOMVC1N6npEnyPLyZp5P2s6zS2O7SMB+8keUy8zDNu+jTBt3fJeQFlN7pQEajEvZDOJcuQ0V1lso66fdxKn77qHqIhNR2Jl51t1DJhj+jjUaTMPR0XQ2SS6cZ6AEL+pQcnj4WxUEbiAl6Wwy5LqqKeQBECobZ6deX6OhjoJCXIZ7HS9NJuFk2JBqdzYVKXx7jb2IgXMBipx37Iq0ad18ZwbeoFfVEKTDKp+UihizVXQ4pgwiiw3upeW+gbXPSHe3wSxkEVJMu7ZY/0A0ESMKnQmTsAmO8cOAWlS2qbXsFVg1RInJCo3BB91UB31O2STas3NptlbQpZ5wHoW852vE33XDSurNcY4cgyVbQmBqTiRIBcPw06yGoHnjTfb3tCnOow1dGhQYmtf34enRWWRjQe+xsaTzqWYwCjtNUGub8krOxHj0eyS3wixmpThQoPtJyyw/BqcnwouDkecdjb3O94z9Z6FjSlvTIsmOGjZbsynE7adFp5+2vxfhA1xe5uVh6/MRKINR7iWr8ddlKNmzi+QnOs8gbXr2Gnx5pJjKIXM8VHV44nGSXyexxHAhPOmjMWHHXQKEoyo0zs63FezyKlwIVlp912PYPUJApOBwWzHqlaF+x2ED/d25fl+TzmXsyekLoVub3BbZh60gOC67BI0DVgEw39857Id4yUaF3d9vWGLLEJCFGgSmRMIlmQ7u/o2yecFclg4lkTbAoLmaA2MEDA+we3ZAC+t29fbdoQ31Df0xP+ZUVsfdBnUBWvIuPIUqkQdCRgyJdODufZ4jlC1ZXvUq0aFRWtFfpzvLMJw9XCh5EwKSRBta/JG9v+wglZDSpqLIfhicNIdqOCe5Vg7dadcnaYEReO7kIL6dPbdDoGhPbsA+FEPUW2ZwpQgkan9W82Y4U5sOna2iKAw/zsJgLf64qzr3/Sej1K9P16Mw8ET/WbYV14IVm3avYI/5dUITP41BSj/oHfNmSni4S4LTQVQdLIw48hBgP8FpRIfICvEP3S+Gq1kirIRdH2EfJqEb5xsYBftYd1y5igQpkynufo8JjeboITyEJLQIKmPfs2yEXOR04FlTcQZB/IiUalAB/eCWi6dTwIFOzeRbbknmMSso7mY6JS4lBQeyN2zsDdUNf8OXMwNC9eDYa7P6qzpJ4IuUCzboBB2gKMf3MT9JMNSwTaNzCPaQjtkxpyTOXofPeK6yh47OK8nfeFcoltnnFzlhT5C/qtvtHmHehe+bXljYBQMyLhQHC9HpHkXQo21OWoacAoCbFqc770j+mGisb8ZHcRpx0jYT4gNeCTtqLyJ3eMHoomQgPpR2bI1am4TMfuYPDhtwrw6ch7v8SF4VtkMrxSY/91kgi+PrxmVEPB+z77tKzLZI0E8/FrDK6QqpQNeJ66epTAw3doGpwmvT9q4yJCm2XmRCjSmXXqBq6srwuC8TQffNBxYhTEPG1W0wjUXQSVMlPKe4LYp7Fqr7yq9EgWD+sSs10s53UriZMYpeEbyTpke0yTy74FmGEegIFq5zO1s7/eAO2WYEavn5MV77zMJFLefp0JEw7tRb5dpj58QsfKvNMFlhaiEIKFDFvjRD3ityNp9IHxTXKNmi9CkKwK6XvDAYpoT50A4ajvMYaJM9dHy7QXa4ZaOGsXlQsep8PT0Kd+qRCG4QrBqMOzyMeLJJKmmF+JSY1OF39TYZI67OPVsYzv0oSjuvN/Rys6ARfDq5UtYQzt1mT8z3u0cVXrD4cIT1lMIjSSLsW8ecBdr15LRDnZGRu2HcmuWsyXMnnerl0Z00I3AmYAD7eRBwFqKMNJ+f/caSn5ebDA0j9Jhlq8ks+6p8J5ahRsDMIyEROs/phuOV9tRuatB6EJI18xMI5RiCRQKCfv4OfHiIyLjaHFvRzz7URnMtW4cr2kWDx+coIjXvP/f9N0w8mYLEBbBt5BQoL+Ic+zqD+e7EhHMXUT1OMy/6wNmU839HRbqaJQN+EkIDpRjl5qkbj/oBJFEJ+v5btQqKb2PWCsDqGbJRS95HDiokH9Q3j2q9Ftpj06COB+5QWFWv1y31lhIYxU2g4K05lScVz3HAD7oYe0Zr0rwEC0ZZE6JvCVUdIWEGoH2LBrtbqpu+rUlNI+UOdElpCaKgJXuepIMVquTiXZY31QsexIQQDFgLX4Y5u8l9HkPx/LqkCGo+jZKZFhUW7A/ftYXPgXxm4ZFtym54eLJ+JHX671NERg/+pQAmY6UKAqWSzj0tQohxytA46QW6CqSEIt9xzM8c9sAMz0IPE2Gyv+GZfGZq3uscZzP3Julnqjr8lLJOx9VJF5ue667f7JwjMn7oZft89RbZv0XCTOb5xi9XKOt/6CB2Lxgeb3r/bO9//PndGCa5Av5BHCllufykwxtOOr/nBwbue3jlPscryufvONz7yvWLj5ZsOib9/kX66K9GSSLYhSW+9ZWVl4t6pw9QxDHck/D1roT/4OGdJY6FRstDZ1/JOCQ/buJ1qvr+CRvju9flM59OutMRo5HmmA2Tjzm8z7PB12Nmi+GuvzqrNV+581VyHN9wlTHg/WdB+SZkWeUmSrBFlS26w4Wv/KQZ+JHBfk5EJ0O9pOSuxhWFiVqz5MWYcq5903XluA5B6bEkrMX55K5L4woi+bUvGSkSMD/telKxKLzsJZ0Db14Kc5EubvT8+nCXLb4wDP4tlEhfJ9DBrxl8LwcP3op46yEFLzTBctUDe9hkPyIZD/mAin5FOH2ssMRe0nfiN8E2+eOiYDhdvEg/ZqQfVOb4PSO77D1Jg5AgSWvyxylO5cPfyZTvmZbp9p3IjS8IbFLjqCg6tRVWO/2dUnLjTYpwjjEOz1o00nQhNCIcW+OEeDn445olxV5YHIleNokNRAPrx3iX9urc/WdiDEltJzVXU6dKZ8tkvJ0FPsEXL84/13PPy1AU15jT0hIoY73+7vTRwhc25nqBZ/PyMWq8rfmgzsiwfDdp0DcuL2ylVyCdm1NiajrkDTXZW/VCctQfVlX1UeZ8lWNvUBSO3RJvqblXXoLCiX8pcx4+8BbmsWWZKfKOTZ3u4B+EWWxiKifP6JKioiyHG/DNtPgN13R8DeG1X1/R/iiOFn8bmeII++7UxHWT03/0u+dNX7RevUjsBLWDvmLZ30OuX7naWzIlw6c/0RIo0edyfxG9PmJOxBF/h1XxtIR6l7+rJUTw5kij/YQBVBMhFh/IedtPHYCLcYV9UDKpqaTJvjThxRi7tJEkAPqVNpLOyVeg3iCIHrADPyVzpmrrhBH3/QWsXPN9XsHsK06vrNCnZvMryPxi7mui2Beo1s8gW9PhfQXB7jnmK+57BZLSU8IausEpQVLywsNXtOKAvK+caluTkGdtC1rEu4+cE8mxvMTquq3NJWJSO0V22vxcQ1/R95fw6tuG96tY9k0Y9MWi/rSqPjTm/09W1S0N+hDxpRuDvzSe8Na+3ni6MSpC5Ymxs9tF5jTbiTLg9ZrPBy1FtUhCcR3InFWI6o6M5DoQ6y3lPdYrwmsKXgpwcio0R6yzBc7Y5ECzjHJfT/4nED+B+N5AfCNIQzFEzr7+zrD8obC/0uqXebpvInticmiTtiy/4tqffc10YpNRLqUTrclIqeBVfxzVeiIWhru6J4kfZ1lQohbZSdFDMSTQiXbRLc+k5rVC0I/vso4ku47Lf8RuR140PpjOln89rvkr1u57GZF9ZUGU42iDfyorVT7Ph1KN5phRI8NxALoX8ATecY7NseYqd80XL9OCifHl6GsmjBy1SDez/JaEYooQlaVt+SwP3nfZPsSCj2GIvGuUl7UnL4q/0prZ87eW8BoTrsoFf3V869k8mzs3TxZ+Ng/ePFn42Tx482ThZ/PgzZOFn82DN08WfjYP3jxZ+Nk8ePNk4Wfz4M2ThZ/NgzdPFn42D948WfjZPHjzZOFn8+DNk4WfzYM3TxZ+Ng/ePFn42Tx482ThZ/PgzZOFn82DN08WfjYP3jxZ+Nk8ePNk4Wfz4M1fgYXve+L/5R7kF8fz918PLu3FZ2OD+n0+CGT7bY1a9/tiyE/OJr2x9fTVsysXuUnPW78++VOO/NSzPtMhn1U6+/mxnvPVafb8sXyAIumQXo5h+f4TiXU2F4eR/lUX7nMn0TDnhz0I6KjCiPc4D4guyxW182b165PWlukFh11u1f/Cg/Y41ai+C9FvIamqoyzm3rmC87lay8Vvn2y063TMQ4lXc70aYZne+cImaof3Xn0T6ifDjlrks4NRgJl+h8FcflXk2wbTYvPrByOvv/syZcPrFNt86Mo11P7ky2/SRR3G5EvJQ9nKkSKHnqZmR4CI5rbv2dofTWGaClqFUKt8CGWb5DftWvuUT4yteor6FO/UkenarfJaHpA7gVfrepUHpDMdvEovdwqwpM+k6aSb3NkubjEEXEVpcvjMKr0outX4OF3L0Vmvfr/w1mk06YyxN+oSUWmqS+YtNnwj+YjELvP/AVKsNoA="];
Export[ExamplesDir[]<>"test_import.pdf",bin,"Binary"]
]//ShowExample
Ma8ImportRules={JoinedCurve[_,{pts_List},_]:>Line[pts],JoinedCurve[_,ptsets_,_]:>Line/@ptsets};
Ma9ImportRules=Ma8ImportRules;
Ma10ImportRules=Ma9ImportRules;
Ma11ImportRules=Ma9ImportRules;
Ma12ImportRules=Ma9ImportRules;
LineArtImportRules=Ma12ImportRules;
Module[{pdf,converted},
pdf=Import[ExamplesDir[]<>"test_import.pdf"][[1]];
Print[pdf];
Print["original pdf = ",InputForm[pdf]];
converted=pdf/.LineArtImportRules;
Print[converted];
Print["converted pdf = ",InputForm[converted]]
]//ShowExample
FractureLines[obj_]:=obj/.Line[x_]:>Line/@Drop[Transpose[{x,RotateLeft[x]}],-1]
FractureLines[{Line[{a,b,c}],Line[{d,e,f,d}]}]//ShowExample
ExtractFracturedLines[obj_]:=Flatten[Cases[FractureLines[obj],_Line,\[Infinity]]]
ExtractFracturedLines[{Style[Line[{a,b,c}],Red],Style[Line[{d,e,f,d}],Green]}]//ShowExample
FractureStyles[obj_]:=obj/.Style[x_List,y___]:>(Style[#,y]&/@Flatten[x])
FractureStyles[{
Style[{Line[{0,0},{1,0}],Line[{{1,0},{1,1}}]},Red],
Style[{Line[{1,0},{2,0}],Line[{{2,0},{2,1}}]},Green]
}]//ShowExample
FractureLinesAndStyles[obj_]:=FractureStyles[FractureLines[obj]]
ExtractFracturedStyledLines[obj_]:=Module[{fobj},
fobj=FractureLinesAndStyles[obj];
Cases[fobj,Style[x_Line,y___],\[Infinity]]]
ExtractFracturedStyledLines[{
Style[{Line[{{0,0},{1,0},{.5,.5}}],Line[{{1,0},{1,1},{.5,.5}}]},Red],
Style[{Polygon[{0,0},{1,0}],Polygon[{{1,0},{1,1}}]},Blue],
Style[{Line[{1,0},{2,0}],Line[{{2,0},{2,1}}]},Green]
}]//ShowExample
ShowSample::usage="ShowSample is an option to ExtractStyleArgs that displays an example of each style found.";
MagnifySample::usage="MagnifySample is an option to ExtractStyleArgs that multiplies thickness and dashing by a factor of 10.";
StyleObjectSample::usage="StyleObjectSample specifies the sample graphics elements for ExtractStyleArgs.";
Options[ExtractStyleArgs]={
ShowSample->False,
MagnifySample->True,
StyleObjectSample->{Line[{{0,0},{1,.1}}],Point[{1,0}]}
};
ExtractStyleArgs[obj_,opts___]:=Module[{ss,ms,sos,sta,styleargs},
ss=ShowSample/.{opts}/.Options[ExtractStyleArgs];
ms=MagnifySample/.{opts}/.Options[ExtractStyleArgs];
sos=StyleObjectSample/.{opts}/.Options[ExtractStyleArgs];
styleargs=DeleteDuplicates[Cases[obj,Style[_,style___]:>{style},\[Infinity]]];
If[ss,
Do[
sta=styleargs[[i]];
If[ms,
sta=sta/.{
Thickness[t_]:>Thickness[10t],
AbsoluteThickness[t_]:>AbsoluteThickness[10t],
Dashing[d_]:>Dashing[10d],
AbsoluteDashing[d_]:>AbsoluteDashing[10d],
PointSize[t_]:>PointSize[10 t],
AbsolutePointSize[t_]:>AbsolutePointSize[10 t]};
If[!ContainsAny[Head/@sta,{Thickness,AbsoluteThickness}],AppendTo[sta,AbsoluteThickness[10]]];
If[!ContainsAny[Head/@sta,{PointSize,AbsolutePointSize}],AppendTo[sta,AbsolutePointSize[10]]]];
Print[{Graphics[Style[sos,sta]],styleargs[[i]]}]
,{i,Length[styleargs]}]];
styleargs
]
Module[{obj},
obj=Graphics[{
Style[Line[{{0,0},{1,0}}],Red],
Style[Line[{{0,.2},{1,.2}}],Red],
Style[Line[{{0,.4},{1,.4}}],Green,Thickness[.01]],
Style[Line[{{0,.6},{1,.6}}],Blue,AbsoluteThickness[2]],
{}}];
Print[obj];
ExtractStyleArgs[obj,ShowSample->True]
]//ShowExample
ReplaceStyleArgs[obj_,oldstyleargs_,newstyleargs_]:=obj/.Style[xobj_,style___]:>Style[xobj,{style}/.Thread[Rule[oldstyleargs,newstyleargs]]]
InvisibleSphere[p_List,r_:1]:=Style[Sphere[p,r],Opacity[0]]
InvisibleCube[p_List,r_:1]:=Style[#,PointSize[0]]&/@Table[Point[p+{i,j,k}],{i,-1,1,2},{j,-1,1,2},{k,-1,1,2}]
InvisibleCube[{1,1,1},1]//ShowExample
DynamicModule[{},
Manipulate[
Graphics3D[{
InvisibleCube[{1,1,1},1.3],
Style[Sphere[{x,y,z},0.1],Red],
{}},Axes->True,Boxed->True],
{{x,1},0,2},{{y,1},0,2},{{z,1},0,2}]
]//ShowExample
LabelPt[lbl_,p_,r_:1.5]:=
If[Mag[p]==0 ||Length[p]!=2,
Text[lbl,p,{-r,0}],
(* else *)
Text[lbl,p,r NormalizeReal[p]]
]
Module[{p0,p1,p2,p3,p4},
p0={0,0};p1={-1,-1};p2={1,-1};p3={1,1};p4={-1,1};
Graphics[{AbsolutePointSize[5],Gray,Point/@{p0,p1,p2,p3,p4},Black,
LabelPt["p0",p0],LabelPt["p1",p1],LabelPt["p2",p2],LabelPt["p3",p3],LabelPt["p4",p4]}]]//ShowExample
Module[{p0,p1,p2,p3,p4},
p0={0,0,0};p1={-1,-1,-1};p2={1,-1,-1};p3={1,1,1};p4={-1,1,1};
Graphics3D[{AbsolutePointSize[5],Gray,Point/@{p0,p1,p2,p3,p4},Black,
LabelPt["p0",p0],LabelPt["p1",p1],LabelPt["p2",p2],LabelPt["p3",p3],LabelPt["p4",p4]}]]//ShowExample
LabelPtStr[pstr_, r_:1.5]:=LabelPt[pstr,ToExpression[pstr],r]
Module[{p,pstr},
pstr=ToString[p];Print[pstr];
p={1.0,0};
Graphics[{AbsolutePointSize[5],Gray,Point[p],Black,LabelPtStr[pstr]}]]//ShowExample
LabelAngleAtBase[lbl_,q1_,q2_,q3_,r_:2]:=
Module[{f2=ArcTan@@(q2-q1),f3=ArcTan@@(q3-q1),fa},
fa=f2+Mod[f3-f2,2\[Pi]]/2;
Text[lbl,q1,-r{Cos[fa],Sin[fa]}]]
Show[Graphics[{Gray,Line[{#[[1]],#[[2]]}],Line[{#[[1]],#[[3]]}],Black,LabelAngleAtBase["\[Alpha]",#[[1]],#[[2]],#[[3]],2]}]]&@{{0,0},{1.,.5},{.5,1.}}//ShowExample
EndArrow[start_, finish_]:={Arrowheads[Medium],Arrow[{start,finish}]}
Graphics[{EndArrow[{0,0.5},{1,0}]}]//ShowExample
MidArrow[start_,finish_]:=With[{mid=.45 start + .55 finish},{Arrowheads[Medium],Arrow[{start,mid}],Line[{mid,finish}]}]
Graphics[{MidArrow[{0,0.5},{1,0}]}]//ShowExample
TextArrow[text_,start_,finish_,offset___]:={Text[text,start,offset],Arrowheads[Medium],Arrow[{start,finish}]}
Graphics[{TextArrow["foo",{0,0.5},{1,0}]}]//ShowExample
ArcArrow[ctr_,r_,{q1_,q2_}] :={Circle[ctr,r,{q1,q2}],Arrow[Join[ctr+r{Cos[#],Sin[#]}&/@{q2-.01(q2-q1),q2}]]}
Graphics[{Point[{0,0}],ArcArrow[{0,0},.9,{0,45\[Degree]}]}]//ShowExample
ArrowPosition::usage="ArrowPosition is an option to DirectedEdgeArrow that specifies where along the arrow the arrowhead should be placed.";
ArrowheadStyle::usage="ArrowheadStyle is an option to DirectedEdgeArrow that specifies the style to be used for arrowheads.";
Options[DirectedEdgeArrow]:={
ArrowPosition->0.667,
ArrowheadStyle->Arrowheads[Automatic]
};
DirectedEdgeArrow[{p1_,p2_}, opts___]:=Module[{ap,ahs,r},
ap=ArrowPosition/.{opts}/.Options[DirectedEdgeArrow];
ahs=ArrowheadStyle/.{opts}/.Options[DirectedEdgeArrow];
r=p1+ap(p2-p1);
{Line[{r,p2}],ahs,Arrow[{p1,r}]}]
Graphics[DirectedEdgeArrow[{{0,0},{1,.5}}]]//ShowExample
Graphics[DirectedEdgeArrow[{{0,0},{1,.5}},ArrowheadStyle->Arrowheads[Large]]]//ShowExample
DirectedEdgeArrow3D[{p1_,p2_}, opts___]:=Module[{ap,ahs,r},
ap=ArrowPosition/.{opts}/.Options[DirectedEdgeArrow];
ahs=ArrowheadStyle/.{opts}/.Options[DirectedEdgeArrow];
r=p1+ap(p2-p1);
{Tube[{p1,p2}],ahs,Arrow[Tube[{p1,r}]]}]
Graphics3D[DirectedEdgeArrow3D[{{0,0,0},{1,.5,0}}],Lighting->Automatic]//ShowExample
Options[CrossedEdgeArrow]:={
ArrowPosition->0.5,
ArrowheadStyle->Arrowheads[Automatic]
};
CrossedEdgeArrow[{p1_,p2_}, opts___]:=Module[{ap,ahs,r,rt},
ap=ArrowPosition/.{opts}/.Options[CrossedEdgeArrow];
ahs=ArrowheadStyle/.{opts}/.Options[CrossedEdgeArrow];
r=p1+ap(p2-p1);
rt=r+10^-6 Rotate90[p2-p1];
{Line[{p1,p2}],ahs,Arrow[{rt,r}]}]
Graphics[CrossedEdgeArrow[{{0,0},{1,.5}}]]//ShowExample
Graphics[CrossedEdgeArrow[{{0,0},{1,.5}},ArrowheadStyle->Arrowheads[Large]]]//ShowExample
VertexLetter::usage="VertexLetter is an option to StdVertexLabels that specifies the letter used to label vertices.";
Options[StdVertexLabels]={
VertexLetter->"v"
};
StdVertexLabels[verts_List,opts___]:=Module[{vl},
vl=VertexLetter/.{opts}/.Options[StdVertexLabels];
Table[{Point[verts[[i]]],LabelPt[Subscript[vl, i],verts[[i]]]},{i,Length[verts]}]
]
Module[{},
Graphics[StdVertexLabels[{{0,0},{1,0},{1,.5}},VertexLetter->"V"]]
]//ShowExample
EdgeLetter::usage="EdgeLetter is an option to StdEdgeLabels that specifies the letter used to label edges.";
Options[StdEdgeLabels]={
EdgeLetter->"e"
};
StdEdgeLabels[verts_List,edges_List,opts___]:=Module[{el,mp},
el=EdgeLetter/.{opts}/.Options[StdEdgeLabels];
mp=(Plus@@verts[[#]]/2&)/@edges;
Table[LabelPt[Subscript[el, i],mp[[i]]],{i,Length[edges]}]]
Module[{verts,edges},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
Graphics[{Line[verts[[#]]]&/@edges,StdEdgeLabels[verts,edges,EdgeLetter->"E"]}]
]//ShowExample
FaceLetter::usage="FaceLetter is an option to StdPolyLables that specifies the letter used to label polygons.";
Options[StdFaceLabels]={
FaceLetter->"f"
};
StdFaceLabels[verts_List,polys_List,opts___]:=Module[{pl,mp},
pl=FaceLetter/.{opts}/.Options[StdFaceLabels];
mp=(Plus@@verts[[#]]/Length[#]&)/@polys;
Table[LabelPt[Subscript[pl, i],mp[[i]]],{i,Length[polys]}]]
Module[{verts,edges,polys},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
polys={{1,2,3},{3,4,1}};Graphics[{Line[AppendFirst[verts[[#]]]]&/@polys,StdFaceLabels[verts,polys,FaceLetter->"P"]}]
]//ShowExample
EdgeLines[verts_List,edges_List,opts___]:=Line[verts[[#]]]&/@edges
With[{verts={{0,0},{1,0},{1,.5},{0,.5}},edges={{1,2},{2,3},{3,4},{4,1},{1,3}}},Show[Graphics[EdgeLines[verts,edges]]]]//ShowExample
DirectedEdgeLines[verts_List,edges_List,opts___]:=DirectedEdgeArrow[verts[[#]],opts]&/@edges
With[{verts={{0,0},{1,0},{1,.5},{0,.5}},edges={{1,2},{2,3},{3,4},{4,1},{1,3}}},Show[Graphics[DirectedEdgeLines[verts,edges]]]]//ShowExample
With[{verts={{0,0},{1,0},{1,.5},{0,.5}},edges={{1,2},{2,3},{3,4},{4,1},{1,3}}},Show[Graphics[DirectedEdgeLines[verts,edges,ArrowheadStyle->Arrowheads[Large]]]]]//ShowExample
DirectedEdgeLines3D[verts3d_List,edges_List,opts___]:=DirectedEdgeArrow3D[verts3d[[#]],opts]&/@edges
With[{verts={{0,0,0},{1,0,0},{1,.5,0},{0,.5,0}},edges={{1,2},{2,3},{3,4},{4,1},{1,3}}},Show[Graphics3D[DirectedEdgeLines3D[verts,edges],Lighting->Automatic]]]//ShowExample
ShrinkPoly[verts_List,r_]:=Module[{ct},
ct=(Plus@@verts)/Length[verts];
r #+(1-r)ct&/@verts]
Module[{verts,newverts},
verts={{0,0},{2,0},{2,1},{0,1}};
newverts=ShrinkPoly[verts,0.85];
Graphics[{
Style[Line[AppendFirst[verts]],Black],
Style[Line[AppendFirst[newverts]],Green]}]]//ShowExample
InsetPoly[verts_List,h_]:=Module[{elines,insets,ilines},
elines=Transpose[{verts,RotateLeft[verts]}];(* lines for each of the edges *)
insets=-h Rotate90[NormalizeReal[Subtract@@#]]&/@elines;(* inset vectors for each line *)
ilines=MapThread[{#1+#2[[1]],#1+#2[[2]]}&,{insets,elines}];
MapThread[LineInt2D1[First[#1],Last[#1],First[#2],Last[#2]]&,{ilines,RotateRight[ilines]}]]
Module[{verts,newverts},
verts={{0,0},{2,0},{2,1},{0,1}};
newverts=InsetPoly[verts,0.1];
Graphics[{
Style[Line[AppendFirst[verts]],Black],
Style[Point/@verts,PointSize[.01]],
Style[Line[AppendFirst[newverts]],Green],
Style[Point/@newverts,PointSize[.01],Darker[Green]]}]
]//ShowExample
InsetPoly::badlist="Vertex list `1` and inset list `2` must have the same length.";
InsetPoly[verts_List,hlist_List]:=Module[{elines,insets,ilines},
If[Length[verts]!=Length[hlist],Message[InsetPoly::badlist,verts,hlist];Abort[]];
elines=Transpose[{verts,RotateLeft[verts]}];(* lines for each of the edges *)
insets=-hlist (Rotate90[NormalizeReal[Subtract@@#]]&/@elines);(* inset vectors for each line *)
ilines=MapThread[{#1+#2[[1]],#1+#2[[2]]}&,{insets,elines}];
MapThread[LineInt2D1[First[#1],Last[#1],First[#2],Last[#2]]&,{ilines,RotateRight[ilines]}]]
Module[{verts,newverts},
verts={{0,0},{2,0},{2,1},{0,1}};
newverts=InsetPoly[verts,{.1,.2,.3,.4}];
Graphics[{
Style[Line[AppendFirst[verts]],Black],
Style[Point/@verts,PointSize[.01]],
Style[Line[AppendFirst[newverts]],Green],
Style[Point/@newverts,PointSize[.01],Darker[Green]]}]
]//ShowExample
Module[{verts,newverts},
verts={{0,0},{1,.1},{2,0},{2,1},{1,.5},{0,1}};
newverts=InsetPoly[verts,{.05,.1,.15,.2,.25,.3}];
Graphics[{
Style[Line[AppendFirst[verts]],Black],
Style[Point/@verts,PointSize[.01]],
Style[Line[AppendFirst[newverts]],Green],
Style[Point/@newverts,PointSize[.01],Darker[Green]]}]
]//ShowExample
Shrinkage::usage="Shrinkage is an option to PolyLine that describes how much smaller the polygon should be than its vertices.";
Options[PolyLines]={
Shrinkage->0.8
};
PolyLines[verts_List,polys_List,opts___]:=Module[{sh},
sh=Shrinkage/.{opts}/.Options[PolyLines];
Line[AppendFirst[ShrinkPoly[verts[[#]],sh]]]&/@polys
]
Module[{verts,polys},
verts={{0,0},{1,0},{1,1},{0,1}};
polys={{1,2,3,4}};
Graphics[{Point/@verts,PolyLines[verts,polys]}]]
FaceLabels::usage="FaceLabels is an option to GenericGraphGraphics that specifies labels on the faces of a graph.";
DirectedEdges::usage="DirectedEdges is an option to GenericGraphGraphics that displays arrows on the edges of a graph.";
VertexColor::usage="VertexColor is an option to GenericGraphGraphics that specifies the color or colors to use for vertices and their labels.";
EdgeColor::usage="EdgeColor is an option to GenericGraphGraphics that specifies the color or colors to use for edges and their labels.";
FaceColor::usage="FaceColor is an option to GenericGraphGraphics that specifies the color or colors to use for faces and their labels.";
FaceColoring::usage = "FaceColoring is an option to GenericGraphGraphics that colors the faces depending on whether each entry in the list is +1 or -1.";
Options[GenericGraphGraphics]={
VertexLabels->Automatic,
EdgeLabels->Automatic,
FaceLabels->Automatic,
DirectedEdges->False,
VertexColor->DarkGray,
EdgeColor->Red,
FaceColor->Green,
FaceColoring->None
};
GenericGraphGraphics[verts_List,edges_List,faces_:{},opts___]:=Module[{vl,el,fl,de,vc,ec,fc,fcng,hf,gg},
vl=VertexLabels/.{opts}/.Options[GenericGraphGraphics];
el=EdgeLabels/.{opts}/.Options[GenericGraphGraphics];
fl=FaceLabels/.{opts}/.Options[GenericGraphGraphics];
de=DirectedEdges/.{opts}/.Options[GenericGraphGraphics];
vc=VertexColor/.{opts}/.Options[GenericGraphGraphics];
ec=EdgeColor/.{opts}/.Options[GenericGraphGraphics];
fc=FaceColor/.{opts}/.Options[GenericGraphGraphics];
fcng=FaceColoring/.{opts}/.Options[GenericGraphGraphics];
hf = !(faces === {});
If[!ListQ[vc],vc=Table[vc,{Length[verts]}]];
If[!ListQ[ec],ec=Table[ec,{Length[edges]}]];
If[!ListQ[fc],fc=Table[fc,{Length[faces]}]];
gg = {};
If[hf,
If[!(fcng===None),
AppendTo[gg,MapThread[Style[Polygon[verts[[#1]]],Lighter[fc,.9-.05#2]]&,{faces,fcng}]]];
AppendTo[gg,MapThread[Style,{PolyLines[verts,faces],fc}]]];
AppendTo[gg,MapThread[Style[#1,#2]&,{If[de,DirectedEdgeLines,EdgeLines][verts,edges],ec}]];
If[hf&&!(fl===None),
AppendTo[gg,MapThread[Style,{If[fl===Automatic,StdFaceLabels[verts,faces],fl],Darker/@fc}]]];
If[!(el===None),
AppendTo[gg,MapThread[Style,{If[el===Automatic,StdEdgeLabels[verts,edges],el],Darker/@ec}]]];
If[!(vl===None),AppendTo[gg,MapThread[Style,{If[vl===Automatic,StdVertexLabels[verts],vl],Darker/@vc,Table[AbsolutePointSize[4],{Length[verts]}]}]]];
Graphics[gg,FilterRules[{opts},Options[Graphics]]]]
Module[{verts,edges},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
GenericGraphGraphics[verts,edges,{},DirectedEdges->True,PlotLabel->"GenericGraphGraphics"]
]//ShowExample
Module[{verts,edges,faces,ec,fc},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
faces={{1,2,3},{3,4,1}};
ec={Magenta,Brown,Orange,Gray,Purple};
fc={-1,+1};
GenericGraphGraphics[verts,edges,faces,FaceColoring->fc,EdgeLabels->None,EdgeColor->ec]
]//ShowExample
GenericGraphGraphics3D[verts_List,edges_List,faces_:{},opts___]:=Graphics3D@@GenericGraphGraphics[verts,edges,faces,opts]
Module[{verts,edges},
verts={{0,0,0},{1,0,0},{1,.5,0},{0,.5,0}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
GenericGraphGraphics3D[verts,edges,{},DirectedEdges->True,PlotLabel->"GenericGraphGraphics3D"]
]//ShowExample
Module[{verts,edges,faces,fc},
verts={{0,0,0},{1,0,0},{1,.5,0},{0,.5,0}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
faces={{1,2,3},{3,4,1}};
fc={-1,+1};
GenericGraphGraphics3D[verts,edges,faces,FaceColoring->fc,EdgeLabels->None,EdgeColor->Blue]
]//ShowExample
FaceShrinkage::usage="FaceShrinkage is an option to FaceShrink that specifies the relative amount by which vertices are pulled toward the centroids of their surrounding faces.";
Options[FaceShrink]={
FaceShrinkage->0.1 (* this is a good all-around value *)
};
FaceShrink[verts_List,faces_List,opts___]:=Module[{fs,vfi,ctrs,pulls},
fs=FaceShrinkage/.{opts}/.Options[FaceShrink];
(* create centroids of all faces *)
ctrs=Plus@@verts[[#]]/Length[#]&/@faces;
(* create a list of faces incident to the vertices (no particular order) *)
vfi=Table[{},{Length[verts]}];
Do[AppendTo[vfi[[#]],i]&/@faces[[i]],{i,Length[faces]}];
(* create centroid of pull for each vertex; empty list for orphan vertices. *)
pulls=If[ListEmptyQ[#],{},Plus@@ctrs[[#]]/Length[#]]&/@vfi;
(* pull vertices (no pull for orphan vertices *)
MapThread[If[#1==={},#2,fs #1+(1-fs)#2]&,{pulls,verts}]]
Module[{verts,edges,faces,cverts},
verts={{0,0},{1,0},{2,0},{0,1},{1,1},{2,1},{0,2},{1,2},{1,2},{2,2}};
edges={{1,2},{2,3},{1,4},{2,5},{3,6},{4,5},{5,6},{4,7},{5,8},{5,9},{6,10},{7,8},{9,10}};
faces={{1,2,5,4},{2,3,6,5},{4,5,8,7},{5,6,10,9}};
cverts=FaceShrink[verts,faces,FaceShrinkage->0.2];
GraphicsRow[{
GenericGraphGraphics[verts,edges,faces],
GenericGraphGraphics[cverts,edges,faces]}]
]//ShowExample
TObj::usage="TObj is the Head of all Tessellatica objects.";
GetAllRules[TObj[args_List]]:=args;
Module[{tobj},
tobj=TObj[{A->1,B->2}];
GetAllRules[tobj]
]//ShowExample
GetAllProperties[TObj[args_List]]:=First/@args
Module[{tobj},
tobj=TObj[{A->1,B->2,C->4}];
GetAllProperties[tobj]
]//ShowExample
ReplacePropertyIn[tobj_TObj,rule_Rule]:=Module[{pos},
pos=Flatten[Position[tobj[[1]],First[rule]->_,1]];
If[Length[pos]!=0,TObj[ReplacePart[tobj[[1]],pos[[1]]->rule]],tobj]
]
Module[{tobj,tobj1},
tobj=TObj[{A->1,B->2,C->3}];
tobj1=ReplacePropertyIn[tobj,A->4];
GetAllRules[tobj1]
]//ShowExample
Module[{tobj,tobj1},
tobj=TObj[{A->1,B->2,C->3,D->TObj[{A->1}]}];
tobj1=ReplacePropertyIn[tobj,A->4];
InputForm[tobj1]
]//ShowExample
ReplaceProperty[rule_Rule]:=ReplacePropertyIn[#,rule]&
ReplacePropertiesIn[tobj_TObj,rules_List]:= Module[{tobj1},
tobj1=tobj;
(tobj1=ReplacePropertyIn[tobj1,#])&/@rules;
tobj1]
Module[{tobj,tobj1},
tobj=TObj[{A->1,B->2,C->3}];
tobj1=ReplacePropertiesIn[tobj,{C->4,D->5}];
GetAllRules[tobj1]
]//ShowExample
ReplaceProperties[rules_List]:=ReplacePropertiesIn[#,rules]&
AddPropertyTo[tobj_TObj, rule_Rule]:=If[MemberQ[GetAllProperties[tobj],First[rule]],ReplacePropertyIn[tobj,rule],
TObj[Append[GetAllRules[tobj],rule]]]
Module[{tobj,tobj1},
tobj=TObj[{A->1,B->2,C->3}];
tobj1=AddPropertyTo[tobj,C->4];
GetAllRules[tobj1]
]//ShowExample
Module[{tobj,tobj1},
tobj=TObj[{A->1,B->2,C->3}];
tobj1=AddPropertyTo[tobj,D->5];
GetAllRules[tobj1]
]//ShowExample
AddProperty[rule_Rule]:=AddPropertyTo[#,rule]&
AddPropertiesTo[tobj_TObj, rules_List]:=Module[{tobj1},
tobj1=tobj;
(tobj1 = AddPropertyTo[tobj1,#])&/@rules;
tobj1]
Module[{tobj,tobj1},
tobj=TObj[{A->1,B->2,C->3}];
tobj1=AddPropertiesTo[tobj,{B->4,D->5,E->6}];
GetAllRules[tobj1]
]//ShowExample
AddProperties[rules_List]:=AddPropertiesTo[#,rules]&
HasPropertyQ[tobj_TObj, property_Symbol]:=MemberQ[GetAllProperties[tobj],property]
Module[{tobj},
tobj=TObj[{A->1,B->2}];
Print["HasPropertyQ[tobj,A]: ",HasPropertyQ[tobj,A]];
Print["HasPropertyQ[tobj,C]: ",HasPropertyQ[tobj,C]];
GetAllRules[tobj]
]//ShowExample
AssertProperty::missing = "`1` is missing required property `2`.";
AssertProperty[tobj_TObj, property_Symbol]:=If[!MemberQ[GetAllProperties[tobj],property],Message[AssertProperty::missing,tobj,property];Abort[]]
Module[{tobj},
tobj=TObj[{A->1,B->2}];
AssertProperty[tobj,A]
]//ShowExample
Module[{tobj},
tobj=TObj[{A->1,B->2}];
AssertProperty[tobj,C]
]//ShowErrorExample
AssertProperties::missing="`1` is missing required properties `2`.";
AssertProperties[tobj_TObj, properties_List]:=Module[{missing},
missing=Complement[properties,GetAllProperties[tobj]];
If[!ListEmptyQ[missing],Message[AssertProperties::missing,tobj,missing];Abort[]]]
Module[{tobj},
tobj=TObj[{A->1,B->2}];
AssertProperties[tobj,{A,B}]]//ShowExample
Module[{tobj},
tobj=TObj[{A->1,B->2}];
AssertProperties[tobj,{A,B,C,D}]]//ShowErrorExample
Options[GetValue]={
AssertProperty->True
};
GetValue[tobj_TObj,property_Symbol,opts___]:=Module[{cp},
cp=AssertProperty/.{opts}/.Options[GetValue];
If[cp,AssertProperty[tobj,property]];
property/.GetAllRules[tobj]]
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
GetValue[tobj,A]
]//ShowExample
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
GetValue[tobj,D]
]//ShowErrorExample
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
GetValue[tobj,D,AssertProperty->False]
]//ShowExample
Options[GetValues]={
AssertProperties->True
};
GetValues[tobj_TObj, properties_List,opts___]:=Module[{cp},
cp=AssertProperties/.{opts}/.Options[GetValues];
If[cp,AssertProperties[tobj,properties]];
#/.GetAllRules[tobj]&/@properties
]
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
GetValues[tobj,{B, C}]
]//ShowExample
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
GetValues[tobj,{B, C,D}]
]//ShowErrorExample
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
GetValues[tobj,{B, C,D},AssertProperties->False]
]//ShowExample
GetAllValues[TObj[args_List]]:=Last/@args
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
GetAllValues[tobj]
]//ShowExample
TObj[args_List][property_Symbol]:=GetValue[TObj[args],property]
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
tobj[A]
]//ShowExample
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
tobj[D]
]//ShowErrorExample
TObj[args_List][properties_List]:=GetValues[TObj[args],properties]
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
tobj[{B, C}]
]//ShowExample
Module[{tobj},
tobj=TObj[{A->1,B->2,C->3}];
tobj[{B, C,D}]
]//ShowErrorExample
TClasses::usage="TClasses is a TObj property that specifies the classes of TObj that a particular TObj belongs to.";
MakeTObj[]:=TObj[{TClasses->{}}]
MakeTObj[class_Symbol,properties_List]:=TObj[Prepend[properties,TClasses->{class}]]
AddClassTo[tobj_TObj,class_Symbol,properties_List:{}]:=AddPropertiesTo[tobj,Prepend[properties,TClasses->Append[GetValue[tobj,TClasses],class]]]
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}];
tobj=AddClassTo[tobj,Y];
GetAllRules[tobj]
]//ShowExample
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}];
tobj=AddClassTo[tobj,Y,{C->3}];
GetAllRules[tobj]
]//ShowExample
AddClass[class_Symbol,properties_List:{}]:=AddClassTo[#,class,properties]&
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}] // AddClass[Y];
GetAllRules[tobj]
]//ShowExample
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}]//AddClass[Y,{C->3}];
GetAllRules[tobj]
]//ShowExample
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}]//AddClass[Y,{C->3}]//AddClass[Z,{D->4}];
GetAllRules[tobj]
]//ShowExample
HasClassQ[tobj_TObj, class_Symbol]:=MemberQ[GetValue[tobj,TClasses],class]
AssertClass::missing="In `1`, `2` is not a `3`.";
AssertClass::nottobj="`1` is not a TObj.";
AssertClass[tobj_,___]:=(Message[AssertClass::nottobj,tobj];Abort[];)
AssertClass[tobj_TObj, class_Symbol,where_:"<unspecified>"]:=If[MemberQ[GetValue[tobj,TClasses],class],True,
Message[AssertClass::missing,where,tobj,class];Abort[]]
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}];
AssertClass[tobj,X]
]//ShowExample
Module[{tobj},
tobj="Not A Tobj";
AssertClass[tobj,Y]
]//ShowErrorExample
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}];
AssertClass[tobj,Y]
]//ShowErrorExample
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}];
AssertClass[tobj,Y,"EXAMPLE"]
]//ShowErrorExample
AssertClasses::nottobj="`1` is not a TObj.";
AssertClasses[tobj_,___]:=(Message[AssertClasses::nottobj,tobj];Abort[];)
AssertClasses[tobj_TObj,classes_List,where_:"<unspecified>"]:=And@@(AssertClass[tobj,#,where]&/@classes)
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}];
AssertClasses[tobj,{X}]
]//ShowExample
Module[{tobj},
tobj=MakeTObj[X,{A->1,B->2}];
AssertClasses[tobj,{X,Y,Z},"EXAMPLE"]
]//ShowErrorExample
Format[TObj[args_List]]^:=Module[{classes},
classes=TClasses/.args;
If[classes==TClasses,classes={}];
"\[SkeletonIndicator]TObj:<"<>StringJoin[Riffle[ToString/@classes,", "]]<>">\[SkeletonIndicator]"]
Module[{tobj},
tobj=TObj[{TClasses->{A, B},C->1,D->2}];
tobj]//ShowExample
Module[{tobj},
tobj=TObj[{C->1,D->2}];
tobj]//ShowExample
$TClasses={};
$TClassInheritance={};
RegisterTClass[class_Symbol,parents_List:{}]:=Module[{ci,ce},
If[MemberQ[$TClasses,class],Return[]];(* don't if we've already registered *)
AppendTo[$TClasses,class];
ci=Length[$TClasses];
(ce=Position[$TClasses,#][[1,1]]->ci;If[!MemberQ[$TClassInheritance,ce],
AppendTo[$TClassInheritance,ce]])&/@parents
]
ClassGraphRotation::usage="ClassGraphRotation is an option to TClassGraphics that specifies the angle to rotate the class hierarchy graph.";
Options[TClassGraphics]={
ClassGraphRotation->-60\[Degree],
FontSize->14
};
TClassGraphics[opts___]:=Module[{gr,fs,rm,g},
gr=ClassGraphRotation/.{opts}/.Options[TClassGraphics];
fs=FontSize/.{opts}/.Options[TClassGraphics];
rm=RotationMatrix2D[gr];
g=LayeredGraphPlot[$TClassInheritance,Left,VertexRenderingFunction->({Style[Point[#1],AbsolutePointSize[5],DarkGray],Style[Text[$TClasses[[#2]],#1,{-1.1,-1.1}],FontSize->fs]}&)];
g/.
GraphicsComplex[pts_,stuff___]:>GraphicsComplex[rm . #&/@pts,stuff]/.Point[x_]:>Point[rm . x]/.Text[label_,y_,pos_]:>Text[label,rm . y,pos]]
TGraph::usage="TGraph is a TObj class that represents a graph.";
RegisterTClass[TGraph];
Vertices::usage = "Vertices is a TObj property that specifies a list of vertex coordinates.";
Edges::usage = "Edges is a TObj property that specifies a list of edges as index pairs on a list of vertices.";
Faces::usage="Faces is a TObj property that specifies a list of faces, each face being a list of indices on a list of vertex coordinates.";
AddTGraphTo[tobj_TObj, verts_List,edges_List,faces_List:{}]:=AddClassTo[TGraph,{Vertices->verts,Edges->edges,Faces->faces}]
AddTGraph[verts_List,edges_List,faces_List:{}]:=AddTGraphTo[#,verts,edges,faces]&
MakeTGraph[verts_List,edges_List,faces_List:{}]:=MakeTObj[TGraph, {Vertices->verts,Edges->edges,Faces->faces}];
HasFacesQ[tobj_TObj]:=!ListEmptyQ[GetValue[tobj,Faces]]
GraphGraphics[tobj_TObj,opts___]:=Module[{vl,el,fl,de,fd,fc,verts, edges, faces,hf,gg},
AssertClass[tobj,TGraph,GraphGraphics];
{verts, edges, faces} = GetValues[tobj,{Vertices, Edges, Faces},AssertProperties->False];
GenericGraphGraphics[verts,edges,faces,opts]]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
tobj=MakeTGraph[verts,edges];
GraphGraphics[tobj,DirectedEdges->True,PlotLabel->"GraphGraphics"]
]//ShowExample
Graphics[{{RGBColor[1, 0, 0], {Arrow[{{0, 0}, {0.667, 0.}}], Line[{{0.667, 0.}, {1, 0}}]}, {Arrow[{{1, 0}, {1., 0.3335}}], Line[{{1., 0.3335}, {1, 0.5}}]}, {Arrow[{{1, 0.5}, {0.33299999999999996`, 0.5}}], Line[{{0.33299999999999996`, 0.5}, {0, 0.5}}]}, {Arrow[{{0, 0.5}, {0., 0.16649999999999998`}}], Line[{{0., 0.16649999999999998`}, {0, 0}}]}, {Arrow[{{0, 0}, {0.667, 0.3335}}], Line[{{0.667, 0.3335}, {1, 0.5}}]}}, {RGBColor[Rational[2, 3], 0, 0], Inset[Subscript["e", 1], {Rational[1, 2], 0}, {1.5, 0.}], Inset[Subscript["e", 2], {1, 0.25}, {1.4552137502179978`, 0.36380343755449945`}], Inset[Subscript["e", 3], {Rational[1, 2], 0.5}, {1.0606601717798212`, 1.0606601717798212`}], Inset[Subscript["e", 4], {0, 0.25}, {0., 1.5}], Inset[Subscript["e", 5], {Rational[1, 2], 0.25}, {1.3416407864998738`, 0.6708203932499369}]}, {GrayLevel[0], AbsolutePointSize[4], {Point[{0, 0}], Inset[Subscript["v", 1], {0, 0}, {-1.5, 0}]}, {Point[{1, 0}], Inset[Subscript["v", 2], {1, 0}, {1.5, 0.}]}, {Point[{1, 0.5}], Inset[Subscript["v", 3], {1, 0.5}, {1.3416407864998738`, 0.6708203932499369}]}, {Point[{0, 0.5}], Inset[Subscript["v", 4], {0, 0.5}, {0., 1.5}]}}}, PlotLabel -> "GraphGraphics"]
Module[{verts,edges,faces,tobj,fc},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
faces={{1,2,3},{3,4,1}};
fc={-1,+1};
tobj=MakeTGraph[verts,edges,faces];
GraphGraphics[tobj,FaceColoring->fc,EdgeLabels->None]
]//ShowExample
$TGraphExamples={};
AddTGraphExample::badobj="`1` is not a TObj.";
AddTGraphExample[name_Symbol,tobj_TObj]:=Module[{namestr},
namestr=ToString[name];
$TGraphExamples=DeleteItems[$TGraphExamples,{namestr}];
AppendTo[$TGraphExamples,namestr];
name=tobj]
AddTGraphExample[name_Symbol,any_]:=Module[{},
Message[AddTGraphExample::badobj,any];
Abort[]]
Clear[CrossedSquareGraphNoFaces];
AddTGraphExample[CrossedSquareGraphNoFaces,Module[{verts,edges},
verts={{0,0},{2,0},{4,0},{0,2},{2,2},{4,2},{0,4},{2,4},{4,4}};
edges={{2,5},{4,5},{5,6},{5,8},{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};
MakeTGraph[verts,edges]]];
Module[{tobj},
tobj=CrossedSquareGraphNoFaces;
GraphGraphics[tobj]
]//ShowExample
Clear[CrossedSquareGraph];
AddTGraphExample[CrossedSquareGraph,Module[{verts,edges,faces},
verts={{0,0},{1,0},{2,0},{0,1},{1,1},{2,1},{0,2},{1,2},{2,2}};
edges={{1,2},{2,3},{4,5},{5,6},{7,8},{8,9},{1,4},{2,5},{3,6},{4,7},{5,8},{6,9}};
faces={{1,2,5,4},{2,3,6,5},{4,5,8,7},{5,6,9,8}};
MakeTGraph[verts,edges,faces]]];
Module[{tobj},
tobj=CrossedSquareGraph;
GraphGraphics[tobj]
]//ShowExample
Clear[ThreeFoldSquareGraphNoFaces];
AddTGraphExample[ThreeFoldSquareGraphNoFaces,Module[{verts,edges},
verts={{0,0},{1,0},{3,0},{7/2,0},{0,1},{1,1},{2,1},{7/2,1},{1,2},{0,3},{0,7/2},{1,7/2},{7/2,7/2}};
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8},{5,10},{6,9},{7,9},{8,13},{9,10},{10,11},{9,12},{11,12},{12,13}};
MakeTGraph[verts,edges]]];
Module[{tobj},
tobj=ThreeFoldSquareGraphNoFaces;
GraphGraphics[tobj]
]//ShowExample
Clear[ThreeFoldSquareGraph];
AddTGraphExample[ThreeFoldSquareGraph,Module[{verts,edges,faces},
verts={{0,0},{1,0},{3,0},{7/2,0},{0,1},{1,1},{2,1},{7/2,1},{1,2},{0,3},{0,7/2},{1,7/2},{7/2,7/2}};
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8},{5,10},{6,9},{7,9},{8,13},{9,10},{10,11},{9,12},{11,12},{12,13}};
faces={{1,2,6,5},{2,3,7,6},{3,4,8,7},{5,6,9,10},{6,7,9},{7,8,13,12,9},{9,12,11,10}};
MakeTGraph[verts,edges,faces]]];
Module[{tobj},
tobj=ThreeFoldSquareGraph;
GraphGraphics[tobj]
]//ShowExample
Clear[SimpleSquareTwistGraph];
AddTGraphExample[SimpleSquareTwistGraph,Module[{verts,edges,faces},
verts={{0,0},{1,0},{1,1},{0,1},{-.4,-1},{-.8,-1},{2,-.4},{2,-.8},{1.4,2},{1.8,2},{-1,1.4},{-1,1.8},{-1,-1},{2,-1},{2,2},{-1,2}};
edges={{1,2},{2,3},{4,3},{1,4},(* interior square *)
{1,5},{4,6},{7,2},{8,1},{3,9},{2,10},{4,11},{3,12},(* pleats *)
{13,6},{6,5},{5,14},{14,8},{8,7},{7,15},{15,10},{10,9},{9,16},{16,12},{12,11},{11,13} (* border *)
};
faces={{1,2,3,4},{4,3,12,11},{1,4,6,5},{1,5,14,8},{7,2,1,8},{3,9,16,12},{2,10,9,3},{4,11,13,6},{7,15,10,2}};
MakeTGraph[verts,edges,faces]]];
Module[{tobj},
tobj=SimpleSquareTwistGraph;
GraphGraphics[tobj]
]//ShowExample
Clear[SimpleSplitSquareTwistGraph];
AddTGraphExample[SimpleSplitSquareTwistGraph,Module[{verts,edges,faces},
verts={{0,0},{1,0},{1,1},{0,1},{-.4,-1},{-.8,-1},{2,-.4},{2,-.8},{1.4,2},{1.8,2},{-1,1.4},{-1,1.8},{-1,-1},{2,-1},{2,2},{-1,2}};
edges={{1,2},{2,3},{4,3},{1,4},{1,3},(* interior square *)
{1,5},{4,6},{7,2},{8,1},{3,9},{2,10},{4,11},{3,12},(* pleats *)
{13,6},{6,5},{5,14},{14,8},{8,7},{7,15},{15,10},{10,9},{9,16},{16,12},{12,11},{11,13} (* border *)
};
faces={{1,2,3},{4,3,12,11},{1,4,6,5},{1,3,4},{1,5,14,8},{7,2,1,8},{3,9,16,12},{2,10,9,3},{4,11,13,6},{7,15,10,2}};
MakeTGraph[verts,edges,faces]]];
Module[{tobj},
tobj=SimpleSplitSquareTwistGraph;
GraphGraphics[tobj]
]//ShowExample
Clear[SingleVertexGraph];
AddTGraphExample[SingleVertexGraph,Module[{verts,edges,faces,tobj},
verts={{0,0},{1,0},{1,1},{0,1},{-1,1},{-1,1/\[Sqrt]3},{-1,-1},{-1/\[Sqrt]3,-1},{1,-1}}//N;
edges={{1,2},{1,4},{1,6},{1,8},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,2}};
faces={{1,2,3,4},{1,4,5,6},{1,6,7,8},{1,8,9,2}};
MakeTGraph[verts,edges,faces]]]
Module[{tobj},
tobj=SingleVertexGraph;
GraphGraphics[tobj]
]//ShowExample
Clear[CrossPleatedSquareGraph];
AddTGraphExample[CrossPleatedSquareGraph,Module[{verts,edges,faces,tobj},
verts=Flatten[Table[{i-1+0.1(-1)^i,j-1+0.1(-1)^j},{j,4},{i,4}],1];
edges=Join[Flatten[Table[{i+4(j-1),i+1+4(j-1)},{j,4},{i,3}],1],Flatten[Table[{i+4(j-1),i+4(j)},{j,3},{i,4}],1]];
faces={{1,2,6,5},{2,3,7,6},{3,4,8,7},{5,6,10,9},{6,7,11,10},{7,8,12,11},{9,10,14,13},{10,11,15,14},{11,12,16,15}};
MakeTGraph[verts,edges,faces]]]
Module[{tobj},
tobj=CrossPleatedSquareGraph;
GraphGraphics[tobj]
]//ShowExample
SamePtQ=PtOnPtQ;
SamePtTolerance=PtOnPtTolerance;
SameEdgeQ=#1==#2||#1==Reverse[#2]&;
SameEdgeQ[{1,2},{2,1}]//ShowExample
SameEdgeQ[{1,2},{2,3}]//ShowExample
SameFaceQ[f1_,f2_]:=Or@@(f1==#&/@Table[RotateLeft[f2,i],{i,Length[f2]}])
SameFaceQ[{1,2,3},{2,3,1}]//ShowExample
SameFaceQ[{1,2,3},{2,3,4}]//ShowExample
Unprotect[VertexIndex];
VertexIndex[tobj_TObj,v_List,opts___]:=With[{verts=tobj[Vertices]},
Catch[Do[If[SamePtQ[verts[[i]],v,opts],Throw[i]],{i,Length[verts]}];Throw[0]]];
Protect[VertexIndex];
Unprotect[EdgeIndex];
EdgeIndex[tobj_TObj,e_List,opts___]:=With[{edges=tobj[Edges]},
Catch[Do[If[SameEdgeQ[edges[[i]],e,opts],Throw[i]],{i,Length[edges]}];Throw[0]]];
Protect[EdgeIndex];
FaceIndex[tobj_TObj,f_List,opts___]:=With[{faces=tobj[Faces]},
Catch[Do[If[SameFaceQ[faces[[i]],f,opts],Throw[i]],{i,Length[faces]}];Throw[0]]];
Module[{tobj},
tobj=CrossedSquareGraph;
Print[GraphGraphics[tobj,Axes->True]];
PrintThis[VertexIndex[tobj,{2.,2.}]];
PrintThis[VertexIndex[tobj,{2.,2.1}]];
PrintThis[EdgeIndex[tobj,{5,6}]];
PrintThis[EdgeIndex[tobj,{5,9}]];
PrintThis[FaceIndex[tobj,{5,6,9,8}]];
]//ShowExample
StartPoints::usage="StartPoints is an option to Indexify that specifies an initial list of points to use in when indexifying an object.";
Options[Indexify]=Join[Options[SamePtQ],{
StartPoints->{},
SameTest->SamePtQ
}];
Indexify[obj_,levspec_Integer:1, opts___]:=Module[{sp,st,allpts,il},
sp=StartPoints/.{opts}/.Options[Indexify];
st=SameTest/.{opts}/.Options[Indexify];
allpts=Flatten[obj,levspec];
Reverse[{Map[Function[p,If[il=Position[st[#,p,opts]&/@sp,True];Length[il]==0,AppendTo[sp,p];Length[sp],il[[1,1]]]],obj,{levspec}],sp}]]
Indexify[{Line[{{0,0},{1,0}}],Line[{{1,0},{1,1}}]},3]//ShowExample
Indexify[{Line[{{0,0},{1,0}}],Line[{{1,0},{1,1}}]},3,StartPoints->{{1,1},{1,0},{0,0}}]
Indexify[{Line[{{a,b},{c,d}}],Line[{{c,d},{e,f}}]},3]//ShowExample
Indexify[{Line[{{a,b},{c,d}}],Line[{{c,d},{e,f}}]},3,SameTest->SameQ]//ShowExample
Embed[pts_,obj_,levspec_Integer:1]:=Map[pts[[#]]&,obj,{levspec}]
<<ComputationalGeometry`;
PruneUnivalentEdges[tobj_TObj]:=Module[{edges},
AssertClass[tobj,TGraph,PruneUnivalentEdges];
edges=FixedPoint[Function[ll,Transpose[#][[1]]&/@Select[Map[{#,Count[Flatten[ll],#]}&,ll,{2}],#[[1,2]]>1&&#[[2,2]]>1&]],tobj[Edges]];
ReplacePropertiesIn[tobj,{Edges->edges}]]
Module[{edges,tobj1,tobj2},
edges={{1,2},{2,3},{2,4},{3,5},{4,5},{5,6}};
tobj1=MakeTGraph[{},edges];
tobj2=PruneUnivalentEdges[tobj1];
tobj2[Edges]
]//ShowExample
AbsorbOneDivalentVertex[edges_List]:=Module[{vinds,vvals,dvvals,di},
vinds=Flatten[edges];
vvals=Table[{i,Count[vinds,i]},{i,Max[vinds]}];
dvvals=First/@Select[vvals,Last[#]==2&];
If[ListEmptyQ[dvvals],Return[edges]];
di=First[dvvals];Append[Select[edges,!MemberQ[#,di]&],Select[Flatten[Select[edges,MemberQ[#,di]&]],#!=di&]]]
AbsorbOneDivalentVertex[{{1,2},{2,3},{3,4},{4,5},{3,7},{7,8}}]//ShowExample
AbsorbDivalentVertices[tobj_TObj]:=Module[{},
AssertClass[tobj,TGraph,AbsorbDivalentVertices];
ReplacePropertiesIn[tobj,{Edges->FixedPoint[AbsorbOneDivalentVertex,tobj[Edges]]}]];
Module[{edges,tobj,tobj1},
edges={{1,2},{2,3},{3,4},{4,5},{3,7},{7,8}};
tobj=MakeTGraph[{},edges];
tobj1=AbsorbDivalentVertices[tobj];
tobj1[Edges]
]//ShowExample
DropOrphanVertices[tobj_TObj]:=Module[{verts,edges,vrefs,vmap,iv,newverts,newedges},
AssertClass[tobj,TGraph,DropOrphanVertices];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
vrefs=Union[Flatten[edges]];
vmap={};
iv=1;
newverts={};
Do[If[MemberQ[vrefs,i],AppendTo[vmap,i->iv];AppendTo[newverts,verts[[i]]];iv++],{i,Length[verts]}];
newedges=edges/.vmap;
MakeTGraph[newverts,newedges]]
Module[{verts, edges,tobj,tobj1},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{2,3},{3,4},{4,2}};
tobj=MakeTGraph[verts,edges];
tobj1=DropOrphanVertices[tobj];
GetAllRules[tobj1]
]//ShowExample
ConvexHullifyEdges[tobj_TObj]:=Module[{verts,edges,chull,newedges},
AssertClass[tobj,TGraph,ConvexHullifyEdges];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
chull=ConvexHull[verts];
newedges=Union[Join[edges,Transpose[{chull,RotateLeft[chull]}]],SameTest->(#1==#2||#1==Reverse[#2]&)];
ReplacePropertiesIn[tobj,{Vertices->verts,Edges->newedges}]
]
Module[{verts,edges,tobj,tobj1},
verts={{0,0},{1,0},{1,1},{0,1},{0.5,0.5}};
edges={{1,5},{2,5},{3,5},{4,5}};
tobj=MakeTGraph[verts,edges];
tobj1=ConvexHullifyEdges[tobj];
GetAllRules[tobj1]
]//ShowExample
AtLeastTrivalentQ[tobj_TObj]:=Module[{verts,edges},
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
And@@Table[Count[Flatten[edges],i]>=3,{i,Length[verts]}]]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,1},{0,1},{0.5,0.5}};
edges={{1,5},{2,5},{3,5},{4,5},{1,2},{2,3},{3,4},{4,1}};
tobj=MakeTGraph[verts,edges];
AtLeastTrivalentQ[tobj]
]//ShowExample
UnionVerticesAndEdges[tobj_TObj,opts___]:=Module[{verts, edges,nverts,ll,vm,nedges},
AssertClass[tobj,TGraph,UnionVerticesAndEdges];
{verts, edges}=GetValues[tobj,{Vertices,Edges}];
nverts={};
vm={};
Function[vv,ll=Select[MapIndexed[{SamePtQ[vv,#1,opts],First[#2]}&,nverts],First];If[Length[ll]==0,AppendTo[nverts,vv];AppendTo[vm,Length[nverts]],AppendTo[vm,ll[[1,2]]]]]/@verts;
nedges=Union[Map[vm[[#]]&,edges,{2}],SameTest->SameEdgeQ];
ReplacePropertiesIn[tobj,{Vertices->nverts,Edges->nedges}]]
Module[{verts,edges,tobj,tobj1},
verts={{0,0},{0,0},{1,0},{1,1},{0,1}};
edges={{1,3},{2,3},{3,4},{4,3},{4,5}};
tobj=MakeTGraph[verts,edges];
tobj1=UnionVerticesAndEdges[tobj];
GetAllRules[tobj1]
]//ShowExample
EmbeddedIntersectifyOld[verts_List, edges_List,opts___]:=Module[{emedges,intfn,accum,newpts},
emedges=Embed[verts,edges,2];
intfn[{p1_,p2_},{q1_,q2_}]:=Module[{detd,tp,tq},
detd=Det[{p2-p1,q2-q1}];
If[Chop[Abs[detd]]==0,{-1,-1,{0,0}},
tp=Det[{q1-p1,q2-q1}]/detd;
tq=-Det[{p1-q1,p2-p1}]/detd;
{tp,tq,p1+tp(p2-p1)}]];
accum={};
Do[
newpts=Join[
{{0,0,emedges[[i,1]]}},
{{1,0,emedges[[i,2]]}},
intfn[emedges[[i]],#]&/@Drop[emedges,{i}]];
newpts=Select[newpts,#[[1]]>=-0.01&&#[[1]]<=1.01&&#[[2]]>=-0.01&&#[[2]]<=1.01&];
newpts=Union[newpts,SameTest->(SamePtQ[#1[[3]],#2[[3]],opts]&)];
newpts=Sort[newpts,#1[[1]]<#2[[1]]&];
newpts=Last/@newpts;
JoinTo[accum,MapThread[{{#1,#2},i}&,{Drop[newpts,-1],Drop[newpts,1]}]];
,{i,Length[edges]}];
Transpose[accum]
]
Options[EmbeddedIntersectify]={
IntersectionTolerance->0
};
EmbeddedIntersectify[verts_List, edges_List,opts___]:=Module[{itol,eptsall,p1,p2,q1,q2,r,d,tpair,accum,epts},
itol=IntersectionTolerance/.{opts}/.Options[EmbeddedIntersectify];
eptsall=Table[{{verts[[edges[[i,1]]]],0},{verts[[edges[[i,2]]]],1}},{i,Length[edges]}];
(* Find all pairwise intersections *)
Do[
{p1,p2}=verts[[edges[[i]]]];
{q1,q2}=verts[[edges[[j]]]];
If[!BoundingBoxesIntersectQ[BoundingBox[{p1,p2}],BoundingBox[{q1,q2}],opts],Continue[]];
{r,d,tpair}=SegmentSegmentMedialInfo[{p1,p2},{q1,q2}];
(* If within tolerance and it's not an endpoint, record the intersection *)
If[Chop[d]<=itol/2,
If[Chop[tpair[[1]]]!=0&&Chop[tpair[[1]]-1]!=0,AppendTo[eptsall[[i]],{r,tpair[[1]]}]];
If[Chop[tpair[[2]]]!=0&&Chop[tpair[[2]]-1]!=0,AppendTo[eptsall[[j]],{r,tpair[[2]]}]]]
,{i,Length[edges]},{j,i+1,Length[edges]}];
accum={};
Do[
(* Sort all points of each edge in order of t-parameter along edge, then drop t-parameter *)
epts=First/@Sort[eptsall[[i]],#1[[2]]<#2[[2]]&];
(* construct individual edges and index of where it came from *)
JoinTo[accum,MapThread[{{#1,#2},i}&,{Drop[epts,-1],Drop[epts,1]}]];
,{i,Length[edges]}];
Transpose[accum]]
Module[{verts,edges,emedges,emap},
verts={{-1,0},{1,0},{0,-1},{0,1}};
edges={{1,2},{3,4}};
{emedges,emap}=EmbeddedIntersectify[verts,edges];
Print[Show[Graphics[{Style[Line/@emedges,LightGray,Thickness[.02]],Style[Point/@Flatten[emedges,1],GrayLevel[.75],PointSize[.03]]}],GenericGraphGraphics[verts,edges]]];
{emedges,emap}
]//ShowExample
Module[{verts,edges,emedges,emap},
verts={{-1,0},{0,0},{0,-.5},{0,.5}};
edges={{1,2},{3,4}};
{emedges,emap}=EmbeddedIntersectify[verts,edges];
Print[Show[Graphics[{Style[Line/@emedges,LightGray,Thickness[.02]],Style[Point/@Flatten[emedges,1],GrayLevel[.75],PointSize[.03]]}],GenericGraphGraphics[verts,edges]]];
{emedges,emap}
]//ShowExample
Module[{verts,edges,emedges,emap},
verts={{-1,0},{0,0},{0,0},{0,1}};
edges={{1,2},{3,4}};
{emedges,emap}=EmbeddedIntersectify[verts,edges];
Print[Show[Graphics[{Style[Line/@emedges,LightGray,Thickness[.02]],Style[Point/@Flatten[emedges,1],GrayLevel[.75],PointSize[.03]]}],GenericGraphGraphics[verts,edges]]];
{emedges,emap}
]//ShowExample
Module[{verts,edges,itol,emedges,emap},
verts={{-1,0},{-.1,0},{0,-1},{0,1}};
edges={{1,2},{3,4}};
itol=0.15;
{emedges,emap}=EmbeddedIntersectify[verts,edges,IntersectionTolerance->itol];
Print[Show[Graphics[{Style[Line/@emedges,LightGray,Thickness[.02]],Style[Point/@Flatten[emedges,1],GrayLevel[.75],PointSize[.03]]}],GenericGraphGraphics[verts,edges]]];
{emedges,emap}
]//ShowExample
Intersectify[tobj_TObj, opts___]:=Module[{verts,edges,newemedges,newverts,newedges},
AssertClass[tobj,TGraph,Intersectify];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
newemedges=EmbeddedIntersectify[verts,edges,opts][[1]];
{newverts,newedges}=Indexify[newemedges,2,opts];
newedges=Select[newedges,#[[1]]!=#[[2]]&];
ReplacePropertiesIn[tobj,{Vertices->newverts,Edges->newedges}]
]
Module[{verts,edges,tobj,tobj1},
verts={{1.,0.},{2.,0.},{0.,1.},{3.,1.},{0.,2.},{3.,2.},{1.,3.},{2.,3.}};
edges={{1,7},{2,8},{3,4},{5,6}};
tobj=MakeTGraph[verts,edges];
tobj1=Intersectify[tobj];
GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1]}]
]//ShowExample
RadialAxialTolerance::usage="RadialAxialTolerance is an option to RadialAxialOrderingFn that specifies the tolerance on switching between radial and axial ordering.";
RadialMajor::usage="RadialMajor is an option to RadialAxialOrderingFn that specifies radial priority.";
RadialDirection::usage="RadialDirection is a option to RadialAxialOrderingFn that specials the radial orientation.";
AxialDirection::usage="AxialDirection is an option to RadialAxialOrderingFn that specifies the axial orientation.";
Inward::usage="Inward is a value for the option RadialDirection.";
Outward::usage = "Outward is a value for the option RadialDirection.";
Options[RadialAxialOrderingFn]={
RadialAxialTolerance->10^-6,
RadialMajor->True,
RadialDirection->Outward,
AxialDirection->CCW
};
RadialAxialOrderingFn::badedge="Edge `1` has zero length and can't be oriented.";
RadialAxialOrderingFn[ctr_,opts___]:=Function[{p1,p2},Module[{tol, rm,ad,rd,mp,rmp,r,dp},
tol=RadialAxialTolerance/.{opts}/.Options[RadialAxialOrderingFn];
rm=RadialMajor/.{opts}/.Options[RadialAxialOrderingFn];
ad=AxialDirection/.{opts}/.Options[RadialAxialOrderingFn];
rd=RadialDirection/.{opts}/.Options[RadialAxialOrderingFn];
If[Chop[Mag[p1-p2]]==0,Message[RadialAxialOrderingFn::badedge,{p1,p2}];Abort[]];
mp=(p1+p2)/2-ctr;(* midpt of edge, relative to ctr *)
If[Chop[Mag[mp]]==0,True,(* midpt lies on ctr, always return True *)
mp=NormalizeReal[mp];(* radial unit vector *)
rmp=Rotate90[mp];(* axial unit vector *)
r=NormalizeReal[p2-p1]; (* unit vector in direction of edge *)
If[rm,
dp=r . mp;If[Abs[dp]>tol,(dp>0)\[Xnor](rd===Outward),(r . rmp>0)\[Xnor](ad===CCW)],
dp=r . rmp;If[Abs[dp]>tol,(dp>0)\[Xnor](ad===CCW),(r . mp>0)\[Xnor](rd===Outward)]]]]]
RadialAxialOrderingFn[{0,0},RadialMajor->True][{-1,0},{1,0}]//ShowExample
RadialAxialOrderingFn[{0,0},RadialMajor->True][{1,0},{.9,-.1}]//ShowExample
OrientEdges[tobj_TObj, fn_]:=Module[{verts,edges,newedges},
AssertClass[tobj,TGraph,OrientEdges];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
newedges=If[fn[verts[[#[[1]]]],verts[[#[[2]]]]],#,Reverse[#]]&/@edges;
ReplacePropertiesIn[tobj,{Edges->newedges}]]
Module[{verts,edges,ctr,tobj,fn,tobj1,newverts,newedges},
verts=edges={};
SeedRandom[0];
Do[With[{r={Random[]-.5,Random[]-.5},s={Random[]-.5,Random[]-.5}},JoinTo[verts,{r,r+0.3Mag[r]s}]];AppendTo[edges,{Length[verts]-1,Length[verts]}],{50}];
ctr={0,0};
tobj = MakeTGraph[verts,edges];
fn=RadialAxialOrderingFn[ctr,RadialMajor->True,RadialAxialTolerance->0.1];
tobj1=OrientEdges[tobj,fn];
{newverts,newedges}=GetValues[tobj1,{Vertices,Edges}];
GraphicsRow[{
Graphics[{Style[Point[ctr],AbsolutePointSize[5],Blue],Style[Arrow[#],If[fn[#[[1]],#[[2]]],Green,Red]]&/@(verts[[#]]&/@edges)},Frame->True,PlotLabel->"Input"],
Graphics[{Style[Point[ctr],AbsolutePointSize[5],Blue],Style[Arrow[#],If[fn[#[[1]],#[[2]]],Green,Red]]&/@(newverts[[#]]&/@newedges)},Frame->True,PlotLabel->"Oriented"]
}]
]//ShowExample
VertexVertexAdjacencyFromVerticesAndEdges[verts_List,edges_List]:=Module[{halfedges,heangles,hevtable,hesvtable},
halfedges=Join[edges,Reverse/@edges];
heangles={#,ArcTan@@-Subtract@@verts[[#]]}&/@halfedges;(* append angle to each halfedge *)
hevtable=Table[Select[heangles,#[[1,1]]==i&],{i,Length[verts]}]; (* group by vertex *)
hesvtable=Sort[#,#1[[2]]<#2[[2]]&]&/@hevtable;(* sort each list by angle *)
Map[#[[1,2]]&,hesvtable,{2}](* return just the vertex index of each halfedge *)
]
Module[{verts,edges,tobj},
tobj=CrossedSquareGraph;
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
Print[GraphGraphics[tobj]];
VertexVertexAdjacencyFromVerticesAndEdges[verts,edges]
]//ShowExample
VertexDegreeFromEdges[edges_List]:=Module[{vv},
vv=Flatten[edges];
Table[Count[vv,i],{i,Max[vv]}]]
Module[{verts,edges,tobj},
verts={{0,0},{2,0},{1,-1},{1,+1}};
edges={{1,2},{1,3},{1,4},{2,3},{2,4}};
tobj=MakeTGraph[verts,edges];
Print[GraphGraphics[tobj]];
VertexDegreeFromEdges[edges]
]//ShowExample
CircularlyExtendEdges::badvert="Vertex `1` must have 0 or 1 interior edge but has `2` interior edges.";
CircularlyExtendEdges[verts_List,edges_List,bverts_List, ctr_List, r_]:=Module[{nb,idata,bv,be,ie,ni,ee,nv,na,ip,in,pdata,ndata,newverts,dn,di,da},
nb=Length[bverts];
(* First pass: make a list of {nv, na} for interior-connected edges, Null for others *)
idata=Function[bv,
be=Select[edges,MemberQ[#,bv]&];(* all edges containing bv *)
ie=Select[be,!(MemberQ[bverts,#[[1]]]&&MemberQ[bverts,#[[2]]])&];(* all edges of form {bv, iv} *)
ni=Length[ie];
Which[
ni==0,Null,(* no interior edge *)
ni==1,ee=ie[[1]];If[ee[[2]]==bv,ee=Reverse[ee]];nv=RayCircleInt2D[verts[[ee[[2]]]],verts[[bv]]-verts[[ee[[2]]]],ctr,r];(* new vertex position *)
na=AbsoluteAngle[nv-ctr];(* radial angle around  circle *)
{nv,na},
ni>1,Message[CircularlyExtendEdges::badvert,bv,ni];Abort[]]
]/@bverts;
(* For all non-interior-connected vertices, find the i-c vertices that come before and after *)
ip=in=0;
pdata=ndata=Table[0,{nb}];
Do[If[Head[idata[[i]]]===List,ip=i,If[ip!=0&&pdata[[i]]==0,pdata[[i]]=ip]],{2},{i,nb}];
Do[If[Head[idata[[i]]]===List,in=i,If[in!=0&&ndata[[i]]==0,ndata[[i]]=in]],{2},{i,nb,1,-1}];
(* extend selected vertices to circle *)
newverts=verts;
Do[If[Head[idata[[i]]]===List,newverts[[bverts[[i]]]]=idata[[i,1]],
dn=Mod[ndata[[i]]-pdata[[i]],nb];
di=Mod[i-pdata[[i]],nb];
da=Mod[idata[[ndata[[i]],2]]-idata[[pdata[[i]],2]],2\[Pi],-\[Pi]];
newverts[[bverts[[i]]]]=ctr+r U[idata[[pdata[[i]],2]]+(di/dn)da]],{i,nb}];
newverts]
Module[{verts,edges,bverts,ctr,r,nverts,circle},
verts={{-1,-1},{1,-1},{1,1},{-1,1},{-1,-2},{1,-2},{2,-2},{2,-1},{2,1},{2,2},{1,2},{-1,2},{-2,2},{-2,1},{-2,-1},{-2,-2}};
edges={{1,2},{2,3},{3,4},{4,1},{1,5},{2,8},{3,11},{4,14},{5,6},{6,7},{7,8},{8,9},{9,10},{10,11},{11,12},{12,13},{13,14},{14,15},{15,16},{16,5}};
bverts={5,6,7,8,9,10,11,12,13,14,15,16};
ctr={0,0};
r=4;
nverts=CircularlyExtendEdges[verts,edges,bverts,ctr,r];
circle=Graphics[Style[Circle[{0,0},r],LightGray]];
Show[Graphics[{
Style[Point[ctr],Black],
Style[Circle[{0,0},r],LightGray],
Style[Line/@Transpose[{verts,nverts}],Blue],
Style[Point/@nverts,Darker[Blue]]
}],
GenericGraphGraphics[verts,edges]]
]//ShowExample
CircularlyExtendEdges[tobj_TObj,bverts_List, ctr_List, r_]:=Module[{verts,edges,newverts},
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
newverts=CircularlyExtendEdges[verts,edges,bverts,ctr,r];
tobj//ReplaceProperty[Vertices->newverts]]
Module[{verts,edges,tobj,r,tobj1,circle},
verts={{-1,-1},{1,-1},{1,1},{-1,1},{-1,-2},{1,-2},{2,-2},{2,-1},{2,1},{2,2},{1,2},{-1,2},{-2,2},{-2,1},{-2,-1},{-2,-2}};
edges={{1,2},{2,3},{3,4},{4,1},{1,5},{2,8},{3,11},{4,14},{5,6},{6,7},{7,8},{8,9},{9,10},{10,11},{11,12},{12,13},{13,14},{14,15},{15,16},{16,5}};
tobj=MakeTGraph[verts,edges];
r=4;
tobj1=CircularlyExtendEdges[tobj,Table[i,{i,5,16}],{0,0},r];
circle=Graphics[Style[Circle[{0,0},r],LightGray]];
GraphicsRow[{Show[GraphGraphics[tobj],circle],Show[GraphGraphics[tobj1],circle]}]
]//ShowExample
CircularlyAddEdges[tobj_TObj,bverts_,ctr_List,r_]:=Module[{verts, edges,nverts,nedges},
AssertClass[tobj,TGraph,CircularlyAddEdges];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
nverts=ctr+r*NormalizeReal[#-ctr]&/@verts[[bverts]];
nedges=Table[{bverts[[i]],Length[verts]+i},{i,Length[nverts]}];
ReplacePropertiesIn[tobj,{Vertices->Join[verts,nverts],Edges->Join[edges,nedges]}]]
Module[{verts,edges,tobj,r,tobj1,circle},
verts={{-1,-1},{1,-1},{1,1},{-1,1},{-1,-2},{1,-2},{2,-2},{2,-1},{2,1},{2,2},{1,2},{-1,2},{-2,2},{-2,1},{-2,-1},{-2,-2}};
edges={{1,2},{2,3},{3,4},{4,1},{1,5},{2,8},{3,11},{4,14},{5,6},{6,7},{7,8},{8,9},{9,10},{10,11},{11,12},{12,13},{13,14},{14,15},{15,16},{16,5}};
tobj=MakeTGraph[verts,edges];
r=4;
tobj1=CircularlyAddEdges[tobj,Table[i,{i,5,16}],{0,0},r];
circle=Graphics[Style[Circle[{0,0},r],LightGray]];
GraphicsRow[{Show[GraphGraphics[tobj],circle],Show[GraphGraphics[tobj1],circle]}]
]//ShowExample
Module[{verts,edges,tobj,r,tobj1,circle},
verts={{-1,-1},{1,-1},{1,1},{-1,1}};
edges={{1,2},{2,3},{3,4},{4,1}};
tobj=MakeTGraph[verts,edges];
r=3;
tobj1=CircularlyAddEdges[tobj,{1,3},{0,0},r];
circle=Graphics[Style[Circle[{0,0},r],LightGray]];
GraphicsRow[{Show[GraphGraphics[tobj],circle],Show[GraphGraphics[tobj1],circle]}]
]//ShowExample
CircularlyAddEdgesToConvexHull[tobj_TObj,ctr_List,r_]:=Module[{verts,edges,chull,nverts,nedges},
AssertClass[tobj,TGraph,CircularlyAddEdgesToConvexHull];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
chull=ConvexHull[verts];
nverts=ctr+r*NormalizeReal[#-ctr]&/@verts[[chull]];
nedges=Table[{chull[[i]],Length[verts]+i},{i,Length[nverts]}];
ReplacePropertiesIn[tobj,{Vertices->Join[verts,nverts],Edges->Join[edges,nedges]}]]
Module[{verts,edges,tobj,r,tobj1,circle},
verts={{-1,-1},{1,-1},{1,1},{-1,1}};
edges={{1,2},{2,3},{3,4},{4,1}};
tobj=MakeTGraph[verts,edges];
r=3;
tobj1=CircularlyAddEdgesToConvexHull[tobj,{0,0},r];
circle=Graphics[Style[Circle[{0,0},r],LightGray]];
GraphicsRow[{Show[GraphGraphics[tobj],circle],Show[GraphGraphics[tobj1],circle]}]
]//ShowExample
ClearAll[CircularlyCompletePoly];
CircleDivisions::usage="CircleDivisions is an option to CircularlyCompletePoly that specifies the number of divisions in the circle to use when approximating it as a polygon.";
Options[CircularlyCompletePoly]={
CircleDivisions->64
};
SetAttributes[CircularlyCompletePoly,HoldAll];
CircularlyCompletePoly[verts_,edges_ ,faces_,pface_,ctr_,r_,opts___]:=Module[{cd,astart,aend,alen,k,jstart,jend,jrange},
cd=CircleDivisions/.{opts}/.Options[CircularlyCompletePoly];
astart=N[ArcTan@@(verts[[pface[[-1]]]]-ctr)];
aend=N[ArcTan@@(verts[[pface[[1]]]]-ctr)];
alen=Mod[aend-astart,2\[Pi],-\[Pi]];(* sector arc length *)
aend=astart+alen;(* revise ending arc angle *)
k=Max[Round[cd * Abs[alen]/(2\[Pi])],2];(* number of divisions to use for arc *)
jstart=Length[verts]+1;
Do[AppendTo[verts,ctr + r U[astart+(j/k)(alen)]],{j,k-1}];(* add'l face vertices *)
jend=Length[verts];
jrange=Range[jstart,jend];
JoinTo[edges,Join[{{pface[[-1]],jstart}},Transpose[{Drop[jrange,-1],Drop[jrange,1]}],{{jend,pface[[1]]}}]];
AppendTo[faces,Join[pface,jrange]]
]
Module[{verts,edges,faces,pface,ctr,r},
verts={{0,0},{1,0},{0,1}};
edges={};
faces={};
pface={3,1,2};
ctr={0,0};
r=1.05;
CircularlyCompletePoly[verts,edges,faces,pface,ctr,r];
Graphics[{
Style[Polygon[verts[[#]]&/@faces],LightGray],
Style[Line[verts[[#]]&/@edges],Black],
Style[Point[ctr],Red,AbsolutePointSize[5]]}]
]//ShowExample
WindingNumber::tooshort="Vertex list `1` must be of length greater than or equal to 3.";
WindingNumber::badverts="Vertex list `1` has a repeated vertex.";
WindingNumber[verts_List]:=Module[{diff,absangles,relangles,pos},
If[Length[verts]<3,Message[WindingNumber::tooshort,verts];Abort[]];
(* if a vertex is repeated, we drop it and try again *)
diff=Chop[Mag/@(RotateLeft[verts]-verts)];
pos=Catch[Do[If[diff[[i]]==0,Throw[i]],{i,Length[diff]}];Throw[0]];
If[pos!=0,
WindingNumber[Drop[verts,{pos}]],
absangles=(ArcTan@@Subtract@@#&)/@Transpose[{RotateLeft[verts],verts}];
relangles=Mod[#,2\[Pi],-\[Pi]]&/@(absangles-RotateRight[absangles]);
(* If a vertex returns an angle of -\[Pi], drop it and try again *)
pos=Catch[Do[If[relangles[[i]]==-\[Pi],Throw[i]],{i,Length[relangles]}];Throw[0]];
If[pos!=0,
WindingNumber[Drop[verts,{pos}]],
Round[Plus@@relangles/(2\[Pi])]]]]
WindingNumber[{{0,0},{1,0},{.5,1}}]
Module[{verts},
verts={{0,0},{1,0},{1,1},{1,1/2},{2,0},{1,2}};
Print[Graphics[Line[AppendFirst[verts]]]];
WindingNumber[verts]
]//ShowExample
Module[{verts},
verts={{0,2},{1,2},{2,2},{2,1},{2,0},{1,0},{1,1},{1,0},{0,0},{0,1}};
WindingNumber[verts]
]//ShowExample
WindingNumber::ftooshort="Face list `1` must be of length greater than or equal to 3.";
WindingNumber::badface="Face list `1` has a repeated vertex index.";
WindingNumber[verts_List, face_]:=Module[{sverts,absangles,relangles},
If[Length[face]<3,Message[WindingNumber::ftooshort,face];Abort[]];
If[MemberQ[RotateLeft[face]-face,0],Message[WindingNumber::badface,face];Abort[]];
WindingNumber[verts[[face]]]]
WindingNumber[{{0,0},{2,0},{2,2},{0,2}},{1,2,3,4}]//ShowExample (* a ccw square *)
WindingNumber[{{0,0},{2,0},{2,2},{0,2}},{4,3,2,1}]//ShowExample (* a cw square *)
WindingNumber[{{0,0},{2,0},{2,2},{0,2}},{1,2,4,3}]//ShowExample (* a polygonal figure-eight *)
WindingNumber[verts_List,face_,p_]:=Module[{sverts,angles},
sverts=#-p&/@verts[[face]];
angles=MapThread[RotationAngle,{sverts,RotateLeft[sverts]},1];
Round[Plus@@angles/(2\[Pi])]]
WindingNumber[{{0,0},{2,0},{2,2},{0,2}},{1,2,3,4},{1.,1.}]//ShowExample (* pt inside square *)
WindingNumber[{{0,0},{2,0},{2,2},{0,2}},{1,2,3,4},{-10.,1.}]//ShowExample (* pt outside square *)
MakeCCW[verts_List]:=If[WindingNumber[verts,Range[Length[verts]]]>=0,verts,Reverse[verts]]
MakeCCW[{{0,0},{1,0},{1,1},{0,1}}]//ShowExample
MakeCCW[{{0,0},{0,1},{1,1},{1,0}}]//ShowExample
FaceCentroid[verts_List,face_]:=Centroid[verts[[face]]]
Module[{verts,face},
verts={{-1,0},{1,0},{1,1},{-1,1}};
face={1,2,3,4};
FaceCentroid[verts,face]
]//ShowExample
EdgesFromFaces[faces_]:=Union[Flatten[Transpose[{#,RotateLeft[#]}]&/@faces,1],SameTest->SameEdgeQ]
Module[{faces},
faces={{1,2,3},{3,4,2}};
EdgesFromFaces[faces]
]//ShowExample
BoundaryFromFaces[faces_]:=Module[{halfedges,bedges,boundary,nextitem},
halfedges=Flatten[Transpose[{#,RotateLeft[#]}]&/@faces,1];
bedges=First/@Select[Tally[halfedges,#1==Reverse[#2]&],#[[2]]==1&];
boundary=bedges[[1]];
bedges=DropFirst[bedges];
While[NotListEmptyQ[bedges],
nextitem=Select[bedges,#[[1]]==boundary[[-1]]&,1];
If[nextitem=={},Abort[]];(* to prevent infinite loop *)
AppendTo[boundary,nextitem[[1,2]]];
bedges=DeleteItem[bedges,nextitem[[1]]]];
DropLast[boundary]
]
Module[{faces},
faces={{1,2,6,5},{2,3,7,6},{3,4,8,7},{5,6,9,10},{6,7,9},{7,8,13,12,9},{9,12,11,10}};
BoundaryFromFaces[faces]
]//ShowExample
EdgeCentroids[tobj_TObj]:=Plus@@tobj[Vertices][[#]]/2&/@tobj[Edges]
Module[{verts,edges,eangles,tobj},
verts={{0,0},{1,0},{2,0},{3,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
tobj=MakeTGraph[verts,edges];
Print[GraphGraphics[tobj]];
EdgeCentroids[tobj]
]//ShowExample
EdgeLengths[tobj_TObj]:=Module[{verts,edges},
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
Mag[Subtract@@verts[[#]]]&/@edges]
Module[{verts,edges,eangles,tobj},
verts={{0,0},{1,0},{2,0},{3,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
tobj=MakeTGraph[verts,edges];
Print[GraphGraphics[tobj]];
EdgeLengths[tobj]
]//ShowExample
FaceCentroids[tobj_TObj]:=Module[{verts,faces},
{verts,faces}=GetValues[tobj,{Vertices,Faces}];
FaceCentroid[verts,#]&/@faces
]
Options[FaceCircumcenterInfo]={
SamePtTolerance->10^-6
};
FaceCircumcenterInfo[tobj_TObj,opts___]:=Module[{verts,faces},
{verts,faces}=GetValues[tobj,{Vertices,Faces}];
ConcyclicInfo[verts[[#]],opts]&/@faces
]
Options[FaceCircumscribableQ]={
SamePtTolerance->10^-6
};
FaceCircumscribableQ[tobj_TObj,opts___]:=Module[{verts,faces},
{verts,faces}=GetValues[tobj,{Vertices,Faces}];
And@@(#[[3]]&/@FaceCircumcenterInfo[verts,faces,opts])
]
FaceCircumcenters[tobj_TObj]:=Module[{verts,faces},
{verts,faces}=GetValues[tobj,{Vertices,Faces}];
First/@FaceCircumcenterInfo[tobj]
]
Module[{verts,faces,tobj,fccinfo},
verts={{-2,0.5},{0,-1},{0,1},{3,0.2}};
faces={{1,2,3},{3,2,4}};
tobj=MakeTGraph[verts,{},faces];
fccinfo=FaceCircumcenterInfo[tobj];
Graphics[{
Style[Circle[#[[1]],#[[2]]]&/@fccinfo,Blue],
Style[{PolyLines[verts,faces,Shrinkage->0.99]},Green],
Style[Point/@FaceCentroids[tobj],Orange,AbsolutePointSize[5]],
Style[Point/@FaceCircumcenters[tobj],Gray,AbsolutePointSize[6]],
Style[StdVertexLabels[verts],AbsolutePointSize[4],Red],
Style[{StdFaceLabels[verts,faces]},Darker[Green]],
{}
}]
]//ShowExample
OrientedInteriorEdgePairs::nofaces="The TObj `1` must have nonempty Faces.";
OrientedInteriorEdgePairs[tobj_TObj]:=Module[{verts,edges,faces,tm,epfi,iepfi,iedges,dedges,dverts,signs},
If[!HasFacesQ[tobj],Message[OrientedInteriorEdgePairs::nofaces,tobj];Abort[]];
{verts,edges,faces}=GetValues[tobj,{Vertices,Edges,Faces}];
tm=(Sort/@Transpose[{#,RotateLeft[#]}])&/@faces;
epfi={#,Transpose[Position[tm,#]][[1]]}&/@Union[Flatten[tm,1]];(* list of edge pair, face pair *)
iepfi=Select[epfi,Length[#[[2]]]==2&];(* list of interior edge pair, dual edge pair *)
If[ListEmptyQ[iepfi],Return[{{},{}}]];
{iedges,dedges}=Transpose[iepfi];
iedges = If[MemberQ[edges,#],#,Reverse[#]]&/@iedges;(* match direction to existing edges *)
dverts=FaceCentroids[tobj];
signs=MapThread[Sign[(Subtract@@verts[[#1]]) . Rotate90[Subtract@@dverts[[#2]]]]&,{iedges,dedges}];
{iedges,MapThread[If[#1==-1,#2,Reverse[#2]]&,{signs,dedges}]}
]
Module[{tobj},
tobj=ThreeFoldSquareGraph;
Print[GraphGraphics[tobj]];
Print[tobj[Edges]];
OrientedInteriorEdgePairs[tobj]]//ShowExample
Module[{verts,edges,faces,tobj},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,1}};
faces={{1,2,3,4}};
tobj=MakeTGraph[verts,edges,faces];
OrientedInteriorEdgePairs[tobj]
]//ShowExample
Module[{verts,edges,faces,tobj},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,1}};
faces={};
tobj=MakeTGraph[verts,edges,faces];
OrientedInteriorEdgePairs[tobj]
]//ShowErrorExample
TwoColorableGraphQ[tobj_TObj,opts___]:=Module[{edges,faces,bface,vdeg},
{edges,faces}=GetValues[tobj,{Edges,Faces}];
bface=BoundaryFromFaces[faces];
vdeg=VertexDegreeFromEdges[edges];
And@@MapIndexed[MemberQ[bface,#2[[1]]]||Mod[#1,2]==0&,vdeg]
]
Module[{tobj},
tobj=SimpleSquareTwistGraph;
Print[GraphGraphics[tobj]];
TwoColorableGraphQ[tobj]
]//ShowExample
Module[{tobj},
tobj=SimpleSplitSquareTwistGraph;
Print[GraphGraphics[tobj]];
TwoColorableGraphQ[tobj]
]//ShowExample
StartFace::usage="StartFace is an option to TwoColorGraph that specifies a face to get colored \[PlusMinus]1.";
Options[TwoColorGraph]={
StartFace->1
};
TwoColorGraph::vertdeg="The interior vertices of the graph do not all have even degree.";
TwoColorGraph[tobj_TObj,opts___]:=Module[{edges,faces,sf,pedges,dedges},
AssertClass[tobj,TGraph,TwoColorGraph];
{edges,faces}=GetValues[tobj,{Edges,Faces}];
sf=StartFace/.{opts}/.Options[TwoColorGraph];
If[!TwoColorableGraphQ[edges,faces],Message[TwoColorGraph::vertdeg];Abort[]];
{pedges,dedges}=OrientedInteriorEdgePairs[tobj];
Sign[sf](-1)^#&/@GraphDistance[Graph[dedges],Abs[sf]]]
Module[{verts,edges,faces,tobj,fc},
verts=Flatten[Table[{i-1+0.1(-1)^i,j-1+0.1(-1)^j},{j,4},{i,4}],1];
edges=Join[Flatten[Table[{i+4(j-1),i+1+4(j-1)},{j,4},{i,3}],1],Flatten[Table[{i+4(j-1),i+4(j)},{j,3},{i,4}],1]];
faces={{1,2,6,5},{2,3,7,6},{3,4,8,7},{5,6,10,9},{6,7,11,10},{7,8,12,11},{9,10,14,13},{10,11,15,14},{11,12,16,15}};
tobj=MakeTGraph[verts,edges,faces];
fc=TwoColorGraph[tobj,StartFace->1];
Print[GraphGraphics[tobj,FaceColoring->fc]];
"2-coloring = " <> ToString[fc]
]//ShowExample
FindVertex[tobj_TObj, v_List, opts___]:=Module[{verts},
verts=GetValue[tobj,Vertices];
Catch[Do[If[SamePtQ[verts[[i]],v,opts],Throw[i]],{i,Length[verts]}]]]
Module[{verts,edges,tobj,v,vi,tobj1},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
v={1,0};
FindVertex[tobj, v]
]//ShowExample
Module[{verts,edges,tobj,v,vi,tobj1},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
v={0,1};
FindVertex[tobj, v]
]//ShowExample
AddDistinctVertexData[tobj_TObj, v_List, opts___]:=Module[{verts,vi},
verts=GetValue[tobj,Vertices];
vi=FindVertex[tobj,v,opts];
If[vi===Null,{tobj//ReplaceProperty[Vertices->Append[verts,v]],1+Length[verts]},{tobj,vi}]]
AddDistinctVertex[v_List, opts___]:=AddDistinctVertexData[#,v,opts][[1]]&
Module[{verts,edges,tobj,v,vi,tobj1},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
v={0,1};
{tobj1,vi}=AddDistinctVertexData[tobj,v];
GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1,PlotLabel->"vertex = "<>ToString[vi]]}]
]//ShowExample
Module[{verts,edges,tobj,v,vi,tobj1},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
v={1,1};
{tobj1,vi}=AddDistinctVertexData[tobj,v];
GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1,PlotLabel->"vertex = "<>ToString[vi]]}]
]//ShowExample
FindEdge[tobj_TObj, e_List]:=Module[{edges},
edges=GetValue[tobj,Edges];
Catch[Do[If[SameEdgeQ[edges[[i]],e],Throw[i]],{i,Length[edges]}]]]
Module[{verts,edges,tobj,e,tobj1},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
e={2,3};
FindEdge[tobj, e]
]//ShowExample
Module[{verts,edges,tobj,e,tobj1},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3}};
tobj=MakeTGraph[verts,edges];
e={3,1};
FindEdge[tobj, e]
]//ShowExample
AddDistinctEdgeData[tobj_TObj,e_List]:=Module[{edges,ei},
If[Equal@@e,Return[{tobj,Null}]];
edges=GetValue[tobj,Edges];
ei=FindEdge[tobj,e];
If[ei===Null,{tobj//ReplaceProperty[Edges->Append[edges,e]],1+Length[edges]},{tobj,ei}]]
AddDistinctEdge[e_List]:=AddDistinctEdgeData[#,e][[1]]&
Module[{verts,edges,tobj,e,ei,tobj1},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,1},{1,4}};
tobj=MakeTGraph[verts,edges];
e={3,1};
{tobj1,ei}=AddDistinctEdgeData[tobj,e];
GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1,PlotLabel->"edge = "<>ToString[ei]]}]
]//ShowExample
Module[{verts,edges,tobj,e,ei,tobj1},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,1},{1,4}};
tobj=MakeTGraph[verts,edges];
e={1,2};
{tobj1,ei}=AddDistinctEdgeData[tobj,e];
GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1,PlotLabel->"edge = "<>ToString[ei]]}]
]//ShowExample
Module[{verts,edges,tobj,e,ei,tobj1},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,1},{1,4}};
tobj=MakeTGraph[verts,edges];
e={1,1};
{tobj1,ei}=AddDistinctEdgeData[tobj,e];
GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1,PlotLabel->"edge = "<>ToString[ei]]}]
]//ShowExample
AddDistinctEmbeddedEdgeData[tobj_TObj, {v1_List,v2_List}, opts___]:=Module[{tobj1,vi1,vi2,ei},
{tobj1,vi1}=AddDistinctVertexData[tobj,v1,opts];
{tobj1,vi2}=AddDistinctVertexData[tobj1,v2,opts];
{tobj1,ei}=AddDistinctEdgeData[tobj1,{vi1,vi2}];
{tobj1,{vi1,vi2},ei}]
AddDistinctEmbeddedEdge[{v1_List,v2_List}, opts___]:=AddDistinctEmbeddedEdgeData[#,{v1,v2},opts][[1]]&
Module[{verts,edges,tobj,v1,v2,tobj1,ei,vi1,vi2},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
v1={0,0};
v2={0,1};
{tobj1,{vi1,vi2},ei}=AddDistinctEmbeddedEdgeData[tobj,{v1,v2}];
GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1]}]
]//ShowExample
KillMergedEdges::usage="KillMergedEdges is an option to MergeGraphsData that specifies whether to delete any edges that are duplicates between graphs.";
Options[MergeGraphsData]={
KillMergedEdges->False
};
MergeGraphsData[tglist_List, opts___]:=Module[{kde,verts,vlist,edges,elist,tedges,telist,tedge,tpos,emul,nedges,emap,vmul,nverts,vm,vmap,faces},
AssertClass[#,TGraph,MergeGraphsData]&/@tglist;
kde=KillMergedEdges/.{opts}/.Options[MergeGraphsData];
{verts,vlist}=Indexify[GetValue[#,Vertices]&/@tglist,2,opts];
edges=elist={};
Do[
tedges=tglist[[i]][Edges];
telist={};
Do[
tedge={vlist[[i,tedges[[j,1]]]],vlist[[i,tedges[[j,2]]]]};(* edge, now indexed on verts *)
tpos=Join[Position[edges,tedge],Position[edges,Reverse[tedge]]];
If[tpos=={},
AppendTo[edges,tedge];AppendTo[telist,Length[edges]],
AppendTo[telist,tpos[[1,1]]]]
,{j,Length[tedges]}];
AppendTo[elist,telist];
,{i,Length[tglist]}];
If[kde,
(* look for doubled edges and drop them *)
emul=Table[0,Length[edges]];(* multiplicity of edges *)
Map[emul[[#]]++&,elist,{2}];
nedges={};(* new edges *)
emap=Table[0,{Length[edges]}];(* maps edges to nedges *)
Do[If[emul[[i]]!=2,AppendTo[nedges,edges[[i]]];emap[[i]]=Length[nedges]],{i,Length[edges]}];
edges=nedges;
Do[elist[[i,j]]=emap[[elist[[i,j]]]],{i,Length[elist]},{j,Length[elist[[i]]]}];
(* look for orphan vertices and drop them *)
vmul=Table[0,{Length[verts]}];(* multiplicity of vertices *)
Map[vmul[[#]]++&,nedges,{2}];
nverts={};(* new verts *)
vmap=Table[0,{Length[verts]}];(* maps verts to nverts *)
Do[If[vmul[[i]]>0,AppendTo[nverts,verts[[i]]];vmap[[i]]=Length[nverts]],{i,Length[verts]}];
Do[vlist[[i,j]]=vmap[[vlist[[i,j]]]],{i,Length[vlist]},{j,Length[vlist[[i]]]}];
];
{vlist,elist}]
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,vlist,elist,mgdata,tobj,pr},
verts1={{-1,0.5},{0,0},{0,.5},{0,1}};
edges1={{1,2},{2,3},{3,4},{4,1}};
faces1={{1,2,3,4}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{0,0},{1,.5},{0,1},{0,.5}};
edges2={{1,2},{2,3},{3,4},{4,1}};
faces2={{1,2,3,4}};
tobj2=MakeTGraph[verts2,edges2,faces2];
mgdata=MergeGraphsData[{tobj1,tobj2}];
Print["vlist = ",mgdata[[1]]];
Print["elist = ",mgdata[[2]]];
pr={{-1,1},{0,1}};
GraphicsColumn[{
GraphGraphics[tobj1,PlotLabel->"Graph 1",Frame->True,PlotRange->pr],
GraphGraphics[tobj2,PlotLabel->"Graph 2",Frame->True,PlotRange->pr]
}]
]//ShowExample
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,vlist,elist,mgdata,tobj,pr},
verts1={{-1,0.5},{0,0},{0,.5},{0,1}};
edges1={{1,2},{2,3},{3,4},{4,1}};
faces1={{1,2,3,4}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{0,0},{1,.5},{0,1},{0,.5}};
edges2={{1,2},{2,3},{3,4},{4,1}};
faces2={{1,2,3,4}};
tobj2=MakeTGraph[verts2,edges2,faces2];
mgdata=MergeGraphsData[{tobj1,tobj2},KillMergedEdges->True];
Print["vlist = ",mgdata[[1]]];
Print["elist = ",mgdata[[2]]];
pr={{-1,1},{0,1}};
GraphicsColumn[{
GraphGraphics[tobj1,PlotLabel->"Graph 1",Frame->True,PlotRange->pr],
GraphGraphics[tobj2,PlotLabel->"Graph 2",Frame->True,PlotRange->pr]
}]
]//ShowExample
ApplyMergeTo[tglist_List,mgdata_List]:=Module[{vlist,elist,nverts,vm,nedges},
{vlist,elist}=mgdata;
(* new vertices *)
nverts=Table[{0,0},{Range[Max[Flatten[vlist]]]}];
MapIndexed[If[#1!=0,nverts[[#1]]=tglist[[#2[[1]]]][Vertices][[#2[[2]]]]]&,vlist,{2}];
(* vm[{i,j}] gives new vertex index from jth vertex of ith graph *)
MapIndexed[(vm[{#2[[1]],#2[[2]]}]=#1)&,vlist,{2}];
(* new edges *)
nedges=Table[{0,0},{Range[Max[Flatten[elist]]]}];
MapIndexed[If[#1!=0,nedges[[#1]]=vm/@Transpose[{{#2[[1]],#2[[1]]},tglist[[#2[[1]]]][Edges][[#2[[2]]]]}]]&,elist,{2}];
MakeTGraph[nverts,nedges]]
ApplyMerge[mgdata_List]:=ApplyMergeTo[#,mgdata]&;
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,tglist,mgdata,tobj,pr},
verts1={{-1,0.5},{0,0},{0,.5},{0,1}};
edges1={{1,2},{2,3},{3,4},{4,1}};
faces1={{1,2,3,4}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{0,0},{1,.5},{0,1},{0,.5}};
edges2={{1,2},{2,3},{3,4},{4,1}};
faces2={{1,2,3,4}};
tobj2=MakeTGraph[verts2,edges2,faces2];
mgdata=MergeGraphsData[{tobj1,tobj2}];
Print["vlist = ",mgdata[[1]]];
Print["elist = ",mgdata[[2]]];
tglist={tobj1,tobj2};
tobj=tglist//ApplyMerge[mgdata];
pr={{-1,1},{0,1}};
GraphicsColumn[{
GraphGraphics[tobj1,PlotLabel->"Graph 1",Frame->True,PlotRange->pr],
GraphGraphics[tobj2,PlotLabel->"Graph 2",Frame->True,PlotRange->pr],
GraphGraphics[tobj,PlotLabel->"Merged",Frame->True,PlotRange->pr]
}]
]//ShowExample
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,tglist,mgdata,tobj,pr},
verts1={{-1,0.5},{0,0},{0,.5},{0,1}};
edges1={{1,2},{2,3},{3,4},{4,1}};
faces1={{1,2,3,4}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{0,0},{1,.5},{0,1},{0,.5}};
edges2={{1,2},{2,3},{3,4},{4,1}};
faces2={{1,2,3,4}};
tobj2=MakeTGraph[verts2,edges2,faces2];
tglist={tobj1,tobj2};
mgdata=MergeGraphsData[tglist,KillMergedEdges->True];
Print["vlist = ",mgdata[[1]]];
Print["elist = ",mgdata[[2]]];
tobj=tglist//ApplyMerge[mgdata];
pr={{-1,1},{0,1}};
GraphicsColumn[{
GraphGraphics[tobj1,PlotLabel->"Graph 1",Frame->True,PlotRange->pr],
GraphGraphics[tobj2,PlotLabel->"Graph 2",Frame->True,PlotRange->pr],
GraphGraphics[tobj,PlotLabel->"Merged",Frame->True,PlotRange->pr]
}]
]//ShowExample
GetMergedEdges[elist_List]:=Module[{fe,ne},
fe=Flatten[elist];
ne=Max[fe];
First/@ Select[Table[{i,Count[fe,i]},{i,ne}],#[[2]]==2&]]
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,tglist,mgdata,tobj,pr},
verts1={{-1,0.5},{0,0},{0,.5},{0,1}};
edges1={{1,2},{2,3},{3,4},{4,1}};
faces1={{1,2,3,4}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{0,0},{1,.5},{0,1},{0,.5}};
edges2={{1,2},{2,3},{3,4},{4,1}};
faces2={{1,2,3,4}};
tobj2=MakeTGraph[verts2,edges2,faces2];
tglist={tobj1,tobj2};
mgdata=MergeGraphsData[tglist];
Print["vlist = ",mgdata[[1]]];
Print["elist = ",mgdata[[2]]];
Print["merged edges = ",GetMergedEdges[mgdata[[2]]]];
tobj=tglist//ApplyMerge[mgdata];
pr={{-1,1},{0,1}};
GraphicsColumn[{
GraphGraphics[tobj1,PlotLabel->"Graph 1",Frame->True,PlotRange->pr],
GraphGraphics[tobj2,PlotLabel->"Graph 2",Frame->True,PlotRange->pr],
GraphGraphics[tobj,PlotLabel->"Merged",Frame->True,PlotRange->pr]
}]
]//ShowExample
MergeGraphs[tglist_List,opts___]:=Module[{mgdata},
mgdata=MergeGraphsData[tglist,opts];
tglist//ApplyMerge[mgdata]]
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,vlist,elist,tobj},
verts1={{-1,0.5},{0,0},{0,1}};
edges1={{1,2},{2,3},{3,1}};
faces1={{1,2,3}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{0,0},{1,.5},{0,1}};
edges2={{1,2},{2,3},{3,1}};
faces2={{1,2,3}};
tobj2=MakeTGraph[verts2,edges2,faces2];
tobj=MergeGraphs[{tobj1,tobj2}];
GraphicsRow[{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Merged"]
}]
]//ShowExample
JoinGraphsData[graphspecs_List]:=Module[{tglist,i,j1,j2,k1,k2,vertsj,vertsk,rm,offset},
tglist=#[[1]]&/@graphspecs;
AssertClass[#,TGraph,JoinGraphsData]&/@tglist;
Do[
{i,j1,j2,k1,k2}=Flatten[graphspecs[[l,2]]];
vertsj=tglist[[i]][Vertices];
vertsk=tglist[[l]][Vertices];
{rm,offset}=SimilarityPair2D[vertsk[[{k1,k2}]],vertsj[[{j1,j2}]]];
vertsk=(offset+rm . #)&/@vertsk;
tglist[[l]]=tglist[[l]]//ReplaceProperty[Vertices->vertsk];
,{l,2,Length[tglist]}];
tglist]
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,vlist,elist,tobj,tglist},
verts1={{.1,.1},{.9,.1},{.2,1}};
edges1={{1,2},{2,3},{3,1}};
faces1={{1,2,3}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{.1,.2},{.9,.2},{1,.7}};
edges2={{1,2},{2,3},{3,1}};
faces2={{1,2,3}};
tobj2=MakeTGraph[verts2,edges2,faces2];
tglist=JoinGraphsData[{{tobj1,{}},{tobj2,{1,{2,3},{1,3}}}}];
tobj=MergeGraphs[tglist];
GraphicsRow[{
GraphGraphics[tobj1,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Graph 1"],
GraphGraphics[tobj2,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Graph 2"],
GraphGraphics[tobj,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Joined"]
}]
]//ShowExample
JoinGraphs[graphspecs_List,opts___]:=Module[{tglist},
tglist=JoinGraphsData[graphspecs];
MergeGraphs[tglist,opts]]
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,vlist,elist,tobj,tglist},
verts1={{.1,.1},{.9,.1},{.2,1}};
edges1={{1,2},{2,3},{3,1}};
faces1={{1,2,3}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{.1,.2},{.9,.2},{1,.7}};
edges2={{1,2},{2,3},{3,1}};
faces2={{1,2,3}};
tobj2=MakeTGraph[verts2,edges2,faces2];
tobj=JoinGraphs[{{tobj1,{}},{tobj2,{1,{2,3},{1,3}}}}];
GraphicsRow[{
GraphGraphics[tobj1,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Graph 1"],
GraphGraphics[tobj2,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Graph 2"],
GraphGraphics[tobj,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Joined"]
}]
]//ShowExample
Module[{verts1,edges1,faces1,tobj1,verts2,edges2,faces2,tobj2,vlist,elist,tobj,tglist},
verts1={{.1,.1},{.9,.1},{.2,1}};
edges1={{1,2},{2,3},{3,1}};
faces1={{1,2,3}};
tobj1=MakeTGraph[verts1,edges1,faces1];
verts2={{.1,.2},{.9,.2},{1,.7}};
edges2={{1,2},{2,3},{3,1}};
faces2={{1,2,3}};
tobj2=MakeTGraph[verts2,edges2,faces2];
tobj=JoinGraphs[{{tobj1,{}},{tobj2,{1,{2,3},{1,3}}}},KillMergedEdges->True];
GraphicsRow[{
GraphGraphics[tobj1,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Graph 1"],
GraphGraphics[tobj2,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Graph 2"],
GraphGraphics[tobj,Axes->True,PlotRange->{{0,1},{0,1}},PlotLabel->"Joined"]
}]
]//ShowExample
CollinearTolerance::usage="CollinearTolerance is an option to CollinearCleanupData that specifies the angle between two lines below which they are taken to be collinear.";
Options[CollinearCleanupData]={
CollinearTolerance->10^-6
};
CollinearCleanupData[tobj_TObj,opts___]:=Module[{ct,sct,verts,edges,fe,d2vs,epair,rpair,vr,j1,j2,erep,iedges,nverts,vlist,vm,elist,nedges},
AssertClass[tobj,TGraph,CollinearCleanupData];
ct=CollinearTolerance/.{opts}/.Options[CollinearCleanupData];
sct=Sin[ct];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
(* get indices of all degree-2 vertices *)
fe=Flatten[edges];
d2vs=First/@Select[Table[{i,Count[fe,i]},{i,Length[verts]}],#[[2]]==2&];
(* compute which vertices to absorb and their incident edges *)
iedges=MapIndexed[{#1,#2[[1]]}&,edges];
Do[epair=Select[iedges,MemberQ[#[[1]],d2vs[[i]]]&];
rpair=Normalize[Subtract@@verts[[#[[1]]]]]&/@epair;
If[Abs[rpair[[1]] . Rotate90[rpair[[2]]]]<sct,
vr=d2vs[[i]];(* vertex to remove *)
j1=epair[[1,2]];(* edge to replace *)
j2=epair[[2,2]];(* edge to remove *)
erep=Select[Flatten[First/@epair],#!=vr&];(* replacement edge *)
verts[[vr]]=Null;
edges[[j1]]={Null,True,{j1,j2},erep};
edges[[j2]]={Null,False};
],{i,Length[d2vs]}];
(* build new list of vertices, vlist (new\[Rule]old) and vm (old\[Rule]new) *)
nverts=vlist={};
Do[If[!verts[[i]]===Null,
AppendTo[nverts,verts[[i]]];
AppendTo[vlist,i];
vm[i]=Length[nverts]],{i,Length[verts]}];
(* build new list of edges and elist *)
nedges=elist={};
Do[If[!edges[[j,1]]===Null,
AppendTo[nedges,edges[[j]]];
AppendTo[elist,{j}],
If[edges[[j,2]],
AppendTo[elist,edges[[j,3]]];
AppendTo[nedges,edges[[j,4]]]
]],{j,Length[edges]}];
(* re-map new edges to new vertices *)
nedges=Map[vm,nedges,{2}];
{vlist,elist}]
Module[{verts,edges,tobj,ccdata},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
tobj=MakeTGraph[verts,edges];
ccdata=CollinearCleanupData[tobj];
Print["vlist = ",ccdata[[1]]];
Print["elist = ",ccdata[[2]]];
GraphGraphics[tobj]
]//ShowExample
ApplyCollinearCleanupTo[tobj_TObj,ccdata_List]:=Module[{vlist,elist,verts,edges,vm,nverts,nedges,evs},
{vlist,elist}=ccdata;
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
(* new vertices *)
nverts=verts[[#]]&/@vlist;
(* vm maps old vertex index to new vertex index *)
MapIndexed[(vm[#1]=#2[[1]])&,vlist];
(* new edges in terms of old vertices *)
nedges={};
Do[If[Length[elist[[i]]]==1,
AppendTo[nedges,edges[[elist[[i,1]]]]],
evs=Flatten[edges[[elist[[i]]]]];
AppendTo[nedges,First/@Select[{#,Count[evs,#]}&/@evs,#[[2]]==1&]]],{i,Length[elist]}];
(* put new edges in terms of new vertices *)
nedges=Map[vm,nedges,{2}];
(* replace verts, edges, and faces, keep everything else *)
tobj//ReplaceProperties[{Vertices->nverts,Edges->nedges,Faces->{}}]]
ApplyCollinearCleanup[ccdata_List]:=ApplyCollinearCleanupTo[#,ccdata]&;
Module[{verts,edges,tobj,ccdata,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
tobj=MakeTGraph[verts,edges];
ccdata=CollinearCleanupData[tobj];
Print["vlist = ",ccdata[[1]]];
Print["elist = ",ccdata[[2]]];
tobj1=tobj//ApplyCollinearCleanup[ccdata];
GraphicsColumn[{GraphGraphics[tobj],GraphGraphics[tobj1]}]
]//ShowExample
CollinearCleanupGraph[tobj_TObj,opts___]:=Module[{ccdata},
AssertClass[tobj,TGraph,CollinearCleanupGraph];
ccdata=CollinearCleanupData[tobj,opts];
tobj//ApplyCollinearCleanup[ccdata]]
Module[{verts,edges,tobj,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
tobj=MakeTGraph[verts,edges];
tobj1=CollinearCleanupGraph[tobj];
GraphicsColumn[{GraphGraphics[tobj],GraphGraphics[tobj1]}]
]//ShowExample
Options[GraphicsToTGraph]={
SamePtTolerance -> 10^-6
};
GraphicsToTGraph::dupvert="The extracted edges `1` contain at least one edge with duplicate vertices `2`.";
GraphicsToTGraph[obj_,opts___]:=Module[{tol,fif,llist,verts,edges,tobj},
tol=SamePtTolerance/.{opts}/.Options[GraphicsToTGraph];
fif=AddTPlaneGraphTo/.{opts}/.Options[GraphicsToTGraph];
llist=ExtractFracturedLines[obj];
{verts,edges}=Indexify[First/@llist,2,SamePtTolerance->tol];
If[!Union[Length/@Union/@edges]==={2},Message[GraphicsToTGraph::dupvert,edges,verts]];
MakeTGraph[verts,edges]]
Module[{cp,tobj},
cp=Graphics[{{Style[Polygon[{{0,0},{1,0},{1,1},{0,1}}],LightGray],Style[Polygon[{{0,0},{0,1},{-0.8`,-1},{-0.4`,-1}}],LightGray],Style[Polygon[{{1,0},{0,0},{2,-0.8`},{2,-0.4`}}],LightGray],Style[Polygon[{{1,1},{1,0},{1.8`,2},{1.4`,2}}],LightGray],Style[Polygon[{{0,1},{1,1},{-1,1.8`},{-1,1.4`}}],LightGray],Style[Polygon[{{0,0},{-0.4`,-1},{2,-1},{2,-0.8`}}],LightGray],Style[Polygon[{{1,0},{2,-0.4`},{2,2},{1.8`,2}}],LightGray],Style[Polygon[{{1,1},{1.4`,2},{-1,2},{-1,1.8`}}],LightGray],Style[Polygon[{{0,1},{-1,1.4`},{-1,-1},{-0.8`,-1}}],LightGray]},{Style[Line[{{0,0},{1,0}}],Red],Style[Line[{{1,0},{1,1}}],Blue],Style[Line[{{0,1},{1,1}}],Blue],Style[Line[{{0,0},{0,1}}],Red],Style[Line[{{0,0},{-0.4`,-1}}],Red],Style[Line[{{0,1},{-0.8`,-1}}],Blue],Style[Line[{{2,-0.4`},{1,0}}],Red],Style[Line[{{2,-0.8`},{0,0}}],Blue],Style[Line[{{1,1},{1.4`,2}}],Blue],Style[Line[{{1,0},{1.8`,2}}],Red],Style[Line[{{0,1},{-1,1.4`}}],Blue],Style[Line[{{1,1},{-1,1.8`}}],Red],Style[Line[{{-1,-1},{-0.8`,-1}}],Black],Style[Line[{{-0.8`,-1},{-0.4`,-1}}],Black],Style[Line[{{-0.4`,-1},{2,-1}}],Black],Style[Line[{{2,-1},{2,-0.8`}}],Black],Style[Line[{{2,-0.8`},{2,-0.4`}}],Black],Style[Line[{{2,-0.4`},{2,2}}],Black],Style[Line[{{2,2},{1.8`,2}}],Black],Style[Line[{{1.8`,2},{1.4`,2}}],Black],Style[Line[{{1.4`,2},{-1,2}}],Black],Style[Line[{{-1,2},{-1,1.8`}}],Black],Style[Line[{{-1,1.8`},{-1,1.4`}}],Black],Style[Line[{{-1,1.4`},{-1,-1}}],Black]}}];
tobj=GraphicsToTGraph[cp];
GraphicsRow[{
cp,
GraphGraphics[tobj]}]
]//ShowExample
PolygonMeshRegionToTGraph[mreg_MeshRegion]:=Module[{verts,faces,edges},
verts=MeshCoordinates[mreg];
faces=MeshCells[mreg,2]/.Polygon[pp_]:>pp;
edges=EdgesFromFaces[faces];
MakeTGraph[verts,edges,faces]]
Module[{pts,vm,tobj},
SeedRandom[1];
pts=RandomReal[{-1,1},{20,2}];
vm=VoronoiMesh[pts];
Print[vm];
tobj=PolygonMeshRegionToTGraph[vm];
GraphGraphics[tobj]
]//ShowExample
FlopDirection::usage="FlopDirection is an option to FlopGraph that specifies the direction of flopping of the crease pattern.";
Options[FlopGraph]={
FlopDirection->Horizontal
};
FlopGraph[tobj_, opts___]:=Module[{fd,verts,faces,ctr},
AssertClass[tobj,TGraph,FlopGraph];
fd=FlopDirection/.{opts}/.Options[FlopGraph];
hori=(fd===Horizontal);
{verts,faces}=GetValues[tobj,{Vertices,Faces}];
ctr={(Max[#1]+Min[#1])/2,(Max[#2]+Min[#2])/2}&@@Transpose[verts];
If[fd===Horizontal,
verts=ctr+ReflectionYMatrix2D . (#-ctr)&/@verts,
verts=ctr+ReflectionXMatrix2D . (#-ctr)&/@verts];
faces=Reverse/@faces;
tobj//ReplaceProperties[{Vertices->verts,Faces->faces}]]
Module[{tobj,tobjh,tobjv},
tobj=SingleVertexGraph;
tobjh=FlopGraph[tobj];
tobjv=FlopGraph[tobj,FlopDirection->Vertical];
GraphicsRow[{
GraphGraphics[tobj,PlotLabel->"Original"],
GraphGraphics[tobjh,PlotLabel->"Horizontal"],
GraphGraphics[tobjv,PlotLabel->"Vertical"]
}]]//ShowExample
RotateGraph[tobj_,\[Phi]_]:=Module[{verts,ctr,rr},
AssertClass[tobj,TGraph,RotateGraph];
verts=GetValue[tobj,Vertices];
ctr={(Max[#1]+Min[#1])/2,(Max[#2]+Min[#2])/2}&@@Transpose[verts];
rr=RotationMatrix2D[\[Phi]];
verts=ctr+rr . (#-ctr)&/@verts;
tobj//ReplaceProperty[Vertices->verts]]
Module[{tobj,tobjr},
tobj=SingleVertexGraph;
tobjr=RotateGraph[tobj,15\[Degree]];
GraphicsRow[{
GraphGraphics[tobj,PlotLabel->"Original"],
GraphGraphics[tobjr,PlotLabel->"Rotated"]
}]]//ShowExample
TPlaneGraph::usage="TPlaneGraph is a TObj class that represents a planar graph and a particular plane embedding.";
RegisterTClass[TPlaneGraph,{TGraph}];
InteriorVertices::usage="InteriorVertices is a TObj property that specifies the interior vertices of the plane graph.";
BoundaryVertices::usage="BoundaryVertices is a TObj property that specifies the vertices by index around the boundary of the plane graph in CCW order.";
BoundaryEdges::usage="BoundaryEdges is a TObj property that specifies the edges as by index around the boundary of the plane graph in CCW order.";
BoundaryFaces::usage="BoundaryFaces is a TObj property that specifies the incident faces by index around the boundary of the plane graph in CCW order.";
VertexVertexAdjacency::usage="VertexVertexAdjacency is a TObj property that specifies the adjacent vertices around a vertex in CCW order.";
VertexEdgeIncidence::usage = "VertexEdgeIncidence is a TObj property that specifies the edges incident around a vertex in CCW order.";
VertexFaceIncidence::usage="VertexFaceIncidence is a TObj property that specifies the faces around a vertex in CCW order.";
EdgeEdgeAdjacency::usage="EdgeEdgeAdjacency is a TObj property that specifies the edges around the vertices at each end of each edge, in CCW order.";
EdgeFaceIncidence::usage="EdgeFaceIncidence is a TObj property that specifies the faces to right and left of each edge in a plane graph.";
FaceEdgeIncidence::usage="FaceEdgeIncidence is a TObj property that specifies the edges around a face in a plane graph.";
ExistingFacesWarning::usage="ExistingFacesWarning is an options to AddTPlaneGraphTo that specifies whether to issue a warning if existing Faces data is overwritten.";
Options[AddTPlaneGraphTo]={
ExistingFacesWarning->True
};
AddTPlaneGraphTo::hasfaces="Warning: TObj `1` already has Faces data. It will be overwritten.";
AddTPlaneGraphTo::badwinding="TObj `1` does not have a face cycle with a winding number of -1. Cycles are `2`.";
AddTPlaneGraphTo[tobj_TObj, opts___]:=Module[{efw,verts, edges,vva,vei,emap,nhefn,cycles,halfedges,curedge,curcycle,cycwin,wnos,nplus,nminus,faces,iverts,bverts,bedges,bfaces,ib,allfaces,starpp,facepp,edgepp,efifn,vfifn,vfi,efi,fei,,va,vb,eea},
AssertClass[tobj,TGraph,AddTPlaneGraphTo];
efw=ExistingFacesWarning/.{opts}/.Options[AddTPlaneGraphTo];
If[efw && HasFacesQ[tobj],Message[AddTPlaneGraphTo::hasfaces,tobj]];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];

(* compute VertexVertexAdjacency *)
vva=VertexVertexAdjacencyFromVerticesAndEdges[verts,edges];

(* build a lookup function that returns edge index for either order of the edge *)
Do[emap[edges[[i]]]=i,{i,Length[edges]}];
Do[emap[Reverse[edges[[i]]]]=i,{i,Length[edges]}];

(* compute VertexEdgeAdjacency *)
vei=Table[emap[{i,#}]&/@vva[[i]],{i,Length[vva]}];

(* compute cycles of vertex adjacency and from that, extract Faces and BoundaryVertices *)
nhefn[{i_,j_}]:={j,vva[[j,Mod[Position[vva[[j]],i][[1,1]]-1,Length[vva[[j]]],1]]]};(* nhefn returns next half-edge in a cycle *)
(* build all CCW cycles. Note that one will be retrograde, which is the boundary. *)
curedge={};
curcycle={};
cycles={};
halfedges=Join[edges,Reverse/@edges];
While[Length[halfedges]>0,
If[curedge=={},
(* start a new cycle from a halfedge *)
curedge=halfedges[[1]];
halfedges=DropFirst[halfedges];
curcycle={curedge},
(* continue the existing cycle *)
curedge=nhefn[curedge];
If[MemberQ[halfedges,curedge],
(* add this edge to the cycle and continue *)
AppendTo[curcycle,curedge];
halfedges=DeleteItem[halfedges,curedge],
(* else close the cycle *)
AppendTo[cycles,Transpose[curcycle][[1]]];
curcycle={};
curedge={};
]]];
AppendTo[cycles,Transpose[curcycle][[1]]];(* last one *)
(* now sort by winding number to get faces, boundary, and interior vertices *)
cycwin={#,WindingNumber[verts,#]}&/@cycles;

wnos=#[[2]]&/@cycwin;(* just winding numbers *)
nplus=Count[wnos,1];(* number of +1 *)
nminus=Count[wnos,-1];(* number of -1 *)
If[nminus!=1,Message[AddTPlaneGraphTo::badwinding,tobj,cycwin];Abort[]];

faces=First/@Select[cycwin,#[[2]]==1&]; (* faces have winding # = 1 *)
bverts=Reverse[First[First/@Select[cycwin,#[[2]]==-1&]]]; (* reverse boundary so it's also CCW *)
iverts=Select[Range[Length[verts]],!MemberQ[bverts,#]&];(* interior vertices *)

(* compute BoundaryEdges *)
bedges=emap/@Transpose[{bverts,RotateLeft[bverts]}];

(* compute VertexFaceIncidence *)
allfaces=Append[faces,Reverse[bverts]]; (* in this list, boundary is the last face *)
ib=1+Length[faces];
starpp=Table[Transpose[{vva[[i]],Table[i,{Length[vva[[i]]]}],RotateRight[vva[[i]]]}],{i,Length[vva]}];
facepp=Flatten[Table[{#,i}&/@Transpose[{RotateRight[allfaces[[i]]],allfaces[[i]],RotateLeft[allfaces[[i]]]}],{i,Length[allfaces]}],1];
(vfifn[#[[1]]]=#[[-1]])&/@facepp;
vfi =RotateLeft/@Map[vfifn,starpp,{2}]/.ib->0; 

(* compute EdgeFaceIncidence *)
edgepp=Flatten[Table[{#,i}&/@Transpose[{allfaces[[i]],RotateRight[allfaces[[i]]]}],{i,Length[allfaces]}],1];
(efifn[#[[1]]]=#[[2]])&/@edgepp;(* gives face to the right of an edge *)
efi={efifn[#],efifn[Reverse[#]]}&/@edges/.ib->0; 

(* compute BoundaryFaces *)
bfaces=Map[If[#[[1]]==0,#[[2]],#[[1]]]&,efi[[#]]&/@bedges];

(* Compute FaceEdgeIncidence *)
fei=Map[emap,Transpose[{#,RotateLeft[#]}]&/@faces,{2}];

(* Compute EdgeEdgeAdjacency *)
eea=Table[
{va,vb}=edges[[i]];
{Drop[RotateLeft[vei[[va]],Position[vei[[va]],i][[1,1]]-1],1],Drop[RotateLeft[vei[[vb]],Position[vei[[vb]],i][[1,1]]-1],1]}
,{i,Length[edges]}];

AddClassTo[tobj,TPlaneGraph,{Faces->faces,InteriorVertices->iverts,BoundaryVertices->bverts,BoundaryEdges->bedges,BoundaryFaces->bfaces,VertexVertexAdjacency->vva,VertexEdgeIncidence->vei,VertexFaceIncidence->vfi,EdgeEdgeAdjacency->eea,EdgeFaceIncidence->efi,FaceEdgeIncidence->fei}]
]
AddTPlaneGraph:=AddTPlaneGraphTo[#]&
RebuildPlaneGraph:=AddTPlaneGraphTo[#,ExistingFacesWarning->False]&
MakeTPlaneGraph[verts_List,edges_List,faces_List:{}]:=MakeTGraph[verts,edges]//AddTPlaneGraph
Module[{tobj,tobj1},
tobj=CrossedSquareGraphNoFaces;
tobj1=AddTPlaneGraphTo[tobj];
Print[GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1]}]];
ColumnForm[GetAllRules[tobj1]]
]//ShowExample
Module[{tobj,tobj1},
tobj=ThreeFoldSquareGraphNoFaces;
tobj1=tobj//AddTPlaneGraph;
Print[GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1]}]];
ColumnForm[GetAllRules[tobj1]]
]//ShowExample
Module[{verts,edges,tobj,tobj1,faces,vva,boundary},
verts=Flatten[Table[N[{i-1,j-1}],{j,4},{i,4}],1];
edges=Join[Flatten[Table[{i+4(j-1),i+1+4(j-1)},{j,4},{i,3}],1],Flatten[Table[{i+4(j-1),i+4(j)},{j,3},{i,4}],1]];
tobj=MakeTGraph[verts,edges];
tobj1=MakeTPlaneGraph[verts,edges];
Print[GraphicsRow[{GraphGraphics[tobj],GraphGraphics[tobj1]}]];
ColumnForm[GetAllRules[tobj1]]
]//ShowExample
Module[{n,verts,edges,tobj,tobj1},
n=3;
verts=Flatten[Table[N[{i-1,j-1}],{j,n+1},{i,n+1}],1];
edges=Join[Flatten[Table[{i+(n+1)(j-1),i+1+(n+1)(j-1)},{j,n+1},{i,n}],1],Flatten[Table[{i+(n+1)(j-1),i+(n+1)(j)},{j,n},{i,(n+1)}],1]];
tobj=MakeTPlaneGraph[verts,edges];
GraphGraphics[tobj]
]//ShowExample
Module[{verts,edges,faces,tobj},
verts={{0,0},{1,0},{2,0},{0,1},{1,1},{2,1},{0,2},{1,2},{2,2},{1,0}};
edges={{1,2},{10,3},{4,5},{5,6},{7,8},{8,9},{1,4},{2,5},{3,6},{4,7},{5,8},{6,9},{5,10}};
faces={{1,2,5,4},{10,3,6,5},{4,5,8,7},{5,6,9,8}};
tobj=MakeTPlaneGraph[verts,edges,faces];
GraphGraphics[tobj]
]//ShowExample
EdgeFaceAngles[tobj_TObj]:=Module[{verts,faces,efi,fwn,fpair},
{verts,faces,efi}=GetValues[tobj,{Vertices,Faces,EdgeFaceIncidence}];
fwn=WindingNumber[verts,#]&/@faces;(* winding number of each face *)
Table[
fpair=efi[[i]];
If[MemberQ[fpair,0],
0,
If[fwn[[fpair[[1]]]]== fwn[[fpair[[2]]]],0,\[Pi]]]
,{i,Length[efi]}]]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{2,0},{3,1},{4,1},{4,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,3},{4,7},{7,8},{8,1},{7,2}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph;
Print[GraphGraphics[tobj]];
EdgeFaceAngles[tobj]
]//ShowExample
VertexEdgeAngles[tobj_TObj]:=Module[{verts,vva,vfi,ra,vfa},
{verts,vva,vfi}=GetValues[tobj,{Vertices,VertexVertexAdjacency,VertexFaceIncidence}];
Table[
ra=(verts[[#]]-verts[[i]])&/@vva[[i]];
vfa=MapThread[RotationAngle,{ra,RotateLeft[ra]}];
MapThread[If[#1==0,Null,#2]&,{vfi[[i]],vfa}]
,{i,Length[vva]}]]
Module[{tobj},
tobj=SingleVertexGraph//RebuildPlaneGraph;
Print[GraphGraphics[tobj]];
VertexEdgeAngles[tobj]
]//ShowExample
Module[{tobj},
tobj=ThreeFoldSquareGraph//RebuildPlaneGraph;
Print[GraphGraphics[tobj]];
VertexEdgeAngles[tobj]
]//ShowExample
Module[{verts,edges,faces,tobj},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph;
Print[GraphGraphics[tobj]];
VertexEdgeAngles[tobj]
]//ShowExample
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1/2,1/2},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,1}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph;
Print[GraphGraphics[tobj]];
VertexEdgeAngles[tobj]
]
SingleVertexEdgeAngles::badedge="Vertex `1` is not adjacent to vertex `2`.";
SingleVertexEdgeAngles[tobj_TObj, i0_, i1_]:=Module[{verts,vva,vfi,va,vfa},
{verts,vva,vfi}=GetValues[tobj,{Vertices,VertexVertexAdjacency,VertexFaceIncidence}];
If[!MemberQ[vva[[i0]],i1],Message[SingleVertexEdgeAngles::badedge,i1,i0];Abort[]];
va=AbsoluteAngle[verts[[#]]-verts[[i0]]]&/@vva[[i0]];
vfa=Abs[Mod[Subtract@@#,2\[Pi],-\[Pi]]]&/@Transpose[{RotateLeft[va],va}];
vfa=MapThread[If[#1==0,Null,#2]&,{vfi[[i0]],vfa}];
RotateLeft[vfa,Position[vva[[i0]],i1,1,1][[1,1]]-1]]
Module[{tobj},
tobj=SingleVertexGraph//RebuildPlaneGraph;
Print[GraphGraphics[tobj]];
SingleVertexEdgeAngles[tobj,1,2]
]//ShowExample
Module[{tobj},
tobj=ThreeFoldSquareGraph//RebuildPlaneGraph;
Print[GraphGraphics[tobj]];
SingleVertexEdgeAngles[tobj,10,9]
]//ShowExample
EdgeVertexAngles[tobj_TObj]:=Module[{edges,vei,vea,ia,ib,veaa,veab},
{edges,vei}=GetValues[tobj,{Edges,VertexEdgeIncidence}];
vea=VertexEdgeAngles[tobj];
Table[
{ia,ib}=edges[[i]];
veaa=RotateLeft[vea[[ia]],Position[vei[[ia]],i][[1,1]]-1];(* edge angles around vertex ia *)
veab=RotateLeft[vea[[ib]],Position[vei[[ib]],i][[1,1]]-1];(* edge angles around vertex ib *)
{{veaa[[1]],veaa[[-1]]},{veab[[1]],veab[[-1]]}}
,{i,Length[edges]}]]
Module[{tobj},
tobj=SingleVertexGraph//RebuildPlaneGraph;
Print[GraphGraphics[tobj]];
Print[tobj[Edges]];
EdgeVertexAngles[tobj]
]//ShowExample
SplitEdges[tobj_TObj,sedges_List]:=Module[{verts,edges,faces,bv,be,vei,vfi,vva,fei,
vev,sverts,nfaces,nverts,nedges},
AssertClass[tobj,TPlaneGraph,SplitEdges];
{verts,edges,faces,bv,be,vei,vfi,vva,fei}=GetValues[tobj,{Vertices,Edges,Faces,BoundaryVertices,BoundaryEdges,VertexEdgeIncidence,VertexFaceIncidence,VertexVertexAdjacency,FaceEdgeIncidence}];
(* vev is a list of {e,v} pairs ordered around each vertex where e is the incident edge, v is the opposite vertex across v. *)
vev = Transpose/@Transpose[{vei,vva}];
(* sverts is the list of vertices to split *)
sverts={};
Do[Module[{nse,vbv,sv},
nse=Length[Intersection[sedges,First/@vev[[i]]]];(* num incident split edges *)
vbv=MemberQ[bv,i];(* True if vertex is on boundary *)
sv=!((nse==0)||(nse==1&&!vbv)); (* whether to split the vertex *)
If[sv,AppendTo[sverts,i]]],{i,Length[verts]}];
(* nfaces is the list of faces after the split (i.e., with new vertex indices). *)
nfaces=faces;
(* nverts are the indices of new vertices, indexed into verts *)
nverts=Range[Length[verts]];
(* Go through all split vertices and substitute new vertex indices into nfaces as appropriate. *)
Do[Module[{vv,vvei,vvfi,rpos,nv,prevnum,added},
vv=sverts[[i]];
vvei=vei[[vv]];
vvfi=vfi[[vv]];
(* Always start going around a vertex from a face that is CCW from either a boundary edge or a split edge. rpos is the position of the first edge in vvei that is one of those. Boundary gets priority. *)
rpos=Position[MemberQ[be,#]&/@vvei,True];
If[ListEmptyQ[rpos],
rpos=Position[MemberQ[sedges,#]&/@vvei,True][[1,1]],
rpos=rpos[[1,1]]];
vvei=RotateLeft[vvei,rpos-1];
vvfi=RotateLeft[vvfi,rpos-1];
(* Now go through the faces and edges around the vertex, creating new vertices as needed. *)
nv=vv;(* index of the current new vertex (which starts as the old vertex). *)
prevnum=Length[nverts];(* record the previous number *)
Do[Module[{pe,cf},
pe=vvei[[j]];(* index of edge preceding current face *)
cf=vvfi[[j]];(* index of the current face *)
If[cf==0,Continue[]];(* do nothing for the border face *)
If[MemberQ[sedges,pe],
(* if preceding edge was a split edge, start a new vertex. *)
AppendTo[nverts,vv];
nv=Length[nverts];
nfaces[[cf]]=nfaces[[cf]]/.vv->nv;
{},
(* if preceding edge was not a split edge, use the current new vertex. *)
nfaces[[cf]]=nfaces[[cf]]/.vv->nv;
{}];
],{j,2,Length[vvei]}];
(* After creating, note how vertices split (useful for debugging). *)
added=Table[i,{i,prevnum+1,Length[nverts]}];
Print[vv->Prepend[added,vv]]//Hold;
],{i,Length[sverts]}];
(* Construct the new list of edges *)
nedges=Union[Flatten[Transpose[{#,RotateLeft[#]}]&/@nfaces,1],SameTest->SameEdgeQ];
{nverts,nedges,nfaces}]
Module[{n,verts,edges,tobj,nverts,nedges,nfaces},
n=3;
verts=Flatten[Table[N[{i-1,j-1}],{j,n+1},{i,n+1}],1];
edges=Join[Flatten[Table[{i+(n+1)(j-1),i+1+(n+1)(j-1)},{j,n+1},{i,n}],1],Flatten[Table[{i+(n+1)(j-1),i+(n+1)(j)},{j,n},{i,(n+1)}],1]];
tobj=MakeTPlaneGraph[verts,edges];
GraphGraphics[tobj]//Print;
{nverts,nedges,nfaces}=SplitEdges[tobj,{4,5,18,19}];
PrintThis[nverts];
PrintThis[nedges];
PrintThis[nfaces];
]//ShowExample
Clear[SquareTwist45Graph];
AddTGraphExample[SquareTwist45Graph,Module[{verts,edges,faces},
verts={{0,0},{1,0},{2,0},{4,0},
{2,1},{4,1},
{0,2},{1,2},{3,2},{4,2},
{0,3},{2,3},
{0,4},{2,4},{3,4},{4,4}};
edges={{1,2},{2,3},{3,4},{1,7},{2,8},{3,5},{4,6},{5,6},{5,8},{5,9},{6,10},{7,8},{9,10},{7,11},{8,12},{9,12},{9,15},{10,16},{11,12},{11,13},{12,14},{13,14},{14,15},{15,16}};
MakeTGraph[verts,edges]//AddTPlaneGraph]];
Module[{tobj},
tobj=SquareTwist45Graph;
GraphGraphics[tobj]
]//ShowExample
Clear[SplitSquareTwist45Graph];
AddTGraphExample[SplitSquareTwist45Graph,Module[{verts,edges,faces},
verts={{0,0},{1,0},{2,0},{4,0},
{2,1},{4,1},
{0,2},{1,2},{3,2},{4,2},
{0,3},{2,3},
{0,4},{2,4},{3,4},{4,4}};
edges={{1,2},{2,3},{3,4},{1,7},{2,8},{3,5},{4,6},{5,6},{5,8},{5,9},{6,10},{7,8},{8,9},{9,10},{7,11},{8,12},{9,12},{9,15},{10,16},{11,12},{11,13},{12,14},{13,14},{14,15},{15,16}};
MakeTGraph[verts,edges]//AddTPlaneGraph]];
Module[{tobj},
tobj=SquareTwist45Graph;
GraphGraphics[tobj]
]//ShowExample
TGraph2D::usage="TGraph2D is a TObj class that describes a graph with a second 2D embedding.";
RegisterTClass[TGraph2D,{TGraph}];
Vertices2D::usage="Vertices2D is a TObj property that specifies a 2D embedding of the vertices of a graph.";
AddTGraph2DTo[tobj_TObj,verts2d_List:{}]:=Module[{v2d,tobj1},
AssertClass[tobj,TGraph,AddTGraph2DTo];
v2d=If[verts2d==={},GetValue[tobj,Vertices],verts2d];
AddClassTo[tobj,TGraph2D,{Vertices2D->v2d}]]
Module[{verts,edges,tobj,tobj1},
verts={{0,0},{1,0},{.5,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
tobj=AddTGraph2DTo[tobj];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
AddTGraph2D[verts2d_List:{}]:= AddTGraph2DTo[#,verts2d]&
MakeTGraph2D[verts_List,edges_List,faces_List:{},verts2d_List:{}]:=MakeTGraph[verts,edges,faces]//AddTGraph2D[verts2d]
Graph2DGraphics[tobj_TObj,opts___]:=Module[{vl,el,fl,de,fd,fc,verts2d, edges, faces,hf,gg},
AssertClass[tobj,TGraph,GraphGraphics];
AssertClass[tobj,TGraph2D,GraphGraphics];
{verts2d, edges, faces} = GetValues[tobj,{Vertices2D, Edges, Faces},AssertProperties->False];
GenericGraphGraphics[verts2d,edges,faces,EdgeColor->Darker[Magenta],opts]]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
tobj=MakeTGraph2D[verts,edges];
Graph2DGraphics[tobj,DirectedEdges->True,PlotLabel->"Graph2DGraphics"]
]//ShowExample
Module[{verts,edges,faces,tobj,fc},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
faces={{1,2,3},{3,4,1}};
fc={-1,+1};
tobj=MakeTGraph2D[verts,edges,faces];
Graph2DGraphics[tobj,FaceColoring->fc,EdgeLabels->None]
]//ShowExample
Clear[SingleVertexGraph2D];
AddTGraphExample[SingleVertexGraph2D,Module[{tobj,verts2d},
tobj=SingleVertexGraph;
verts2d={{0,0},{1,0},{1,1},{0,1},{1,1},{1,1/\[Sqrt]3},{-1-(3/2) (-1+1/\[Sqrt]3),-1+(1/2) \[Sqrt]3 (-1+1/\[Sqrt]3)-2 (-1+(1/2) \[Sqrt]3 (-1+1/\[Sqrt]3))},{-1/\[Sqrt]3,1},{1,1}}//N;
tobj//AddTGraph2D[verts2d]]];
Module[{tobj},
tobj=SingleVertexGraph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
EdgeLengths2D[tobj_TObj]:=Module[{verts2d,edges},
{verts2d,edges}=GetValues[tobj,{Vertices2D,Edges}];
Mag[Subtract@@verts2d[[#]]]&/@edges]
Module[{verts,edges,eangles,tobj},
verts={{0,0},{1,0},{2,0},{3,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
tobj=MakeTGraph2D[verts,edges];
Print[GraphGraphics[tobj]];
EdgeLengths2D[tobj]
]//ShowExample
EdgeFaceAngles2D[tobj_TObj]:=Module[{verts2d,faces,efi,fwn,fpair},
{verts2d,faces,efi}=GetValues[tobj,{Vertices2D,Faces,EdgeFaceIncidence}];
fwn=WindingNumber[verts2d,#]&/@faces;(* winding number of each face *)
Table[
fpair=efi[[i]];
If[MemberQ[fpair,0],
0,
If[fwn[[fpair[[1]]]]== fwn[[fpair[[2]]]],0,\[Pi]]]
,{i,Length[efi]}]]
Module[{verts,verts2d,edges,tobj},
verts={{0,0},{1,0},{2,0},{3,1},{4,1},{4,0},{1,1},{0,1}};
verts2d={{0,0},{1,0},{2,0},{3,1},{3,2},{2,2},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,3},{4,7},{7,8},{8,1},{7,2}};
tobj=MakeTGraph[verts,edges]//AddTGraph2D[verts2d]//AddTPlaneGraph;
Print[GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]];
EdgeFaceAngles2D[tobj]
]//ShowExample
VertexEdgeAngles2D[tobj_TObj]:=Module[{verts,vva,vfi,va,vfa},
{verts,vva,vfi}=GetValues[tobj,{Vertices2D,VertexVertexAdjacency,VertexFaceIncidence}];
Table[
va=AbsoluteAngle[verts[[#]]-verts[[i]]]&/@vva[[i]];
vfa=Abs[Mod[Subtract@@#,2\[Pi],-\[Pi]]]&/@Transpose[{RotateLeft[va],va}];
MapThread[If[#1==0,Null,#2]&,{vfi[[i]],vfa}]
,{i,Length[vva]}]
]
Module[{tobj},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
Print[GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]];
VertexEdgeAngles2D[tobj]//N
]//ShowExample
Module[{verts2d,tobj},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
Print[GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]];
Chop[N[VertexEdgeAngles2D[tobj]-VertexEdgeAngles[tobj]]]
]//ShowExample
SingleVertexEdgeAngles2D::badedge="Vertex `1` is not adjacent to vertex `2`.";
SingleVertexEdgeAngles2D[tobj_TObj, i0_, i1_]:=Module[{verts,vva,vfi,va,vfa},
{verts,vva,vfi}=GetValues[tobj,{Vertices2D,VertexVertexAdjacency,VertexFaceIncidence}];
If[!MemberQ[vva[[i0]],i1],Message[SingleVertexEdgeAngles2D::badedge,i1,i0];Abort[]];
va=AbsoluteAngle[verts[[#]]-verts[[i0]]]&/@vva[[i0]];
vfa=Abs[Mod[Subtract@@#,2\[Pi],-\[Pi]]]&/@Transpose[{RotateLeft[va],va}];
vfa=MapThread[If[#1==0,Null,#2]&,{vfi[[i0]],vfa}];
RotateLeft[vfa,Position[vva[[i0]],i1,1,1][[1,1]]-1]]
Module[{tobj},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
Print[GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]];
SingleVertexEdgeAngles2D[tobj,1,2]/\[Degree]//N
]//ShowExample
EdgeVertexAngles2D[tobj_TObj]:=Module[{edges,vei,vea,ia,ib,veaa,veab},
{edges,vei}=GetValues[tobj,{Edges,VertexEdgeIncidence}];
vea=VertexEdgeAngles2D[tobj];
Table[
{ia,ib}=edges[[i]];
veaa=RotateLeft[vea[[ia]],Position[vei[[ia]],i][[1,1]]-1];(* edge angles around vertex ia *)
veab=RotateLeft[vea[[ib]],Position[vei[[ib]],i][[1,1]]-1];(* edge angles around vertex ib *)
{{veaa[[1]],veaa[[-1]]},{veab[[1]],veab[[-1]]}}
,{i,Length[edges]}]]
Module[{tobj},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
Print[GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]];
Print[tobj[Edges]];
EdgeVertexAngles[tobj]
]//ShowExample
StationaryFace::usage="StationaryFace is an option to FoldEmbedding that specifies which face remains stationary.";
ShowProgress::usage="ShowProgress is an option to FoldEmbedding (and other complex functions) that specifies to show intermediate results and internal data structures.";
Options[FoldEmbedding]={
StationaryFace->1,
ShowProgress->False
};
FoldEmbedding[tobj_TObj,everts_List,foldangles_List,opts___]:=Module[{sface,sp,dim,verts3d,tobj1,edges,faces,vei,vfi,efi,fei,ei,nf,efaces,emap,efn,dedges,vstree,bfte,kids,face,ffn,dedge,if,redge,fedge,\[Phi],eface,w,q,rm,xfrm},
sface=StationaryFace/.{opts}/.Options[FoldEmbedding];
sp=ShowProgress/.{opts}/.Options[FoldEmbedding];
tobj1=If[HasClassQ[tobj,TPlaneGraph],tobj,tobj//RebuildPlaneGraph];
If[sp,Print[GraphGraphics[tobj1]]];
{edges,faces,vei,vfi,efi,fei}=GetValues[tobj1,{Edges,Faces,VertexEdgeIncidence,VertexFaceIncidence,EdgeFaceIncidence,FaceEdgeIncidence}];
(* ei[{i,j}] returns the index into edges of edge {i,j}. *)
Do[ei[edges[[i]]]=i;ei[Reverse[edges[[i]]]]=i,{i,Length[edges]}];
nf=Length[faces];
dim=Dimensions[everts][[2]];
verts3d=If[dim==3,everts,Append[#,0]&/@everts];
efaces=verts3d[[#]]&/@faces (* embedded faces *);
(* map pairing original edge with dual edge *)
emap=Select[Transpose[{edges,efi}],#[[2,1]]!=0&&#[[2,2]]!=0&];
If[sp,Print["emap = ",emap]];
(* efn takes a dual edge (fi,fj} and returns the corresponding original edge {i,j} *)
(efn[#[[2]]]=#[[1]];efn[Reverse[#[[2]]]]=#[[1]])&/@emap;
(* internal dual edges *)
dedges=Last/@emap;
If[sp,Print["internal dual edges = ",dedges]];
(* breadth-first traversal edges from the spanning tree, in reverse order *)
vstree=FindSpanningTree[{Graph[Range[nf],dedges],sface}];
bfte=Reap[BreadthFirstScan[vstree,sface,{"FrontierEdge"->Sow}]][[2,1]]/.UndirectedEdge->List;
bfte=Reverse[bfte];
If[sp,Print["traversal edges = ",bfte]];
(* show the spanning tree, this time with vertices for rendering *)
If[sp,Print[Graph[vstree,VertexCoordinates->FaceCentroids[tobj1],VertexLabels->"Index",EdgeLabels->"Index",EdgeLabelStyle->Red]]];
(* children of each node of spanning tree *)
kids=Table[{i},{i,nf}];
Do[kids[[bfte[[i,1]]]]=Flatten[{kids[[bfte[[i,1]]]],kids[[bfte[[i,2]]]]}],{i,nf-1}];
If[sp,Print["kids = ",kids]];
(* ffn[i,{j,k}] takes an undirected edge {j,k} in face i and returns the index pair into the ith face of the vertices of the corresponding directed edge. *)
Do[face=faces[[i]];
With[{n=Length[face]},
Do[
ffn[i,{face[[j]],face[[Mod[j+1,n,1]]]}]={j,Mod[j+1,n,1]};
ffn[i,{face[[Mod[j+1,n,1]]],face[[j]]}]={j,Mod[j+1,n,1]};
,{j,Length[face]}]]
,{i,nf}];
(* for each traversal edge, apply rotation to embedded face and its children *)
Do[
dedge=bfte[[i]](* directed dual edge *);
if=dedge[[1]](* index of source face *);
face=faces[[if]];
redge=efn[dedge](* undirected rotation edge (as pair of vertex indices) *);
fedge=ffn[if,redge](* index pair into embedded face of rotation edge *);
\[Phi]=foldangles[[ei[redge]]];(* desired fold angle *)
eface=efaces[[if]];
w=NormalizeReal[Subtract@@eface[[fedge]]](* rotation axis *);
q=efaces[[if,fedge[[1]]]](* initial point of rotation axis *);
rm=RotationMatrix3Du[\[Phi],w](* fully evaluate rotation matrix *);
xfrm=q+rm . (#-q)&;
If[sp,Print[{"dedge"->dedge,"if"->if,"face"->face,"redge"->redge,"fedge"->fedge,"eface"->eface,"\[Phi]"->\[Phi],"w"->w,"q"->q}]];
Do[efaces[[kids[[dedge[[2]],j]]]]=xfrm/@efaces[[kids[[dedge[[2]],j]]]],{j,Length[kids[[dedge[[2]]]]]}];
,{i,nf-1}];
If[sp,Print[Graphics3D[Line[AppendFirst[#]]&/@efaces]]];
(* rebuild verts3d from embedded faces *)
Do[Do[verts3d[[faces[[i,j]]]]=efaces[[i,j]],{j,Length[faces[[i]]]}],{i,nf}];
verts3d]
Module[{tobj,foldangles,newverts},
tobj=SimpleSquareTwistGraph//RebuildPlaneGraph;
foldangles={\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],-\[Pi],\[Pi],-\[Pi],\[Pi],-\[Pi],\[Pi],-\[Pi],0,0,0,0,0,0,0,0,0,0,0,0};
newverts=FoldEmbedding[tobj,tobj[Vertices],foldangles];
tobj=tobj//AddTGraph2D[Drop[#,-1]&/@newverts];
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Options[FoldGraph2D]={
StationaryFace->1
};
FoldGraph2D[tobj_TObj,foldangles_List,opts___]:=Module[{tobj1,verts,edges,faces,sface,v,e,f,m,p,el,ea,vfa,verts2d},
AssertClass[tobj,TGraph,FoldGraph2D];
verts2d=Drop[#,-1]&/@FoldEmbedding[tobj,tobj[Vertices],foldangles,opts];
If[HasClassQ[tobj,TGraph2D],tobj//ReplaceProperty[Vertices2D->verts2d],tobj//AddTGraph2D[verts2d]]]
Module[{tobj,foldangles},
tobj=SingleVertexGraph;
foldangles={\[Pi],\[Pi],-\[Pi],\[Pi],0,0,0,0,0,0,0,0};
tobj=FoldGraph2D[tobj,foldangles,ShowProgress->True];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj]
}]]//ShowExample
Module[{tobj,foldangles},
tobj=CrossPleatedSquareGraph;
foldangles={0,0,0,\[Pi],\[Pi],\[Pi],-\[Pi],-\[Pi],-\[Pi],0,0,0,0,\[Pi],-\[Pi],0,0,-\[Pi],\[Pi],0,0,\[Pi],-\[Pi],0};
tobj=FoldGraph2D[tobj,foldangles];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj]
}]]//ShowExample
Module[{tobj,foldangles},
tobj=SimpleSquareTwistGraph;
foldangles={\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],-\[Pi],\[Pi],-\[Pi],\[Pi],-\[Pi],\[Pi],-\[Pi],0,0,0,0,0,0,0,0,0,0,0,0};
tobj=FoldGraph2D[tobj,foldangles];
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Module[{angles,tobj},
angles={-\[Pi],-\[Pi],-\[Pi],-\[Pi],-\[Pi],-\[Pi],-\[Pi],-\[Pi],-\[Pi],-\[Pi],-\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],\[Pi],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
tobj=TObj[{TClasses -> {TGraph, TPlaneGraph}, Vertices -> {{0.6, 0.}, {0.7665750576834912, 0.48086077196920557}, {0.5191392280307945, 0.7665750576834912}, {0.6, 1.}, {0.23342494231650882, 0.5191392280307945}, {0., 0.6}, {0.48086077196920557, 0.23342494231650882}, {1.6, 0.}, {1.7665750576834913, 0.48086077196920557}, {2., 0.6}, {1.5191392280307945, 0.7665750576834912}, {1.6, 1.}, {1.233424942316509, 0.5191392280307945}, {1.4808607719692055, 0.23342494231650882}, {0.4, 0.}, {0.4, 1.}, {0., 0.4}, {1.4, 0.}, {2., 0.4}, {1.4, 1.}, {0., 0.}, {1., 0.}, {1., 1.}, {0., 1.}, {2., 0.}, {2., 1.}}, Edges -> {{1, 2}, {4, 3}, {3, 5}, {6, 5}, {5, 7}, {8, 9}, {10, 11}, {12, 11}, {11, 13}, {13, 14}, {3, 13}, {15, 7}, {7, 2}, {2, 3}, {16, 5}, {17, 7}, {18, 14}, {14, 9}, {19, 9}, {9, 11}, {20, 13}, {2, 14}, {15, 1}, {4, 16}, {6, 17}, {21, 15}, {17, 21}, {1, 22}, {23, 4}, {24, 6}, {16, 24}, {18, 8}, {19, 10}, {12, 20}, {22, 18}, {25, 19}, {8, 25}, {26, 12}, {10, 26}, {20, 23}}, Faces -> {{1, 2, 7, 15}, {4, 3, 13, 20, 23}, {3, 5, 7, 2}, {6, 5, 16, 24}, {8, 9, 14, 18}, {10, 11, 9, 19}, {12, 11, 10, 26}, {11, 13, 14, 9}, {15, 7, 17, 21}, {16, 5, 3, 4}, {17, 7, 5, 6}, {18, 14, 2, 1, 22}, {19, 9, 8, 25}, {20, 13, 11, 12}, {2, 14, 13, 3}}, InteriorVertices -> {2, 3, 5, 7, 9, 11, 13, 14}, BoundaryVertices -> {22, 18, 8, 25, 19, 10, 26, 12, 20, 23, 4, 16, 24, 6, 17, 21, 15, 1}, BoundaryEdges -> {35, 32, 37, 36, 33, 39, 38, 34, 40, 29, 24, 31, 30, 25, 27, 26, 23, 28}, BoundaryFaces -> {12, 5, 13, 13, 6, 7, 7, 14, 2, 2, 10, 4, 4, 11, 9, 9, 1, 12}, VertexVertexAdjacency -> {{22, 2, 15}, {7, 1, 14, 3}, {5, 2, 13, 4}, {3, 23, 16}, {7, 3, 16, 6}, {17, 5, 24}, {15, 2, 5, 17}, {25, 9, 18}, {14, 8, 19, 11}, {19, 26, 11}, {13, 9, 10, 12}, {11, 26, 20}, {14, 11, 20, 3}, {18, 9, 13, 2}, {1, 7, 21}, {5, 4, 24}, {21, 7, 6}, {8, 14, 22}, {25, 10, 9}, {13, 12, 23}, {15, 17}, {18, 1}, {20, 4}, {6, 16}, {19, 8}, {10, 12}}, VertexEdgeIncidence -> {{28, 1, 23}, {13, 1, 22, 14}, {3, 14, 11, 2}, {2, 29, 24}, {5, 3, 15, 4}, {25, 4, 30}, {12, 13, 5, 16}, {37, 6, 32}, {18, 6, 19, 20}, {33, 39, 7}, {9, 20, 7, 8}, {8, 38, 34}, {10, 9, 21, 11}, {17, 18, 10, 22}, {23, 12, 26}, {15, 24, 31}, {27, 16, 25}, {32, 17, 35}, {36, 33, 19}, {21, 34, 40}, {26, 27}, {35, 28}, {40, 29}, {30, 31}, {36, 37}, {39, 38}}, VertexFaceIncidence -> {{12, 1, 0}, {1, 12, 15, 3}, {3, 15, 2, 10}, {2, 0, 10}, {3, 10, 4, 11}, {11, 4, 0}, {1, 3, 11, 9}, {13, 5, 0}, {5, 13, 6, 8}, {0, 7, 6}, {8, 6, 7, 14}, {7, 0, 14}, {8, 14, 2, 15}, {5, 8, 15, 12}, {1, 9, 0}, {10, 0, 4}, {9, 11, 0}, {5, 12, 0}, {0, 6, 13}, {14, 0, 2}, {9, 0}, {12, 0}, {0, 2}, {4, 0}, {13, 0}, {0, 7}}, EdgeEdgeAdjacency -> {{{23, 28}, {22, 14, 13}}, {{29, 24}, {3, 14, 11}}, {{14, 11, 2}, {15, 4, 5}}, {{30, 25}, {5, 3, 15}}, {{3, 15, 4}, {16, 12, 13}}, {{32, 37}, {19, 20, 18}}, {{33, 39}, {8, 9, 20}}, {{38, 34}, {9, 20, 7}}, {{20, 7, 8}, {21, 11, 10}}, {{9, 21, 11}, {22, 17, 18}}, {{2, 3, 14}, {10, 9, 21}}, {{26, 23}, {13, 5, 16}}, {{5, 16, 12}, {1, 22, 14}}, {{13, 1, 22}, {11, 2, 3}}, {{24, 31}, {4, 5, 3}}, {{25, 27}, {12, 13, 5}}, {{35, 32}, {18, 10, 22}}, {{10, 22, 17}, {6, 19, 20}}, {{36, 33}, {20, 18, 6}}, {{18, 6, 19}, {7, 8, 9}}, {{34, 40}, {11, 10, 9}}, {{14, 13, 1}, {17, 18, 10}}, {{12, 26}, {28, 1}}, {{2, 29}, {31, 15}}, {{4, 30}, {27, 16}}, {{27}, {23, 12}}, {{16, 25}, {26}}, {{1, 23}, {35}}, {{40}, {24, 2}}, {{31}, {25, 4}}, {{15, 24}, {30}}, {{17, 35}, {37, 6}}, {{19, 36}, {39, 7}}, {{8, 38}, {40, 21}}, {{28}, {32, 17}}, {{37}, {33, 19}}, {{6, 32}, {36}}, {{39}, {34, 8}}, {{7, 33}, {38}}, {{21, 34}, {29}}}, EdgeFaceIncidence -> {{1, 12}, {2, 10}, {3, 10}, {4, 11}, {3, 11}, {5, 13}, {6, 7}, {7, 14}, {8, 14}, {8, 15}, {2, 15}, {1, 9}, {1, 3}, {3, 15}, {4, 10}, {9, 11}, {5, 12}, {5, 8}, {6, 13}, {6, 8}, {2, 14}, {12, 15}, {1, 0}, {10, 0}, {11, 0}, {9, 0}, {9, 0}, {12, 0}, {2, 0}, {4, 0}, {4, 0}, {5, 0}, {6, 0}, {14, 0}, {12, 0}, {13, 0}, {13, 0}, {7, 0}, {7, 0}, {2, 0}}, FaceEdgeIncidence -> {{1, 13, 12, 23}, {2, 11, 21, 40, 29}, {3, 5, 13, 14}, {4, 15, 31, 30}, {6, 18, 17, 32}, {7, 20, 19, 33}, {8, 7, 39, 38}, {9, 10, 18, 20}, {12, 16, 27, 26}, {15, 3, 2, 24}, {16, 5, 4, 25}, {17, 22, 1, 28, 35}, {19, 6, 37, 36}, {21, 9, 8, 34}, {22, 10, 11, 14}}}];
tobj=FoldGraph2D[tobj,angles];
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Options[UnfoldGraph2D]={
StationaryFace->1
};
UnfoldGraph2D[tobj_TObj,opts___]:=Module[{foldangles,verts},
AssertClass[tobj,TGraph2D,UnfoldGraph2D];
foldangles=EdgeFaceAngles2D[If[HasClassQ[tobj,TPlaneGraph],tobj,tobj//RebuildPlaneGraph]];
verts=Drop[#,-1]&/@FoldEmbedding[tobj,tobj[Vertices2D],foldangles,opts];
tobj//ReplaceProperty[Vertices->verts]]
Module[{foldangles,tobj,tobj1},
foldangles={\[Pi],\[Pi],-\[Pi],\[Pi],0,0,0,0,0,0,0,0};
tobj=SingleVertexGraph;
tobj=FoldGraph2D[tobj,foldangles];
tobj1=UnfoldGraph2D[tobj,ShowProgress->False];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj],
GraphGraphics[tobj1]
}]]//ShowExample
Module[{foldangles,tobj,tobj1},
tobj=CrossPleatedSquareGraph;
foldangles={0,0,0,\[Pi],\[Pi],\[Pi],-\[Pi],-\[Pi],-\[Pi],0,0,0,0,\[Pi],-\[Pi],0,0,-\[Pi],\[Pi],0,0,\[Pi],-\[Pi],0};
tobj=FoldGraph2D[tobj,foldangles];
tobj1=UnfoldGraph2D[tobj];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj],
GraphGraphics[tobj1]
}]]//ShowExample
Module[{foldangles,tobj,tobj1},
tobj=SimpleSquareTwistGraph;
foldangles={\[Pi],\[Pi],\[Pi],\[Pi],
\[Pi],-\[Pi],\[Pi],-\[Pi],\[Pi],-\[Pi],\[Pi],-\[Pi],
0,0,0,0,0,0,0,0,0,0,0,0};
tobj=FoldGraph2D[tobj,foldangles];
tobj1=UnfoldGraph2D[tobj];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj],
GraphGraphics[tobj1]
}]]//ShowExample
FoldGraph2DAll[tobj_TObj,opts___]:=FoldGraph2D[tobj,Table[\[Pi],{Length[tobj[Edges]]}],opts]
Module[{tobj,foldangles},
tobj=SingleVertexGraph;
foldangles={\[Pi],\[Pi],-\[Pi],\[Pi],0,0,0,0,0,0,0,0};
tobj=FoldGraph2DAll[tobj];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj]
}]]//ShowExample
Options[FlopGraph2D]={
FlopDirection->Horizontal
};
FlopGraph2D[tobj_, opts___]:=Module[{fd,verts2d,ctr},
AssertClass[tobj,TGraph2D,FlopGraph2D];
fd=FlopDirection/.{opts}/.Options[FlopGraph2D];
hori=(fd===Horizontal);
verts2d=GetValue[tobj,Vertices2D];
ctr={(Max[#1]+Min[#1])/2,(Max[#2]+Min[#2])/2}&@@Transpose[verts2d];
If[fd===Horizontal,
verts2d=ctr+ReflectionYMatrix2D . (#-ctr)&/@verts2d,
verts2d=ctr+ReflectionXMatrix2D . (#-ctr)&/@verts2d];
tobj//ReplaceProperty[Vertices2D->verts2d]]
Module[{tobj,tobjh,tobjv},
tobj=SingleVertexGraph2D;
tobjh=FlopGraph2D[tobj];
tobjv=FlopGraph2D[tobj,FlopDirection->Vertical];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj],
Graph2DGraphics[tobjh],
Graph2DGraphics[tobjv]
}]]//ShowExample
RotateGraph2D[tobj_,\[Phi]_]:=Module[{verts2d,ctr,rr},
AssertClass[tobj,TGraph2D,RotateGraph2D];
verts2d=GetValue[tobj,Vertices2D];
ctr={(Max[#1]+Min[#1])/2,(Max[#2]+Min[#2])/2}&@@Transpose[verts2d];
rr=RotationMatrix2D[\[Phi]];
verts2d=ctr+rr . (#-ctr)&/@verts2d;
tobj//ReplaceProperty[Vertices2D->verts2d]]
Module[{tobj,tobjr},
tobj=SingleVertexGraph2D;
tobjr=RotateGraph2D[tobj,15\[Degree]];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj],
Graph2DGraphics[tobjr]
}]]//ShowExample
Clear[CrossPleatedSquareGraph2D];
AddTGraphExample[CrossPleatedSquareGraph2D,Module[{tobj},
tobj=CrossPleatedSquareGraph;
FoldGraph2DAll[tobj]]];
Module[{tobj},
tobj=CrossPleatedSquareGraph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Clear[SimpleSquareTwistGraph2D];
AddTGraphExample[SimpleSquareTwistGraph2D,Module[{tobj},
tobj=SimpleSquareTwistGraph;
FoldGraph2DAll[tobj]]];
Module[{tobj},
tobj=SimpleSquareTwistGraph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Clear[SquareTwist45Graph2D];
AddTGraphExample[SquareTwist45Graph2D,Module[{tobj},
tobj=SquareTwist45Graph;
FoldGraph2DAll[tobj]]];
Module[{tobj},
tobj=SquareTwist45Graph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Clear[SplitSquareTwist45Graph2D];
AddTGraphExample[SplitSquareTwist45Graph2D,Module[{tobj,edges},
tobj=SplitSquareTwist45Graph;
tobj=SquareTwist45Graph2D;
edges=Append[GetValue[tobj,Edges],{8,9}];
tobj//ReplaceProperty[Edges->edges]//RebuildPlaneGraph]];
Module[{tobj},
tobj=SplitSquareTwist45Graph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Clear[BirdBaseGraph2D];
AddTGraphExample[BirdBaseGraph2D,Module[{h,verts,edges,a,b,c,d,e,f,verts2d},
h=.5(\[Sqrt]2-1);
verts={{0,0},{.5,0},{1,0},
{.5,h},
{0,.5},{h,.5},{.5,.5},{1-h,.5},{1,.5},
{.5,1-h},
{0,1},{.5,1},{1,1},
{.5-h/\[Sqrt]2,.5-h/\[Sqrt]2},{.5+h/\[Sqrt]2,.5+h/\[Sqrt]2}};
edges={{1,2},{2,3},{1,5},{1,6},{1,4},{2,4},{3,4},{3,8},{3,9},
{4,14},{14,6},{4,7},{4,8},
{5,6},{6,7},{7,8},{8,9},
{5,11},{6,11},{6,10},{7,10},{8,15},{15,10},{8,13},{9,13},
{10,11},{10,12},{10,13},
{11,12},{12,13},
{1,14},{14,7},{7,15},{15,13}};
(* folded form vertices *)
a={0,0};b={-h,.5};c={0,.5};d={h,.5};e={0,.5+h};f={0,1};
verts2d={a,c,f,b,c,
b,e,d,c,d,
f,c,a,c,c};
MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph2D[verts2d]]];
Module[{tobj},
tobj=BirdBaseGraph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
TSplitGraph2D::usage="TSplitGraph2D is a TObj class that describes a flat folded form with an interacting fold line and splitting information.";
RegisterTClass[TSplitGraph2D,{TGraph2D}];
SplitFoldLine::usage="SplitFoldLine is a TObj property that specifies a fold line on a TGraph2D";
SplitInfo::usage="SplitInfo is a TObj property that specifies splitting activity on a TGraph2D";
MakeSplitGraph2D::badsplit="MakeSplitGraph2D failed to split face `1` based on vfinfo=`2`, esinfo=`3`. Intersection list is flist=`4`";
Options[MakeSplitGraph2D]={
PtOnLineTolerance->(PtOnLineTolerance/.Options[PtOnLineQ])
};
MakeSplitGraph2D[tobj_TObj,{p_List,r_List},opts___]:=Module[{tol,vfinfo,efinfo,esinfo,fsinfo,flist,verts2d,edges,faces,fei,r0,d0,tpair},
tol=PtOnLineTolerance/.{opts}/.Options[MakeSplitGraph2D];
AssertClasses[tobj,{TGraph2D,TPlaneGraph},MakeSplitGraph2D];
{verts2d,edges,faces,fei}=GetValues[tobj,{Vertices2D,Edges,Faces,FaceEdgeIncidence}];
(* vertices on fold line *)
vfinfo={};
Do[
If[PtOnLineQ[verts2d[[i]],{p,r},opts],AppendTo[vfinfo,i]],{i,Length[verts2d]}];
(* edges on fold line (has both vertices on fold line) *)
efinfo={};
Do[If[ContainsAll[vfinfo,edges[[i]]],AppendTo[efinfo,i]],{i,Length[edges]}];
(* edges split by fold line *)
esinfo={};
Do[If[DisjointQ[vfinfo,edges[[i]]],
{r0,d0,tpair}=LineSegmentMedialInfo[{p,p+r},verts2d[[edges[[i]]]]];
If[2d0<=tol,AppendTo[esinfo,{i,tpair[[2]]}]]],{i,Length[edges]}];
(* faces split by fold line *)
fsinfo={};
Do[
(* If any face edge is on the fold line, no need to consider further *)
If[IntersectingQ[fei[[i]],efinfo],Continue[]];
flist={};
Do[If[MemberQ[vfinfo,faces[[i,j]]],AppendTo[flist,{0,faces[[i,j]]}]],{j,Length[faces[[i]]]}];
Do[If[MemberQ[First/@esinfo,fei[[i,j]]],AppendTo[flist,{1,fei[[i,j]]}]],{j,Length[fei[[i]]]}];
(* ignore faces that don't hit the fold line anywhere *)
If[Length[flist]==0,Continue[]];
(* ignore faces that hit the fold line at only one vertex *)
If[Length[flist]==1&&flist[[1,1]]==0,Continue[]];
(* faces that hit the fold line at two places should be split *)
If[Length[flist]==2,
AppendTo[fsinfo,Join[{i},flist]],
(* otherwise, bad number of intersections with face *)
Message[MakeSplitGraph2D::badsplit,i,vfinfo,esinfo,flist];Abort[]]
,{i,Length[faces]}];AddClassTo[tobj,TSplitGraph2D,{SplitFoldLine->{p,r},SplitInfo->{vfinfo,efinfo,esinfo,fsinfo}}]]
Module[{tobj,f1,f2,sinfo},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
f1={0,-.1};
f2={0,1.5};
tobj=MakeSplitGraph2D[tobj,{f1,f2-f1}];
GraphicsRow[{
GraphGraphics[tobj],
Show[Graph2DGraphics[tobj],Graphics[{Style[Line[{f1,f2}],Lighter[Blue]],Style[Point/@{f1,f2},Blue,PointSize[.015]]}]]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm
]//ShowExample
SplitGraphGraphics[tobj_TObj,opts___]:=Module[{verts,edges,sinfo,vfinfo,efinfo,esinfo,fsinfo,et,elems,fj,j,p1,p2,q1,q2},
AssertClass[tobj,TSplitGraph2D,SplitGraphGraphics];
{verts,edges,sinfo}=GetValues[tobj,{Vertices,Edges,SplitInfo}];
{vfinfo,efinfo,esinfo,fsinfo}=sinfo;
(* make a lookup table from split edge index to its split parameter *)
(et[#[[1]]]=#[[2]])&/@esinfo;
elems=Join[
(* folded edges, no labels needed *)
Table[
{p1,p2}=verts[[edges[[efinfo[[i]]]]]];
Style[Line[{p1,p2}],Blue]
,{i,Length[efinfo]}],
(* face-splitting edges, label with face index *)
Table[
{fj,j}=fsinfo[[i,2]];
p1=If[fj==0,verts[[j]],
{q1,q2}=verts[[edges[[j]]]];
q1+et[j](q2-q1)];
{fj,j}=fsinfo[[i,3]];
p2=If[fj==0,verts[[j]],
{q1,q2}=verts[[edges[[j]]]];
q1+et[j](q2-q1)];
{Style[Line[{p1,p2}],Blue],
Style[LabelPt[Subscript["f", fsinfo[[i,1]]],.5p1+.5p2],Darker[Blue]]}
,{i,Length[fsinfo]}]];
Show[GraphGraphics[tobj,opts],Graphics[elems]]]
Module[{tobj,f1,f2,sinfo},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
f1={0,-.1};
f2={0,1.5};
tobj=MakeSplitGraph2D[tobj,{f1,f2-f1}];
GraphicsRow[{
SplitGraphGraphics[tobj],
Show[Graph2DGraphics[tobj],Graphics[{Style[Line[{f1,f2}],Lighter[Blue]],Style[Point/@{f1,f2},Blue,PointSize[.015]]}]]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm
]//ShowExample
SplitGraph2DGraphics[tobj_TObj,opts___]:=Module[{verts2d,edges,sfl,sinfo,p,r,vfinfo,efinfo,esinfo,fsinfo,et,elems,fj,j,p1,p2,q1,q2},
AssertClass[tobj,TSplitGraph2D,SplitGraph2DGraphics];
{verts2d,edges,sfl,sinfo}=GetValues[tobj,{Vertices2D,Edges,SplitFoldLine,SplitInfo}];
{p,r}=sfl;
{vfinfo,efinfo,esinfo,fsinfo}=sinfo;
(* make a lookup table from split edge index to its split parameter *)
(et[#[[1]]]=#[[2]])&/@esinfo;
elems=Join[
(* folded edges, no labels needed *)
Table[
{p1,p2}=verts2d[[edges[[efinfo[[i]]]]]];
Style[Line[{p1,p2}],Blue]
,{i,Length[efinfo]}],
(* face-splitting edges, label with face index *)
Table[
{fj,j}=fsinfo[[i,2]];
p1=If[fj==0,verts2d[[j]],
{q1,q2}=verts2d[[edges[[j]]]];
q1+et[j](q2-q1)];
{fj,j}=fsinfo[[i,3]];
p2=If[fj==0,verts2d[[j]],
{q1,q2}=verts2d[[edges[[j]]]];
q1+et[j](q2-q1)];
Style[Line[{p1,p2}],Blue]
,{i,Length[fsinfo]}]];
Show[Graphics[Style[Line[{p,p+r}],LightGray]],Graph2DGraphics[tobj,opts],Graphics[elems]]]
Module[{tobj,f1,f2,sinfo},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
f1={0,-.2};
f2={0,1.4};
tobj=MakeSplitGraph2D[tobj,{f1,f2-f1}];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm
]//ShowExample
FilterSplitGraph2D[tobj_TObj,eflist_List,fslist_List]:=Module[{edges,sinfo,vfinfo,efinfo,esinfo,fsinfo,vfinfo1,efinfo1,esinfo1,fsinfo1,vfe,vsf,esf},
AssertClasses[tobj,{TGraph2D,TPlaneGraph},FilterSplitGraph2D];
{edges,sinfo}=GetValues[tobj,{Edges,SplitInfo}];
{vfinfo,efinfo,esinfo,fsinfo}=sinfo;
efinfo1=eflist;
fsinfo1=Select[fsinfo,MemberQ[fslist,#[[1]]]&];
(* vertices that are part of folded edges *)
vfe=Union[Flatten[edges[[efinfo1]]]];
(* vertices that are hit by face-splitting folds *)
vsf=Union[Flatten[#[[2]]&/@Select[Flatten[Drop[#,1]&/@fsinfo1,1],#[[1]]==0&]]];
vfinfo1=Union[Join[vfe,vsf]];
(* edges that are hit by face-splitting folds *)
esf=Union[Flatten[#[[2]]&/@Select[Flatten[Drop[#,1]&/@fsinfo1,1],#[[1]]==1&]]];
esinfo1=Select[esinfo,MemberQ[esf,#[[1]]]&];
tobj//ReplaceProperty[SplitInfo->{vfinfo1,efinfo1,esinfo1,fsinfo1}]]
Module[{tobj,f1,f2,sinfo},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
f1={0,-.1};
f2={0,1.3};
tobj=MakeSplitGraph2D[tobj,{f1,f2-f1}];
Print["all split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
tobj=FilterSplitGraph2D[tobj,{},{3,4}];
Print["filtered split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
]//ShowExample
Module[{tobj,f1,f2,sinfo},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
f1={0,-.1};
f2={0,1.3};
tobj=MakeSplitGraph2D[tobj,{f1,f2-f1}];
Print["all split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
tobj=FilterSplitGraph2D[tobj,{2},{3}];
Print["filtered split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
]//ShowExample
SplitSplitGraph2D[tobj_TObj]:=Module[{verts,edges,faces,verts2d,sinfo,vfinfo,efinfo,esinfo,fsinfo,j,t,i1,i2,p1,p2,evi,tobj1},
AssertClass[tobj,TSplitGraph2D,SplitSplitGraph2D];
{verts,edges,faces,verts2d,sinfo}=GetValues[tobj,{Vertices,Edges,Faces,Vertices2D,SplitInfo}];
{vfinfo,efinfo,esinfo,fsinfo}=sinfo;
(* split edges, creating new vertices and append the new vertex index and new edge index to the entries in esinfo *)
Do[
{j,t}=esinfo[[i]];
{i1,i2}=edges[[j]];
{p1,p2}=verts[[{i1,i2}]];
AppendTo[verts,p1+t(p2-p1)];
{p1,p2}=verts2d[[{i1,i2}]];
AppendTo[verts2d,p1+t(p2-p1)];
edges[[j]]=edges[[j]]/.i2->Length[verts];
AppendTo[edges,{Length[verts],i2}];
evi[j]=Length[verts](* lookup from edge index to its new vertex *)
,{i,Length[esinfo]}];
(* add new edges that split faces *)
Do[
i1=If[fsinfo[[i,2,1]]==0,fsinfo[[i,2,2]],evi[fsinfo[[i,2,2]]]];
i2=If[fsinfo[[i,3,1]]==0,fsinfo[[i,3,2]],evi[fsinfo[[i,3,2]]]];
AppendTo[edges,{i1,i2}]
,{i,Length[fsinfo]}];
tobj1=MakeTGraph2D[verts,edges,{},verts2d];
If[HasClassQ[tobj,TPlaneGraph],tobj1=tobj1//AddTPlaneGraph];
tobj1]
Module[{tobj,f1,f2,sinfo,tobj1},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
f1={0,-.1};
f2={0,1.3};
tobj=MakeSplitGraph2D[tobj,{f1,f2-f1}];
Print["All split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
tobj1=SplitSplitGraph2D[tobj];
Print["The split pattern"];
GraphicsRow[{
GraphGraphics[tobj1],
Graph2DGraphics[tobj1]}]//Print;
]//ShowExample
Module[{tobj,f1,f2,sinfo,tobj1},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
f1={0,-.1};
f2={0,1.3};
tobj=MakeSplitGraph2D[tobj,{f1,f2-f1}];
Print["All split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
tobj=FilterSplitGraph2D[tobj,{2},{3}];
Print["Filtered split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
Print["The split graph"];
tobj1=SplitSplitGraph2D[tobj];
GraphicsRow[{
GraphGraphics[tobj1],
Graph2DGraphics[tobj1]}]//Print;
]//ShowExample
SplitAndFoldSplitGraph2D[tobj_TObj,vlist_List]:=Module[{tobj1,sfl,verts2d,u},
sfl=GetValue[tobj,SplitFoldLine];
tobj1=SplitSplitGraph2D[tobj];
verts2d=GetValue[tobj1,Vertices2D];
u={{0,-1},{1,0}} . sfl[[2]];
(verts2d[[#]]=Reflect[verts2d[[#]],sfl[[1]],u])&/@vlist;
tobj1//ReplaceProperty[Vertices2D->verts2d]]
Module[{tobj,f1,f2,sinfo,tobj1},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
f1={0,-.1};
f2={0,1.3};
tobj=MakeSplitGraph2D[tobj,{f1,f2-f1}];
Print["All split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
tobj=FilterSplitGraph2D[tobj,{2},{3}];
Print["Filtered split information"];
GraphicsRow[{
SplitGraphGraphics[tobj],
SplitGraph2DGraphics[tobj]}]//Print;
sinfo=GetValue[tobj,SplitInfo];
sinfo//ColumnForm//Print;
tobj1=SplitAndFoldSplitGraph2D[tobj,{5,6}];
Print["Split and folded"];
GraphicsRow[{
GraphGraphics[tobj1],
Graph2DGraphics[tobj1]}]//Print;
]//ShowExample
Module[{verts,edges},
verts={{0,0},{1,-1},{2,0},{1,1}}//N;
edges={{1,2},{2,3},{3,4},{4,1}};
foo=MakeTGraph2D[verts,edges]//AddTPlaneGraph;
GraphicsRow[{GraphGraphics[foo],Graph2DGraphics[foo]}]
]//ShowExample
Module[{stobj},
stobj=MakeSplitGraph2D[foo,{{0,0},{1,0}}];
GraphicsRow[{SplitGraphGraphics[stobj],SplitGraph2DGraphics[stobj]}]//Print;
foo=SplitAndFoldSplitGraph2D[stobj,{4}];
GraphicsRow[{GraphGraphics[foo],Graph2DGraphics[foo]}]
]//ShowExample
Module[{stobj},
stobj=MakeSplitGraph2D[foo,{{2,0},.2U[22.5\[Degree]]}];
GraphicsRow[{SplitGraphGraphics[stobj],SplitGraph2DGraphics[stobj]}]//Print;
foo=SplitAndFoldSplitGraph2D[stobj,{2,4}];
GraphicsRow[{GraphGraphics[foo],Graph2DGraphics[foo]}]
]//ShowExample
Module[{stobj},
stobj=MakeSplitGraph2D[foo,{{1.7,0},.2U[70.\[Degree]]}];
GraphicsRow[{SplitGraphGraphics[stobj],SplitGraph2DGraphics[stobj]}]//Print;
foo=SplitAndFoldSplitGraph2D[stobj,{3}];
GraphicsRow[{GraphGraphics[foo],Graph2DGraphics[foo]}]
]//ShowExample
Module[{stobj},
stobj=MakeSplitGraph2D[foo,{{1.1,0},.2U[70.\[Degree]]}];
GraphicsRow[{SplitGraphGraphics[stobj],SplitGraph2DGraphics[stobj]}]//Print;
foo=SplitAndFoldSplitGraph2D[stobj,{3,8,11,9,10,7}];
GraphicsRow[{GraphGraphics[foo],Graph2DGraphics[foo]}]
]//ShowExample
Module[{},
foo=RotateGraph2D[foo,-22.5\[Degree]];
GraphicsRow[{GraphGraphics[foo],Graph2DGraphics[foo]}]
]//ShowExample
Clear[DuckGraph2D];
AddTGraphExample[DuckGraph2D,Module[{verts,edges,tobj,stobj},
(* a square in diamond orientation *)
verts={{0,0},{1,-1},{2,0},{1,1}}//N;
edges={{1,2},{2,3},{3,4},{4,1}};
tobj=MakeTGraph2D[verts,edges]//AddTPlaneGraph;
(* fold in half along horizontal diagonal *)
stobj=MakeSplitGraph2D[tobj,{{0,0},{1,0}}];
tobj=SplitAndFoldSplitGraph2D[stobj,{4}];
(* kite-fold both bottom corners *)
stobj=MakeSplitGraph2D[tobj,{{2,0},.2U[22.5\[Degree]]}];
tobj=SplitAndFoldSplitGraph2D[stobj,{2,4}];
(* fold the head *)
stobj=MakeSplitGraph2D[tobj,{{1.7,0},.2U[70.\[Degree]]}];
tobj=SplitAndFoldSplitGraph2D[stobj,{3}];
(* fold the body and head together *)
stobj=MakeSplitGraph2D[tobj,{{1.1,0},.2U[70.\[Degree]]}];
tobj=SplitAndFoldSplitGraph2D[stobj,{3,8,11,9,10,7}];
(* rotate the folded form *)
RotateGraph2D[tobj,-22.5\[Degree]]]] // Hold;
Module[{tobj},
tobj=DuckGraph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Clear[CraneGraph2D];
AddTGraphExample[CraneGraph2D,Module[{tobj,stobj},
tobj=BirdBaseGraph2D;
(* fold left edge in to the center *)
stobj=MakeSplitGraph2D[tobj,{{0,0},U[101.25\[Degree]]}];
tobj=SplitAndFoldSplitGraph2D[stobj,{4,6}];
(* fold right edge in to the center *)
stobj=MakeSplitGraph2D[tobj,{{0,0},U[78.75\[Degree]]}];
tobj=SplitAndFoldSplitGraph2D[stobj,{8,10}];
(* fold up left flap *)
stobj=MakeSplitGraph2D[tobj,{{0,.5},.3U[202.5\[Degree]]}];
tobj=SplitAndFoldSplitGraph2D[stobj,{1}];
(* fold up right flap *)
stobj=MakeSplitGraph2D[tobj,{{0,.5},.3U[-22.5\[Degree]]}];
tobj=SplitAndFoldSplitGraph2D[stobj,{13}];
(* fold down head. Note that we have filter the split to fold head but not wings. *)
stobj=MakeSplitGraph2D[tobj,{{0,.73},.5U[0\[Degree]]}];
GraphicsRow[{SplitGraphGraphics[stobj],SplitGraph2DGraphics[stobj,Frame->True]}]//Hold;
stobj=FilterSplitGraph2D[stobj,{},{22,91,56,96,29,92,58,95}];
SplitAndFoldSplitGraph2D[stobj,{13}]]]//Hold;
Module[{tobj},
tobj=CraneGraph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
TGraph3D::usage="TGraph3D is a TObj class that describes a graph with a 3D embedding.";
RegisterTClass[TGraph3D,{TGraph}];
Vertices3D::usage="Vertices3D is a TObj property that specifies a 3D embedding of the vertices of a graph.";
FoldAngles::usage="FoldAngles is a TObj property that specifies the angles of the folds for each edge of a TGraph3D.";
AddTGraph3DTo[tobj_TObj,verts3d_List:{}, foldangles_List:{}]:=Module[{v3d,fa,tobj1},
AssertClass[tobj,TGraph,AddTGraph3DTo];
v3d=If[verts3d==={},Append[#,0]&/@GetValue[tobj,Vertices],verts3d];
fa=If[foldangles==={},Table[0,{Length[GetValue[tobj,Edges]]}],foldangles];
AddClassTo[tobj,TGraph3D,{Vertices3D->v3d,FoldAngles->fa}]]
Module[{verts,edges,tobj,tobj1},
verts={{0,0},{1,0},{.5,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
tobj=AddTGraph3DTo[tobj];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
AddTGraph3D[verts3d_List:{},foldangles_List:{}]:= AddTGraph3DTo[#,verts3d,foldangles]&
MakeTGraph3D[verts_List,edges_List,faces_List,verts3d_List:{}, foldangles_List:{}]:=MakeTGraph[verts,edges,faces]//AddTGraph3D[verts3d,foldangles]
FoldAngleForm::usage="FoldAngleForm is an option to FoldAngleLabels that specifies the printed form of the fold angle.";
FoldAngleDigits[n_:0]:=If[n==0,Round,NumberForm[N[Round[# 10^n]10^-n],{5,n}]&]
Table[FoldAngleDigits[n][\[Pi]/100],{n,0,3}]//ColumnForm//ShowExample
Table[FoldAngleDigits[n][\[Pi]],{n,0,3}]//ColumnForm//ShowExample
Table[FoldAngleDigits[n][100\[Pi]],{n,0,3}]//ColumnForm//ShowExample
EdgeIndices::usage="EdgeIndices is an option to FoldAngleLabels that specifies whether to show the index of the edge.";
UseDegrees::usage="UseDegrees is an option to FoldAngleLabels that specifies whether to display angles in degrees.";
Options[FoldAngleLabels]={
EdgeIndices->False,
UseDegrees->True,
FoldAngleForm->(#&)
};
FoldAngleLabels[tobj_TObj, opts___]:=Module[{ei,ud,faf,verts,edges,foldangles,fa},
ei=EdgeIndices/.{opts}/.Options[FoldAngleLabels];
ud=UseDegrees/.{opts}/.Options[FoldAngleLabels];
faf=FoldAngleForm/.{opts}/.Options[FoldAngleLabels];
{verts,edges,foldangles}=GetValues[tobj,{Vertices,Edges,FoldAngles}];
Table[
fa=foldangles[[i]];
Text[If[ei,"e"<>ToString[i]<>"\[Rule]",""]<>If[ud,ToString[faf[fa/\[Degree]]]<>"\[Degree]",ToString[faf[fa[[i]]]]],Plus@@verts[[edges[[i]]]]/2]
,{i,Length[edges]}]]
Module[{verts,edges,tobj,foldangles,edgelabels},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
foldangles={90 \[Degree],-90 \[Degree],90 \[Degree],150 \[Degree],90 \[Degree],-90 \[Degree],90 \[Degree],0,0,0,0,0,0};
tobj=MakeTGraph[verts,edges]//AddTGraph3D[{},foldangles];
edgelabels=FoldAngleLabels[tobj,EdgeIndices->True];
GraphGraphics[tobj,EdgeLabels->edgelabels]
]//ShowExample
Module[{verts,edges,tobj,foldangles,edgelabels},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
foldangles={90 \[Degree],-90 \[Degree],90 \[Degree],150 \[Degree],90 \[Degree],-90 \[Degree],90 \[Degree],0,0,0,0,0,0};
tobj=MakeTGraph[verts,edges]//AddTGraph3D[{},foldangles];
edgelabels=FoldAngleLabels[tobj,FoldAngleForm->FoldAngleDigits[2]];
GraphGraphics[tobj,EdgeLabels->edgelabels]
]//ShowExample
FoldAngleGraphics[tobj_TObj, opts___]:=Module[{elabels},
AssertClass[tobj,TGraph,FoldAngleGraphics];
AssertClass[tobj,TGraph3D,FoldAngleGraphics];
elabels=FoldAngleLabels[tobj,opts];
GraphGraphics[tobj,EdgeLabels->elabels,Faces->False]]
Module[{verts,edges,foldangles,tobj},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
foldangles={90 \[Degree],-90 \[Degree],90 \[Degree],150 \[Degree],90 \[Degree],-90 \[Degree],90 \[Degree],0,0,0,0,0,0};
tobj=MakeTGraph3D[verts,edges,{},{},foldangles];
FoldAngleGraphics[tobj]
]//ShowExample
Module[{verts,edges,foldangles,tobj},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
foldangles={90 \[Degree],-90 \[Degree],90 \[Degree],150 \[Degree],90 \[Degree],-90 \[Degree],90 \[Degree],0,0,0,0,0,0};
tobj=MakeTGraph3D[verts,edges,{},{},foldangles];
FoldAngleGraphics[tobj,EdgeIndices->True]
]//ShowExample
DirectedEdges3D::usage="DirectedEdges3D is an option to Graph3DGraphics3D that specifies whether to use 3D arrows for directed edges.";
Options[Graph3DGraphics3D]={
VertexLabels->Automatic,
EdgeLabels->Automatic,
FaceLabels->Automatic,
DirectedEdges->False,
DirectedEdges3D->False,
VertexColor->DarkGray,
EdgeColor->Darker[Magenta],
FaceColor->Green,
FaceColoring->None
};
Graph3DGraphics3D[tobj_TObj,opts___]:=Module[{vl,el,fl,de,de3d,vc,ec,fc,fcng,verts3d, edges, faces,hf,gg},
vl=VertexLabels/.{opts}/.Options[Graph3DGraphics3D];
el=EdgeLabels/.{opts}/.Options[Graph3DGraphics3D];
fl=FaceLabels/.{opts}/.Options[Graph3DGraphics3D];
de=DirectedEdges/.{opts}/.Options[Graph3DGraphics3D];
de3d=DirectedEdges3D/.{opts}/.Options[Graph3DGraphics3D];
vc=VertexColor/.{opts}/.Options[Graph3DGraphics3D];
ec=EdgeColor/.{opts}/.Options[Graph3DGraphics3D];
fc=FaceColor/.{opts}/.Options[Graph3DGraphics3D];
fcng=FaceColoring/.{opts}/.Options[Graph3DGraphics3D];
AssertClass[tobj,TGraph,Graph3DGraphics3D];
AssertClass[tobj,TGraph3D,Graph3DGraphics3D];
{verts3d, edges, faces} = GetValues[tobj,{Vertices3D, Edges, Faces}];
hf = HasFacesQ[tobj];
gg = {};
If[hf,
If[!(fcng===None),AppendTo[gg,MapThread[Style[Polygon[verts3d[[#1]]],Lighter[fc,.8-.1#2]]&,{faces,fcng}]]];
AppendTo[gg,Style[PolyLines[verts3d,faces],fc]];
];
Which[
de,AppendTo[gg,Style[DirectedEdgeLines[verts3d,edges],ec]],
de3d,AppendTo[gg,Style[DirectedEdgeLines3D[verts3d,edges],ec]],
True,AppendTo[gg,Style[EdgeLines[verts3d,edges],ec]]];
If[hf,AppendTo[gg,Style[Switch[fl,None,{},Automatic,StdFaceLabels[verts3d,faces],_,fl],Darker[fc,0.75]]]];
AppendTo[gg,Style[Switch[el,None,{},Automatic,StdEdgeLabels[verts3d,edges],_,el],Darker[ec,0.75]]];
AppendTo[gg,Style[Switch[vl,None,{},Automatic,StdVertexLabels[verts3d],_,vl],vc,AbsolutePointSize[4]]];
Graphics3D[gg,FilterRules[{opts},Options[Graphics3D]]]]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
tobj=MakeTGraph3D[verts,edges,{}];
Graph3DGraphics3D[tobj,Boxed->True]
]
Module[{verts,edges,faces,tobj,fc},
verts={{0,0},{1,0},{1,.5},{0,.5}};
edges={{1,2},{2,3},{3,4},{4,1},{1,3}};
faces={{1,2,3},{1,3,4}};
tobj=MakeTGraph3D[verts,edges,faces];
Graph3DGraphics3D[tobj,DirectedEdges3D->True,FaceColoring->{1,-1},Boxed->True]
]
Options[FoldAngleSpecLabels]={
EdgeIndices->False,
UseDegrees->True
};
FoldAngleSpecLabels[tobj_TObj, faspecs_List, opts___]:=Module[{ei,ud,verts,edges,el},
ei=EdgeIndices/.{opts}/.Options[FoldAngleLabels];
ud=UseDegrees/.{opts}/.Options[FoldAngleSpecLabels];
AssertClass[tobj,TGraph,FoldAngleSpecLabels];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
Table[Text[If[ei,"e"<>ToString[i]<>"\[Rule]{","{"]<>ToString[faspecs[[i,1]]/.Infinity->"\[Infinity]"]<>", "<>If[ud,ToString[faspecs[[i,2]]/\[Degree]]<>"\[Degree]",ToString[faspecs[[i,2]]]]<>"}",Plus@@verts[[edges[[i]]]]/2],{i,Length[edges]}]]
Module[{verts,edges,faspecs,tobj,edgelabels},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
tobj=MakeTGraph[verts,edges];
faspecs={{1,90\[Degree]},{1,-90\[Degree]},{1,90\[Degree]},{\[Infinity],150\[Degree]},{1,90\[Degree]},{1,-90\[Degree]},{1,90\[Degree]},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0}};
edgelabels=FoldAngleSpecLabels[tobj,faspecs];
GraphGraphics[tobj,EdgeLabels->edgelabels,Faces->False]
]//ShowExample
FoldAngleSpecGraphics[tobj_TObj, faspecs_List, opts___]:=GraphGraphics[tobj,EdgeLabels->FoldAngleSpecLabels[tobj,faspecs,opts],Faces->False]
Module[{verts,edges,faspecs,tobj},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
tobj=MakeTGraph[verts,edges];
faspecs={{1,90\[Degree]},{1,-90\[Degree]},{1,90\[Degree]},{\[Infinity],150\[Degree]},{1,90\[Degree]},{1,-90\[Degree]},{1,90\[Degree]},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0}};
FoldAngleSpecGraphics[tobj,faspecs]
]//ShowExample
ConstrainFoldDirection::usage="ConstrainFoldDirection is an option to MakeGraphFoldAngles that specifies whether to bound the direction of the creases.";
Options[MakeGraphFoldAngles]={
ConstrainFoldDirection->True
};
MakeGraphFoldAngles[tobj_TObj, faspecs_List,opts___]:=Module[{bfd,tobj1,faspecs1,iverts,bedges,vei,vars,angles,a,vea,vfa,krms,fom,kcons,bcons,val,soln},
bfd=ConstrainFoldDirection/.{opts}/.Options[MakeGraphFoldAngles];
tobj1=tobj;(* make a copy to work on *)
If[!HasClassQ[tobj1,TPlaneGraph],tobj1=tobj1//RebuildPlaneGraph];
faspecs1=faspecs; (* ditto *)
{iverts,bedges,vei}=GetValues[tobj1,{InteriorVertices,BoundaryEdges,VertexEdgeIncidence}];
(* groom the specs by setting all boundary edges to {0,0} *)
(faspecs1[[#]]={\[Infinity],0})&/@bedges;
(* make lists of variables and angles (either as variable a[i] or value) *)
vars={};
angles=Table[If[faspecs1[[i,1]]==\[Infinity],faspecs1[[i,2]],AppendTo[vars,{a[i],faspecs1[[i,2]]}];a[i]],{i,Length[faspecs1]}];
vea=angles[[#]]&/@vei;(* dihedral angles around each vertex *)
vfa=VertexEdgeAngles[tobj1];(* sector angles around each vertex *)
(* generalized Kawasaki condition matrices on each interior vertex *)
krms=Table[VertexConsistencyMatrix3D[vea[[iverts[[i]]]],vfa[[iverts[[i]]]]],{i,Length[iverts]}];
kcons=And@@Flatten[{#[[1,2]]==0,#[[1,3]]==0,#[[2,3]]==0,#[[1,1]]>0,#[[2,2]]>0,#[[3,3]]>0}&/@krms];
(* figure of merit on goal vertices *)
fom=Plus@@Table[Switch[faspecs1[[i,1]],0,0,\[Infinity],0,_,faspecs1[[i,1]](a[i]-faspecs1[[i,2]])^2],{i,Length[faspecs1]}];
(* bounds on angle variables *)
bcons=And@@If[bfd,
#[[1]]<=(If[#[[2]]<0,0,\[Pi]])&&#[[1]]>=(If[#[[2]]>0,0,-\[Pi]])&/@vars,
#[[1]]<=\[Pi]&&#[[1]]>=-\[Pi]&/@vars];
(* solve for all unknown angles *)
{val,soln}=FindMinimum[{fom,kcons&&bcons},vars];
angles/.soln
]
Module[{verts,edges,tobj,faspecs,gmj,gmn,foldangles,tobj1},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
tobj=MakeTGraph[verts,edges];
faspecs={{1,90 \[Degree]},{1,-90 \[Degree]},{1,90 \[Degree]},{1,90 \[Degree]},{1,90 \[Degree]},{1,-90 \[Degree]},{1,90 \[Degree]},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0},{\[Infinity],0}};
faspecs[[4]]={\[Infinity],100.\[Degree]};(* fix one angle *)
foldangles=MakeGraphFoldAngles[tobj,faspecs];(* solve for remaining angles *)
Print[FoldAngleSpecGraphics[tobj,faspecs]];
foldangles/\[Degree]
]//ShowExample
EdgeLengths3D[tobj_TObj]:=Module[{verts3d,edges},
{verts3d,edges}=GetValues[tobj,{Vertices3D,Edges}];
Mag[Subtract@@verts3d[[#]]]&/@edges]
FaceCentroids3D[tobj_TObj]:=Module[{verts3d,faces},
{verts3d,faces}=GetValues[tobj,{Vertices3D,Faces}];
FaceCentroid[verts3d,#]&/@faces
]
FaceNormal3D[verts3d_List,face_List]:=Module[{c},
c=FaceCentroid[verts3d,face];
NormalizeReal[(verts3d[[face[[1]]]]-c)\[Cross](verts3d[[face[[2]]]]-c)]]
Module[{verts3d,face},
verts3d={{0,0,0},{1,0,0},{1,1,0},{0,1,0}};
face={1,2,3,4};
FaceNormal3D[verts3d,face]
]//ShowExample
FaceNormals3D[tobj_TObj]:=Module[{verts3d,faces,fc},
{verts3d,faces}=GetValues[tobj,{Vertices3D,Faces}];
fc=FaceCentroids3D[tobj];
MapThread[NormalizeReal[(verts3d[[#1[[1]]]]-#2)\[Cross](verts3d[[#1[[2]]]]-#2)]&,{faces,fc}]]
Module[{verts,edges,faces,tobj,verts3d},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1},{2,0,0},{2,1,0},{1,1,-1},{0,1,0}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d];
Print[Graph3DGraphics3D[tobj]];
FaceNormals3D[tobj]
]//ShowExample
EdgeFaceAngles3D[tobj_TObj]:=Module[{verts3d,edges,faces,efi,fc,fn,ei,fi},
{verts3d,edges,faces,efi}=GetValues[tobj,{Vertices3D,Edges,Faces,EdgeFaceIncidence}];
fc=FaceCentroids3D[tobj];
fn=FaceNormals3D[tobj];
Table[
ei=edges[[i]];(* each edge as vertex index pair *)
fi=efi[[i]];(* faces incident to the edge as face indices *)
If[MemberQ[fi,0],
0,(* is boundary edge, return 0, else: *)
DirectedAngle3D[fn[[fi[[1]]]],fn[[fi[[2]]]],verts3d[[ei[[2]]]]-verts3d[[ei[[1]]]]] ],
{i,Length[edges]}]
]
Module[{verts,edges,faces,tobj,verts3d},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1},{2,0,0},{2,1,0},{1,1,-1},{0,1,0}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d];
Print[Graph3DGraphics3D[tobj]];
EdgeFaceAngles3D[tobj]
]//ShowExample
Module[{verts,edges,faces,tobj,verts3d},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,1},{2,0,0},{2,1,0},{1,1,1},{0,1,0}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d];
Print[Graph3DGraphics3D[tobj]];
EdgeFaceAngles3D[tobj]
]//ShowExample
VertexEdgeAngles3D[tobj_TObj]:=Module[{verts3d,vva,vfi,fn,vc,va,vf},
{verts3d,vva,vfi}=GetValues[tobj,{Vertices3D,VertexVertexAdjacency,VertexFaceIncidence}];
fn=FaceNormals3D[tobj];
Table[
vc=verts3d[[i]];(* this vertex coords *)
va=vva[[i]];(* vertices adjacent to this vertex, by index *)
vf=vfi[[i]];(* faces incident to this vertex, by index. Could include zeroes. *)
Table[
If[vf[[j]]==0,
Null,
DirectedAngle3D[verts3d[[va[[j]]]]-vc,verts3d[[va[[Mod[j+1,Length[va],1]]]]]-vc,fn[[vf[[j]]]]]
],{j,Length[va]}]
,{i,Length[verts3d]}]]
Module[{verts,edges,faces,tobj,verts3d},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d];
Print[Graph3DGraphics3D[tobj]];
VertexEdgeAngles3D[tobj]
]//ShowExample
Module[{verts,edges,faces,tobj,verts3d},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d];
Print[Graph3DGraphics3D[tobj]];
Chop[N[VertexEdgeAngles3D[tobj]-VertexEdgeAngles[tobj]]]
]//ShowExample
SingleVertexEdgeAngles3D::badedge="Vertex `1` is not adjacent to vertex `2`.";
SingleVertexEdgeAngles3D[tobj_TObj, i0_, i1_]:=Module[{verts3d,vva,vfi,fn,vc,va,vf,vfa},
{verts3d,vva,vfi}=GetValues[tobj,{Vertices3D,VertexVertexAdjacency,VertexFaceIncidence}];
fn=FaceNormals3D[tobj];
vc=verts3d[[i0]];(* this vertex coords *)
va=vva[[i0]];(* vertices adjacent to this vertex, by index *)
If[!MemberQ[va,i1],Message[SingleVertexEdgeAngles3D::badedge,i1,i0];Abort[]];
vf=vfi[[i0]];(* faces incident to this vertex, by index. Could include zeroes. *)
vfa=Table[
If[vf[[j]]==0,
Null,
DirectedAngle3D[verts3d[[va[[j]]]]-vc,verts3d[[va[[Mod[j+1,Length[va],1]]]]]-vc,fn[[vf[[j]]]]]
],{j,Length[va]}];
RotateLeft[vfa,Position[va,i1,1,1][[1,1]]-1]]
Module[{verts,edges,faces,tobj,verts3d},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d];
Print[Graph3DGraphics3D[tobj]];
SingleVertexEdgeAngles3D[tobj,2,3]
]//ShowExample
EdgeVertexAngles3D[tobj_TObj]:=Module[{edges,vei,vea,ia,ib,veaa,veab},
{edges,vei}=GetValues[tobj,{Edges,VertexEdgeIncidence}];
vea=VertexEdgeAngles3D[tobj];
Table[
{ia,ib}=edges[[i]];
veaa=RotateLeft[vea[[ia]],Position[vei[[ia]],i][[1,1]]-1];(* edge angles around vertex ia *)
veab=RotateLeft[vea[[ib]],Position[vei[[ib]],i][[1,1]]-1];(* edge angles around vertex ib *)
{{veaa[[1]],veaa[[-1]]},{veab[[1]],veab[[-1]]}}
,{i,Length[edges]}]]
Module[{verts,edges,faces,tobj,verts3d},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d];
Print[GraphicsRow[{GraphGraphics[tobj],Graph3DGraphics3D[tobj]}]];
Print[edges];
EdgeVertexAngles[tobj]
]//ShowExample
RecalcFoldAngles[tobj_TObj]:=Module[{tobj1,fa},
AssertClass[tobj,TGraph3D,RecalcFoldAngles];
tobj1=If[HasClassQ[tobj,TPlaneGraph],tobj,tobj//RebuildPlaneGraph];
fa=EdgeFaceAngles3D[tobj1];
tobj//ReplaceProperty[FoldAngles->fa]]
Module[{verts,edges,faces,verts3d,tobj},
verts={{0,0},{1,0},{2,0},{3,0},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{5,6},{6,7},{7,8},{1,5},{2,6},{3,7},{4,8}};
faces={{1,2,6,5},{2,3,7,6},{3,4,8,7}};
verts3d={{0,0,0},{1,0,0},{1,0,1},{2,0,1},{0,1,0},{1,1,0},{1,1,1},{2,1,1}};
tobj=MakeTGraph3D[verts,edges,faces,verts3d];
tobj=RecalcFoldAngles[tobj];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
FoldGraph3D[tobj_TObj,foldangles_List,opts___]:=Module[{verts3d},
AssertClass[tobj,TGraph,FoldGraph3D];
verts3d=FoldEmbedding[tobj,tobj[Vertices],foldangles,opts];
If[HasClassQ[tobj,TGraph3D],tobj//ReplaceProperties[{Vertices3D->verts3d,FoldAngles->foldangles}],tobj//AddTGraph3D[verts3d,foldangles]]]
Module[{verts,edges,foldangles,verts3d,tobj,tobj1},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
foldangles={0,90\[Degree],0,0,0,0,0};
tobj=MakeTGraph[verts,edges]//AddTGraph3D[verts3d, foldangles]//AddTPlaneGraph;
(* re-fold it to the new angle, keeping original orientation of facet 2 *)
tobj1=FoldGraph3D[tobj,foldangles,StationaryFace->2,ShowProgress->True];
GraphicsRow[{Graph3DGraphics3D[tobj],Graph3DGraphics3D[tobj1]}]
]//ShowExample
Module[{verts,edges,foldangles,verts3d,tobj,tobj1},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
foldangles={0,90\[Degree],0,0,0,0,0};
tobj=MakeTGraph[verts,edges];
(* re-fold it to the new angle, keeping original orientation *)
tobj1=FoldGraph3D[tobj,foldangles,StationaryFace->2,ShowProgress->False];
GraphicsRow[{
GraphGraphics[tobj],
Graph3DGraphics3D[tobj1]
}]
]//ShowExample
Module[{verts,edges,tobj,verts3d,foldangles,tobj1},
verts={{0,0},{2,0},{0,1},{1,1},{2,1},{0,2},{2,2}};
edges={{1,2},{1,3},{2,5},{3,4},{4,5},{3,6},{5,7},{6,7}};
tobj=MakeTGraph[verts,edges];
verts3d=Append[#,0]&/@verts;
foldangles={0,0,0,90\[Degree],90\[Degree],0,0,0};
tobj1=FoldGraph3D[tobj,foldangles,StationaryFace->2,ShowProgress->False];
GraphicsRow[{
GraphGraphics[tobj],
Graph3DGraphics3D[tobj1]
}]]//ShowExample
Module[{verts,edges,faces,foldangles,tobj},
verts={{0,0},{1,0},{1,1},{0,1},{-1,1},{-1,Tan[30\[Degree]]},{-1,-1},{-Tan[30\[Degree]],-1},{1,-1}};
edges={{1,2},{1,4},{1,6},{1,8},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,2}};
faces={{1,2,3,4},{1,4,5,6},{1,6,7,8},{1,8,9,2}};
foldangles={2 ArcTan[1+2/(\[Sqrt]3)],-60 \[Degree],2 ArcTan[1+2/(\[Sqrt]3)],60 \[Degree],0,0,0,0,0,0,0,0};
tobj=MakeTGraph[verts,edges,faces]//AddTGraph3D[];
tobj=FoldGraph3D[tobj,foldangles];
GraphicsRow[{
GraphGraphics[tobj],
Graph3DGraphics3D[tobj]
}]]//ShowExample
Module[{o,verts,edges,\[Alpha]2,\[Alpha]1,gmj,gmn,foldangles,tobj,tobj1,tobj2},
(* crease pattern *)
o=0.2;(* offset of central row *)
verts={{0,0},{o,1},{0,2},{1,0},{1+o,1},{1,2},{2,0},{2+o,1},{2,2},{3,0},{3+o,1},{3,2}};
edges={{1,2},{2,3},{1,4},{2,5},{3,6},{4,5},{5,6},{4,7},{5,8},{6,9},{7,8},{8,9},{7,10},{8,11},{9,12},{10,11},{11,12}};
(* Get sector angles *)
\[Alpha]1=RotationAngle[verts[[8]]-verts[[5]],verts[[6]]-verts[[5]]];
Print["\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)/\[Degree] = ",\[Alpha]1/\[Degree]];
\[Alpha]2=RotationAngle[verts[[6]]-verts[[5]],verts[[2]]-verts[[5]]];
Print["\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)/\[Degree] = ",\[Alpha]2/\[Degree]];
(* 2D graph *)
tobj=MakeTGraph[verts,edges,{}]//AddTPlaneGraph;
(* flat 3D form *)
tobj1=tobj//AddTGraph3D[];
(* folded 3D form *)
(* Choose the major fold angle, calculate the minor fold angle *)
gmj=60.\[Degree];
Print["\!\(\*SubscriptBox[\(\[Gamma]\), \(major\)]\)/\[Degree] = ",gmj/\[Degree]];
gmn=2 ArcTan[(Sin[(1/2)(\[Alpha]1-\[Alpha]2)]/Sin[(1/2)(\[Alpha]1+\[Alpha]2)])Tan[gmj/2]];
Print["\!\(\*SubscriptBox[\(\[Gamma]\), \(minor\)]\)/\[Degree] = ",gmn/\[Degree]];
(* Set the edge angles *)
foldangles={0,0,0,-gmn,0,gmj,gmj,0,gmn,0,-gmj,-gmj,0,-gmn,0,0,0};
tobj2=FoldGraph3D[tobj1,foldangles];
GraphicsRow[{GraphGraphics[tobj],Graph3DGraphics3D[tobj1],Graph3DGraphics3D[tobj2]}]
]//ShowExample
Options[UnfoldGraph3D]={
StationaryFace->1
};
UnfoldGraph3D[tobj_TObj,opts___]:=Module[{sface,tobj1,foldangles,verts3d,faces,m,verts},
AssertClass[tobj,TGraph3D,UnfoldGraph3D];
sface=StationaryFace/.{opts}/.Options[UnfoldGraph3D];
tobj1=If[HasClassQ[tobj,TPlaneGraph],tobj,tobj//RebuildPlaneGraph];
{verts3d,faces}=GetValues[tobj1,{Vertices3D,Faces}];
foldangles=-EdgeFaceAngles3D[tobj1];
verts3d=FoldEmbedding[tobj1,verts3d,foldangles,opts];
(* translate to origin *)
verts3d=#-verts3d[[faces[[sface,1]]]]&/@verts3d;
(* rotate so that stationary face lies in x-y plane with first edge along x-axis. *)
m=TriangleBasis3D@@(verts3d[[#]]&/@Take[faces[[sface]],3]);
verts3d=m . #&/@verts3d;
verts=Drop[#,-1]&/@verts3d;
tobj//ReplaceProperty[Vertices->verts]]
Module[{verts,edges,foldangles,verts3d,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
foldangles={0,90\[Degree],0,0,0,0,0};
tobj=MakeTGraph[verts,edges]//AddTGraph3D[verts3d, foldangles]//AddTPlaneGraph;
(* re-fold it to the new angle, keeping original orientation *)
tobj1=FoldGraph3D[tobj,foldangles,StationaryFace->2];
tobj2=UnfoldGraph3D[tobj1,ShowProgress->False];
GraphicsRow[{
GraphGraphics[tobj],
Graph3DGraphics3D[tobj1],
GraphGraphics[tobj2]
}]
]//ShowExample
Module[{verts,edges,faces,foldangles,tobj,tobj1},
verts={{0,0},{1,0},{1,1},{0,1},{-1,1},{-1,Tan[30\[Degree]]},{-1,-1},{-Tan[30\[Degree]],-1},{1,-1}};
verts = {.2,.3}+RotationMatrix2D[10.\[Degree]] . #&/@verts;
edges={{1,2},{1,4},{1,6},{1,8},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,2}};
faces={{1,2,3,4},{1,4,5,6},{1,6,7,8},{1,8,9,2}};
foldangles={2 ArcTan[1+2/(\[Sqrt]3)],-60 \[Degree],2 ArcTan[1+2/(\[Sqrt]3)],60 \[Degree],0,0,0,0,0,0,0,0}//N;
tobj=MakeTGraph[verts,edges,faces];
tobj=FoldGraph3D[tobj,foldangles];
tobj1=UnfoldGraph3D[tobj];
GraphicsRow[{
GraphGraphics[tobj,Axes->True],
Graph3DGraphics3D[tobj],
GraphGraphics[tobj1,Axes->True]
}]]//ShowExample
TranslateGraph3D[tobj_TObj, r_]:=Module[{verts3d},
AssertClass[tobj,TGraph3D,TranslateGraph3D];
verts3d=GetValue[tobj,Vertices3D];
verts3d=#+r&/@verts3d;
tobj//ReplaceProperty[Vertices3D->verts3d]]
Module[{verts,edges,foldangles,verts3d,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
foldangles={0,90\[Degree],0,0,0,0,0};
tobj=MakeTGraph[verts,edges];
(* re-fold it to the new angle, keeping original orientation *)
tobj1=FoldGraph3D[tobj,foldangles];
tobj2=TranslateGraph3D[tobj1,{1,1,1}];
GraphicsRow[{
GraphGraphics[tobj],
Graph3DGraphics3D[tobj1,Axes->True,AxesLabel->{"x","y","z"}],
Graph3DGraphics3D[tobj2,Axes->True,AxesLabel->{"x","y","z"}]
}]
]//ShowExample
RotateGraph3D[tobj_TObj, \[Phi]_, w_]:=Module[{verts3d},
AssertClass[tobj,TGraph3D,RotateGraph3D];
verts3d=GetValue[tobj,Vertices3D];
verts3d=RotationMatrix3D[\[Phi],w] . #&/@verts3d;
tobj//ReplaceProperty[Vertices3D->verts3d]]
Module[{verts,edges,foldangles,verts3d,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
foldangles={0,90\[Degree],0,0,0,0,0};
tobj=MakeTGraph[verts,edges];
(* re-fold it to the new angle, keeping original orientation *)
tobj1=FoldGraph3D[tobj,foldangles];
tobj2=RotateGraph3D[tobj1,\[Pi]/10,{0,1,0}];
GraphicsRow[{
GraphGraphics[tobj],
Graph3DGraphics3D[tobj1,Axes->True,AxesLabel->{"x","y","z"}],
Graph3DGraphics3D[tobj2,Axes->True,AxesLabel->{"x","y","z"}]
}]
]//ShowExample
VertexRotateGraph3D::badind="Index specification `1` is invalid because `2` only has `3` vertices.";
VertexRotateGraph3D[tobj_TObj, {io_, ix_, iy_}]:=Module[{nv,verts3d},
AssertClass[tobj,TGraph3D,VertexRotateGraph3D];
nv=Length[tobj[Vertices]];
If[io<1||io>nv||ix<1||ix>nv||iy<1||iy>nv,Message[VertexRotateGraph3D::badind,{io,ix,iy},tobj,nv];Abort[]];
verts3d=GetValue[tobj,Vertices3D];
verts3d= #-verts3d[[io]]&/@verts3d;
If[Chop[Mag[verts3d[[ix]]\[Cross]{1,0,0}]]!=0,
verts3d=RotationMatrix[{verts3d[[ix]],{1,0,0}}] . #&/@verts3d];
If[Chop[Mag[verts3d[[iy]]\[Cross]{0,1,0}]]!=0,
verts3d=RotationMatrix[{verts3d[[iy]],{0,1,0}}] . #&/@verts3d];
tobj//ReplaceProperty[Vertices3D->verts3d]]
Module[{verts,edges,foldangles,verts3d,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,5},{5,6},{6,1},{2,3},{3,4},{4,5}};
verts3d={{0,0,0},{1,0,-1/2},{2,0,0},{2,1,0},{1,1,-1/2},{0,1,0}};
foldangles={0,90\[Degree],0,0,0,0,0};
tobj=MakeTGraph[verts,edges];
(* re-fold it to the new angle, keeping original orientation *)
tobj1=FoldGraph3D[tobj,foldangles];
tobj2=VertexRotateGraph3D[tobj1,{5,4,6}];
GraphicsRow[{
GraphGraphics[tobj],
Graph3DGraphics3D[tobj1,Axes->True,AxesLabel->{"x","y","z"}],
Graph3DGraphics3D[tobj2,Axes->True,AxesLabel->{"x","y","z"}]
}]
]//ShowExample
TPrimalDualGraph::usage="TPrimalDualGraph is a TObj class that represents a primal graph together with its dual graph.";
RegisterTClass[TPrimalDualGraph,{TPlaneGraph}];
DualVertices::usage="DualVertices is a TObj property specifying vertices of a dual graph as a list of vertex coordinates.";
DualEdges::usage="DualEdges is a TObj property specifying edges of a dual graph as a list of index pairs into DualVertices.";
DualFaces::usage="DualFaces is a TObj property that specifies the dual graph faces as lists of indices into DualVertices.";
InteriorEdges::usage="InteriorEdges is a TObj property that specifies the interior edges of a plane graph as ordered pairs of vertex indices.";
AddTPrimalDualGraphTo[tobj_TObj]:=Module[{verts,edges,faces,iedges,dedges,dverts,vfi,iverts,dfaces},
AssertClass[tobj,TPlaneGraph,AddTPrimalDualGraphTo];
{verts,edges,faces,iverts}=GetValues[tobj,{Vertices,Edges,Faces,InteriorVertices}];
(* InteriorEdges, DualEdges *)
{iedges,dedges}=OrientedInteriorEdgePairs[tobj];
(* DualVertices *)
dverts=FaceCentroids[tobj];
(* InteriorVertices *)
vfi=GetValue[tobj,VertexFaceIncidence];
iverts=Reap[Do[If[!MemberQ[vfi[[i]],0],Sow[i]],{i,Length[verts]}]][[2]];
If[!ListEmptyQ[iverts],iverts=Flatten[iverts]];
(* DualFaces *)
dfaces=vfi[[#]]&/@iverts;
AddClassTo[tobj,TPrimalDualGraph,{
InteriorVertices->iverts,
InteriorEdges->iedges,
DualVertices->dverts,
DualEdges->dedges,
DualFaces->dfaces}]]
AddTPrimalDualGraph:=AddTPrimalDualGraphTo[#]&
Module[{verts,edges,tobj},
verts={{0,0},{2,0},{4,0},{0,2},{2,2},{4,2},{0,4},{2,4},{4,4}};
edges={{2,5},{4,5},{5,6},{5,8},{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTPrimalDualGraph;
ColumnForm[GetAllRules[tobj]]
]//ShowExample
ShowPrimalEdges::usage="ShowPrimalEdges is an option to PrimalDualGraphics that specifies whether to display the primal graph edges.";
ShowDualEdges::usage="ShowDualEdges is an option to PrimalDualGraphics that specifies whether to display the primal graph edges.";
PrimalDirectedEdges::usage="PrimalDirectedEdges is an option to PrimalDualGraphics that specifies whether the primal graph should be drawn with directed edges.";
DualDirectedEdges::usage="DualDirectedEdges is an option to PrimalDualGraphics that specifies whether the dual graph should be drawn with directed edges.";
ShowPrimalVertices::usage="ShowPrimalVertices is an option to PrimalDualGraphics that specifies whether to display the primal graph vertices.";
ShowDualVertices::usage="ShowDualVertices is an option to PrimalDualGraphics that specifies whether to display the dual graph vertices.";
PrimalVertexLabels::usage="PrimalVertexLabels is an option to PrimalDualGraphics that specifies the labels used for the primal graph vertices.";
DualVertexLabels::usage="DualVertexLabels is an option to PrimalDualGraphics that specifies the labels used for the dual graph vertices.";
PrimalVertexLetter::usage="PrimalVertexLetter is an option to PrimalDualGraphics that specifies the letter used for the primal graph vertices.";
DualVertexLetter::usage="DualVertexLetter is an option to PrimalDualGraphics that specifies the letter used for the dual graph vertices.";
PlaceSideBySide::usage="PlaceSideBySide is an option to PrimalDualGraphics that specifies whether the primal and dual graphs should be displayed side-by-side (True) or superimposed (False).";
Options[PrimalDualGraphics]={
ShowPrimalEdges->True,
ShowDualEdges->True,
PrimalDirectedEdges->False,
DualDirectedEdges->False,
ShowPrimalVertices->True,
ShowDualVertices->True,
PrimalVertexLabels->Automatic,
DualVertexLabels->Automatic,
PrimalVertexLetter->"p",
DualVertexLetter->"d",
PlaceSideBySide->False
};
PrimalDualGraphics[tobj_TObj,opts___]:=Module[{spe,sde,pde,dde,spv,sdv,pvl,dvl,pvt,dvt,psbs,verts,edges,dverts,dedges,iedges,bedges,primalcolor,dualcolor,pg,dg},
AssertClass[tobj,TPrimalDualGraph,PrimalDualGraphics];
{verts,edges,dverts,dedges,iedges,bedges}=GetValues[tobj,{Vertices,Edges,DualVertices,DualEdges,InteriorEdges,BoundaryEdges}];
spe=ShowPrimalEdges/.{opts}/.Options[PrimalDualGraphics];
sde=ShowDualEdges/.{opts}/.Options[PrimalDualGraphics];
pde=PrimalDirectedEdges/.{opts}/.Options[PrimalDualGraphics];
dde=DualDirectedEdges/.{opts}/.Options[PrimalDualGraphics];
spv=ShowPrimalVertices/.{opts}/.Options[PrimalDualGraphics];
sdv=ShowDualVertices/.{opts}/.Options[PrimalDualGraphics];
pvl=PrimalVertexLabels/.{opts}/.Options[PrimalDualGraphics];
dvl=DualVertexLabels/.{opts}/.Options[PrimalDualGraphics];
pvt=PrimalVertexLetter/.{opts}/.Options[PrimalDualGraphics];
dvt=DualVertexLetter/.{opts}/.Options[PrimalDualGraphics];
psbs=PlaceSideBySide/.{opts}/.Options[PrimalDualGraphics];
primalcolor=ColorConvert[Darker[Orange,0.15],"CMYK"]; (* darkening slightly gives better contrast in projected images *)
dualcolor=ColorConvert[Darker[Green,0.15],"CMYK"];
pg={If[spe,{
Style[EdgeLines[verts,edges[[#]]&/@bedges],AbsoluteThickness[1],primalcolor],
Style[If[pde,DirectedEdgeLines,EdgeLines][verts,iedges,opts],AbsoluteThickness[1],primalcolor]},{}],
If[spv,{
Style[Point/@verts,Darker[primalcolor],AbsolutePointSize[4]],
Style[Switch[pvl,None,{},Automatic,StdVertexLabels[verts,VertexLetter->pvt],_,pvl],Darker[primalcolor]]},{}]};
dg={If[sde,{
Style[If[dde,DirectedEdgeLines,EdgeLines][dverts,dedges,opts],AbsoluteThickness[1.2],dualcolor],
Style[Switch[dvl,None,{},Automatic,StdVertexLabels[dverts,VertexLetter->dvt],_,dvl],Darker[dualcolor]]},{}],
If[sdv,{Style[Point/@dverts,Darker[dualcolor],AbsolutePointSize[4]],
},{}]};
Graphics[If[psbs,PlaceInRowGraphics[{pg,dg}],{pg,dg}],FilterRules[{opts},Options[Graphics]]]]
Module[{verts,edges,dverts,dedges,tobj},
verts={{0,0},{1,0},{2,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{1,2},{2,2},{3,2},{0,3},{1,3},{2,3},{3,3}};
edges={{1,2},{2,3},{3,4},{5,6},{6,7},{7,8},{9,10},{10,11},{11,12},{13,14},{14,15},{15,16},{1,5},{2,6},{3,7},{4,8},{5,9},{6,10},{7,11},{8,12},{9,13},{10,14},{11,15},{12,16}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddClass[TPrimalDualGraph,{InteriorEdges->{{2,6},{3,7},{5,6},{6,7},{6,10},{7,8},{7,11},{9,10},{10,11},{10,14},{11,12},{11,15}},DualVertices->{{0.5`,0.5`},{1.5`,0.5`},{2.5`,0.5`},{0.5`,1.5`},{1.5`,1.5`},{2.5`,1.5`},{0.5`,2.5`},{1.5`,2.5`},{2.5`,2.5`}},DualEdges->{{2,1},{3,2},{1,4},{2,5},{5,4},{3,6},{6,5},{4,7},{5,8},{8,7},{6,9},{9,8}}}];
GraphicsRow[{
PrimalDualGraphics[tobj,PrimalDirectedEdges->True,DualDirectedEdges->True],PrimalDualGraphics[tobj,PrimalDirectedEdges->True,DualDirectedEdges->True,PrimalVertexLabels->None,DualVertexLabels->Automatic,PlaceSideBySide->True]}]
]//ShowExample
Module[{verts,edges,tobj},
verts={{0,0},{2,0},{4,0},{0,2},{2,2},{4,2},{0,4},{2,4},{4,4}};
edges={{2,5},{4,5},{5,6},{5,8},{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTPrimalDualGraph;
PrimalDualGraphics[tobj,PrimalDirectedEdges->True,DualDirectedEdges->True]
]//ShowExample
Module[{verts,edges,tobj},
verts=Flatten[Table[N[{i-1,j-1}],{j,4},{i,4}],1];
edges=Join[Flatten[Table[{i+4(j-1),i+1+4(j-1)},{j,4},{i,3}],1],Flatten[Table[{i+4(j-1),i+4(j)},{j,3},{i,4}],1]];
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTPrimalDualGraph;
PrimalDualGraphics[tobj,PrimalDirectedEdges->True,DualDirectedEdges->True,
ArrowPosition->0.75,ArrowheadStyle->Arrowheads[Large]]
]//ShowExample
Module[{verts,edges,tobj},
verts={{-0.5`,0.`},{0.5`,0.`},{0.20710678118654746`,0.7071067811865475`},{-0.5`,1.`},{-1.2071067811865475`,0.7071067811865475`},{-1.5`,0.`},{-0.20710678118654746`,-0.7071067811865475`},{0.5`,-1.`},{1.2071067811865475`,-0.7071067811865475`},{1.5`,1.1102230246251565`*^-16}};
edges={{1,2},{1,3},{1,4},{1,5},{1,6},{2,3},{3,4},{4,5},{5,6},{2,7},{2,8},{2,9},{1,7},{7,8},{8,9},{9,10},{2,10}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTPrimalDualGraph;
Print[PrimalDualGraphics[tobj]];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
Module[{verts,edges,dverts,dedges,tobj},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,1}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTPrimalDualGraph;
Print[PrimalDualGraphics[tobj]];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
OrientEdgePairs[tobj_TObj, fn_]:=Module[{verts,iedges,dverts,dedges},
AssertClass[tobj,TPrimalDualGraph,OrientEdgePairs];
{dverts,dedges,iedges}=GetValues[tobj,{DualVertices,DualEdges,InteriorEdges}];
Do[
If[!fn[dverts[[dedges[[i,1]]]],dverts[[dedges[[i,2]]]]],dedges[[i]]=Reverse[dedges[[i]]];iedges[[i]]=Reverse[iedges[[i]]]]
,{i,Length[dedges]}];
ReplacePropertiesIn[tobj,{InteriorEdges->iedges,DualEdges->dedges}]]
Module[{verts,edges,tobj,fn,tobj1},
verts={{-1,-1},{0,-1},{1,-1},{-1,0},{0,0},{1,0},{-1,1},{0,1},{1,1}};
edges={{1,2},{2,3},{4,5},{5,6},{7,8},{8,9},{1,4},{4,7},{2,5},{5,8},{3,6},{6,9}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo;
fn=RadialAxialOrderingFn[{0,0},RadialMajor->True];
tobj1=OrientEdgePairs[tobj,fn];
GraphicsRow[{
PrimalDualGraphics[tobj,PrimalDirectedEdges->True,DualDirectedEdges->True],
PrimalDualGraphics[tobj1,PrimalDirectedEdges->True,DualDirectedEdges->True]
}]
]//ShowExample
InteriorEdgeMap[tobj_TObj]:=Module[{edges,iedges,emap},
{edges,iedges}=GetValues[tobj,{Edges,InteriorEdges}];
Do[emap[edges[[i]]]=i;emap[Reverse[edges[[i]]]]=i,{i,Length[edges]}];
emap/@iedges]
Module[{verts,edges,tobj,fn,tobj1},
verts={{-1,-1},{0,-1},{1,-1},{-1,0},{0,0},{1,0},{-1,1},{0,1},{1,1}};
edges={{1,2},{2,3},{4,5},{5,6},{7,8},{8,9},{1,4},{4,7},{2,5},{5,8},{3,6},{6,9}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo;
Print[PrimalDualGraphics[tobj,PrimalDirectedEdges->True,DualDirectedEdges->True]];
Print["Edges = ",tobj[Edges]];
Print["InteriorEdges = ",tobj[InteriorEdges]];
InteriorEdgeMap[tobj]
]//ShowExample
DualEdgeRatio[tobj_TObj]:=Module[{verts,iedges,dverts,dedges,dplens},
AssertClass[tobj,TPrimalDualGraph,DualEdgeRatio];
{verts,iedges,dverts,dedges}=GetValues[tobj,{Vertices,InteriorEdges,DualVertices,DualEdges}];
dplens=MapThread[Dot,{Subtract@@dverts[[#]]&/@dedges,NormalizeReal[Rotate90[Subtract@@verts[[#]]]]&/@iedges},1];
dplens=dplens*(Sign/@dplens);
Max[#]/Min[#]&[dplens]]
Module[{verts,edges,dverts,dedges,tobj},
verts={{-1,-1},{0,-1},{1,-1},{-1,0},{0,0},{1,0},{-1,1},{0,1},{1,1}};
edges={{1,2},{2,3},{4,5},{5,6},{7,8},{8,9},{1,4},{4,7},{2,5},{5,8},{3,6},{6,9}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTPrimalDualGraph;
Print[PrimalDualGraphics[tobj]];
DualEdgeRatio[tobj]
]//ShowExample
OrthogonalityAngles[tobj_TObj]:=Module[{verts,edges,dverts,dedges,pairsv,dpairsv,dplens},
AssertClass[tobj,TPrimalDualGraph,OrthogonalityAngles];
{verts,edges,dverts,dedges}=GetValues[tobj,{Vertices,InteriorEdges,DualVertices,DualEdges}];
pairsv=Subtract@@verts[[#]]&/@edges;
dpairsv=Subtract@@dverts[[#]]&/@dedges;
dplens=MapThread[Dot,{NormalizeReal/@Rotate90/@pairsv,dpairsv}];
dplens=dplens*(Sign/@dplens);
MapThread[ArcTan[Abs[#1 . Rotate90[#2]],Abs[#1 . #2]]/\[Degree]&,{dpairsv,pairsv}] (* orthogonality *)
]
Module[{verts,edges,dverts,dedges,tobj},
verts={{-1,-1},{0,-1},{1,-1},{-1,0},{0.2,0},{1,0},{-1,1},{0,1},{1,1}};
edges={{1,2},{2,3},{4,5},{5,6},{7,8},{8,9},{1,4},{4,7},{2,5},{5,8},{3,6},{6,9}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTPrimalDualGraph;
Print[PrimalDualGraphics[tobj]];
OrthogonalityAngles[tobj]
]//ShowExample
WorstOrthogonalityAngle[tobj_TObj]:=Max[OrthogonalityAngles[tobj]]
TriangleGraphQ[tobj_TObj]:=Module[{faces},
AssertClass[tobj,TGraph,TriangleGraphQ];
faces=GetValue[tobj,Faces];
And@@(Length[#]==3&/@faces)]
Module[{tobj},
tobj=TObj[{TClasses->{TGraph},Faces->{{1,2,3},{3,4,2}}}];
TriangleGraphQ[tobj]
]//ShowExample
DelaunayTriangleGraphQ[tobj_TObj]:=Module[{verts,faces,dverts,ctr,rad,testverts,ret},
{verts,faces} = GetValues[tobj,{Vertices,Faces}];
If[!TriangleGraphQ[tobj],Return[False]];
dverts=Circumcenter[verts[[#]]]&/@faces;
ret=True;
Do[
ctr=dverts[[i]];
rad=Mag[verts[[faces[[i,1]]]]-ctr];
testverts=verts[[Complement[Range[Length[verts]],faces[[i]]]]];
If[Or@@(Mag[#-ctr]<rad&/@testverts),ret=False;Break[]],{i,Length[faces]}];
ret
]
Module[{r,pverts,pedges,tobj},
r=1.0;(* r=1.0 gives non-crossing graph, r=1.6 gives a crossing dual *)
pverts={1.0,r}*#&/@{{0,0},{1,0.3},{2,0},{0,1},{2,1},{0,2},{1,1.7},{2,2}};
pedges={{1,2},{2,3},{2,4},{2,5},{2,7},{3,5},{4,1},{4,7},{5,7},{5,8},{6,4},{7,6},{8,7}};
tobj=MakeTPlaneGraph[pverts,pedges];
Print[GraphGraphics[tobj]];
DelaunayTriangleGraphQ[tobj]
]//ShowExample
Module[{r,pverts,pedges,tobj},
r=1.6;(* r=1.0 gives non-crossing graph, r=1.6 gives a crossing dual *)
pverts={1.0,r}*#&/@{{0,0},{1,0.3},{2,0},{0,1},{2,1},{0,2},{1,1.7},{2,2}};
pedges={{1,2},{2,3},{2,4},{2,5},{2,7},{3,5},{4,1},{4,7},{5,7},{5,8},{6,4},{7,6},{8,7}};
tobj=MakeTPlaneGraph[pverts,pedges];
Print[GraphGraphics[tobj]];
DelaunayTriangleGraphQ[tobj]
]//ShowExample
MakeTriangleGraphReciprocalDiagram::nottg="Graph `1` with faces `2` does not consist entirely of triangles.";
MakeTriangleGraphReciprocalDiagram[tobj_TObj]:=Module[{tobj1,dverts},
AssertClass[tobj,TPrimalDualGraph,MakeTriangleGraphReciprocalDiagram];
If[!TriangleGraphQ[tobj],Message[MakeTriangleGraphReciprocalDiagram::nottg,tobj,GetValues[tobj,Faces]];Abort[]];
dverts=FaceCircumcenters[tobj];
tobj//ReplaceProperty[DualVertices->dverts]
]
Module[{r,verts,edges,faces,tobj},
verts={{0,0},{1,0.3},{2,0},{0,1},{2,1},{0,2},{1,1.7},{2,2}};
edges={{1,2},{2,3},{2,4},{2,5},{2,7},{3,5},{4,1},{4,7},{5,7},{5,8},{6,4},{7,6},{8,7}};
tobj=MakeTPlaneGraph[verts,edges]//AddTPrimalDualGraph//MakeTriangleGraphReciprocalDiagram;
Print[PrimalDualGraphics[tobj]];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
Module[{r,verts,edges,faces,tobj},
verts={1.0,1.6}#&/@{{0,0},{1,0.3},{2,0},{0,1},{2,1},{0,2},{1,1.7},{2,2}};
edges={{1,2},{2,3},{2,4},{2,5},{2,7},{3,5},{4,1},{4,7},{5,7},{5,8},{6,4},{7,6},{8,7}};
tobj=MakeTPlaneGraph[verts,edges]//AddTPrimalDualGraph//MakeTriangleGraphReciprocalDiagram;
Print[PrimalDualGraphics[tobj]];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
Module[{r,verts,edges,tobj},
verts={{-0.5`,0.`},{0.5`,0.`},{0.20710678118654746`,0.7071067811865475`},{-0.5`,1.`},{-1.2071067811865475`,0.7071067811865475`},{-1.5`,0.`},{-0.20710678118654746`,-0.7071067811865475`},{0.5`,-1.`},{1.2071067811865475`,-0.7071067811865475`},{1.5`,1.1102230246251565`*^-16}};
edges={{1,2},{1,3},{1,4},{1,5},{1,7},{2,3},{2,7},{2,8},{2,9},{3,4},{4,5},{5,6},{6,1},{7,8},{8,9},{9,10},{10,2}};
tobj=MakeTPlaneGraph[verts,edges]//AddTPrimalDualGraph//MakeTriangleGraphReciprocalDiagram;
Print[PrimalDualGraphics[tobj]];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
OrthogonalityTolerance::usage="OrthogonalityTolerance is an option to MakeReciprocalDiagram that establishes a nonzero tolerance on the primal-dual orthogonality condition.";
PleatLengthWeight::usage="PleatLengthWeight is a option to MakeReciprocalDiagram that lets you mix some total pleat length into the optimization objective function.";
Options[MakeReciprocalDiagram]={
Method->"MaxMinPleat",
OrthogonalityTolerance->0,
PleatLengthWeight->1.0
};
MakeReciprocalDiagram::nosoln="BuildReciprocalDiagrams was unable to find a solution.";
MakeReciprocalDiagram::unsup="`1` is an unsupported method of MakeReciprocalDiagram.";
MakeReciprocalDiagram::notweb="MakeReciprocalDiagram found a negative minimum pleat width and so this graph is not a spiderweb.";
MakeReciprocalDiagram[tobj_TObj,opts___]:=Module[{verts,faces,me,tol,plw,iedges,dverts,dedges,v,vars,vars0,dcoords,lmax,lmin,pairsv,dpairsv,dplens,drules,orthofn,ortho,eqns,ineqns,obj,pineqns,soln,dverts1,ro,xo,yo,rms,soln1},
AssertClass[tobj,TPrimalDualGraph,MakeReciprocalDiagram];
me=Method/.{opts}/.Options[MakeReciprocalDiagram];
tol=OrthogonalityTolerance/.{opts}/.Options[MakeReciprocalDiagram];
plw=PleatLengthWeight/.{opts}/.Options[MakeReciprocalDiagram];
(* Build the plane graph parts for a false reciprocal diagram *)
{verts,iedges,dverts,dedges}=GetValues[tobj,{Vertices,InteriorEdges,DualVertices,DualEdges}];
(* Set up to solve for the new dverts *)
vars=Table[Unique[v],{2 Length[dverts]}];
vars0=Flatten[dverts];
dcoords=Partition[vars,2];
drules=MapThread[Rule,{vars,vars0}];
pairsv=NormalizeReal/@(Subtract@@verts[[#]]&/@iedges);
(*
dpairsv=Subtract@@dcoords\[LeftDoubleBracket]#\[RightDoubleBracket]&/@dedges; (* dpairsv are not *)
dplens=MapThread[Dot,{Rotate90/@pairsv,dpairsv}];(* gives length of dual edge when ortho holds *)
dplens=dplens*(Sign/@dplens/.drules);
ortho=MapThread[Dot,{pairsv,dpairsv/(Mag/@(dpairsv/.drules))}];(* approximately normalized ortho *)
*)
dpairsv=Subtract@@dcoords[[#]]&/@dedges;
dplens=MapThread[Dot,{Rotate90/@pairsv,dpairsv}];
dplens=dplens*(Sign/@dplens/.drules);
ortho=MapThread[Dot,{pairsv,dpairsv}];
(*
pineqns={vars\[LeftDoubleBracket]1\[RightDoubleBracket]\[Equal]vars0\[LeftDoubleBracket]1\[RightDoubleBracket],vars\[LeftDoubleBracket]2\[RightDoubleBracket]\[Equal]vars0\[LeftDoubleBracket]2\[RightDoubleBracket]
,If[Abs[vars0\[LeftDoubleBracket]3\[RightDoubleBracket]-vars0\[LeftDoubleBracket]1\[RightDoubleBracket]]>Abs[vars0\[LeftDoubleBracket]4\[RightDoubleBracket]-vars0\[LeftDoubleBracket]2\[RightDoubleBracket]],vars\[LeftDoubleBracket]3\[RightDoubleBracket]\[Equal]vars0\[LeftDoubleBracket]3\[RightDoubleBracket],vars\[LeftDoubleBracket]4\[RightDoubleBracket]\[Equal]vars0\[LeftDoubleBracket]4\[RightDoubleBracket]]
};
*)
Which[
me=="MaxMinPleat",
AppendTo[vars,lmin];
AppendTo[vars0,-1.0];
eqns=Join[{Plus@@dplens==(Plus@@dplens/.drules)},#==0&/@ortho];
ineqns=Join[#>=lmin&/@dplens];
obj=-lmin;
,
me=="MinTotalPleat",
eqns=Join[{vars[[1]]==0,vars[[2]]==0},#==0&/@ortho];
ineqns=#>=1&/@dplens;
obj=Plus@@dplens;
,
me=="MinPleatRange",
AppendTo[vars,lmax];
AppendTo[vars0,2];
eqns=Join[{vars[[1]]==0,vars[[2]]==0},#==0&/@ortho];
ineqns=Join[#>=1&/@dplens,#<=lmax&/@dplens];
obj=lmax;
,
me=="Tolerant",
AppendTo[vars,lmax];
AppendTo[vars0,2];
eqns=Join[{vars[[1]]==0,vars[[2]]==0},#==0&/@ortho];
ineqns=Join[#>=1&/@dplens,#<=lmax&/@dplens,#>=-tol&/@ortho,#<=tol&/@ortho];
obj=lmax;
,
me=="Robust",
eqns={};
ineqns=#>=1&/@dplens;
obj=plw(Plus@@dplens)+(Plus@@(ortho^2));
,
me=="Test",
AppendTo[vars,lmin];
AppendTo[vars0,0.0];
eqns=Join[{vars[[1]]==vars0[[1]],vars[[2]]==vars0[[2]]},{Plus@@dplens==(Plus@@dplens/.drules)},#==0&/@ortho];
ineqns=Join[#>=lmin&/@dplens];
obj=-lmin;
,
True,
Message[MakeReciprocalDiagram::unsup,me];Abort[]];
(*
PrintThis[obj];
PrintThis[eqns];
PrintThis[ineqns];
PrintThis[vars];
PrintThis[vars0];
*)
soln=FindMinimum@@Join[{Join[{obj},eqns,ineqns]},Transpose[{vars,vars0}]];
If[Head[soln]===FindMinimum,Message[MakeReciprocalDiagram::nosoln];Abort[]];
If[me=="MaxMinPleat"&&soln[[1]]>0,Message[MakeReciprocalDiagram::notweb]];
(* Now find the translated/scaled version with min rms deviation from original dverts *)
dverts1=ro #+{xo,yo}&/@(dcoords/.soln[[2]]);
rms=Simplify[Plus@@Mag2/@(dverts1-dverts)];
soln1=FindMinimum[rms,{ro,0},{xo,0},{yo,0},AccuracyGoal->6];(* don't need a ton of accuracy here *)
dverts=dverts1/.soln1[[2]];
tobj//ReplaceProperty[DualVertices->dverts]
]
Module[{verts,edges,tobj,tobj1,tobj2},
verts={1.0,1.6}#&/@{{0,0},{1,0.3},{2,0},{0,1},{2,1},{0,2},{1,1.7},{2,2}};
edges={{1,2},{2,3},{2,4},{2,5},{2,7},{3,5},{4,1},{4,7},{5,7},{5,8},{6,4},{7,6},{8,7}};
tobj=MakeTPlaneGraph[verts,edges]//AddTPrimalDualGraph;
tobj1=MakeTriangleGraphReciprocalDiagram[tobj];
tobj2=MakeReciprocalDiagram[tobj];
GraphicsRow[{
PrimalDualGraphics[tobj],
PrimalDualGraphics[tobj1],
PrimalDualGraphics[tobj2]
}]
]//ShowExample
Module[{verts,edges,faces,tobj,tobj1},
verts={{-1,-1},{5,0},{2,4},{1,1},{3,1},{2,2}};
faces={{1,2,5},{1,5,4},{1,4,6,3},{4,5,6},{2,3,6,5}};
edges={{1,2},{1,4},{1,5},{2,3},{2,5},{3,1},{3,6},{4,5},{4,6},{5,6}};
tobj=MakeTPlaneGraph[verts,edges]//AddTPrimalDualGraph;
tobj1=MakeReciprocalDiagram[tobj];
GraphicsRow[{
PrimalDualGraphics[tobj],
PrimalDualGraphics[tobj1]
}]
]//ShowExample
BorderLine::usage="BorderLine is a symbolic line style indicating the border of the paper in either crease pattern or folded form.";
ValleyLine::usage="ValleyLine is a symbolic line style indicating a valley fold in a crease pattern.";
MountainLine::usage="MountainLine is a symbolic line style indicating a mountain fold in a crease pattern.";
CreaseLine::usage="CreaseLine is a symbolic line style indicating a crease (unfolded) fold in a crease pattern.";
FoldedLine::usage="FoldedLine is a symbolic line style indicating a folded edge in a folded form.";
UnfoldedLine::usage="UnfoldedLine is a symbolic line style indicating an unfolded fold in a folded form.";
HiddenBorderLine::usage="HiddenBorderLine is a symbolic line style indicating a hidden border edge in a 2D folded form.";
HiddenFoldedLine::usage="HiddenFoldedLine is a symbolic line style indicating a hidden folded edge in a 2D folded form.";
HiddenUnfoldedLine::usage="HiddenUnfoldedLine is a symbolic line style indicating a hidden unfolded edge in a 2D folded form.";
ValleyRulingLine::usage="ValleyRulingLine is a symbolic line style indicating a ruling line with positive ruling curvature in a crease pattern.";
MountainRulingLine::usage="MountainRulingLine is a symbolic line style indicating a ruling line with negative ruling curvature in a crease pattern.";
UndefinedRulingLine::usage="UndefinedRulingLine is a symbolic line style indicating a ruling line with undefined ruling curvature in a crease pattern or folded form.";
NoLine::usage="NoLine is a symbolic line style indicating no fold line at all in crease pattern or folded form.";
PaperWhiteSideFill::usage="PaperWhiteSideFill is a symbolic fill style representing the white side of the paper in 2D folded forms.";
PaperColoredSideFill::usage="PaperColoredSideFill is a symbolic fill style representing the colored side of the paper in 2D folded forms.";
Paper3DFill::usage="Paper3DFill is a symbolic fill style representing 3D forms from paper colored on one side and white on the other.";
Paper3DFillReversed::usage="Paper3DFillReversed is a symbolic fill style representing 3D forms from paper colored on one side and white on the other oppositely to Paper3DFill.";
Paper3DFillBothWhite::usage="Paper3DFillBothWhite is a symbolic fill style representing 3D forms from paper white on both sides.";
Paper3DFillBothColored::usage="Paper3DFillBothColored is a symbolic fill style representing 3D forms from paper colored on both sides.";
NoFill::usage="NoFill is a symbolic fill style representing fully transparent paper in 2D and 3D forms.";
MountainColor::usage="MountainColor is an option to OrigamiStyle that specifies the color for mountain fold lines.";
ValleyColor::usage="ValleyColor is an option to OrigamiStyle that specifies the color for valley fold lines.";
CreaseColor::usage="CreaseColor is an option to OrigamiStyle that specifies the color for crease lines and undefined ruling lines.";
BorderColor::usage="BorderColor is an option to OrigamiStyle that specifies the color for the border of the paper.";
FoldedColor::usage="FoldedColor is an option to OrigamiStyle that specifies the color for generic (unassigned) fold lines.";
WhiteSideColor::usage="WhiteSideColor is an option to OrigamiStyle that specifies the color for the white side of the paper.";
ColoredSideColor::usage="ColoredSideColor is an option to OrigamiStyle that specifies the color for the colored side of the paper.";
Opacity2D::usage="Opacity2D is an option to OrigamiStyle that specifies the opacity of polygon faces in the folded form in 2D.";
Opacity3D::usage="Opacity3D is an option to OrigamiStyle that specifies the opacity of polygon faces in the folded form in 3D.";
ShowUnfolded::usage="ShowUnfolded is an option to OrigamiStyle that specifies whether to display UnfoldedLine lines.";
ShowHidden::usage="ShowHidden is an option to OrigamiStyle that specifies whether to display HiddenBorderLine, HiddenFoldedLine, and HiddenUnfolded lines.";
Options[OrigamiStyle]={
MountainColor->RGBColor[0,0,4/9],(* dark blue *)
ValleyColor->Magenta,(* Magenta *)
CreaseColor->Gray,
BorderColor->Black,
FoldedColor->Black,
WhiteSideColor->RGBColor[0.92,0.85,1],(* pale purple *)
ColoredSideColor->RGBColor[.65,.3,1],(* darker purple *)
Opacity2D->0.50,
Opacity3D->0.85,
ShowUnfolded->True,
ShowHidden->True
};
OrigamiStyle[opts___]:=Module[{mc,vc,cc,ac,bc,fc,wsc,csc,op2,op3,su,sh,cj,x},
mc=MountainColor/.{opts}/.Options[OrigamiStyle];
vc=ValleyColor/.{opts}/.Options[OrigamiStyle];
cc=CreaseColor/.{opts}/.Options[OrigamiStyle];
bc=BorderColor/.{opts}/.Options[OrigamiStyle];
fc=FoldedColor/.{opts}/.Options[OrigamiStyle];
wsc=WhiteSideColor/.{opts}/.Options[OrigamiStyle];
csc=ColoredSideColor/.{opts}/.Options[OrigamiStyle];
op2=Opacity2D/.{opts}/.Options[OrigamiStyle];
op3=Opacity3D/.{opts}/.Options[OrigamiStyle];
su=ShowUnfolded/.{opts}/.Options[OrigamiStyle];
sh=ShowHidden/.{opts}/.Options[OrigamiStyle];
cj=Sequence[CapForm["Round"],JoinForm["Round"]];
{BorderLine->{bc,AbsoluteThickness[1],AbsoluteDashing[{}],cj},
ValleyLine->{vc,AbsoluteThickness[1],AbsoluteDashing[{3,3}],cj},
MountainLine->{mc,AbsoluteThickness[1],AbsoluteDashing[{}],cj},
CreaseLine->{cc,AbsoluteThickness[0.5],AbsoluteDashing[{}],cj},
FoldedLine->{fc,AbsoluteThickness[1.0],AbsoluteDashing[{}],cj},
ValleyRulingLine->{vc,AbsoluteThickness[0.5],AbsoluteDashing[{0,1.5}],cj},
MountainRulingLine->{mc,AbsoluteThickness[0.5],AbsoluteDashing[{0,1.5}],cj},
UndefinedRulingLine->{cc,AbsoluteThickness[0.5],AbsoluteDashing[{0,1.5}],cj},
If[su,
UnfoldedLine->{cc,AbsoluteThickness[0.5],AbsoluteDashing[{}],cj},
Style[___,UnfoldedLine,___]->Sequence[]],
If[sh,
HiddenBorderLine->{Lighter[bc],AbsoluteThickness[1],AbsoluteDashing[{0,3}],cj},
Style[___,HiddenBorderLine,___]->Sequence[]],
If[sh,
HiddenFoldedLine->{Lighter[fc],AbsoluteThickness[1],AbsoluteDashing[{0,3}],cj},
Style[___,HiddenFoldedLine,___]->Sequence[]],
If[sh,
HiddenUnfoldedLine->{Lighter[cc],AbsoluteThickness[0.5],AbsoluteDashing[{0,2}],cj},
Style[___,HiddenUnfoldedLine,___]->Sequence[]],
Style[___,NoLine,___]->Sequence[],
PaperWhiteSideFill->{EdgeForm[],FaceForm[wsc],Opacity[op2]},
PaperColoredSideFill->{EdgeForm[],FaceForm[csc],Opacity[op2]},
Paper3DFill->{EdgeForm[],FaceForm[wsc,csc],Opacity[op3]},
Paper3DFillReversed->{EdgeForm[],FaceForm[csc,wsc],Opacity[op3]},
Paper3DFillBothWhite->{EdgeForm[],FaceForm[wsc,wsc],Opacity[op3]},
Paper3DFillBothColored->{EdgeForm[],FaceForm[csc,csc],Opacity[op3]},
Style[___,NoFill,___]->Sequence[]
}]
Module[{test},
test={
Style[Polygon[{{0,0},{1,0},{0,1}}],PaperWhiteSideFill],
Style[Line[AppendFirst[{{0,0},{1,0},{0,1}}]],BorderLine],
Style[Polygon[{{1.2,0},{1.2,1},{0.2,1}}],PaperColoredSideFill],
Style[Line[AppendFirst[{{1.2,0},{1.2,1},{0.2,1}}]],BorderLine],
Style[Line[{{0,0},{.1,.5}}],MountainLine],
Style[Line[{{0,0},{.5,.1}}],ValleyLine],
Style[Line[{{1,0},{0,1}}],FoldedLine],
Style[Line[{{0,0},{.3,.3}}],CreaseLine],
Style[Line[{{.6,.1},{.1,.6}}],HiddenBorderLine],
Style[Line[{{.65,.1},{.1,.65}}],HiddenFoldedLine],
Style[Line[{{.70,.1},{.1,.70}}],HiddenUnfoldedLine],
Style[Line[{{.75,.1},{.1,75}}],NoLine]
};
Graphics[test/.OrigamiStyle[]]
]//ShowExample
DynamicModule[{p1,p2,p3,p4},
p1={0,0,0};
p2={1,0,0};
p3={0,1,0};
Manipulate[
p4=Rotate3D[p1,\[Phi],{-1,1,0},p2];
Graphics3D[{
Style[Sphere[.5(p2+p3),.7],Opacity[0]],
Style[Polygon[{p1,p2,p3}],Paper3DFill],
Style[Polygon[{p2,p4,p3}],Paper3DFill],
Style[Line[{p1,.75 p2 + .25 p3}],ValleyLine],
Style[Line[{p1,.5 p2 + .5 p3}],CreaseLine],
Style[Line[{p1,.25 p2 + .75 p3}],MountainLine],
Style[Line[{p1,p3,p4,p2,p1}],BorderLine],
Style[Line[{p2,p3}],FoldedLine],
Text["\!\(\*SubscriptBox[\(p\), \(1\)]\)",p1,{2,0}],
Text["\!\(\*SubscriptBox[\(p\), \(2\)]\)",p2,{-2,0}],
Text["\!\(\*SubscriptBox[\(p\), \(3\)]\)",p3,{0,-2}],
Text["\!\(\*SubscriptBox[\(p\), \(4\)]\)",p4,{-2,0}],
{}}/.OrigamiStyle[],Lighting->"Neutral"],
{{\[Phi],.1\[Pi]},.1\[Pi],1.9\[Pi]}]
]//ShowExample

Module[{xmin,xmax,ymin,ymax,p1,p2,p3,p4,dr},
{xmin,xmax,ymin,ymax}={0,2,0,1};
p1={xmin,ymin};
p2={xmax,ymin};
p3={xmax,ymax};
p4={xmin,ymax};
Graphics[{
Style[Polygon[{p1,p2,p3,p4}],PaperWhiteSideFill],
Style[Line[{p1,p2,p3,p4,p1}],BorderLine],
Table[Style[Line[{(1-t)p1+t p2,(1-t)p4+t p3}],Which[t>1/2,ValleyRulingLine,t<1/2,MountainRulingLine,True,UndefinedRulingLine]],{t,0,1,1/10}],
Style[Line[{.67 p1+.33p4,.67p2+.33p3}],ValleyLine],
Style[Line[{.33 p1+.67p4,.33p2+.67p3}],MountainLine],
{}}]/.OrigamiStyle[]
]//ShowExample

DynamicModule[{cc,du,dr},
Manipulate[
cc={Cos[r #1],#1+#2,Sin[r #1]}&;(* a helix *)
du=\[Pi]/50;(* divisions for rendering smooth surface *)
dr=\[Pi]/10;(* divisions for rending rulings *)
Graphics3D[{
InvisibleCube[{0,0,0},1],
Table[Style[Polygon[{cc[u-du,-1],cc[u,-1],cc[u,+1],cc[u-du,+1]}],Paper3DFill],{u,0+du,2\[Pi],du}],
Style[Line[Table[cc[u,-1],{u,0,2\[Pi],du}]],BorderLine],
Style[Line[Table[cc[u,+1],{u,0,2\[Pi],du}]],BorderLine],
Style[Line[{cc[0,-1],cc[0,+1]}],BorderLine],
Style[Line[{cc[2\[Pi],-1],cc[2\[Pi],+1]}],BorderLine],
Table[Style[Line[{cc[u,-1],cc[u,+1]}],UndefinedRulingLine],{u,0+dr,2\[Pi]-dr,dr}],
{}},Lighting->"Neutral"]/.OrigamiStyle[]
,{{r,1},0,1}]
]//ShowExample
OrigamiSampleGraphics=Graphics[{
Style[Polygon[{{0,0},{6,0},{6,2},{0,2}}],PaperWhiteSideFill],
Style[Line[{{0,0},{6,0},{6,2},{0,2},{0,0}}],BorderLine],
Style[Line[{{1,0},{3,2}}],ValleyLine],
Style[Line[{{2,0},{4,2}}],MountainLine],
Style[Line[{{4.5,2},{6,.5}}],ValleyLine],
Style[Line[{{5,0},{5,2}}],CreaseLine]
}];
OrigamiSampleGraphics/.OrigamiStyle[]//ShowExample
OrigamiSampleGraphics2D=Graphics[{
Style[Polygon[{{0,0},{1,0},{3,2},{0,2}}],PaperWhiteSideFill],
Style[Polygon[{{1,0},{3,2},{3,3},{1,1}}],PaperColoredSideFill],
Style[Polygon[{{1,1},{5,1},{5,1.5},{3.5,3},{3,3}}],PaperWhiteSideFill],
Style[Polygon[{{3.5,1.5},{5,1.5},{3.5,3}}],PaperColoredSideFill],
Style[Line[{{2,2},{0,2},{0,0},{1,0},{1,1},{5,1},{5,1.5},{3.5,1.5},{3.5,3},{3,3}}],BorderLine],
Style[Line[{{1,0},{2,1}}],FoldedLine],
Style[Line[{{2,1},{3,2}}],HiddenFoldedLine],
Style[Line[{{2,2},{3,2},{3,3}}],HiddenBorderLine],
Style[Line[{{1,1},{3,3}}],FoldedLine],
Style[Line[{{3.5,3},{5,1.5}}],FoldedLine],
Style[Line[{{4,1},{4,1.5}}],UnfoldedLine],
Style[Line[{{4,1.5},{4,2.5},{3.5,2.5}}],HiddenUnfoldedLine]
}];
OrigamiSampleGraphics2D/.OrigamiStyle[]//ShowExample
OrigamiSampleGraphics3D=Graphics3D[{
Style[Polygon[{{0,0,0},{1,0,0},{3,2,0},{0,2,0}}],Paper3DFill],
Style[Polygon[{{1,0,0},{1,2,1},{3,4,1},{3,2,0}}],Paper3DFill],
Style[Polygon[{{1,2,1},{5,2,1},{5,4,1},{3,4,1}}],Paper3DFill],
Style[Line[{{1,0,0},{3,2,0}}],FoldedLine],
Style[Line[{{1,2,1},{3,4,1}}],FoldedLine],
Style[Line[{{3,2,0},{0,2,0},{0,0,0},{1,0,0},{1,2,1},{5,2,1},{5,4,1},{3,4,1},{3,2,0}}],BorderLine],
Style[Line[{{4,2,1},{4,4,1}}],CreaseLine]
}];
OrigamiSampleGraphics3D/.OrigamiStyle[]//ShowExample
OrigamiSampleGraphicsTrio=GraphicsRow[{
OrigamiSampleGraphics,
OrigamiSampleGraphics2D,
OrigamiSampleGraphics3D}];
(temp=OrigamiSampleGraphicsTrio/.OrigamiStyle[])//ShowExample
Export[ExamplesDir[]<>"OrigamiSampleGraphicsTrio.pdf",temp,ImageSize->768]//ShowExample
OrigamiSwatchGraphics=Graphics[{
Style[Polygon[{{0,0},{1,0},{1,1},{0,1}}],{EdgeForm[],PaperWhiteSideFill}],
Style[Polygon[{{1.5,0},{2.5,0},{2.5,1},{1.5,1}}],{EdgeForm[],PaperColoredSideFill}],
Style[Line[{{0,1.5},{1,1.5}}],ValleyLine],
Style[Line[{{1.5,1.5},{2,1.5},{2.5,1.5}}],MountainLine],
{}}];
(temp=OrigamiSwatchGraphics/.OrigamiStyle[])//ShowExample
Export[ExamplesDir[]<>"OrigamiSwatchGraphics.pdf",temp,ImageSize->256]//ShowExample
ShowOrigamiSamples[stylerules_]:=Module[{},
Print[OrigamiSampleGraphics/.stylerules];
Print[OrigamiSampleGraphics2D/.stylerules];
Print[OrigamiSampleGraphics3D/.stylerules]
]
ShowOrigamiSamples[OrigamiStyle[]]//ShowExample
ShowOrigamiSamples[OrigamiStyle[
WhiteSideColor->RGBColor[0.8,0.8,1],
ColoredSideColor->RGBColor[.3,.3,1],
Opacity2D->1,
Opacity3D->1,
ShowHidden->False
]]//ShowExample
ShowOrigamiSamples[OrigamiStyle[
WhiteSideColor->RGBColor[.6,1,.6],
ColoredSideColor->RGBColor[.6,1,.6],
Opacity2D->.25,
Opacity3D->.85
]]//ShowExample
ScoreLineThickness::usage="ScoreLineThickness is an option to ScoringStyle that sets the thickness, in points, of scoring lines.";
Options[ScoringStyle]={
MountainColor->Blue,
ValleyColor->Red,
BorderColor->Black,
ScoreLineThickness->1
};
ScoringStyle[opts___]:=Module[{mc,vc,bc,st,x},
mc=MountainColor/.{opts}/.Options[ScoringStyle];
vc=ValleyColor/.{opts}/.Options[ScoringStyle];
bc=BorderColor/.{opts}/.Options[ScoringStyle];
st=ScoreLineThickness/.{opts}/.Options[ScoringStyle];
{BorderLine->{bc,AbsoluteThickness[st]},
ValleyLine->{vc,AbsoluteThickness[st]},
MountainLine->{mc,AbsoluteThickness[st]},
Style[___,CreaseLine,___]->Sequence[],
Style[___,FoldedLine,___]->Sequence[],
ValleyRulingLine->{vc,AbsoluteThickness[st]},
MountainRulingLine->{mc,AbsoluteThickness[st]},
Style[___,UnfoldedLine,___]->Sequence[],
Style[___,NoLine,___]->Sequence[],
Style[___,HiddenBorderLine,___]->Sequence[],
Style[___,HiddenFoldedLine,___]->Sequence[],
Style[___,HiddenUnfoldedLine,___]->Sequence[],
Style[___,PaperWhiteSideFill,___]->Sequence[],
Style[___,PaperColoredSideFill,___]->Sequence[],
Style[___,Paper3DFill,___]->Sequence[],
Style[___,Paper3DFillReversed,___]->Sequence[],
Style[___,Paper3DFillBothWhite,___]->Sequence[],
Style[___,Paper3DFillBothColored,___]->Sequence[]
}]
Module[{test},
test=Graphics[{
Style[Line[{{0,.25},{1,.25}}],MountainLine],
Style[Line[{{0,.5},{1,.5}}],CreaseLine],
Style[Line[{{0,.75},{1,.75}}],ValleyLine],
Style[Line[{{0,0},{1,0},{1,1},{0,1},{0,0}}],BorderLine]
}];
GraphicsRow[{
test/.OrigamiStyle[],
 test/.ScoringStyle[], 
test/.ScoringStyle[ScoreLineThickness->0.216]}]
]//ShowExample
Options[OripaStyle]={
MountainColor->Red,
ValleyColor->Blue,
CreaseColor->Gray,
BorderColor->Black,
FoldedColor->Darker[Gray],
WhiteSideColor->GrayLevel[0.9],
ColoredSideColor->GrayLevel[0.7]
};
OripaStyle[opts___]:=Module[{mc,vc,cc,bc,fc,wsc,csc,cj,x},
mc=MountainColor/.{opts}/.Options[OripaStyle];
vc=ValleyColor/.{opts}/.Options[OripaStyle];
cc=CreaseColor/.{opts}/.Options[OripaStyle];
bc=BorderColor/.{opts}/.Options[OripaStyle];
fc=FoldedColor/.{opts}/.Options[OripaStyle];
wsc=WhiteSideColor/.{opts}/.Options[OripaStyle];
csc=ColoredSideColor/.{opts}/.Options[OripaStyle];
cj=Sequence[CapForm["Round"],JoinForm["Round"]];
{BorderLine->{bc,AbsoluteThickness[1],cj},
ValleyLine->{vc,AbsoluteThickness[1],cj},
MountainLine->{mc,AbsoluteThickness[1],cj},
CreaseLine->{cc,AbsoluteThickness[.5],cj},
FoldedLine->{fc,AbsoluteThickness[1],cj},
UnfoldedLine->{cc,AbsoluteThickness[.5],cj},
HiddenBorderLine->{bc,AbsoluteThickness[1],cj},
HiddenFoldedLine->{fc,AbsoluteThickness[1],cj},
HiddenUnfoldedLine->{cc,AbsoluteThickness[.5],cj},
ValleyRulingLine->{vc,AbsoluteThickness[.5],cj},
MountainRulingLine->{mc,AbsoluteThickness[.5],cj},
PaperWhiteSideFill->{EdgeForm[],FaceForm[wsc]},
PaperColoredSideFill->{EdgeForm[],FaceForm[csc]},
Paper3DFill->{EdgeForm[],FaceForm[wsc,csc]},
Paper3DFillReversed->{EdgeForm[],FaceForm[csc,wsc]},
Paper3DFillBothWhite->{EdgeForm[],FaceForm[wsc,wsc]},
Paper3DFillBothColored->{EdgeForm[],FaceForm[csc,csc]}
}]
Module[{test},
test=Graphics[{
Style[Polygon[{{0,0},{1,0},{1,1},{0,1},{0,0}}],Paper3DFill],
Style[Line[{{0,.25},{1,.25}}],MountainLine],
Style[Line[{{0,.5},{1,.5}}],CreaseLine],
Style[Line[{{0,.75},{1,.75}}],ValleyLine],
Style[Line[{{0,0},{1,0},{1,1},{0,1},{0,0}}],BorderLine]
}];
GraphicsRow[{
test/.OrigamiStyle[], 
test/.ScoringStyle[],
 test/.OripaStyle[]}]
]//ShowExample
NeutralLighting[r_]:={
{"Ambient",RGBColor[0.35r,0.35r,0.35r]},{"Directional",RGBColor[0.37r,0.37r,0.37r],ImageScaled[{2,0,2}]},{"Directional",RGBColor[0.37r,0.37r,0.37r],ImageScaled[{2,2,2}]},{"Directional",RGBColor[0.37r,0.37r,0.37r],ImageScaled[{0,2,2}]}}
Module[{g},
g=OrigamiSampleGraphics3D;
GraphicsRow[{
Show[g],
Show[g,Lighting->NeutralLighting[.75]],
Show[g,Lighting->NeutralLighting[.5]]}]/.OrigamiStyle[]
]//ShowExample
ShadowHeight::usage="ShadowHeight is an option to StyledCurve and StyledPatch that specifies the height of the shadow below the curve or patch. Only for 3D.";
ShadowColor::usage="ShadowColor is an option to StyledCurve and StyledPatch that specifies the color of the shadow below the curve or patch. Only for 3D.";
Options[MakeShadow]={
ShadowHeight->Automatic,
ShadowOffset->0,
ShadowColor->LightGray
};
ShadowOffset::usage="ShadowOffset is an option to MakeShadow that specifies how far below the lowest point of the object the shadow should be placed.";
MakeShadow[g_,opts___]:=Module[{sh,so,sc,bbox,gs},
sh=ShadowHeight/.{opts}/.Options[MakeShadow];
so=ShadowOffset/.{opts}/.Options[MakeShadow];
sc=ShadowColor/.{opts}/.Options[MakeShadow];
If[sh===Automatic,
bbox=Graphics3DBoundingBox[g];
If[ListEmptyQ[bbox],Return[{}]];
sh=bbox[[3,1]]-so];
gs=FunctionTransform[g,{1,1,0}#+{0,0,sh}&];
gs/.{
expr_Text:>{},
Style[expr_Line,sopts___]:>Style[expr,Flatten[{sopts,sc,EdgeForm[]}]],
Style[Arrow[expr_Tube],sopts___]:>Style[Arrow[expr],Flatten[{Glow[sc],Black,Opacity[1],EdgeForm[]}]],
Style[expr_Arrow,sopts___]:>Style[expr,Flatten[{sopts,sc,Opacity[1],EdgeForm[]}]],
Style[expr_Polygon,sopts___]:>Style[expr,Flatten[{sopts,Glow[sc],Black,Opacity[1],EdgeForm[]}]],
Style[expr_,sopts___]:>Style[expr,Flatten[{sopts,Glow[sc],Black,Opacity[1],EdgeForm[]}]]}]
AddShadow[expr_,opts___]:={expr,MakeShadow[expr,opts]}
Module[{g},
g={
Style[Line[{{0,0,.7},{1,-.2,-.1},{1,1,.7},{.2,.2,1}}],Red,Thickness[.02]],
Style[Arrow[{{0,0,1},{1,.1,1}}],Purple,Thickness[.01]],
Style[Arrow[Tube[{{0,0,1},{.1,1,1}},.01]],Orange],
Style[Polygon[{{.25,.25,.3},{.75,.25,.3},{.75,.75,.3},{.25,.75,.3}}],Green],
Style[Polygon[{{.2,.2,.5},{.5,.2,.5},{.5,.5,.5},{.2,.5,.5}}],Blue],
{}};
GraphicsRow[{Graphics3D[g],Graphics3D[g//AddShadow]}]
]//ShowExample
Module[{g},
g={
Style[Line[{{0,0,.7},{1,0,-.1},{1,1,.7},{.1,.1,1}}],ValleyLine],
Style[Arrow[{{0,0,0},{1,1,0}}],Thickness[.02],Black],
Style[Polygon[{{.25,.25,.3},{.75,.25,.3},{.75,.75,.3},{.25,.75,.3}}],PaperWhiteSideFill],
Style[Polygon[{{.2,.2,.5},{.5,.2,.5},{.5,.5,.5},{.2,.5,.5}}],PaperColoredSideFill],
{}};
Graphics3D[AddShadow[g,ShadowHeight->-.5],
Lighting->NeutralLighting[.5],
ViewPoint->{10,-8,5}]/.OrigamiStyle[]
]//ShowExample
PointStyle::usage="PointStyle is an option to StyledPoint that specifies style directives for the point.";
Options[StyledPoint]={
PointStyle->{}
};
StyledPoint[p_,opts___]:=Module[{ps},
ps=PointStyle/.{opts}/.Options[StyledPoint];
Style[Point[p],ps]
]
Graphics[{
StyledPoint[{0,0}]
}]/.OrigamiStyle[]//ShowExample
LineTube::usage="LineTube is an option to StyledLine that specifies whether to use Tube in 3D.";
LineTubeThickness::usage="LineTubeThickness is an option to StyledLine that specifies the thickness to use for Tube in 3D.";
LineDirected::usage="LineDirected is an option to StyledLine that specifies whether to put an arrowhead at the end of the line.";
Options[StyledLine]={
LineStyle->{},
LineTube->False,
LineTubeThickness->0.005,
LineDirected->False
};
StyledLine::mixdims="List `1` is not all 2D or all 3D points.";
StyledLine[pts_,opts___]:=Module[{ls,lt,ltt,ld,dim},
ls=LineStyle/.{opts}/.Options[StyledLine];
lt=LineTube/.{opts}/.Options[StyledLine];
ltt=LineTubeThickness/.{opts}/.Options[StyledLine];
ld=LineDirected/.{opts}/.Options[StyledLine];
If[ls===None,Return[{}]];
dim=Union[Length/@pts];
If[Length[dim]!=1,Message[StyledLine::mixdims,pts];Abort[]];
dim=First[dim];
If[ld,
If[dim==2||!lt,
Style[Arrow[pts],ls,CapForm["Round"]],
Style[Arrow[Tube[pts,ltt]],ls,CapForm["Round"]],
],
If[dim==2||!lt,
Style[Line[pts],ls,CapForm["Round"]],
Style[Tube[pts,ltt],ls,CapForm["Round"]]]]]
Module[{},
Graphics[{
StyledLine[{{0,0},{1,0}},LineStyle->Red],
StyledLine[{{0,0},{1,1}},LineStyle->HiddenFoldedLine],
StyledLine[{{0,0},{0,1}},LineStyle->Blue,LineDirected->True]}]/.OrigamiStyle[]
]//ShowExample
Module[{},
Graphics3D[{
StyledLine[{{0,0,0},{1,0,0}},LineStyle->Red],
StyledLine[{{0,0,0},{1,1,0}},LineStyle->MountainLine],
StyledLine[{{0,0,0},{1,0,1}},LineStyle->ValleyLine],
StyledLine[{{0,0,0},{0,1,0}},LineStyle->Green,LineDirected->True],
StyledLine[{{0,0,0},{0,0,1}},LineStyle->Blue,LineDirected->True,LineTube->True],
{}}]/.OrigamiStyle[]
]//ShowExample
VectorThickness2D::usage="VectorThickness2D is an option to StyledVector that specifies the thickness of a 2D vector.";
VectorThickness3D::usage="VectorThickness3D is an option to StyledVector that specifies the thickness of a 3D vector.";
VectorColor::usage="VectorColor is an option to StyledVector that specifies the color of the vector.";
VectorLabel::usage="VectorLabel is an option to StyledVector that specifies the label at the tip of the vector.";
VectorLabelStyle::usage="VectorLabelStyle is an option to StyledVector that specifies the style to be applied to the label at the tip of the vector.";
VectorLabelPosition::usage="VectorLabelPosition is an option to StyledVector that specifies the relative position of the label at the tip of the vector.";
Options[StyledVector]={
VectorThickness2D->3,
VectorThickness3D->.007,
VectorColor->Black,
VectorLabel->"",
VectorLabelStyle->{},
VectorLabelPosition->{-2,0}
};
StyledVector[{p1_List,p2_List},opts___]:=Module[{vt2d,vt3d,vc,vls,vl,vlp,vh},
vt2d=VectorThickness2D/.{opts}/.Options[StyledVector];
vt3d=VectorThickness3D/.{opts}/.Options[StyledVector];
vc=VectorColor/.{opts}/.Options[StyledVector];
vls=VectorLabelStyle/.{opts}/.Options[StyledVector];
vl=VectorLabel/.{opts}/.Options[StyledVector];
vlp=VectorLabelPosition/.{opts}/.Options[StyledVector];
{StyledLine[{p1,p2},LineStyle->{vc,AbsoluteThickness[vt2d]},LineDirected->True,LineTube->True,LineTubeThickness->vt3d],
If[vl=!="",Text[Style[vl,vls],p2,vlp],{}]}]
StyledVector[p_List,d_List,opts___]:=StyledVector[{p,p+d},opts]
Module[{p1,p2},
p1={0,0};
p2={1,1};
Graphics[StyledVector[{p1,p2},VectorLabel->"p"],Frame->True]
]//ShowExample
Module[{p,d},
p={0,0,0};
d={1,1,1};
Graphics3D[StyledVector[p,d,VectorLabel->"q"],Boxed->True]
]//ShowExample
Module[{p,d},
p={0,0,0};
d={1,1,1};
Graphics3D[StyledVector[p,d,VectorLabel->"q",VectorLabelPosition->{0,-2},VectorLabelStyle-> {FontFamily->"Helvetica",Bold,Italic}],Boxed->True]
]//ShowExample
ArcLabel::usage="ArcLabel is an option to Styled2DArc that specifies a label to be placed in the middle of the arc.";
ArcLabelRadius::usage="ArcLabelRadius is an option to Styled2DArc that specifies the distance from the center that the label should be placed.";
LineStyle::usage="LineStyle is an option to Styled2DArc that specifies the styling to apply to the arc line. It should be one of the predefined origami line styles.";
Options[Styled2DArc]={
ArcLabel->None,
ArcLabelRadius->0.2,
LineStyle->{}
};
Styled2DArc[r1_List,r2_List,opts___]:=Module[{\[Alpha],alr,as,q1,q2,dq},
\[Alpha]=ArcLabel/.{opts}/.Options[Styled2DArc];
alr=ArcLabelRadius/.{opts}/.Options[Styled2DArc];
as=LineStyle/.{opts}/.Options[Styled2DArc];
q1=ArcTan@@r1;
q2=ArcTan@@r2;
dq=Mod[q2-q1,2\[Pi]];
{Style[Circle[{0,0},1,{q1,q1+dq}],as],
If[\[Alpha]===None,{},Text[\[Alpha],alr U[q1+dq/2]]]
}]

Graphics[Styled2DArc[{1,0},{-1,-1},ArcLabel->"A"],
PlotRange->{{-1,1},{-1,1}},Axes->True]/.OrigamiStyle[]//ShowExample
Graphics[Styled2DArc[{1,0},{-1,-1},ArcLabel->Style["A",24, Red],LineStyle->ValleyLine],
PlotRange->{{-1,1},{-1,1}},Axes->True]/.OrigamiStyle[]//ShowExample
AxesThickness2D::usage="AxesThickness2D is an option to Styled2DAxes that specifies the thickness of the axes.";
AxesColor::usage="AxesColor is an option toStyled2DAxes and Styled3DAxes that specifies the color of the axes and arrowheads.";
AxesLabelStyle::usage="AxesLabelStyle is an option to Styled2DAxes and Styled3DAxes that specifies the style for the axes labels.";
AxesLabelPosition::usage="AxesLabelPosition is an option to Styled2DAxes and Styled3DAxes that specifies the relative position of the labels on the axes relative to the tips of the arrows.";
Options[Styled2DAxes]={
AxesThickness2D->2,
AxesColor->Gray,
AxesLabelStyle->{FontFamily->"Times New Roman",Italic},
AxesLabel->{"x","y"},
AxesLabelPosition->{{-2,0},{0,-1}}
};
Styled2DAxes[opts___]:=Styled2DAxes[1,1,opts]
Styled2DAxes[xmax_, ymax_, opts___]:=Styled2DAxes[{0, xmax}, {0, ymax},  opts]/;NumericQ[xmax]&&NumericQ[ymax]
Styled2DAxes[{xmin_, xmax_}, {ymin_, ymax_},  opts___]:=Module[{at,ac,als,al,alp},
at=AxesThickness2D/.{opts}/.Options[Styled2DAxes];
ac=AxesColor/.{opts}/.Options[Styled2DAxes];
als=AxesLabelStyle/.{opts}/.Options[Styled2DAxes];
al=AxesLabel/.{opts}/.Options[Styled2DAxes];
alp=AxesLabelPosition/.{opts}/.Options[Styled2DAxes];
{StyledVector[{{xmin,0},{xmax,0}},VectorThickness2D->at,VectorColor->ac,VectorLabelStyle->als,VectorLabel->al[[1]],VectorLabelPosition->alp[[1]]],
StyledVector[{{0,ymin},{0,ymax}},VectorThickness2D->at,VectorColor->ac,VectorLabelStyle->als,VectorLabel->al[[2]],VectorLabelPosition->alp[[2]]]}]
Module[{},
GraphicsRow[{
Graphics[Styled2DAxes[]],
Graphics[{
Styled2DAxes[1.3,1,AxesColor->Orange,AxesThickness2D->4],
Style[Point[{0,0}],Red],
Style[Point[{1.3,0}],Green],
Style[Point[{0,1}],Blue],
{}}]}]
]//ShowExample
FillStyle::usage="FillStyle is an option to many styled graphics functions that specifies the fill style to use for polygons.";
Options[Styled3DArc]={
ArcLabel->None,
LineStyle->{},
FillStyle->None
};
Styled3DArc[r1_List, r2_List,opts___]:=Module[{al,ls,fs,m1,m2,x,y,z,a,arc},
al=ArcLabel/.{opts}/.Options[Styled3DArc];
ls=LineStyle/.{opts}/.Options[Styled3DArc];
fs=FillStyle/.{opts}/.Options[Styled3DArc];
m1=Mag[r1];
m2=Mag[r2];
x=r1/m1;
y=NormalizeReal[r2-(x . r2)x];
z=x~Cross~y;
a=ArcTan[x . r2,y . r2];
arc=PolygonalEllipseArc3D[r1,r2,opts];
{If[fs===None,{},Style[Polygon[{{0,0,0}}~Join~arc~Join~{{0,0,0}}],fs]],
If[ls===None,{},Style[Line[arc],ls]],
If[al===None,{},Text[al,m1^(1/2) m2^(1/2) U[0.5 a] . {x,y}]]}]
Graphics3D[Styled3DArc[{1,0,0},{0,1,0},ArcLabel->Style["A",Italic,FontSize->16],FillStyle->Gray]]//ShowExample
Graphics3D[Styled3DArc[{1,0,0},{0,1,0},ArcLabel->Style["A",Italic,FontSize->16],FillStyle->Paper3DFillBothColored,LineStyle->MountainLine,FillStyle->Paper3DFill]]/.OrigamiStyle[]//ShowExample
Graphics3D[{
Styled3DArc[{1,0,0},{0,1,0},ArcLabel->"O",LineStyle->MountainLine,FillStyle->Paper3DFill],
Styled3DArc[{0,1,0},{0,0,1},ArcLabel->"R2D",LineStyle->ValleyLine,FillStyle->Paper3DFill],
Styled3DArc[{0,0,1},{1,0,0},ArcLabel->"T",LineStyle->CreaseLine,FillStyle->Paper3DFill]
},Boxed->False]/.OrigamiStyle[]//ShowExample
Styled3DArc[rlist_List,opts___]:=
Drop[MapThread[Styled3DArc[#1,#2,opts]&,{rlist,RotateLeft[rlist]},1],-1]
Graphics3D[Styled3DArc[{{1,0,0},{0,1,0},{0,0,1}},FillStyle->Paper3DFill]]/.OrigamiStyle[]//ShowExample
Styled3DArcClosed[rlist_List,opts___]:=
MapThread[Styled3DArc[#1,#2,opts]&,{rlist,RotateLeft[rlist]},1]
Graphics3D[Styled3DArcClosed[{{1,0,0},{0,1,0},{0,0,1}},FillStyle->Paper3DFill]]/.OrigamiStyle[]//ShowExample
Options[Styled3DDiskFromInPlaneVectors]={
ArcDivisions->200,
LineStyle->{},
FillStyle->{}
};
Styled3DDiskFromInPlaneVectors[p_List,{r1_List,r2_List},r_,opts___]:=Module[{ad,ls,fs,x,y,z,pts},
ad=ArcDivisions/.{opts}/.Options[Styled3DDiskFromInPlaneVectors];
ls=LineStyle/.{opts}/.Options[Styled3DDiskFromInPlaneVectors];
fs=FillStyle/.{opts}/.Options[Styled3DDiskFromInPlaneVectors];
x=NormalizeReal[r1];
z=NormalizeReal[r1\[Cross]r2];
y=z\[Cross]x;
pts=p+r #&/@ Table[x Cos[\[Phi]] + y Sin[\[Phi]],{\[Phi],0,2\[Pi],2\[Pi]/ad}];
{If[fs===None,{},Style[Polygon[pts],fs]],If[ls===None,{},Style[Line[pts],ls]]}
]
Graphics3D[Styled3DDiskFromInPlaneVectors[{0,0,0},{{1,0,0},{1,1,0}},1]]//ShowExample
Graphics3D[Styled3DDiskFromInPlaneVectors[{0,0,0},{{1,0,0},{1,1,0}},1,LineStyle->BorderLine,FillStyle->Paper3DFill]]/.OrigamiStyle[]//ShowExample
Styled3DDisk[p_List,n_List,r_,opts___]:=Module[{nx, ny,n1,n2},
nx=n\[Cross]{1,0,0};
ny=n\[Cross]{0,1,0};
If[Mag[nx]>Mag[ny],n1=NormalizeReal[nx],n1=NormalizeReal[ny]];
n2=n\[Cross]n1;
Styled3DDiskFromInPlaneVectors[p,{n1,n2},r,opts]
]
Graphics3D[Styled3DDisk[{0,0,0},{1,1,0},1]]//ShowExample
Graphics3D[Styled3DDisk[{0,0,0},{1,1,0},1,LineStyle->CreaseLine,FillStyle->Paper3DFill]]/.OrigamiStyle[]//ShowExample
Styled3DUnitCircleFromInPlaneVectors[r1_List,r2_List,opts___]:=Styled3DDiskFromInPlaneVectors[{0,0,0},{r1,r2},1,FillStyle->None,opts]
Graphics3D[Styled3DUnitCircleFromInPlaneVectors[{1,0,0},{1,1,0}]]//ShowExample
Graphics3D[Styled3DUnitCircleFromInPlaneVectors[{1,0,0},{1,1,0},LineStyle->CreaseLine]]/.OrigamiStyle[]//ShowExample
Styled3DUnitCircleFromNormal[n_List,opts___]:=Styled3DDisk[{0,0,0},n,1,FillStyle->None,opts]
Graphics3D[Styled3DUnitCircleFromNormal[{1,1,0}]]//ShowExample
Graphics3D[Styled3DUnitCircleFromNormal[{1,1,0},LineStyle->CreaseLine]]/.OrigamiStyle[]//ShowExample
Styled3DUnitDiskFromInPlaneVectors[r1_List,r2_List,opts___]:=Styled3DDiskFromInPlaneVectors[{0,0,0},{r1,r2},1,opts]
Graphics3D[Styled3DUnitDiskFromInPlaneVectors[{1,0,0},{1,1,0}]]//ShowExample
Graphics3D[Styled3DUnitDiskFromInPlaneVectors[{1,0,0},{1,1,0},LineStyle->BorderLine,FillStyle->Paper3DFill]]/.OrigamiStyle[]//ShowExample
Styled3DUnitDiskFromNormal[n_,opts___]:=Styled3DDisk[{0,0,0},n,1,opts]
Graphics3D[Styled3DUnitDiskFromNormal[{1,1,0}]]//ShowExample
Graphics3D[Styled3DUnitDiskFromNormal[{1,1,0},LineStyle->CreaseLine,FillStyle->Paper3DFill]]/.OrigamiStyle[]//ShowExample
ArrowheadFraction::usage="ArrowheadFraction is an option to Styled3DSolidArrow that specifies the fraction of the length that should be used for the arrowhead.";
ArrowheadRadius::usage="ArrowheadRadius is an option ot Styled3DSolidArrow that specifies the radius of the base of the arrowhead.";
ArrowRadius::usage="ArrowRadius is an option to Styled3DSolidArrow that specifies the radius of the body of the arrow.";
ArrowLabel::usage="ArrowLabel is an option to Styled3DSolidArrow that specifies an label to place at the arrow ti.";
Options[Styled3DSolidArrow]={
ArrowheadFraction->0.333,
ArrowheadRadius->0.333,
ArrowRadius->0.25,
ArrowLabel->None,
FillStyle->{}
};
Styled3DSolidArrow[r1_List,r2_List,opts___]:=Module[{rr=Mag[r2-r1],ahf,ahr,ar,\[Alpha],fs,rx},
ahf=ArrowheadFraction/.{opts}/.Options[Styled3DSolidArrow];
ahr=ArrowheadRadius/.{opts}/.Options[Styled3DSolidArrow];
ar=ArrowRadius/.{opts}/.Options[Styled3DSolidArrow];
\[Alpha]=ArrowLabel/.{opts}/.Options[Styled3DSolidArrow];
fs=FillStyle/.{opts}/.Options[Styled3DSolidArrow];
rx=ahf r1 + (1-ahf) r2;
{Style[{Cylinder[{r1,rx},ar ahf rr],Cone[{rx,r2},ahr ahf rr]},fs],If[\[Alpha]===None,{},Text[\[Alpha],r2]]}]
Graphics3D[{Styled3DSolidArrow[{0,0,0},{1,0,0},ArrowLabel->"x"],Styled3DSolidArrow[{0,0,0},{0,1,0},ArrowLabel->"y"],Styled3DSolidArrow[{0,0,0},{0,0,1},ArrowLabel->"z"]}]//ShowExample
Module[{x,y,z,ahf,ar},
x={{0,0,0},{1,0,0}};
y={{0,0,0},{0,1,0}};
z={{0,0,0},{0,0,1}};
ahf=0.1;
ar=0.04;
Graphics3D[{
Style[Arrow[Tube[x,ar]],Arrowheads[ahf], Red],
Style[Arrow[Tube[y,ar]],Arrowheads[ahf], Green],
Style[Arrow[Tube[z,ar]],Arrowheads[ahf], Blue]
}]
]//ShowExample
AxesThickness3D::usage="AxesThickness3D is an option to Styled3DAxes that specifies the thickness of the axes and arrowheads.";
Options[Styled3DAxes]={
AxesThickness3D->0.01,
AxesColor->Gray,
AxesLabelStyle->{FontFamily->"Times New Roman",Italic},
AxesLabel->{"x","y","z"},
AxesLabelPosition->{{-2,0},{-2,0},{-3,0}}
};
Styled3DAxes[opts___]:=Styled3DAxes[1,1,1,opts]
Styled3DAxes[xmax_, ymax_, zmax_, opts___]:=Styled3DAxes[{0, xmax}, {0, ymax}, {0, zmax}, opts]/;(NumericQ[xmax]&&NumericQ[ymax]&&NumericQ[zmax])
Styled3DAxes[{xmin_, xmax_}, {ymin_, ymax_}, {zmin_, zmax_}, opts___]:=Module[{at,ac,als,al,alp},
at=AxesThickness3D/.{opts}/.Options[Styled3DAxes];
ac=AxesColor/.{opts}/.Options[Styled3DAxes];
als=AxesLabelStyle/.{opts}/.Options[Styled3DAxes];
al=AxesLabel/.{opts}/.Options[Styled3DAxes];
alp=AxesLabelPosition/.{opts}/.Options[Styled3DAxes];
{StyledVector[{{xmin,0,0},{xmax,0,0}},VectorThickness3D->at,VectorColor->ac,VectorLabelStyle->als,VectorLabel->al[[1]],VectorLabelPosition->alp[[1]]],
StyledVector[{{0,ymin,0},{0,ymax,0}},VectorThickness3D->at,VectorColor->ac,VectorLabelStyle->als,VectorLabel->al[[2]],VectorLabelPosition->alp[[2]]],
StyledVector[{{0,0,zmin},{0,0,zmax}},VectorThickness3D->at,VectorColor->ac,VectorLabelStyle->als,VectorLabel->al[[3]],VectorLabelPosition->alp[[3]]]}]
Module[{},
GraphicsRow[{
Graphics3D[{Styled3DAxes[]}],
Graphics3D[{Styled3DAxes[1.7,1.3,1.0,
AxesLabelPosition->{{-2,0},{-2,-1},{0,-1.5}},
AxesColor->Orange]
}]}]
]//ShowExample
StyledMountainLine[rlist_List]:=Style[Line[rlist],MountainLine]
Graphics[StyledMountainLine[{{0,0},{1,0},{1,1}}]]/.OrigamiStyle[]//ShowExample
StyledValleyLine[rlist_List]:=Style[Line[rlist],ValleyLine]
Graphics[StyledValleyLine[{{0,0},{1,0},{1,1}}]]/.OrigamiStyle[]//ShowExample
StyledCreaseLine[rlist_List]:=Style[Line[rlist],CreaseLine]
Graphics[StyledCreaseLine[{{0,0},{1,0},{1,1}}]]/.OrigamiStyle[]//ShowExample
MinimumAngle::usage="MinimumAngle is an option to StyledFoldLine that specifies the minimum angle at which to render a mountain or valley line (as opposed to an unfolded crease line).";
Options[StyledFoldLine]={
MinimumAngle->1\[Degree]
};
StyledFoldLine[rlist_List,gg_,opts___]:=Module[{gmin},
gmin=MinimumAngle/.{opts}/.Options[StyledFoldLine];
Which[
gg>gmin,StyledValleyLine[rlist],
gg<-gmin,StyledMountainLine[rlist],
True,StyledCreaseLine[rlist]]
]
Graphics[{
StyledFoldLine[{{0,0},{1,0}},-30\[Degree]],(* mountain *)
StyledFoldLine[{{0,0},{1,1}},0\[Degree]], (* unfolded *)
StyledFoldLine[{{0,0},{0,1}},30\[Degree]] (* valley *)
}]/.OrigamiStyle[]//ShowExample
Options[StyledGenericFoldLine]={
MinimumAngle->1\[Degree]
};
StyledGenericFoldLine[rlist_List,gg_,opts___]:=Module[{gmin},
gmin=MinimumAngle/.{opts}/.Options[StyledFoldLine];
If[gg>gmin||gg<-gmin,Style[Line[rlist],FoldedLine],{}]]
Graphics[{
StyledGenericFoldLine[{{0,0},{1,0}},-30\[Degree]],(* mountain *)
StyledGenericFoldLine[{{0,0},{1,1}},0\[Degree]], (* unfolded *)
StyledGenericFoldLine[{{0,0},{0,1}},30\[Degree]] (* valley *)
}]/.OrigamiStyle[]//ShowExample
KillCreases[expr_]:=expr/.Style[_,CreaseLine]->Sequence[];
Module[{g},
g=Graphics[{Style[Line[{{0,0},{1,0}}],ValleyLine],Style[Line[{{0,.5},{1,.5}}],CreaseLine],Style[Line[{{0,1},{1,1}}],MountainLine]}];
GraphicsRow[{g,KillCreases[g]}]/.OrigamiStyle[]
]//ShowExample
KillFolds[expr_]:=expr/.{
Style[_,CreaseLine]->Sequence[],
Style[_,ValleyLine]->Sequence[],
Style[_,MountainLine]->Sequence[],
Style[_,FoldedLine]->Sequence[],
Style[_,HiddenFoldedLine]->Sequence[],
Style[_,UnfoldedLine]->Sequence[],
Style[_,HiddenUnfoldedLine]->Sequence[]
};
Module[{g},
g=Graphics[{
Style[Line[{{0,-.5},{1,-.5}}],BorderLine],
Style[Line[{{0,0},{1,0}}],CreaseLine],
Style[Line[{{0,.5},{1,.5}}],ValleyLine],
Style[Line[{{0,1},{1,1}}],MountainLine],
Style[Line[{{0,1.5},{1,1.5}}],FoldedLine],
Style[Line[{{0,2},{1,2}}],HiddenFoldedLine],
Style[Line[{{0,2.5},{1,2.5}}],UnfoldedLine],
Style[Line[{{0,3},{1,3}}],HiddenUnfoldedLine],
Style[Line[{{0,3.5},{1,3.5}}],BorderLine]
}];
GraphicsRow[{g,KillFolds[g]}]/.OrigamiStyle[]
]//ShowExample
KillBorder[expr_]:=expr/.{Style[_,BorderLine]->Sequence[],Style[_,HiddenBorderLine]->Sequence[]}
KillHidden[expr_]:=expr/.{Style[_,HiddenFoldedLine]->Sequence[],Style[_,HiddenUnfoldedLine]->Sequence[],Style[_,HiddenBorderLine]->Sequence[]}
ReverseLineStyle[obj_]:=obj/.{
MountainLine->ValleyLine,
ValleyLine->MountainLine,
MountainRulingLine->ValleyRulingLine,
ValleyRulingLine->MountainRulingLine};
GraphicsRow[{
OrigamiSampleGraphics,
OrigamiSampleGraphics//ReverseLineStyle
}/.OrigamiStyle[]]//ShowExample
ReverseFillStyle[obj_]:=obj/.{
Paper3DFill->Paper3DFillReversed,
PaperWhiteSideFill->PaperColoredSideFill,
PaperColoredSideFill->PaperWhiteSideFill,
Paper3DFillBothWhite->Paper3DFillBothColored,
Paper3DFillBothColored->Paper3DFillBothWhite};
GraphicsGrid[{
{OrigamiSampleGraphics2D,OrigamiSampleGraphics2D//ReverseFillStyle},
{OrigamiSampleGraphics3D,OrigamiSampleGraphics3D//ReverseFillStyle}
}/.OrigamiStyle[]]//ShowExample

CurveDivisions::usage="CurveDivisions is an option to StyledCurve and other functions that specifies the number of segments to use in drawing a curved line or surface.";
CurveDirected::usage="CurveDirected is an option to StyledCurve and other functions that specifies whether to add an arrowhead to the end of the curve.";
CurveTube::usage="CurveTube is an option to StyledCurve and other functions that specifies whether to use a Tube for the curve in 3D.";
CurveTubeThickness::usage="CurveTubeThickness is an option to StyledCurve and other functions that specifies the thickness to use for a curve tube in 3D.";
Options[StyledCurve]={
CurveDivisions->100,
CurveDirected->False,
CurveTube->False,
CurveTubeThickness->.02,
LineStyle->{AbsoluteThickness[2],Black}
};
StyledCurve[c_Function|c_InterpolatingFunction, {t0_,t1_},opts___]:=Module[{nt,cd,ct,ctt,ls,dim,pts,tt,g,apts,ga},
nt=CurveDivisions/.{opts}/.Options[StyledCurve];
cd=CurveDirected/.{opts}/.Options[StyledCurve];
ls=LineStyle/.{opts}/.Options[StyledCurve];
ct=CurveTube/.{opts}/.Options[StyledCurve];
ctt=CurveTubeThickness/.{opts}/.Options[StyledCurve];
dim=Length[c[t0]];
If[ls===None,Return[{}]];
pts=Table[c[t],{t,t0,t1,(t1-t0)/nt}];
StyledLine[pts,LineDirected->cd,LineStyle->ls,LineTube->ct,LineTubeThickness->ctt]]
Module[{c,stc1,stc2},
c=(1+#/(4\[Pi])){Cos[#],Sin[#]}&;
stc1=StyledCurve[c,{0,\[Pi]}];
stc2=StyledCurve[c,{0,\[Pi]},CurveDirected->True];
GraphicsRow[{
Graphics[stc1,Axes->True],
Graphics[stc2,Axes->True]}]
]//ShowExample
Module[{c,stc1,stc2},
c=(1+#/(4\[Pi])){Cos[#],Sin[#],.1+.1#}&;
stc1=StyledCurve[c,{0,4\[Pi]}];
stc2=StyledCurve[c,{0,4\[Pi]},
LineStyle->{Purple},
CurveDirected->True,
CurveTube->True];
GraphicsRow[{
Graphics3D[stc1],
Graphics3D[stc2]}]
]//ShowExample
Module[{c,stc},
c=(1+#/(4\[Pi])){Cos[#],Sin[#],.1#}&;
stc=StyledCurve[c,{0,4\[Pi]},
LineStyle->ValleyLine,
CurveDivisions->100];
Graphics3D[stc//AddShadow]/.OrigamiStyle[]
]//ShowExample
Module[{c,stc},
c=(1+#/(4\[Pi])){Cos[#],Sin[#],.1#}&;
stc=StyledCurve[c,{0,2\[Pi]},
LineStyle->{Blue,Thickness[.02]}];
Graphics3D[stc//AddShadow]/.OrigamiStyle[]
]//ShowExample
RainbowSurfaceColorFunction[{u0_,u1_},{v0_,v1_}]:=Module[{un=2((#1-u0)/(u1-u0))-1,vn=2((#2-v0)/(v1-v0))-1,\[Theta],r},
\[Theta]=If[un==0&&vn==0,0,ArcTan[un,vn]];
r=Max[Abs[Cos[\[Theta]]],Abs[Sin[\[Theta]]]]\[Sqrt](un^2+vn^2);
If[r>1,Black,Hue[1/2+\[Theta]/(2\[Pi]),r,.7+.3r]]]&
Module[{n,u0,u1,v0,v1,scf},
n=30;
{u0,u1}={1,2};
{v0,v1}={3,4};
scf=RainbowSurfaceColorFunction[{u0,u1},{v0,v1}];
Graphics[Table[Style[Point[{u,v}],scf[u,v],PointSize[.03]],{u,u0,u1,(u1-u0)/n},{v,v0,v1,(v1-v0)/n}]]
]//ShowExample
Module[{n,u0,u1,v0,v1,scf},
n=30;
{u0,u1}={0,1};
{v0,v1}={0,1};
scf=RainbowSurfaceColorFunction[{u0,.9u1},{v0,.8v1}];
Graphics[Table[Style[Point[{u,v}],scf[u,v],PointSize[.03]],{u,u0,u1,(u1-u0)/n},{v,v0,v1,(v1-v0)/n}]]
]//ShowExample
Options[StyledColoredPatch]={
PatchDivisions->{50,50},
SurfaceColorFunction->Automatic
};
StyledColoredPatch[s_Function|s_InterpolatingFunction,{u0_,u1_},{v0_,v1_},opts___]:=Module[{nu,nv,scf,fdim,pts,ua,va,ub,vb},
{nu,nv}=PatchDivisions/.{opts}/.Options[StyledColoredPatch];
scf=SurfaceColorFunction/.{opts}/.Options[StyledColoredPatch];
If[scf===Automatic,scf=Gray&];
Table[
ua=u0+((iu-1)/nu)(u1-u0);
ub=u0+(iu/nu)(u1-u0);
va=v0+((iv-1)/nv)(v1-v0);
vb=v0+(iv/nv)(v1-v0);
(* triangulate quads because they could be skew quads and that confuses rendering *)
{Style[Polygon[{s[ua,va],s[ub,va],s[ub,vb]}],scf@@(({ua,va}+{ub,va}+{ub,vb})/3),EdgeForm[]],
Style[Polygon[{s[ua,va],s[ub,vb],s[ua,vb]}],scf@@(({ua,va}+{ub,vb}+{ua,vb})/3),EdgeForm[]]}
,{iu,nu},{iv,nv}]]
Module[{u0,u1,v0,v1,uu,scf,sgmp},
{u0,u1}={-1,1};
{v0,v1}={-1,1};
uu={#1,#2,.25(1-(#1^2+#2^2))}&;
scf=RainbowSurfaceColorFunction[{u0,u1},{v0,v1}];
sgmp=StyledColoredPatch[uu,{u0,u1},{v0,v1},
SurfaceColorFunction->scf];
Graphics3D[sgmp,
Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
SurfaceOrientation::usage="SurfaceOrientation is an option to StyledPatch and related functions that specifies the orientation of the surface (if orientable). It should be \[PlusMinus]1.";
PatchDivisions::usage="PatchDivisions is an option to StyledPatch that specifies the number of divisions to use in the two directions for constructing the patch.";
OutlineStyle::usage="OutlineStyle is an option to StyledPatch that specifies the style(s) to use for outlining the patch.";
Options[StyledPatch]={
PatchDivisions->{50,50},
FillStyle->Paper3DFill,
OutlineStyle->None,
SurfaceOrientation->1
};
StyledPatch::badline="`1` is an invalid format for the OutlineStyle option.";
StyledPatch[s_Function|s_InterpolatingFunction,{u0_,u1_},{v0_,v1_},opts___]:=Module[{nu,nv,fs,ls,so,dim,pts,spts,polys,lines},
{nu,nv}=PatchDivisions/.{opts}/.Options[StyledPatch];
fs=FillStyle/.{opts}/.Options[StyledPatch];
ls=OutlineStyle/.{opts}/.Options[StyledPatch];
so=SurfaceOrientation/.{opts}/.Options[StyledPatch];
pts=Table[s[u,v],{u,u0,u1,(u1-u0)/nu},
{v,If[Head[v0]===Function||Head[v0]===InterpolatingFunction,v0[u],v0],If[Head[v1]===Function||Head[v1]===InterpolatingFunction,v1[u],v1],(If[Head[v1]===Function||Head[v1]===InterpolatingFunction,v1[u],v1]-If[Head[v0]===Function||Head[v0]===InterpolatingFunction,v0[u],v0])/nv}];
polys=If[fs===None,
{},
Table[{
(* triangulate quads because they could be skew quads and that confuses rendering *)
Style[Polygon[{pts[[iu,iv]],pts[[iu+1,iv]],pts[[iu+1,iv+1]]}],fs],Style[Polygon[{pts[[iu+1,iv+1]],pts[[iu,iv+1]],pts[[iu,iv]]}],fs]},{iu,nu},{iv,nv}]];
If[so==-1,polys=ReversePolygons[polys]];
ls=Switch[Length[ls],
0,{ls,ls,ls,ls},
1,If[Head[ls[[1]]]===List,{ls[[1,1]],ls[[1,1]],ls[[1,1]],ls[[1,1]]},{ls[[1]],ls[[1]],ls[[1]],ls[[1]]}],
4,ls,
_,Message[StyledPatch::badline,ls];Abort[]];
dim=Length[s[u0,v0]];
{polys,
If[ls[[1]]===None,{},Style[Line[Table[pts[[iu,1]],{iu,nu+1}]],ls[[1]]]],
If[ls[[2]]===None,{},Style[Line[Table[pts[[nu+1,iv]],{iv,nv+1}]],ls[[2]]]],
If[ls[[3]]===None,{},Style[Line[Table[pts[[iu,nv+1]],{iu,nu+1}]],ls[[3]]]],
If[ls[[4]]===None,{},Style[Line[Table[pts[[1,iv]],{iv,nv+1}]],ls[[4]]]],
{}}]
Module[{s,spp},
s={#1,#2}&;
spp=StyledPatch[s,{-1,1},{-1,1}];
Graphics[spp]/.OrigamiStyle[]
]//ShowExample
Module[{s,spp1,spp2},
s={#1,#2,.5(1-(#1^2+#2^2))}&;
spp1=StyledPatch[s,{-1,1},{-1,1}];
spp2=StyledPatch[s,{-1,1},{-1,1},SurfaceOrientation->-1];
GraphicsRow[{
Graphics3D[spp1//AddShadow,
Lighting->NeutralLighting[.8]],
Graphics3D[spp2//AddShadow,
Lighting->NeutralLighting[.8]]}]/.OrigamiStyle[]
]//ShowExample
Module[{s,spp},
s={#1,#2,.5(1-(#1^2+#2^2))}&;
spp=StyledPatch[s,{-1,1},{-1,1},
OutlineStyle->FoldedLine,
PatchDivisions->{5,5}];
Graphics3D[spp//AddShadow,
Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
Module[{s,spp},
s={#1,#2,.5(1-(#1^2+#2^2))}&;
spp=StyledPatch[s,{-1,1},{-1,1},OutlineStyle->{
{Red,Thickness[.02]},
{Green,Thickness[.02]},
{Blue,Thickness[.02]},
{Gray,Thickness[.02]}}];
Graphics3D[spp//AddShadow,
Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
Module[{s,spp},
s={#1,#2,.5(1-(#1^2+#2^2))}&;
spp=StyledPatch[s,{-1,1},{-1+0.7#^2&,1-0.7#^2&}];
Graphics3D[spp//AddShadow,
Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
RulingLineDivisions::usage="RulingLineDivisions is an option to StyledRuledPatch that specifies the number of divisions transverse to the ruling direction to use for drawing ruling lines.";
RulingLineOffset::usage="RulingLineOffset is an option to StyledRuledPatch that specifies whether to offset the ruling lines from the sides of the patch.";
RulingLineStyle::usage="RulingLineStyle is an option to StyledRuledPatch that specifies the style to use for drawing ruling lines.";
EndLineStyle::usage="EndLineStyle is an option to StyledRuledPatch that specifies the style to use for drawing the end lines of the patch.";
Options[StyledRuledPatch]={
RulingLineDivisions->10,
RulingLineOffset->False,
RulingLineStyle->UndefinedRulingLine,
EndLineStyle->None,
CurveDivisions->100
};
StyledRuledPatch::badline="`1` is an invalid format for the EndLineStyle option.";
StyledRuledPatch[ss_Function|ss_InterpolatingFunction, {u0_, u1_}, {v0_, v1_}, opts___]:=Module[{cd,rd,rlo,rls,els,u,v,ols,patch,dt,rlines,t,vv0,vv1,rline},
rd=RulingLineDivisions/.{opts}/.Options[StyledRuledPatch];
rlo=RulingLineOffset/.{opts}/.Options[StyledRuledPatch];
rls=RulingLineStyle/.{opts}/.Options[StyledRuledPatch];
els=EndLineStyle/.{opts}/.Options[StyledRuledPatch];
cd=CurveDivisions/.{opts}/.Options[StyledRuledPatch];
(* construct the OutlineStyle for StyledPatch. No outline where ruling lines might be. *)
ols=Switch[Length[els],
0,{els,None,els,None},
1,If[Head[els[[1]]]===List,
{els[[1,1]],None,els[[1,1]],None},
{els[[1]],None,els[[1]],None}],
2,{els[[1]],None,els[[2]],None},
_,Message[StyledRuledPatch::badline,els];Abort[]];
patch=StyledPatch[ss,{u0,u1},{v0,v1},PatchDivisions->{cd,1},OutlineStyle->ols,opts];
(* construct the table of ruling lines *)
dt=(u1-u0)/rd;
rlines=Table[
t=u0+i dt+If[rlo,dt/2,0];
vv0=If[Head[v0]===Function||Head[v0]===InterpolatingFunction,v0[t],v0];
vv1=If[Head[v1]===Function||Head[v1]===InterpolatingFunction,v1[t],v1];
rline=Line[{ss[t,vv0],ss[t,vv1]}];
If[!(rls===None),Style[rline,rls]],{i,0,If[rlo,rd-1,rd]}];
{patch,rlines}]
StyledRuledPatch[bb_Function|bb_InterpolatingFunction,dd_Function|dd_InterpolatingFunction, {u0_, u1_}, {v0_, v1_}, opts___]:=Module[{ss,u,v},
ss=Functionize[{u,v},bb[u]+v dd[u]];
StyledRuledPatch[ss,{u0,u1},{v0,v1},opts]]
StyledRuledPatch[{bb0_Function|bb0_InterpolatingFunction,bb1_Function|dd1_InterpolatingFunction}, {u0_, u1_}, opts___]:=Module[{ss,u,v},
ss=Functionize[{u,v},bb0[u]+v (bb1[u]-bb0[u])];
StyledRuledPatch[ss,{u0,u1},{0,1},opts]]
Module[{bb,dd,u,v,ss},
bb={0,#,#^2}&;
dd={-1,0,0}&;
ss=Functionize[{u,v},bb[u]+v dd[u]];
ss//PrettyParameters//Print;
Graphics3D[{
StyledRuledPatch[ss,{-.5,.5},{-.5,.5},
RulingLineStyle->CreaseLine],
StyledCurve[bb,{-.5,.5},CurveDirected->True],
{}}//AddShadow]/.OrigamiStyle[]
]//ShowExample
Module[{bb0,bb1},
bb0={0,#,#^2}&;
bb1={-1,#,#^2}&;
Graphics3D[{
StyledRuledPatch[{bb0,bb1},{-.5,.5},
RulingLineOffset->True,
RulingLineStyle->CreaseLine,
EndLineStyle->{{Red,Thickness[.01]},{Green,Thickness[.01]}}],
{}}//AddShadow]/.OrigamiStyle[]
]//ShowExample
Module[{bb,dd},
bb={0,#,#^2}&;
dd={-1,0,0}&;
Graphics3D[{
StyledRuledPatch[bb,dd,{-.5,.5},{-.5,.5},
RulingLineOffset->True,
RulingLineStyle->CreaseLine,
EndLineStyle->{{Red,Thickness[.01]},{Green,Thickness[.01]}}],
StyledCurve[bb,{-.5,.5},
CurveDirected->True],
{}}//AddShadow]/.OrigamiStyle[]
]//ShowExample
Module[{bb,dd},
bb={Cos[#],Sin[#],0}&;
dd={-(Cos[#]/2),-(Sin[#]/2),-((\[Sqrt]3)/2)}&;
Graphics3D[{
StyledRuledPatch[bb,dd,{0,\[Pi]/2},{-.5,.5}],
StyledCurve[bb,{0,\[Pi]/2}],
{}}//AddShadow]/.OrigamiStyle[]
]//ShowExample
Module[{bb,dd},
bb=2{Cos[#/2],Sin[#/2]}&;
dd={-Cos[#/2],-Sin[#/2]}&;
Graphics[{
StyledRuledPatch[bb,dd,{0.01,\[Pi]/2-0.01},{-.2,.2}],
StyledCurve[bb,{0,\[Pi]/2}],
{}}]/.OrigamiStyle[]
]//ShowExample
Module[{bb,dd},
bb={Cos[#],Sin[#],0}&;
dd={-(Cos[#]/2),-(Sin[#]/2),-((\[Sqrt]3)/2)}&;
Graphics3D[{
StyledRuledPatch[bb,dd,{0,\[Pi]/2},{-.5,.5-.5(#-\[Pi]/4)^2&}],
StyledCurve[bb,{0,\[Pi]/2}],
{}}//AddShadow]/.OrigamiStyle[]
]//ShowExample
CrossLineDivisions::usage="CrossLineDivisions is an option to StyledCrossRuledPatch that specifies the number of divisions to use for drawing cross curves.";
CrossLineStyle::usage="CrossLineStyle is an option to StyledCrossRuledPatch that specifies the style to use for drawing cross curves.";
Options[StyledCrossRuledPatch]={
CurveDivisions->100,
CrossLineDivisions->10,
CrossLineStyle->UnfoldedLine
};
StyledCrossRuledPatch::badv="You cannot pass functions for {v0, v1} = `1` to StyledCrossRuledPath.";
StyledCrossRuledPatch[ss_Function|s_InterpolatingFunction,{u0_,u1_},{v0_,v1_},opts___]:=Module[{nu,cld,cls,du,dv},
nu=CurveDivisions/.{opts}/.Options[StyledCrossRuledPatch];
cld=CrossLineDivisions/.{opts}/.Options[StyledCrossRuledPatch];
cls=CrossLineStyle/.{opts}/.Options[StyledCrossRuledPatch];
du=(u1-u0)/nu;
If[Head[v0]===Function||Head[v0]===InterpolatingFunction||Head[v1]===Function||Head[v1]===InterpolatingFunction,Message[StyledCrossRuledPatch::badv,{v0,v1}];Abort[]];
dv=(v1-v0)/cld;
Append[StyledRuledPatch[ss,{u0,u1},{v0,v1},opts],
Table[Style[Line[Table[ss[u,v],{u,u0,u1,du}]],cls],{v,v0,v1,dv}]]]
Module[{bb,dd,ss,ff,u,u0,v},
bb={0,Sin[#],1-Cos[#]}&;
dd={1,0,0}&;
ss=FunctionizeOld[bb[u]+v dd[u],{u,v}];
(Graphics3D[{
Styled3DAxes[],
{StyledCrossRuledPatch[ss,{0,\[Pi]/2},{0,1},CrossLineStyle->Purple],
{}}//AddShadow}]//ReverseFillStyle)/.OrigamiStyle[]
]//ShowExample
Module[{\[Theta],bb,dd,ss,ff,u,u0,v},
\[Theta]=30\[Degree];(* cone half-angle *)
bb={0,0,Sin[\[Theta]]}&;(* directrix *)
dd={Cos[\[Theta]],Sin[\[Theta]]Sin[#],-Sin[\[Theta]]Cos[#]}&;
ss=FunctionizeOld[bb[u]+v dd[u],{u,v}];
Graphics3D[{
Styled3DAxes[1,1,.7],
{StyledCrossRuledPatch[ss,{0,\[Pi]/2},{0,1},CrossLineStyle->Purple],
{}}//AddShadow}//ReversePolygons]/.OrigamiStyle[]
]//ShowExample
Module[{u,v,bb,cc},
bb={(1/2) \[Sqrt]3 Cos[#1],(1/2) \[Sqrt]3 Sin[#1],#1/2}&;
cc={(1/2) \[Sqrt]3 (Cos[#1]+Sin[#1] (#1-#2)),(1/2) \[Sqrt]3 (Sin[#1]+Cos[#1] (-#1+#2)),#2/2}&;
Graphics3D[{
Styled3DAxes[],
{StyledCrossRuledPatch[cc,{0,\[Pi]},{0,\[Pi]},CrossLineStyle->Purple]//ReversePolygons,
StyledCurve[bb,{0,\[Pi]}],
{}}//AddShadow},
Lighting->NeutralLighting[.75]]/.OrigamiStyle[]
]//ShowExample
Module[{u,v,bb,cc,ccc},
bb={(1/2) \[Sqrt]3 Cos[#1],(1/2) \[Sqrt]3 Sin[#1],#1/2}&;
cc={(1/2) \[Sqrt]3 (Cos[#1]+Sin[#1] (#1-#2)),(1/2) \[Sqrt]3 (Sin[#1]+Cos[#1] (-#1+#2)),#2/2}&;
ccc=FunctionizeOld[If[u<=v,cc[u,v],bb[u]],{u,v}];
Graphics3D[{
Styled3DAxes[],
{StyledCrossRuledPatch[ccc,{0,\[Pi]},{0,\[Pi]},CrossLineStyle->Purple]//ReversePolygons,
StyledCurve[bb,{0,\[Pi]}],
{}}//AddShadow},
Lighting->NeutralLighting[.75]]/.OrigamiStyle[]
]//ShowExample
Options[StyledRuledPatchSequence]={
CurveDivisions->100,
TransverseLineStyle->None,
RulingLineStyle->UnfoldedLine
};
TransverseLineStyle::usage="TransverseLineStyle is an option to StyledRuledPatchSequence that specifies the style(s) to apply to the transverse lines that run transversely to the ruling lines.";
StyledRuledPatchSequence::badruling="`1` is an invalid format for the RulingLineStyle option.";
StyledRuledPatchSequence::badxvrs="`1` is an invalid format for the TransverseLineStyle option.";
StyledRuledPatchSequence[clist_List,{u0_,u1_},opts___]:=Module[{nu,tls,rls,nc,cs,rs,u,v},
nu=CurveDivisions/.{opts}/.Options[StyledRuledPatchSequence];
tls=TransverseLineStyle/.{opts}/.Options[StyledRuledPatchSequence];
rls=RulingLineStyle/.{opts}/.Options[StyledRuledPatchSequence];
nc=Length[clist];
{Table[
rs=Switch[Length[rls],
0,rls,
1,If[Head[rls[[1]]]===List,rls[[1,1]],rls[[1]]],
nc-1,rls[[i]],
_,Message[StyledRuledPatchSequence::badruling,rls];Abort[]];
StyledRuledPatch[Functionize[{u,v},(v)clist[[i]][u]+(1-v)clist[[i+1]][u]],{u0,u1},{0,1},
RulingLineStyle->rs,
EndLineStyle->None,opts],{i,nc-1}],
Table[
cs=Switch[Length[tls],
0,tls,
1,If[Head[tls[[1]]]===List,tls[[1,1]],tls[[1]]],
Length[clist],tls[[i]],
_,Message[StyledRuledPatchSequence::badxvrs,tls];Abort[]];
StyledCurve[clist[[i]],{u0,u1},CurveDivisions->nu,LineStyle->cs,opts]
,{i,nc}]}]
Module[{t,clist},
clist={{-1,2#1,3/2+#1^2}&,{0,2#1,1-#1^2/2}&,{1,2#1,3/2-(3 #1^2)/2}&,{2,2#1,1-(5 #1^2)/2}&};
Graphics3D[{
StyledRuledPatchSequence[clist,{-.5,.5}],
{}}//AddShadow,
Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
Module[{t,clist},
clist={{-1,2#1,3/2+#1^2}&,{0,2#1,1-#1^2/2}&,{1,2#1,3/2-(3 #1^2)/2}&,{2,2#1,1-(5 #1^2)/2}&};
Graphics3D[{
StyledRuledPatchSequence[clist,{-.5,.5},
RulingLineOffset->True,
RulingLineStyle->{ValleyRulingLine,MountainRulingLine,MountainRulingLine},
TransverseLineStyle->{BorderLine,ValleyLine,MountainLine,BorderLine}],
{}}//AddShadow,
Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
FoldLineStyle::usage="FoldLineStyle is an option to StyledCurvedFold that specifies the style to use for drawing the curved fold.";
RulingLineLeftStyle::usage="RulingLineLeftStyle is an option to StyledCurvedFold that specifies the style to use for drawing the left ruling lines.";
RulingLineRightStyle::usage="RulingLineRightStyle is an option to StyledCurvedFold that specifies the style to use for drawing the right ruling lines.";
BoundaryLineLeftStyle::usage="BoundaryLineLeftStyle is an option to StyledCurvedFold that specifies the style to use for drawing the left boundary line.";
BoundaryLineRightStyle::usage="BoundaryLineRightStyle is an option to StyledCurvedFold that specifies the style to use for drawing the right boundary line.";
Options[StyledCurvedFoldBounded]={
FoldLineStyle->FoldedLine,
RulingLineLeftStyle->UnfoldedLine,
RulingLineRightStyle->UnfoldedLine,
BoundaryLineLeftStyle->None,
BoundaryLineRightStyle->None
};
StyledCurvedFoldBounded[f_Function|f_InterpolatingFunction,{bl_Function|bl_InterpolatingFunction,br_Function|br_InterpolatingFunction},{u0_, u1_},opts___]:=Module[{fls,rlls,rlrs,blls,blrs},
fls=FoldLineStyle/.{opts}/.Options[StyledCurvedFoldBounded];
rlls=RulingLineLeftStyle/.{opts}/.Options[StyledCurvedFoldBounded];
rlrs=RulingLineRightStyle/.{opts}/.Options[StyledCurvedFoldBounded];
blls=BoundaryLineLeftStyle/.{opts}/.Options[StyledCurvedFoldBounded];
blrs=BoundaryLineRightStyle/.{opts}/.Options[StyledCurvedFoldBounded];
StyledRuledPatchSequence[{bl,f,br},{u0,u1},RulingLineStyle->{rlls,rlrs},TransverseLineStyle->{blls,fls,blrs},opts]]
Module[{f,bl,br},
f={Cos[#],Sin[#]}&;
bl=.5{Cos[#],Sin[#]}&;
br=1.5{Cos[#],Sin[#]}&;
Graphics[{
Styled2DAxes[.5,.5],
StyledCurvedFoldBounded[f,{bl,br},{0,\[Pi]/2}],
{}}]/.OrigamiStyle[]
]//ShowExample
Module[{f,bl,br},
f={Cos[#],Sin[#]}&;
bl=.5{Cos[#],Sin[#]}&;
br=1.5{Cos[#],Sin[#]}&;
Graphics[{
Styled2DAxes[.5,.5],
StyledCurvedFoldBounded[f,{bl,br},{0,\[Pi]/2},
FoldLineStyle->ValleyLine,
RulingLineLeftStyle->MountainRulingLine,
RulingLineRightStyle->ValleyRulingLine,
BoundaryLineLeftStyle->{Red,Thickness[.01]},
BoundaryLineRightStyle->{Green,Thickness[.01]}],
{}}]/.OrigamiStyle[]
]//ShowExample
Module[{ff,\[Gamma],bl,br,t},
ff={Cos[#],Sin[#],0.05}&;
\[Gamma]=90\[Degree];
bl=Functionize[t,ff[t]+.5RotationZMatrix3D[t] . RotationYMatrix3D[\[Gamma]/2] . {-1,0,0}];
br=Functionize[t,ff[t]+.5RotationZMatrix3D[t] . RotationYMatrix3D[-\[Gamma]/2] . {1,0,0}];
Graphics3D[{
Styled3DAxes[.5,.5,.5],
{StyledCurvedFoldBounded[ff,{bl,br},{0,\[Pi]/2}],
{}}//AddShadow}]/.OrigamiStyle[]
]//ShowExample
StyledCurvedFold[ff_Function|ff_InterpolatingFunction,{rrl_Function|rrl_InterpolatingFunction,rrr_Function|rrr_InterpolatingFunction},{u0_, u1_},opts___]:=Module[{t,bbl,bbr},
bbl=FunctionizeOld[ff[t]+rrl[t],t];
bbr=FunctionizeOld[ff[t]+rrr[t],t];
StyledCurvedFoldBounded[ff,{bbl,bbr},{u0,u1},opts]]
Module[{ff,\[Gamma],rrr,rrl,t,t0},
ff={Cos[#],Sin[#],0.05}&;
\[Gamma]=90\[Degree];
t0=\[Pi]/4;
rrl=Functionize[t,RotationZMatrix3D[t] . RotationYMatrix3D[\[Gamma]/2] . {-1,0,0}];
rrr=Functionize[t,RotationZMatrix3D[t] . RotationYMatrix3D[-\[Gamma]/2] . {1,0,0}];
Graphics3D[{
Styled3DAxes[.5,.5,.5],
{StyledCurvedFold[ff,{rrl,rrr},{0,\[Pi]/2}],
StyledVector[ff[t0],rrl[t0],VectorColor->Red],
StyledVector[ff[t0],rrr[t0],VectorColor->Green],
{}}//AddShadow}]/.OrigamiStyle[]
]//ShowExample
Module[{ff,\[Gamma],rrr,rrl,t,t0,th},
ff={Cos[#],Sin[#],0.05}&;
\[Gamma]=90\[Degree];
rrl=FunctionizeOld[RotationZMatrix3D[t] . RotationYMatrix3D[\[Gamma]/2] . {-1,0,0},t];
rrr=FunctionizeOld[RotationZMatrix3D[t] . RotationYMatrix3D[-\[Gamma]/2] . {1,0,0},t];
t0=\[Pi]/4;
th=Thickness[.02];
Graphics3D[{
Styled3DAxes[.5,.5,.5],
{StyledCurvedFold[ff,{rrl,rrr},{0,\[Pi]/2},
FoldLineStyle->{Yellow,th},
RulingLineLeftStyle->Lighter[Red],
RulingLineRightStyle->Lighter[Green],
BoundaryLineLeftStyle->Red,
BoundaryLineRightStyle->Green],
StyledVector[{ff[t0],ff[t0]+rrl[t0]},VectorColor->Red],
StyledVector[{ff[t0],ff[t0]+rrr[t0]},VectorColor->Green],
{}}//AddShadow}]/.OrigamiStyle[]
]//ShowExample
DirectrixLeftPointStyle::usage="DirectrixLeftPointStyle is an option to StyledCurvedFoldOptical that specifies to draw the left directrix as a point, not a line, using this style.";
DirectrixRightPointStyle::usage="DirectrixRightPointStyle is an option to StyledCurvedFoldOptical that specifies to draw the right directrix as a point, not a line, using this style.";
VirtualLineLeftStyle::usage="VirtualLineLeftStyle is an option to StyledCurvedFoldOptical that specifies the style to use for the left virtual ruling line.";
VirtualLineRightStyle::usage="VirtualLineRightStyle is an option to StyledCurvedFoldOptical that specifies the style to use for the right virtual ruling line.";
DirectrixLeftStyle::usage="DirectrixLeftStyle is an option to StyledCurvedFoldOptical that specifies the style to use for the left directrix.";
DirectrixRightStyle::usage="DirectrixRightStyle is an option to StyledCurvedFoldOptical that specifies the style to use for the right directrix.";
CrossCurveLeftStyle::usage="CrossCurveLeftStyle is an option to StyledCurvedFoldOptical that specifies the style to use for the left cross curve.";
CrossCurveRightStyle::usage="CrossCurveRightStyle is an option to StyledCurvedFoldOptical that specifies the style to use for the right cross curve.";
CurvedFoldOpticalStyles::usage="CurvedFoldOpticalStyles is a list of style options for StyledCurvedFoldOptical that applies colors for a particular 2D style.";
CurvedFoldOpticalStyles={
FoldLineStyle->FoldedLine,
DirectrixLeftStyle->Darker[Red],
DirectrixRightStyle->Darker[Green],
CrossCurveLeftStyle->Lighter[Purple,.75],
CrossCurveRightStyle->Lighter[Purple,.75],
RulingLineLeftStyle->Red,
RulingLineRightStyle->Green,
VirtualLineLeftStyle->LightGray,
VirtualLineRightStyle->LightGray,
FillStyle->None
};
Options[StyledCurvedFoldOptical]={
FoldLineStyle->FoldedLine,
DirectrixLeftStyle->Darker[Red],
DirectrixRightStyle->Darker[Green],
DirectrixLeftPointStyle->None,
DirectrixRightPointStyle->None,
CrossCurveLeftStyle->BorderLine,
CrossCurveRightStyle->BorderLine,
RulingLineLeftStyle->UndefinedRulingLine,
RulingLineRightStyle->UndefinedRulingLine,
VirtualLineLeftStyle->LightGray,
VirtualLineRightStyle->LightGray
};
StyledCurvedFoldOptical[f_Function|f_InterpolatingFunction,{cl_Function|cl_InterpolatingFunction,cr_Function|cr_InterpolatingFunction},{bl_Function|bl_InterpolatingFunction,br_Function|br_InterpolatingFunction},{t0_, t1_}, opts___]:=Module[{fls,bls,brs,blps,brps,cls,crs,rlls,rlrs,vlls,vlrs,fs,fd},
fls=FoldLineStyle/.{opts}/.Options[StyledCurvedFoldOptical];
bls=DirectrixLeftStyle/.{opts}/.Options[StyledCurvedFoldOptical];
brs=DirectrixRightStyle/.{opts}/.Options[StyledCurvedFoldOptical];
blps=DirectrixLeftPointStyle/.{opts}/.Options[StyledCurvedFoldOptical];
brps=DirectrixRightPointStyle/.{opts}/.Options[StyledCurvedFoldOptical];
cls=CrossCurveLeftStyle/.{opts}/.Options[StyledCurvedFoldOptical];
crs=CrossCurveRightStyle/.{opts}/.Options[StyledCurvedFoldOptical];
rlls=RulingLineLeftStyle/.{opts}/.Options[StyledCurvedFoldOptical];
rlrs=RulingLineRightStyle/.{opts}/.Options[StyledCurvedFoldOptical];
vlls=VirtualLineLeftStyle/.{opts}/.Options[StyledCurvedFoldOptical];
vlrs=VirtualLineRightStyle/.{opts}/.Options[StyledCurvedFoldOptical];
fs=FillStyle/.{opts}/.Options[StyledCurvedFoldOptical];
fd=CurveDivisions/.{opts}/.Options[StyledCurvedFold];
{StyledCurvedFoldBounded[f,{bl,br},{t0,t1},
FillStyle->None,
FoldLineStyle->None,
RulingLineLeftStyle->vlls,
RulingLineRightStyle->vlrs,opts],
StyledCurve[bl,{t0,t1},
LineStyle->bls],
StyledCurvedFoldBounded[f,{cl,cr},{t0,t1},
FillStyle->fs,
FoldLineStyle->fls,
RulingLineLeftStyle->rlls,
RulingLineRightStyle->rlrs,opts],
If[blps===None,
StyledCurve[bl,{t0,t1},
LineStyle->bls,
CurveDivisions->fd],
Style[Point[bl[0]],blps]],
StyledCurve[cl,{t0,t1},
LineStyle->cls,
CurveDivisions->fd],
StyledCurve[cr,{t0,t1},
LineStyle->crs,
CurveDivisions->fd],
If[brps===None,
StyledCurve[br,{t0,t1},
LineStyle->brs,
CurveDivisions->fd],
Style[Point[br[0]],brps]],
{}}]
Module[{f,bl,dl,cl,br,dr,cr},
f={-((6 (-1+Cos[#1]))/(-3+Cos[#1])),-((4 Sin[#1])/(-3+Cos[#1]))}&;
bl={-2,0}&;
dl={Cos[#1],Sin[#1]}&;cl={(1/2) (-4+Cos[#1]),Sin[#1]/2}&;br={-1,0}&;dr={(3-5 Cos[#1])/(-5+3 Cos[#1]),(4 Sin[#1])/(5-3 Cos[#1])}&;cr={(11-13 Cos[#1])/(-5+3 Cos[#1]),(8 Sin[#1])/(5-3 Cos[#1])}&;
GraphicsRow[{
Graphics[StyledCurvedFoldOptical[f,{cl,cr},{bl,br},{0\[Degree],90\[Degree]}]],
Graphics[StyledCurvedFoldOptical[f,{cl,cr},{bl,br},{0\[Degree],90\[Degree]},
Sequence@@CurvedFoldOpticalStyles]]}]/.OrigamiStyle[]
]//ShowExample
TAssigned::usage="TAssigned is a TObj class that represents a graph with a crease assignment on its edges.";
RegisterTClass[TAssigned];
EdgeTypes::usage="EdgeTypes is a TObj property that specifies a list of origami types that apply to the edges of a plane graph.";
V::usage="V is a symbolic type label for an edge of a plane graph to indicate that it is a valley fold.";
M::usage="M is a symbolic type label for an edge of a plane graph to indicate that it is a mountain fold.";
U::usage="U is a symbolic type label for an edge of a plane graph to indicate that it is an unfolded fold. (It is also a 2D unit vector function.)";
B::usage="B is a symbolic type label for an edge of a plane graph to indicate that it is a border edge.";
AddTAssignedTo::badtypes="Length `1` of EdgeTypes `2` does not match length `3` of Edges `4`.";
AddTAssignedTo[tobj_TObj,types_List]:=Module[{edges,ne,nt},
AssertClass[tobj,TGraph,AddTAssignedTo];
edges=GetValue[tobj,Edges];
ne=Length[edges];
nt=Length[types];
If[ne!=nt&&nt!=0,Message[AddTAssignedTo::badtypes,nt,types,ne,edges];Abort[]];
AddClassTo[tobj,TAssigned,{EdgeTypes->If[ListEmptyQ[types],Table[U,{Length[tobj[Edges]]}],types]}]]
AddTAssigned[types_List:{}]:=AddTAssignedTo[#,types]&
Module[{verts,edges,tobj},
verts={{0,0},{1,0}};
edges={{1,2}};
tobj=MakeTGraph[verts,edges]//AddTAssigned[];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
Module[{verts,edges,types,tobj},
verts={{0,0},{1,0}};
edges={{1,2}};
types={M};
tobj=MakeTGraph[verts,edges]//AddTAssigned[types];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
TypeFoldedQ[type_]:=(type===M||type===V);
TypeFoldedQ/@{M,V,U,B,A}//ShowExample
InvertTypeRules={M->V,V->M};
InvertFoldType[expr_]:=expr/.InvertTypeRules
InvertFoldType[{M,M,V,U,U,V}]//ShowExample
TypeMinimumAngle::usage = "TypeMinimumAngle is an option to FoldAngleToType that specifies the minimum value of a fold angle that should be assigned a folded type (M or V).";
Options[FoldAngleToType]={
TypeMinimumAngle->0.5\[Degree]
};
FoldAngleToType[\[Alpha]_,opts___]:=With[{\[Epsilon]=TypeMinimumAngle/.{opts}/.Options[FoldAngleToType]},Which[\[Alpha]>\[Epsilon],V,\[Alpha]<-\[Epsilon],M,True,U]]
SetAttributes[FoldAngleToType,Listable];
FoldAngleToType[{-1\[Degree],0\[Degree],1\[Degree]}]//ShowExample
FoldAngleToType[{-.1\[Degree],0\[Degree],.1\[Degree]}]//ShowExample
TypeToFlatFoldAngle[type_]:=Switch[type,V,\[Pi],M,-\[Pi],_,0]
SetAttributes[TypeToFlatFoldAngle,Listable];
TypeToFlatFoldAngle[{V,M,U,B}]//ShowExample
PlaneGraphTypes[tobj_TObj]:=Module[{efi},
AssertClass[tobj,TPlaneGraph,PlaneGraphTypes];
efi=GetValue[tobj,EdgeFaceIncidence];
If[MemberQ[#,0],B,U]&/@efi]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{2,0},{3,1},{4,1},{4,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,3},{4,7},{7,8},{8,1},{7,2}};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph;
Print[GraphGraphics[tobj]];
PlaneGraphTypes[tobj]
]//ShowExample
MakeStdFoldAngleSpecs::badtype="`1` is not a valid fold type.";
MakeStdFoldAngleSpecs[tobj_TObj]:=Module[{tobj1,types,faspecs},
AssertClasses[tobj,{TGraph,TAssigned},MakeStdFoldAngleSpecs];
types=GetValue[tobj,EdgeTypes];
Switch[#,B,{\[Infinity],0},M,{1,-90\[Degree]},V,{1,90\[Degree]},U,{1,0},_,Message[MakeStdFoldAngleSpecs::badtype];Abort[]]&/@types
]
Module[{verts,edges,types,faspecs,tobj},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
types={V,M,V,V,V,M,V,B,B,B,B,B,B};
tobj=MakeTGraph[verts,edges,{}]//AddTAssigned[types];
faspecs=MakeStdFoldAngleSpecs[tobj];
FoldAngleSpecGraphics[tobj,faspecs]
]//ShowExample
Module[{verts,edges,types,tobjcp,faspecs,foldangles,tobjff},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
types={V,M,V,V,V,M,V,B,B,B,B,B,B};
tobjcp=MakeTGraph[verts,edges]//AddTAssigned[types]//AddTPlaneGraph;
faspecs=MakeStdFoldAngleSpecs[tobjcp];
faspecs[[4]]={\[Infinity],100.\[Degree]};(* fix one angle *)
foldangles=MakeGraphFoldAngles[tobjcp,faspecs];(* solve for remaining angles *)
tobjff=FoldGraph3D[tobjcp,foldangles,StationaryFace->6];
GraphicsRow[{GraphGraphics[tobjcp],Graph3DGraphics3D[tobjff]}]
]//ShowExample
Manipulate[Module[{verts,edges,types,tobjcp,faspecs,foldangles,tobjff},
verts={{0,0},{3,0},{0,1},{1,1},{2,1},{3,1},{0,2},{3,2}};
edges={{1,4},{3,4},{7,4},{4,5},{5,2},{5,6},{5,8},{1,2},{2,6},{6,8},{8,7},{7,3},{3,1}};
types={V,M,V,V,V,M,V,B,B,B,B,B,B};
tobjcp=MakeTGraph[verts,edges]//AddTAssigned[types]//AddTPlaneGraph;
faspecs=MakeStdFoldAngleSpecs[tobjcp];
faspecs[[4]]={\[Infinity],\[Beta] \[Degree]};
foldangles=MakeGraphFoldAngles[tobjcp,faspecs];
tobjff=FoldGraph3D[tobjcp,foldangles,StationaryFace->6];
Graph3DGraphics3D[tobjff]]
,{{\[Beta],90.},0.,135.}]//ShowExample
TypeMaximumAngle::usage="TypeMaximumAngle is an option to ReassignGraphAssigned that specifies the maximum angle that is assigned M or V based upon fold angle.";
Options[ReassignGraphAssigned]={
TypeMaximumAngle->\[Pi]
};
ReassignGraphAssigned[tobj_TObj,foldangles_List, opts___]:=Module[{mnfa,mxfa,types},
AssertClasses[tobj,{TGraph,TAssigned},ReassignGraphAssigned];
mnfa=TypeMinimumAngle/.{opts}/.Options[FoldAngleToType];
mxfa=TypeMaximumAngle/.{opts}/.Options[ReassignGraphAssigned];
types=tobj[EdgeTypes];
Do[If[!(types[[i]]===B),types[[i]]=Which[Abs[foldangles[[i]]]<mnfa,U,Abs[foldangles[[i]]]>mxfa,types[[i]],foldangles[[i]]>0,V,True,M]],{i,Length[types]}];
ReplacePropertyIn[tobj,EdgeTypes->types]
]
Module[{verts,edges,types,tobj,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{4,0},{0,1},{1,1},{2,1},{3,1},{4,1}};
edges={{1,2},{2,3},{3,4},{4,5},{1,6},{2,7},{3,8},{4,9},{5,10},{6,7},{7,8},{8,9},{9,10}};
types={B,B,B,B,B,U,U,U,B,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTAssigned[types];
tobj1=ReassignGraphAssigned[tobj,{0,0,0,0,0,90\[Degree],0.3\[Degree],-90\[Degree],0,0,0,0,0}];
tobj1[EdgeTypes]
]//ShowExample
TGraphAssigned::usage="TGraphAssigned is a TObj class that describes a crease-assigned graph, e.g., a crease pattern or folded form.";
RegisterTClass[TGraphAssigned,{TGraph,TAssigned}];
MakeTGraphAssigned[verts_List, edges_List,faces_List:{}, types_List:{}]:=
MakeTGraph[verts,edges,faces]//AddTAssigned[If[types==={},Table[U,{Length[edges]}],types]]//AddClass[TGraphAssigned]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraphAssigned[verts,edges];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
Module[{verts,edges,types,tobj},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
types={M, V,U};
tobj=MakeTGraphAssigned[verts,edges,{},types];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
TypeToCreasePatternStyleRules={
M->MountainLine,
V->ValleyLine,
U->UnfoldedLine,
B->BorderLine
};
TypeToVisibleFoldedFormStyleRules={
M->FoldedLine,
V->FoldedLine,
U->UnfoldedLine,
B->BorderLine
};
TypeToHiddenFoldedFormStyleRules={
M->HiddenFoldedLine,
V->HiddenFoldedLine,
U->HiddenUnfoldedLine,
B->HiddenBorderLine
};
TypeToGenericFoldedFormStyleRules={
M->CreaseLine,
V->CreaseLine,
U->CreaseLine,
B->CreaseLine
};
TypeToNoFoldStyleRules={
M->NoLine,
V->NoLine,
U->NoLine,
B->BorderLine
};
TypesToString[types_List]:=StringJoin[ToString/@types]
TypesToString[{M,M,M,V,V,V}]//ShowExample
Module[{},
pgvertscp={{0,0},{1,0},{1,1},{0,1},{-.4,-1},{-.8,-1},{2,-.4},{2,-.8},{1.4,2},{1.8,2},{-1,1.4},{-1,1.8},{-1,-1},{2,-1},{2,2},{-1,2}};
pgvertsff={{0,0},{1,0},{1,1},{0,1},{0.4,-1.`},{0.8,-1.`},{2.,0.4},{2.,0.8},{0.6,2.},{0.2,2.},{-1.,0.6},{-1.,0.2},{0.6551724137931035`,-1.1379310344827587`},{2.1379310344827585`,0.6551724137931035`},{0.34482758620689635`,2.1379310344827585`},{-1.137931034482759`,0.3448275862068968`}};
pgedges={{1,2},{2,3},{4,3},{1,4},(* interior square *)
{1,5},{4,6},{7,2},{8,1},{3,9},{2,10},{4,11},{3,12},(* pleats *)
{13,6},{6,5},{5,14},{14,8},{8,7},{7,15},{15,10},{10,9},{9,16},{16,12},{12,11},{11,13} (* border *)
};
pgfaces={{1,2,3,4},(* twist poly *)
{1,4,6,5},{2,1,8,7},{3,2,10,9},{4,3,12,11},(* pleats *)
{1,5,14,8},{2,7,15,10},{3,9,16,12},{4,11,13,6}(* wedges *)
};
pgtypes={V,M,M,V,V,M,V,M,M,V,M,V,B,B,B,B,B,B,B,B,B,B,B,B};(* mixed *)
pgtypes1={M,M,M,M,M,V,M,V,M,V,M,V,B,B,B,B,B,B,B,B,B,B,B,B};(* cyclic, M *)
pgtypes2={V,V,V,V,V,M,V,M,V,M,V,M,B,B,B,B,B,B,B,B,B,B,B,B};(* cyclic, V *)
(* crease pattern and folded form *)
pgtobj=MakeTGraph2D[pgvertscp,pgedges,pgfaces,pgvertsff]//AddTAssigned[pgtypes];
pgtobj1=MakeTGraph2D[pgvertscp,pgedges,pgfaces,pgvertsff]//AddTAssigned[pgtypes1];
pgtobj2=MakeTGraph2D[pgvertscp,pgedges,pgfaces,pgvertsff]//AddTAssigned[pgtypes2];
GraphicsGrid[{
{GraphGraphics[pgtobj],Graph2DGraphics[pgtobj]},
{GraphGraphics[pgtobj1],Graph2DGraphics[pgtobj1]},
{GraphGraphics[pgtobj2],Graph2DGraphics[pgtobj2]}
}]
]//ShowExample
CreasePatternLines[tobj_TObj]:=Module[{verts,edges,types},
{verts,edges,types}=GetValues[tobj,{Vertices,Edges,EdgeTypes}];
MapThread[Style,{Line/@Embed[verts,edges],types}]/.TypeToCreasePatternStyleRules]
Module[{verts, edges,types,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5}};
edges={{1,2},{1,3},{1,4},{1,5}};
types={M,M,V,M};
tobj=MakeTGraph[verts,edges];
tobj1=MakeTGraphAssigned[verts,edges]; (* unassigned *)
tobj2=MakeTGraphAssigned[verts,edges,{},types];(* assigned *)
GraphicsRow[{
Graphics[CreasePatternLines[tobj1],PlotLabel->"Unassigned"],Graphics[CreasePatternLines[tobj2],PlotLabel->"Assigned"]}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj,tobj1,tobj2},
tobj=MakeTGraph[pgvertscp,pgedges];
tobj1=tobj//AddTAssigned[]; (* unassigned *)
tobj2=tobj//AddTAssigned[pgtypes];(* assigned *)
GraphicsRow[{
Graphics[CreasePatternLines[tobj1],PlotLabel->"Unassigned"],Graphics[CreasePatternLines[tobj2],PlotLabel->"Assigned"]}]/.OrigamiStyle[]
]//ShowExample
CreasePatternPolys[tobj_TObj]:=Module[{verts,faces,pf},
{verts,faces}=GetValues[tobj,{Vertices,Faces}];
Style[Polygon[verts[[#]]],PaperWhiteSideFill]&/@faces]
Module[{verts, edges,faces,tobj},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5},{0,.75},{0,-.75}};
edges={{1,2},{1,3},{1,4},{1,5}};
faces={{2,6,3,4,5,7}};
tobj=MakeTGraphAssigned[verts,edges,faces];
Graphics[{CreasePatternPolys[tobj],CreasePatternLines[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj},
tobj=MakeTGraphAssigned[pgvertscp,pgedges,pgfaces,pgtypes];
Graphics[{CreasePatternPolys[tobj],CreasePatternLines[tobj]}]/.OrigamiStyle[]
]//ShowExample
CreasePatternGraphics[tobj_TObj,opts___]:=Module[{},
AssertClasses[tobj,{TGraph,TAssigned},CreasePatternGraphics];
Graphics[
{CreasePatternPolys[tobj],
CreasePatternLines[tobj]},FilterRules[{opts},Options[Graphics]]]]
Module[{verts, edges,types,faces,tobj},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5},{0,.75},{0,-.75}};
edges={{1,2},{1,3},{1,4},{1,5}};
types={M,M,V,M};
faces={{2,6,3,4,5,7}};
tobj=MakeTGraphAssigned[verts,edges,faces,types];
CreasePatternGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
Module[{tobj},
tobj=MakeTGraphAssigned[pgvertscp,pgedges,pgfaces,pgtypes];
CreasePatternGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
Clear[RandlettBirdGraphAssigned];AddTGraphExample[RandlettBirdGraphAssigned,Module[{p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,verts3d,verts,faces,edges,types},
(* constants that define the crease pattern *)
p1=-1;
p2=\[Sqrt]2-2;
p3=1.-\[Sqrt]2;
p4=0;
p5=1-1/\[Sqrt]2;
p6=\[Sqrt]2-1;
p7=1/2;
p8=2-\[Sqrt]2;
p9=4 \[Sqrt]2-5;
p10=5-3 \[Sqrt]2;
p11=2 \[Sqrt]2-2;
p12=1;
(* Vertices and edges, both for real folds and for bent faces *)
verts={{p12,p12},{p10,p10},{p7,p7},{p5,p5},{p4,p4},{p1,p1},{p9,p12},{p12,p9},{p8,p11},{p11,p8},{p5,p12},{p12,p5},{p6,p10},{p10,p6},{p4,p8},{p8,p4},{p4,p12},{p12,p4},{p1,p12},{p12,p1},{p3,p6},{p6,p3},{p2,p4},{p4,p2},{p1,p4},{p4,p1},{p1,p3},{p3,p1}}//N;
edges={{1,2},{1,7},{1,9},{1,10},{2,3},{2,9},{2,10},{3,4},{3,13},{3,14},{3,15},{3,16},{4,5},{4,15},{4,16},{4,21},{4,22},{5,6},{5,21},{5,22},{5,24},{6,27},{7,9},{7,11},{8,1},{8,10},{9,13},{10,14},{11,13},{11,15},{11,17},{12,8},{12,14},{12,16},{13,15},{14,16},{15,17},{15,21},{16,18},{16,22},{17,19},{17,21},{18,12},{18,22},{19,21},{19,23},{20,18},{20,24},{20,26},{21,23},{22,20},{23,5},{23,25},{23,27},{24,22},{24,26},{24,28},{25,19},{26,28},{27,25},{28,6},{5,27},{5,28}};
(* Flat-folded crease assignment *)
types={
(* 1 *) M,B,V,V,V,
(* 6 *) M,M,M,U,U,
(* 11 *) V,V,M,U,U,
(* 16 *) U,U,M,M,M,
(* 21 *) V,B,M,B,B,
(* 26 *) M,M,M,U,V,
(* 31 *) B,B,U,V,M,
(* 36 *) M,U,V,U,V,
(* 41 *) B,U,B,U,M,
(* 46 *) V,B,V,B,M,
(* 51 *) M,V,U,V,M,
(* 56 *) U,V,B,B,B,
(* 61 *) B,U,U};
MakeTPlaneGraph[verts,edges]//AddTAssigned[types]]];
Module[{tobj},
tobj=RandlettBirdGraphAssigned;
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj]/.OrigamiStyle[]}]
]//ShowExample
TGraph2DAssigned::usage="TGraph2DAssigned is a TObj class that describes a crease-assigned graph with an alternate 2D embedding.";
RegisterTClass[TGraph2DAssigned,{TGraph2D,TAssigned}];
MakeTGraph2DAssigned[verts_List, edges_List,faces_List:{}, verts2d_List:{}, types_List:{}]:=
MakeTGraph[verts,edges,faces]//AddTGraph2D[If[verts2d==={},verts,verts2d]]//AddTAssigned[If[types==={},Table[U,{Length[edges]}],types]]//AddClass[TGraph2DAssigned]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph2DAssigned[verts,edges];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
Module[{verts,edges,types,verts2d,tobj},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
types={M, V,U};
verts2d={{10,0},{11,0},{11,1}};
tobj=MakeTGraph2DAssigned[verts,edges,{},verts2d,types];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
GenericFoldedFormLines[tobj_TObj]:=Module[{verts2d,edges,types},
{verts2d,edges,types}=GetValues[tobj,{Vertices2D,Edges,EdgeTypes}];
MapThread[Style,{Line/@Embed[verts2d,edges],types}]/.TypeToGenericFoldedFormStyleRules]
Module[{verts, edges,faces,types,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5}};
edges={{1,2},{1,3},{1,4},{1,5}};
faces={{2,6,3,4,5,7}};
types={M,M,V,M};
tobj=MakeTGraph[verts,edges];
tobj1=MakeTGraph2DAssigned[verts,edges,faces,{},{}]; (* unassigned *)
tobj2=MakeTGraph2DAssigned[verts,edges,faces,{},types]; (* assigned *)
Print[Graphics[GenericFoldedFormLines[tobj1],PlotLabel->"Unassigned"]/.OrigamiStyle[]];
Print[Graphics[GenericFoldedFormLines[tobj2],PlotLabel->"Assigned"]/.OrigamiStyle[]]
]//ShowExample
Options[FoldedFormPolys]={
PaperFill->PaperWhiteSideFill
};
FoldedFormPolys[tobj_TObj,opts___]:=Module[{verts2d,faces,pf},
{verts2d,faces}=GetValues[tobj,{Vertices2D,Faces}];
pf=PaperFill/.{opts}/.Options[FoldedFormPolys];
Style[Polygon[verts2d[[#]]],pf]&/@faces]
Module[{verts, edges,types,faces,tobj},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5},{0,.75},{0,-.75}};
edges={{1,2},{1,3},{1,4},{1,5}};
faces={{2,6,3,4,5,7}};
tobj=MakeTGraph2DAssigned[verts,edges,faces]; (* unassigned *)
Graphics[{FoldedFormPolys[tobj],GenericFoldedFormLines[tobj]}]/.OrigamiStyle[]
]//ShowExample
Options[GenericFoldedFormGraphics]=Options[FoldedFormPolys];
GenericFoldedFormGraphics[tobj_TObj,opts___]:=Module[{},
AssertClasses[tobj,{TGraph2D,TAssigned},GenericFoldedFormGraphics];
Graphics[
{FoldedFormPolys[tobj,opts],
GenericFoldedFormLines[tobj]},FilterRules[{opts},Options[Graphics]]]]
Module[{verts, edges,types,faces,tobj},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5},{0,.75},{0,-.75}};
edges={{1,2},{1,3},{1,4},{1,5}};
faces={{2,6,3,4,5,7}};
types={M,M,V,M};
tobj=MakeTGraph2DAssigned[verts,edges,faces,{},types];
GenericFoldedFormGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
Module[{tobj,fo},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
fo=FaceOverlaps2D[tobj];
GenericFoldedFormGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
FaceupFace::usage="FaceupFace is an option to LocalFaceOrdering that specifies a face that is considered to be face-up. Pass the negative of the index to specify that the face is face-down.";
Options[LocalFaceOrdering]={
FaceupFace->1
};
LocalFaceOrdering[tobj_TObj,opts___]:=Module[{edges,types,faces,sf,fc,iedges,dedges,erules,detypes},
{edges,types,faces}=GetValues[tobj,{Edges,EdgeTypes,Faces}];
sf=FaceupFace/.{opts}/.Options[LocalFaceOrdering];
fc=Sign[sf]*TwoColorGraph[tobj,StartFace->Abs[sf]];
{iedges,dedges}=OrientedInteriorEdgePairs[tobj];
erules=Join[MapThread[Rule,{edges,types}],MapThread[Rule,{Reverse/@edges,types}]];
detypes=Transpose[{dedges,#/.erules&/@iedges,fc[[#[[1]]]]&/@dedges}];(* dual graph edges with fold types and color *)
If[#[[3]]==1\[Xnor]#[[2]]===M,#[[1]],Reverse[#[[1]]]]&/@detypes
]
Module[{vertscp,vertsff,edges,faces,types,tobjcp,tobjff},
vertscp={{0,0},{1,0},{3,0},{3,1},{2,1},{0,1}};
vertsff={{0,0},{1,0},{1,2},{2,2},{2,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,1},{2,5}};
types={B,B,B,B,B,B,V};
faces={{1,2,5,6},{2,3,4,5}};
tobjcp=MakeTGraphAssigned[vertscp,edges,faces,types];
tobjff=tobjcp//ReplaceProperty[Vertices->vertsff];
Print[GraphicsRow[{GraphGraphics[tobjcp],GraphGraphics[tobjff]}]];
LocalFaceOrdering[tobjcp]
]
Module[{tobj,fc,fverts,dverts,lfo,fgraph},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
lfo=LocalFaceOrdering[tobj,FaceupFace->1];
GraphicsGrid[{{
GraphGraphics[tobj,FaceColoring->TwoColorGraph[tobj,StartFace->1]],
CreasePatternGraphics[tobj]/.OrigamiStyle[]},{
Graph2DGraphics[tobj],
Show[GraphGraphics[tobj],
GenericGraphGraphics[FaceCentroids[tobj],lfo,{},DirectedEdges->True,EdgeColor->Blue,VertexLabels->None]]}}]
]//ShowExample
FaceOverlaps2D[tobj_TObj]:=Module[{verts2d,faces,polys,infos,oedges},
{verts2d,faces}=GetValues[tobj,{Vertices2D,Faces}];
polys=verts2d[[#]]&/@faces;
infos=QuasiConvexPolygonIntersectionInfo/@polys; (* each entry is {verts, bbox, convex, triangles } *)
oedges={};
Do[
(* first quick check, see if bounding boxes intersect *)
If[!BoundingBoxesIntersectQ[infos[[i,2]],infos[[j,2]]],Continue[]];
(* now check for real *)
If[QuasiConvexPolygonsIntersectQ[infos[[i]],infos[[j]]],AppendTo[oedges,{j,i}]];
,{i,2,Length[faces]},{j,i-1}];
oedges]
Module[{tobj,fo},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
fo=FaceOverlaps2D[tobj];
Print[fo];
GraphicsGrid[{{
GraphGraphics[tobj,FaceColoring->TwoColorGraph[tobj,StartFace->1]],
CreasePatternGraphics[tobj]/.OrigamiStyle[]},{
Graph2DGraphics[tobj],
Show[GraphGraphics[tobj],
GenericGraphGraphics[FaceCentroids[tobj],fo,{},EdgeColor->Blue,VertexLabels->None]]}}]
]//ShowExample
EdgeOverlaps2D[tobj_TObj,opts___]:=Module[{verts2d,edges,epairs,oedges},
{verts2d,edges}=GetValues[tobj,{Vertices2D,Edges}];
epairs=verts2d[[#]]&/@edges;
oedges={};
Do[
(* don't bother with edges that share a vertex *)
If[Or[edges[[i,1]]==edges[[j,1]],edges[[i,1]]==edges[[j,2]],edges[[i,2]]==edges[[j,1]],edges[[i,2]]==edges[[j,2]]],Continue[]];
(* first quick check, see if bounding boxes intersect *)
If[!BoundingBoxesIntersectQ[BoundingBox[epairs[[i]]],BoundingBox[epairs[[j]]]],Continue[]];
(* now check for real *)
If[SegmentsIntersectQ[epairs[[i]],epairs[[j]],opts],AppendTo[oedges,{j,i}]];
,{i,2,Length[edges]},{j,i-1}];
oedges]
Module[{tobj,eo},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
eo=EdgeOverlaps2D[tobj];
Print[eo];
GraphicsGrid[{{
GraphGraphics[tobj,FaceColoring->TwoColorGraph[tobj,StartFace->1]],
CreasePatternGraphics[tobj]/.OrigamiStyle[]},{
Graph2DGraphics[tobj,Frame->True],
Show[GraphGraphics[tobj],
GenericGraphGraphics[EdgeCentroids[tobj],eo,{},EdgeColor->Blue,VertexLabels->None]]}}]
]//ShowExample
EdgeFacePairs[tobj_TObj]:=Module[{edges,faces,fe},
{edges,faces}=GetValues[tobj,{Edges,Faces}];
fe=Join[#,Reverse/@#]&/@(Transpose[{#,RotateLeft[#]}]&/@faces);(* all edges for each face *)
First/@Position[fe,#]&/@edges]
Module[{tobj,efp},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
efp=EdgeFacePairs[tobj];
Print[efp];
GraphGraphics[tobj]
]//ShowExample
MaxDistance::usage="MaxDistance is an option to FacesAboveOld that specifies how far away we look for a covering-up face.";
Options[FacesAboveOld]={
MaxDistance->\[Infinity],
ShowProgress->False,
};
FacesAboveOld[tobj_TObj,opts___]:=Module[{md,sp,dedges,nf,apsp,fa,aedges},
md=MaxDistance/.{opts}/.Options[FacesAboveOld];
sp=ShowProgress/.{opts}/.Options[FacesAboveOld];
dedges=LocalFaceOrdering[tobj,opts];
If[sp,
(* show the original local facet ordering graph *)
Print[Show[GraphGraphics[tobj],
GenericGraphGraphics[FaceCentroids[tobj],dedges,{},DirectedEdges->True,EdgeColor->RGBColor[0,.5,1],VertexLabels->None]]];
];
nf=Max[Flatten[dedges]];
(* graph distance matrix *)
apsp=GraphDistanceMatrix[Graph[dedges]];

Do[If[apsp[[i,j]]!=\[Infinity]&&apsp[[j,i]]!=\[Infinity],
Which[apsp[[i,j]]<apsp[[j,i]],apsp[[j,i]]=\[Infinity],
apsp[[i,j]]>apsp[[j,i]],apsp[[i,j]]=\[Infinity],
True (* apsp\[LeftDoubleBracket]i,j\[RightDoubleBracket]\[Equal]apsp\[LeftDoubleBracket]j,i\[RightDoubleBracket] *),apsp[[i,j]]=apsp[[j,i]]=\[Infinity]]],
{i,2,Length[apsp]-1},{j,i+1,Length[apsp]}];
fa=Flatten/@MapIndexed[If[#1!=0&&#1!=\[Infinity]&&#1<=md,#2[[2]],{}]&,Transpose[apsp],{2}];
If[sp,
(* Show a sequence of graphs showing which faces lie above each face in turn. *)
(* aedges are edges of the "above" graph. {i,j} means i is above j. *)
aedges=First/@MapIndexed[{#1,#2[[1]]}&,fa,2];
(* Show which facets lie above each individual facet as a series of graphs *)
Print[GraphicsGrid[Partition[Show[
CreasePatternGraphics[tobj]/.OrigamiStyle[],
GenericGraphGraphics[FaceCentroids[tobj],#,{},DirectedEdges->True,EdgeColor->Red]]&/@aedges,3]]];
];
fa]
Module[{tobj,fa},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
Print[GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj],Graph2DGraphics[tobj]}]/.OrigamiStyle[]];
fa=FacesAboveOld[tobj,ShowProgress->True];
fa
]//ShowExample
Module[{tobj,fa},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes1];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
Print[GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj],Graph2DGraphics[tobj]}]/.OrigamiStyle[]];
fa=FacesAboveOld[tobj,ShowProgress->True];
fa
]//ShowExample
ReportInconsistentOrdering::usage="ReportInconsistentOrdering is an option to FacesAboveAutomatic that specifies whether to report inconsistent ordering encountered during computation of the folded form.";
Options[FacesAboveAutomatic]={
ShowProgress->False,
ReportInconsistentOrdering->True
};
FacesAboveAutomatic::incons="Inconsistent face ordering was detected for face pairs `1`.";
FacesAboveAutomatic[tobj_TObj,opts___]:=Module[{sp,rio,nf,lfo,lfoold,fo,eo,efp,fa,eofn,eobadf,ei,ej,fi1,fi2,fj1,fj2,m11ij,m12ij,m21ij,m22ij,m11ji,m12ji,m21ji,m22ji,lfog,gdm,fi,fj,plij,plji,aedges},
sp=ShowProgress/.{opts}/.Options[FacesAboveAutomatic];
rio=ReportInconsistentOrdering/.{opts}/.Options[FacesAboveAutomatic];
nf=Length[tobj[Faces]];
fo=FaceOverlaps2D[tobj]; (* undirected edges on the faces that specify overlapping *)
eo=EdgeOverlaps2D[tobj,IncludeCollinear->False];(* undirected edges on the edges that specify overlapping *)
efp=EdgeFacePairs[tobj];(* faces incident to each edge *)
fa=Table[{},{nf}];(* list of faces above faces, to be populated *)
(* start with the local facet ordering from crease directions and 2-coloring *)
lfoold=lfo=LocalFaceOrdering[tobj,opts];(* directed edges on the faces that specify local ordering *)
(* Go through all overlapping edges and if there's an ordering between any two of the incident facets, add that ordering relationship between the other facets *)
eobadf={};(* running tally of face pairs for which contradictory ordering was implied. *)
eofn=Function[e,
{ei,ej}=e;(* indices of edges that overlap *)
If[Length[efp[[ei]]]==2&&Length[efp[[ej]]]==2,(* both edges incident to 2 facets *)
{fi1,fi2}=efp[[ei]];(* faces incident to ei *)
{fj1,fj2}=efp[[ej]];(* faces incident to ej *)
(* check for existence of {i,j} ordering or {j,i} ordering among any pair of the 4 faces *)
m11ij=MemberQ[lfo,{fi1,fj1}];
m12ij=MemberQ[lfo,{fi1,fj2}];
m21ij=MemberQ[lfo,{fi2,fj1}];
m22ij=MemberQ[lfo,{fi2,fj2}];
m11ji=MemberQ[lfo,{fj1,fi1}];
m12ji=MemberQ[lfo,{fj1,fi2}];
m21ji=MemberQ[lfo,{fj2,fi1}];
m22ji=MemberQ[lfo,{fj2,fi2}];
(* if any ordering exists for one face pair, add the corresponding ordering for the other pairs, but only if the reverse ordering for those pairs does not exist. If a reverse ordering does exist, we've reached an inconsistent state; we won't add the inconsistent ordering to the local face ordering and we'll make a note of the bad ordering. *)
(* check for {i,j} ordering *)
If[Or[m11ij,m12ij,m21ij,m22ij],
If[!m11ij,If[!m11ji,AppendTo[lfo,{fi1,fj1}],AppendTo[eobadf,{fi1,fj1}]]];
If[!m12ij,If[!m12ji,AppendTo[lfo,{fi1,fj2}],AppendTo[eobadf,{fi1,fj2}]]];
If[!m21ij,If[!m21ji,AppendTo[lfo,{fi2,fj1}],AppendTo[eobadf,{fi2,fj1}]]];
If[!m22ij,If[!m22ji,AppendTo[lfo,{fi2,fj2}],AppendTo[eobadf,{fi2,fj2}]]];
];
(* check for {j,i} ordering *)
If[Or[m11ji,m12ji,m21ji,m22ji],
If[!m11ji,If[!m11ij,AppendTo[lfo,{fj1,fi1}],AppendTo[eobadf,{fj1,fi1}]]];
If[!m12ji,If[!m12ij,AppendTo[lfo,{fj1,fi2}],AppendTo[eobadf,{fj1,fi2}]]];
If[!m21ji,If[!m21ij,AppendTo[lfo,{fj2,fi1}],AppendTo[eobadf,{fj2,fi1}]]];
If[!m22ji,If[!m22ij,AppendTo[lfo,{fj2,fi2}],AppendTo[eobadf,{fj2,fi2}]]];
];
]];
(* Repeatedly apply the function to the list of edge overlaps until our list of local facet overlaps no longer changes *)
FixedPoint[Function[x,eofn/@eo;lfo],Null];
eobadf=Union[eobadf];
(* report any inconsistencies *)
If[rio&&!ListEmptyQ[eobadf],
Message[FacesAboveAutomatic::incons,eobadf];
];
If[sp,
(* print and show the old and new local face ordering graphs *)
Print["local ordering = ",lfoold];
Print["extended ordering = ",lfo];
Print[GraphicsRow[{
Show[GraphGraphics[tobj],
GenericGraphGraphics[FaceCentroids[tobj],lfoold,{},DirectedEdges->True,EdgeColor->RGBColor[0,.5,1],VertexLabels->None]],
Show[GraphGraphics[tobj],
GenericGraphGraphics[FaceCentroids[tobj],lfo,{},DirectedEdges->True,EdgeColor->Blue,VertexLabels->None]]}]]];

(* Build a Graph from the lfo edges. We'll query this for path lengths. *)
lfog=Graph[Range[nf],DirectedEdge@@#&/@lfo];
gdm=GraphDistanceMatrix[lfog];
(* gdm\[LeftDoubleBracket]i,j\[RightDoubleBracket] gives the path length for facet i being covered by facet j *)
If[sp,
Print["path length matrix = ",MatrixForm[gdm]]
];
(* Go through overlapping face pairs and try to determine their relative order. If successful, push a face index onto the proper faces-above array. *)
Function[f,
{fi,fj}=f;(* indices of two overlapping faces *)
plij=gdm[[fi,fj]];(* path length for i covered by j *)
plji=gdm[[fj,fi]];(* path length for j covered by i *)
(* path length = 1 means no path exists *)
Which[
plij<plji,AppendTo[fa[[fj]],fi],(* i above j *)
plij>plji,AppendTo[fa[[fi]],fj],(* j above i *)
True,Null(* either no path or same length *)
]]/@fo;
If[sp,
(* Show a sequence of graphs showing which faces lie above each face in turn. *)
(* aedges are edges of the "above" graph. {i,j} means i is above j. *)
aedges=First/@MapIndexed[{#1,#2[[1]]}&,fa,2];
(* Show which facets lie above each individual facet as a series of graphs *)
Print[GraphicsGrid[Partition[Show[
CreasePatternGraphics[tobj]/.OrigamiStyle[],
GenericGraphGraphics[FaceCentroids[tobj],#,{},DirectedEdges->True,EdgeColor->Red]]&/@aedges,3]]];
];
fa]
Module[{tobj,fa},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
Print[GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj],Graph2DGraphics[tobj]}]/.OrigamiStyle[]];
fa=FacesAboveAutomatic[tobj,ShowProgress->True];
fa
]//ShowExample
Module[{tobj,fa},
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes1];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[pgtypes],StationaryFace->4];
Print[GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj],Graph2DGraphics[tobj]}]/.OrigamiStyle[]];
fa=FacesAboveAutomatic[tobj,ShowProgress->True];
fa
]//ShowExample
FacesAbove::usage="FacesAbove is an option to VisibleFoldedFormLines that specifies whether to calculate facet ordering from local ordering or to provide an explicit list of indices of faces lying about each face.";
Options[VisibleFoldedFormLines]={
FacesAbove->Automatic,
FaceupFace->1,
ShowProgress->False
};
VisibleFoldedFormLines[tobj_TObj, opts___]:=Module[{fa,ff,sp,verts,verts2d,edges,types,faces,fverts,dedges,aedges,tm,epfi,trules,emap,ss,cpolys,ssl1,ssl2},
fa=FacesAbove/.{opts}/.Options[VisibleFoldedFormLines];ff=FaceupFace/.{opts}/.Options[VisibleFoldedFormLines];sp=ShowProgress/.{opts}/.Options[VisibleFoldedFormLines];
{verts,verts2d,edges,types,faces}=GetValues[tobj,{Vertices,Vertices2D,Edges,EdgeTypes,Faces}];
If[sp,fverts=FaceCentroids[tobj]]; (* need these for various progress graphs *)
dedges=LocalFaceOrdering[tobj,opts]; (* used to construct emap *)
fa=FacesAboveAutomatic[tobj,opts];(* try our new version! *)
(* trules maps an edge index pair (either order) to its type *)
trules=Join[MapThread[Rule,{edges,types}],MapThread[Rule,{Reverse/@edges,types}]];
(* epfi is a list of the edge pair vertex and face incidences, i.e., {{vi, vj},{fk,fl}} for each edge. *)
tm=(Sort/@Transpose[{#,RotateLeft[#]}])&/@faces;
epfi={#,Transpose[Position[tm,#]][[1]]}&/@Union[Flatten[tm,1]];
(* emap will be a table listing each edge, a list of all faces that lie above it, and its type *)
emap={
#[[1]],(* the edge itself *)
If[Length[#[[2]]]==1,
fa[[#[[2,1]]]],(* face incident to a border edge *)
fa[[If[MemberQ[dedges,#[[2]]],#[[2,1]],#[[2,2]]]]] (* use the upper face incident to this edge *)
],
#[[1]]/.trules (* the type of this edge *)
}&/@epfi;
(* delete any edges that we couldn't assign a type to, which would typically arise if the tobj was missing edges (e.g., is borderless). *)
emap=Select[emap,Length[#[[3]]]!=2&];
(* convert each entry in this map to a list of segment sets and then to styled lines *)
Flatten[Function[ee,
ss=Append[verts2d[[ee[[1]]]],{{0,1}}];
cpolys=verts2d[[faces[[#]]]]&/@ee[[2]];
ss=Chop[Fold[ClipSegmentSetToQuasiConvexPolygonExterior[#1,#2]&,ss,cpolys]];
{ssl1,ssl2}=SegmentSetLines[ss];
{If[ListEmptyQ[ssl1],{},Style[ssl1,ee[[3]]/.TypeToVisibleFoldedFormStyleRules]],
If[ListEmptyQ[ssl2],{},Style[ssl2,ee[[3]]/.TypeToHiddenFoldedFormStyleRules]]}
]/@emap]]
Module[{vertscp,vertsff,edges,faces,types,tobj},
vertscp={{0,0},{1,0},{3,0},{3,1},{2,1},{0,1}};
vertsff={{0,0},{1,0},{1,2},{2,2},{2,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,1},{2,5}};
types={B,B,B,B,B,B,V};
faces={{1,2,5,6},{2,3,4,5}};
tobj=MakeTGraph2DAssigned[vertscp,edges,faces,vertsff,types];
Print["Local facet ordering = ",LocalFaceOrdering[tobj]];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj],
CreasePatternGraphics[tobj],
Graphics[VisibleFoldedFormLines[tobj]],
Graphics[VisibleFoldedFormLines[tobj,FaceupFace->-1]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj,fc,lfo,gfa},
(* crease pattern *)
tobj=MakeTPlaneGraph[pgvertscp,pgedges,pgfaces]//AddTAssigned[pgtypes];
(* primal-dual showing ordering *)
tobj=tobj//AddTPrimalDualGraph;
lfo=LocalFaceOrdering[tobj,FaceupFace->1];
tobj=tobj//ReplaceProperty[DualEdges->lfo];
(* two-colored graph *)
fc=TwoColorGraph[tobj,StartFace->1];
(* folded form *)
tobj=tobj//AddTGraph2D[pgvertsff];
(* output *)
Print["edge/type pairs = ",Transpose[{Range[Length[tobj[Edges]]],tobj[EdgeTypes]}]];
GraphicsRow[{
GraphGraphics[tobj,FaceColoring->fc],
CreasePatternGraphics[tobj],
PrimalDualGraphics[tobj,DualDirectedEdges->True],
Graphics[{StdVertexLabels[pgvertsff],VisibleFoldedFormLines[tobj]}]
}]/.OrigamiStyle[]
]//ShowExample
VisibleFoldedFormGraphics[tobj_TObj, opts___]:=Module[{},
AssertClasses[tobj,{TGraph2D,TAssigned},VisibleFoldedFormGraphics];
Graphics[
{FoldedFormPolys[tobj,opts],
VisibleFoldedFormLines[tobj,opts]},FilterRules[{opts},Options[Graphics]]]]
Module[{vertscp,vertsff,edges,faces,types,tobj},
vertscp={{0,0},{1,0},{3,0},{3,1},{2,1},{0,1}};
vertsff={{0,0},{1,0},{1,2},{2,2},{2,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,1},{2,5}};
types={B,B,B,B,B,B,V};
faces={{1,2,5,6},{2,3,4,5}};
tobj=MakeTGraph2DAssigned[vertscp,edges,faces,vertsff,types];
Print["Local facet ordering = ",LocalFaceOrdering[tobj]];
GraphicsRow[{
GraphGraphics[tobj],
Graph2DGraphics[tobj],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj],
VisibleFoldedFormGraphics[FlopGraph2D[tobj],FaceupFace->2]}]/.OrigamiStyle[]
]//ShowExample
Module[{},
GraphicsRow[{
CreasePatternGraphics[pgtobj],(* crease pattern showing direction of the folds *)
GenericFoldedFormGraphics[pgtobj], (* generic rendering, all fold lines are hidden *)
VisibleFoldedFormGraphics[pgtobj](* hidden line removal *)
}]/.OrigamiStyle[]
]//ShowExample
Module[{},
GraphicsGrid[Transpose[{
{CreasePatternGraphics[pgtobj],VisibleFoldedFormGraphics[pgtobj]},
{CreasePatternGraphics[pgtobj1],VisibleFoldedFormGraphics[pgtobj1]},
{CreasePatternGraphics[pgtobj2],VisibleFoldedFormGraphics[pgtobj2]}
}]]/.OrigamiStyle[]
]//ShowExample
Module[{vertscp,vertsff,edges,types,faces,tobj,pg,cp,ff},
{vertscp,vertsff,edges,types,faces}={{{0.7212601477285518`,0.606300738642759`},{0.6`,0.`},{1.123606797749979`,0.3804226065180615`},{0.6462553746927469`,0.8733163953839403`},{0.3691306448689169`,0.8844949929322115`},{0.823606797749979`,1.3037276676706375`},{0.17639320225002098`,1.3037276676706375`},{0.27286291575046334`,0.624388089422418`},{0.490490916959321`,0.45245458479660516`},{-0.12360679774997896`,0.3804226065180615`},{0.4`,0.`},{1.1854101966249684`,0.5706339097770922`},{0.9854101966249684`,1.186170617212143`},{0.014589803375031574`,1.186170617212143`},{-0.1854101966249685`,0.5706339097770922`},{1.`,2.7755575615628914`*^-17},{1.3090169943749475`,0.9510565162951538`},{0.5`,1.538841768587627`},{-0.30901699437494745`,0.9510565162951535`},{0.`,0.`}},{{0.7212601477285518`,0.606300738642759`},{0.6`,0.`},{1.123606797749979`,0.3804226065180615`},{0.45424449098737063`,0.5312959656069538`},{0.4430658934390996`,0.25417123578312384`},{0.8975420463201613`,0.6734039105215504`},{0.2503284508202035`,0.6734039105215498`},{0.7031727969488931`,0.15790350666467057`},{0.8751063015747056`,0.3755315078735282`},{0.2610085868654055`,0.30349952959498483`},{0.7846153846153846`,-0.07692307692307698`},{0.9933993129195924`,0.22861348000010612`},{0.7933993129195919`,0.8441501874351567`},{0.44489968457346074`,0.7196860344543949`},{0.24489968457346079`,0.10414932701934498`},{1.`,2.7755575615628914`*^-17},{1.1170061106695712`,0.6090360865181679`},{0.5739352485701824`,0.9085180114385396`},{0.12129288682348194`,0.48457193353740635`},{0.38461538461538447`,-0.07692307692307676`}},{{1,2},{3,1},{1,4},{5,6},{7,5},{5,8},{9,10},{11,9},{9,1},{4,12},{13,4},{4,5},{8,14},{15,8},{8,9},{11,2},{3,12},{13,6},{7,14},{15,10},{2,16},{16,3},{12,17},{17,13},{6,18},{18,7},{14,19},{19,15},{10,20},{20,11}},{M,M,M,M,M,M,M,V,V,V,V,V,V,V,V,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B},{{1,2,16,3},{1,4,5,8,9},{5,6,18,7},{9,10,20,11},{4,12,17,13},{8,14,19,15},{11,2,1,9},{3,12,4,1},{13,6,5,4},{7,14,8,5},{15,10,9,8}}};
tobj=MakeTGraph2DAssigned[vertscp,edges,faces,vertsff,types];
pg=GraphGraphics[tobj];
cp=CreasePatternGraphics[tobj];
ff=VisibleFoldedFormGraphics[tobj,ShowProgress->True];
GraphicsRow[{pg,cp,ff}/.OrigamiStyle[]]
]//ShowExample
CreasePatternGraphics[pgtobj]/.OrigamiStyle[]
GenericPairGraphics[tobj_TObj, opts___]:=Module[{},
AssertClasses[tobj,{TGraph2D,TAssigned},GenericPairGraphics];
Graphics[PlaceInRowGraphics[{
CreasePatternGraphics[tobj,opts],
GenericFoldedFormGraphics[tobj,opts]},opts][[1]],FilterRules[{opts},Options[Graphics]]]]
GenericPairGraphics[pgtobj,Frame->True]/.OrigamiStyle[]//ShowExample
VisiblePairGraphics[tobj_TObj,opts___]:=Module[{},
AssertClasses[tobj,{TGraph,TAssigned},VisiblePairGraphics];
Graphics[PlaceInRowGraphics[{CreasePatternGraphics[tobj,opts],VisibleFoldedFormGraphics[tobj,opts]}][[1]],FilterRules[{opts},Options[Graphics]]]]
VisiblePairGraphics[pgtobj,Frame->True]/.OrigamiStyle[]//ShowExample
TPlaneGraphAssigned::usage="TPlaneGraphAssigned is a TObj class that represents a full plane graph with crease assignment on its edges.";
RegisterTClass[TPlaneGraphAssigned,{TPlaneGraph,TAssigned}];
MakeTPlaneGraphAssigned[verts_List, edges_List, faces_List:{},types_List:{}]:=
MakeTPlaneGraph[verts,edges,faces]//AddTAssigned[If[ListEmptyQ[types],Table[U,{Length[edges]}],types]]//AddClass[TPlaneGraphAssigned]
Module[{verts,edges,faces,types,tobj},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,1}};
faces={{1,2,3,4}};
types={M,M,V,V};
tobj=MakeTPlaneGraphAssigned[verts,edges,faces,types];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
CreasePatternStyleToEdgeTypeRules={
MountainLine->M,
ValleyLine->V,
UnfoldedLine->U,
BorderLine->B
};
BorderOverride::usage="BorderOverride is an option to CreasePatternToPlaneGraphAssigned that overrides any fold line assignments on the border lines, setting them to B.";
Options[CreasePatternToPlaneGraphAssigned]={
SamePtTolerance->10^-6,
BorderOverride->False
};
CreasePatternToPlaneGraphAssigned::badstyles="The styles in this object, `1`, contain more than just {{MountainLine}, {ValleyLine}, {UnfoldedLine}, {BorderLine}}.";
CreasePatternToPlaneGraphAssigned::dupvert="The extracted edges `1` contain at least one edge with duplicate vertices `2`.";
CreasePatternToPlaneGraphAssigned[cp_,opts___]:=Module[{tol,bo,llist,styles,elist,edgetypes,verts,edges,tobj,faces,boundary,bedges},
tol=SamePtTolerance/.{opts}/.Options[CreasePatternToPlaneGraphAssigned];
bo=BorderOverride/.{opts}/.Options[CreasePatternToPlaneGraphAssigned];
llist=ExtractFracturedStyledLines[cp];
styles=ExtractStyleArgs[llist];
If[Length[Union[styles,{{MountainLine},{ValleyLine},{UnfoldedLine},{BorderLine}}]]>4,Message[CreasePatternToPlaneGraphAssigned::badstyles,styles];Abort[]];
{elist,edgetypes}=Transpose[llist/.Style->List];
edgetypes=edgetypes/.CreasePatternStyleToEdgeTypeRules;
{verts,edges}=Indexify[First/@elist,2,SamePtTolerance->tol];
If[!Union[Length/@Union/@edges]==={2},Message[CreasePatternToPlaneGraphAssigned::dupvert,edges,verts]];
tobj=MakeTGraph[verts,edges]//AddTPlaneGraphTo;
{faces,boundary}=GetValues[tobj,{Faces,BoundaryVertices}];
If[bo,
bedges=Join@@({#,Reverse/@#}&@Transpose[{boundary,RotateLeft[boundary]}]);(* all possible border edges *)
edgetypes=If[MemberQ[bedges,#[[1]]],B,#[[2]]]&/@Transpose[{edges,edgetypes}]
];
tobj//AddTAssigned[edgetypes]
]
Module[{cp,tobj,pg,cp1},
cp=CreasePatternGraphics[pgtobj];
tobj=CreasePatternToPlaneGraphAssigned[cp];
pg=GraphGraphics[tobj];
cp1=CreasePatternGraphics[tobj,PaperFill->PaperColoredSideFill];
GraphicsRow[{cp,pg,cp1}]/.OrigamiStyle[]
]//ShowExample
CreasePatternToGraph2DAssigned[cp_, opts___]:=Module[{tobj},
tobj=CreasePatternToPlaneGraphAssigned[cp,opts];
FoldGraph2D[tobj,TypeToFlatFoldAngle[tobj[EdgeTypes]],opts]]
Module[{cp,tobj},
cp=Graphics[{Style[Line[{{59.244, 11.934}, {128.40800000000002, 46.521}}], ValleyLine], Style[Line[{{59.375, 12.068}, {48.648, 1.3453}}], ValleyLine], Style[Line[{{128.412, 46.524}, {63.878, 89.13}}], ValleyLine], Style[Line[{{128.231, 46.571}, {155.678, 39.212}}], ValleyLine], Style[Line[{{63.872, 89.13199999999999}, {59.242000000000004, 11.940999999999999}}], ValleyLine], Style[Line[{{63.922000000000004, 88.952}, {60., 103.603}}], ValleyLine], Style[Line[{{160.312, 116.40700000000001}, {91.14800000000001, 81.822}}], MountainLine], Style[Line[{{160.181, 116.27400000000002}, {170.90800000000002, 126.99600000000001}}], MountainLine], Style[Line[{{91.144, 81.81800000000001}, {155.678, 39.21200000000001}}], MountainLine], Style[Line[{{91.325, 81.77100000000002}, {63.879000000000005, 89.13000000000001}}], MountainLine], Style[Line[{{155.684, 39.210000000000015}, {160.314, 116.4}}], MountainLine], Style[Line[{{155.634, 39.38900000000002}, {159.55599999999998, 24.738000000000017}}], MountainLine], Style[Line[{{0.83743, 1.2787}, {48.24343, 1.2665}}], BorderLine], Style[Line[{{48.27543, 1.2665}, {82.99943, 1.2562}}], BorderLine], Style[Line[{{83.01543000000001, 1.2562}, {145.91843, 1.2403}}], BorderLine], Style[Line[{{0.8374300000000261, 1.2787}, {42.38743000000002, 73.27170000000001}}], BorderLine], Style[Line[{{42.41843000000002, 73.27170000000001}, {59.87043000000002, 103.5417}}], BorderLine], Style[Line[{{59.88543000000002, 103.5417}, {73.40643000000001, 126.99870000000001}}], BorderLine], Style[Line[{{135.76343, 126.99870000000001}, {73.40643, 126.99870000000001}}], BorderLine], Style[Line[{{218.608, 126.998}, {170.499, 126.998}}], BorderLine], Style[Line[{{170.515, 126.998}, {135.74899999999997, 126.99900000000001}}], BorderLine], Style[Line[{{218.592, 126.998}, {176.96, 54.87100000000001}}], BorderLine], Style[Line[{{176.991, 54.872}, {159.67200000000003, 24.898}}], BorderLine], Style[Line[{{159.68800000000002, 24.898}, {146.06300000000002, 1.3230000000000004}}], BorderLine], Style[Line[{{160.312, 116.405}, {176.76, 55.021}}], ValleyLine], Style[Line[{{91.144, 81.818}, {136.08, 126.755}}], ValleyLine], Style[Line[{{59.243, 11.936}, {42.795, 73.32}}], MountainLine], Style[Line[{{128.411, 46.522999999999996}, {83.475, 1.5859999999999985}}], MountainLine]}];
tobj=CreasePatternToGraph2DAssigned[cp,SamePtTolerance->5,StationaryFace->8];
GraphicsRow[{CreasePatternGraphics[tobj],VisibleFoldedFormGraphics[tobj,FaceupFace->8]}]/.OrigamiStyle[]
]//ShowExample
Options[BorderlessCreasePatternToPlaneGraphAssigned]={
	SamePtTolerance->10^-6
};
BorderlessCreasePatternToPlaneGraphAssigned::nostyle="The input pattern had no lines with style MountainLine or ValleyLine.";
BorderlessCreasePatternToPlaneGraphAssigned::nopolys="The input pattern had no styled polygons so no border could be computed.";
BorderlessCreasePatternToPlaneGraphAssigned::badborder="The computed border does not appear to be a single closed loop.";
BorderlessCreasePatternToPlaneGraphAssigned::badmerge="The number of merged edges doesn't match the number of merge vertices, possibly because a merge vertex is incident to both mountain and valley folds.";
BorderlessCreasePatternToPlaneGraphAssigned[blcp_,opts___]:=Module[{tol,mlines,vlines,spolys,verts,imlines,ivlines,ispolys,medges,vedges,bedges,border,d2vs,medges1,vedges1,medges2,vedges2,edges,edgetypes,vkeep,vmap},
tol=SamePtTolerance/.{opts}/.Options[BorderlessCreasePatternToPlaneGraphAssigned];
(* Start by extracting mountain and valley lines and polys. All else will be ignored. *)
mlines=Cases[blcp,Style[_Line,MountainLine],\[Infinity]];
vlines=Cases[blcp,Style[_Line,ValleyLine],\[Infinity]];
spolys=Cases[blcp,Style[_Polygon,___],\[Infinity]];
If[Length[mlines]+Length[vlines]==0,Message[BorderlessCreasePatternToPlaneGraphAssigned::nostyle];Abort[]];
If[Length[spolys]==0,Message[BorderlessCreasePatternToPlaneGraphAssigned::nopolys];Abort[]];
(* Indexify everything *)
{verts,{imlines,ivlines,ispolys}}=Indexify[{mlines,vlines,spolys},5,SamePtTolerance->tol];
medges=#[[1,1]]&/@imlines;(* index pairs for mountain lines *)
vedges=#[[1,1]]&/@ivlines;(* index pairs for valley lines *)
bedges=Flatten[Transpose[{#,RotateLeft[#]}]&/@(#[[1,1]]&/@ispolys),1];(* all possible polygon index pairs *)
bedges=First/@Select[Tally[bedges,#1==#2||#1==Reverse[#2]&],#[[2]]==1&];(* filter to edges with multiplicity 1 *)
If[Or@@(#[[2]]!=2&/@Tally[Flatten[bedges]]),Message[BorderlessCreasePatternToPlaneGraphAssigned::badborder];Abort[]];
(* get ordered list of border vertices. *)
border=GetValue[AddTPlaneGraphTo[MakeTGraph[verts,bedges]],BoundaryVertices];
(* find verts with multiplicity=2; those need to be merged *)
d2vs=First/@Select[Tally[Flatten[{medges,vedges}]],#[[2]]==2&];
medges1=Select[medges,!IntersectingQ[#,d2vs]&];(* don't need merging *)
vedges1=Select[vedges,!IntersectingQ[#,d2vs]&];(* don't need merging *)
medges2=Select[medges,IntersectingQ[#,d2vs]&];(* needs merging *)
medges2=Select[Function[i,Select[Flatten[Select[medges2,MemberQ[#,i]&]],#!=i&]]/@d2vs,NotListEmptyQ];(* merged *)
vedges2=Select[vedges,IntersectingQ[#,d2vs]&];(* needs merging *)
vedges2=Select[Function[i,Select[Flatten[Select[vedges2,MemberQ[#,i]&]],#!=i&]]/@d2vs,NotListEmptyQ];(* merged *)
If[Length[d2vs]!=Length[medges2]+Length[vedges2],Message[BorderlessCreasePatternToPlaneGraphAssigned::badmerge];Abort[]];
edges=Join[medges1,medges2,vedges1,vedges2,bedges];
edgetypes=Join[Table[M,{Length[medges1]+Length[medges2]}],Table[V,{Length[vedges1]+Length[vedges2]}],Table[B,{Length[bedges]}]];
(* we may still have orphan vertices that got merged out of the graph. So we need to
eliminate the orphan vertices and then renumber the indices in the edges appropriately. *)
vkeep=Union[Flatten[edges]];(* indices of vertices to keep *)
vmap=MapThread[Rule,{Join[vkeep,Table[0,{Length[verts]-Length[vkeep]}]],Range[Length[verts]]}];(* map from old vertex numbers to new ones *)
(* and finally we can rebuild the plane graph *)
MakeTGraph[verts[[vkeep]],edges/.vmap]//AddTPlaneGraphTo//AddTAssigned[edgetypes]
]
Module[{cp,tobj,cp1},
cp=Graphics[{{{Style[Polygon[{{0.48086077196920557`,0.2334249423165088`},{0.7665750576834912`,0.48086077196920557`},{0.5191392280307945`,0.7665750576834912`},{0.2334249423165088`,0.5191392280307945`}}],PaperWhiteSideFill],Style[Polygon[{{0.4`,0.`},{0.6`,0.`},{0.7665750576834912`,0.48086077196920557`},{0.48086077196920557`,0.2334249423165088`}}],PaperWhiteSideFill],Style[Polygon[{{1.`,0.4`},{1.`,0.6`},{0.5191392280307945`,0.7665750576834912`},{0.7665750576834912`,0.48086077196920557`}}],PaperWhiteSideFill],Style[Polygon[{{0.6`,1.`},{0.4`,1.`},{0.2334249423165088`,0.5191392280307945`},{0.5191392280307945`,0.7665750576834912`}}],PaperWhiteSideFill],Style[Polygon[{{0.`,0.6`},{0.`,0.4`},{0.48086077196920557`,0.2334249423165088`},{0.2334249423165088`,0.5191392280307945`}}],PaperWhiteSideFill],Style[Polygon[{{0.6`,0.`},{1.`,0.`},{1.`,0.4`},{0.7665750576834912`,0.48086077196920557`}}],PaperWhiteSideFill],Style[Polygon[{{1.`,0.6`},{1.`,1.`},{0.6`,1.`},{0.5191392280307945`,0.7665750576834912`}}],PaperWhiteSideFill],Style[Polygon[{{0.4`,1.`},{0.`,1.`},{0.`,0.6`},{0.2334249423165088`,0.5191392280307945`}}],PaperWhiteSideFill],Style[Polygon[{{0.`,0.4`},{0.`,0.`},{0.4`,0.`},{0.48086077196920557`,0.2334249423165088`}}],PaperWhiteSideFill]},{Style[Line[{{0.4`,0.`},{0.48086077196920557`,0.2334249423165088`}}],ValleyLine],Style[Line[{{0.48086077196920557`,0.2334249423165088`},{0.7665750576834912`,0.48086077196920557`}}],ValleyLine],Style[Line[{{0.7665750576834912`,0.48086077196920557`},{0.6`,0.`}}],MountainLine],Style[Line[{{1.`,0.4`},{0.7665750576834912`,0.48086077196920557`}}],ValleyLine],Style[Line[{{0.7665750576834912`,0.48086077196920557`},{0.5191392280307945`,0.7665750576834912`}}],ValleyLine],Style[Line[{{0.5191392280307945`,0.7665750576834912`},{1.`,0.6`}}],MountainLine],Style[Line[{{0.6`,1.`},{0.5191392280307945`,0.7665750576834912`}}],MountainLine],Style[Line[{{0.5191392280307945`,0.7665750576834912`},{0.2334249423165088`,0.5191392280307945`}}],MountainLine],Style[Line[{{0.2334249423165088`,0.5191392280307945`},{0.4`,1.`}}],ValleyLine],Style[Line[{{0.`,0.6`},{0.2334249423165088`,0.5191392280307945`}}],MountainLine],Style[Line[{{0.2334249423165088`,0.5191392280307945`},{0.48086077196920557`,0.2334249423165088`}}],MountainLine],Style[Line[{{0.48086077196920557`,0.2334249423165088`},{0.`,0.4`}}],ValleyLine]}},{{Style[Polygon[{{1.4808607719692055`,0.2334249423165088`},{1.7665750576834913`,0.48086077196920557`},{1.5191392280307945`,0.7665750576834912`},{1.2334249423165087`,0.5191392280307945`}}],PaperWhiteSideFill],Style[Polygon[{{1.4`,0.`},{1.6`,0.`},{1.7665750576834913`,0.48086077196920557`},{1.4808607719692055`,0.2334249423165088`}}],PaperWhiteSideFill],Style[Polygon[{{2.`,0.4`},{2.`,0.6`},{1.5191392280307945`,0.7665750576834912`},{1.7665750576834913`,0.48086077196920557`}}],PaperWhiteSideFill],Style[Polygon[{{1.6`,1.`},{1.4`,1.`},{1.2334249423165087`,0.5191392280307945`},{1.5191392280307945`,0.7665750576834912`}}],PaperWhiteSideFill],Style[Polygon[{{1.`,0.6`},{1.`,0.4`},{1.4808607719692055`,0.2334249423165088`},{1.2334249423165087`,0.5191392280307945`}}],PaperWhiteSideFill],Style[Polygon[{{1.6`,0.`},{2.`,0.`},{2.`,0.4`},{1.7665750576834913`,0.48086077196920557`}}],PaperWhiteSideFill],Style[Polygon[{{2.`,0.6`},{2.`,1.`},{1.6`,1.`},{1.5191392280307945`,0.7665750576834912`}}],PaperWhiteSideFill],Style[Polygon[{{1.4`,1.`},{1.`,1.`},{1.`,0.6`},{1.2334249423165087`,0.5191392280307945`}}],PaperWhiteSideFill],Style[Polygon[{{1.`,0.4`},{1.`,0.`},{1.4`,0.`},{1.4808607719692055`,0.2334249423165088`}}],PaperWhiteSideFill]},{Style[Line[{{1.4`,0.`},{1.4808607719692055`,0.2334249423165088`}}],ValleyLine],Style[Line[{{1.4808607719692055`,0.2334249423165088`},{1.7665750576834913`,0.48086077196920557`}}],ValleyLine],Style[Line[{{1.7665750576834913`,0.48086077196920557`},{1.6`,0.`}}],MountainLine],Style[Line[{{2.`,0.4`},{1.7665750576834913`,0.48086077196920557`}}],ValleyLine],Style[Line[{{1.7665750576834913`,0.48086077196920557`},{1.5191392280307945`,0.7665750576834912`}}],ValleyLine],Style[Line[{{1.5191392280307945`,0.7665750576834912`},{2.`,0.6`}}],MountainLine],Style[Line[{{1.6`,1.`},{1.5191392280307945`,0.7665750576834912`}}],MountainLine],Style[Line[{{1.5191392280307945`,0.7665750576834912`},{1.2334249423165087`,0.5191392280307945`}}],MountainLine],Style[Line[{{1.2334249423165087`,0.5191392280307945`},{1.4`,1.`}}],ValleyLine],Style[Line[{{1.`,0.6`},{1.2334249423165087`,0.5191392280307945`}}],MountainLine],Style[Line[{{1.2334249423165087`,0.5191392280307945`},{1.4808607719692055`,0.2334249423165088`}}],MountainLine],Style[Line[{{1.4808607719692055`,0.2334249423165088`},{1.`,0.4`}}],ValleyLine]}}}];
tobj=BorderlessCreasePatternToPlaneGraphAssigned[cp];
cp1=CreasePatternGraphics[tobj]/.OrigamiStyle[];
GraphicsGrid[{{cp},{cp1},{GraphGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
BorderlessCreasePatternToGraph2DAssigned[blcp_, opts___]:=Module[{tobj},
tobj=BorderlessCreasePatternToPlaneGraphAssigned[blcp];
FoldGraph2D[tobj,TypeToFlatFoldAngle[tobj[EdgeTypes]],opts]]
BorderlessTGraphAssignedToPlaneGraphAssigned[tobj_TObj]:=Module[{cp},
AssertClasses[tobj,{TGraph,TAssigned},BorderlessTGraphAssignedToPlaneGraphAssigned];
cp=CreasePatternGraphics[tobj];
BorderlessCreasePatternToPlaneGraphAssigned[cp]
]
Module[{verts,edges,types,faces,tobj,tobj1,g1,g2},
{verts,edges,types,faces}={{{0.`,0.`},{1.`,0.`},{0.9876883405951378`,0.15643446504023087`},{-0.3255681544571567`,0.9455185755993168`},{-0.42261826174069944`,-0.9063077870366499`},{0.7392394270225962`,0.6734426995189003`},{0.2475627213913862`,0.9688718692259007`},{-0.7986355100472929`,0.6018150231520482`},{-0.9986295347545738`,0.05233595624294425`},{-0.8571673007021123`,-0.5150380749100542`},{0.23061587074244025`,-0.9730448705798238`},{0.7844156649195757`,-0.62023549126826`}},{{1,2},{1,3},{1,4},{1,5}},{M,V,V,V},{{1,2,3},{1,3,6,7,4},{1,4,8,9,10,5},{1,5,11,12,2}}};
tobj=MakeTGraphAssigned[verts,edges,faces,types];
g1=CreasePatternGraphics[tobj];
tobj1=BorderlessTGraphAssignedToPlaneGraphAssigned[tobj];
g2=CreasePatternGraphics[tobj1];
(* g1 is what we started with; g2 is the result after we've added a border. *)
GraphicsGrid[{
{GraphGraphics[tobj],GraphGraphics[tobj1]},
{g1,g2}/.OrigamiStyle[]}]
]//ShowExample
Clear[SingleVertexGraph2DAssigned];
AddTGraphExample[SingleVertexGraph2DAssigned,Module[{tobj,types},
tobj=SingleVertexGraph2D//RebuildPlaneGraph;
types={V,M,V,V,B,B,B,B,B,B,B,B};
tobj//AddTAssigned[types]]];
Module[{tobj},
tobj=SingleVertexGraph2DAssigned;
GraphicsGrid[{
{GraphGraphics[tobj],Graph2DGraphics[tobj]},
{CreasePatternGraphics[tobj],VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Clear[RigidlyFoldableDuckGraph2DAssigned];
AddTGraphExample[RigidlyFoldableDuckGraph2DAssigned,Module[{tobj,types},
tobj=DuckGraph2D//RebuildPlaneGraph;
types={B,B,B,B,M,
B,B,V,V,B,
B,M,M,M,M,
M,M,M,B,V,
B,V,V,V,V,
V,V};
tobj//AddTAssigned[types]]] // Hold;
Module[{tobj},
tobj=RigidlyFoldableDuckGraph2DAssigned;
GraphicsGrid[{
{GraphGraphics[tobj],Graph2DGraphics[tobj]},
{CreasePatternGraphics[tobj],VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Clear[OutsideReversedDuckGraph2DAssigned];
AddTGraphExample[OutsideReversedDuckGraph2DAssigned,Module[{tobj,types},
tobj=DuckGraph2D//RebuildPlaneGraph;
types={B,B,B,B,V,
B,B,V,V,B,
B,V,V,V,V,
M,M,V,B,M,
B,V,V,M,V,
V,M};
tobj//AddTAssigned[types]]]//Hold;
Module[{tobj},
tobj=OutsideReversedDuckGraph2DAssigned;
GraphicsGrid[{
{GraphGraphics[tobj],Graph2DGraphics[tobj]},
{CreasePatternGraphics[tobj],GenericFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Clear[SquareTwist45MMMMGraph2DAssigned];
AddTGraphExample[SquareTwist45MMMMGraph2DAssigned,Module[{tobj,types},
tobj=SquareTwist45Graph2D;
types={B,B,B,B,V,
M,B,V,M,M,
B,M,M,B,M,
M,V,B,V,B,
M,B,B,B};
tobj//AddTAssigned[types]]];
Module[{tobj},
tobj=SquareTwist45MMMMGraph2DAssigned;
GraphicsGrid[{{GraphGraphics[tobj],Graph2DGraphics[tobj]},{CreasePatternGraphics[tobj],GenericFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Clear[SquareTwist45MMMVGraph2DAssigned];
AddTGraphExample[SquareTwist45MMMVGraph2DAssigned,Module[{tobj,types},
tobj=SquareTwist45Graph2D;
types={B,B,B,B,V,
M,B,V,M,M,
B,M,M,B,M,
V,M,B,V,B,
V,B,B,B};
tobj//AddTAssigned[types]]];
Module[{tobj},
tobj=SquareTwist45MMMVGraph2DAssigned;
GraphicsGrid[{{GraphGraphics[tobj],Graph2DGraphics[tobj]},{CreasePatternGraphics[tobj],GenericFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Clear[SquareTwist45MMVVGraph2DAssigned];
AddTGraphExample[SquareTwist45MMVVGraph2DAssigned,Module[{tobj,types},
tobj=SquareTwist45Graph2D;
types={B,B,B,B,V,
M,B,M,M,V,
B,M,V,B,M,
V,M,B,V,B,
V,B,B,B};
tobj//AddTAssigned[types]]];
Module[{tobj},
tobj=SquareTwist45MMVVGraph2DAssigned;
GraphicsGrid[{{GraphGraphics[tobj],Graph2DGraphics[tobj]},{CreasePatternGraphics[tobj],GenericFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Clear[SplitSquareTwist45MVMVGraph2DAssigned];
AddTGraphExample[SplitSquareTwist45MVMVGraph2DAssigned,Module[{tobj,types},
tobj=SplitSquareTwist45Graph2D;
types={B,B,B,B,V,
M,B,M,M,V,
B,V,V,B,V,
M,V,B,M,B,
M,B,B,B,V};
tobj//AddTAssigned[types]]];
Module[{tobj},
tobj=SplitSquareTwist45MVMVGraph2DAssigned;
GraphicsGrid[{{GraphGraphics[tobj],Graph2DGraphics[tobj]},{CreasePatternGraphics[tobj],GenericFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
TGraph3DAssigned::usage="TGraph3DAssigned is a TObj class that describes a crease-assigned graph with an alternate 3D embedding.";
RegisterTClass[TGraph3DAssigned,{TGraph3D,TAssigned}];
MakeTGraph3DAssigned[verts_List, edges_List,faces_List:{}, verts3d_List:{},foldangles_List:{}, types_List:{}]:=
MakeTGraph[verts,edges,faces]//AddTGraph3D[verts3d,foldangles]//AddTAssigned[types]//AddClass[TGraph3DAssigned]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph3DAssigned[verts,edges];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
Module[{verts,edges,types,verts3d,tobj},
verts={{0,0},{1,0},{1,1}};
edges={{1,2},{2,3},{3,1}};
types={M, V,U};
verts3d={{10,0,0},{11,0,0},{11,1,0}};
tobj=MakeTGraph3DAssigned[verts,edges,{},verts3d,{},types];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
FoldAngleCreasePatternGraphics[tobj_TObj, opts___]:=Module[{cp,elabels},
AssertClasses[tobj,{TGraph3D,TAssigned},FoldAngleCreasePatternGraphics];
cp=CreasePatternGraphics[tobj][[1]];
elabels=FoldAngleLabels[tobj,opts];
Graphics[{cp,elabels},FilterRules[{opts},Options[Graphics]]]]
Module[{verts,verts3d,edges,faces,types,foldangles,tobj},
verts={{0,0},{1,0},{2,0},{0,1},{1,1},{2,1}};
verts3d={{0,0,0},{1,0,0},{1,0,1},{0,1,0},{1,1,0},{1,1,1}};
edges={{1,2},{2,3},{1,4},{2,5},{3,6},{4,5},{5,6}};
types={B,B,B,V,B,B,B};
foldangles={0,0,0,90\[Degree],0,0,0};
faces={{1,2,5,4},{2,3,6,5}};
tobj=MakeTGraph2D[verts,edges,faces]//AddTGraph3D[verts3d,foldangles]//AddTAssigned[types];
FoldAngleCreasePatternGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
Module[{verts,verts3d,edges,faces,types,foldangles,tobj},
verts={{0,0},{1,0},{2,0},{3,0},{4,0},
{0,1},{1,1},{2,1},{3,1},{4,1}};
verts3d={{0,0,0},{1,0,0},{1,0,1},{2,0,1},{3,0,1},
{0,1,0},{1,1,0},{1,1,1},{2,1,1},{3,1,1}};
edges={{1,2},{2,3},{3,4},{4,5},
{1,6},{2,7},{3,8},{4,9},{5,10},
{6,7},{7,8},{8,9},{9,10}};
types={B,B,B,B,
B,V,M,U,B,
B,B,B,B};
foldangles={0,0,0,0,
0,90\[Degree],-90\[Degree],0,0,
0,0,0,0};
faces={{1,2,7,6},{2,3,8,7},{3,4,9,8},{4,5,10,9}};
tobj=MakeTGraph2D[verts,edges,faces]//AddTGraph3D[verts3d,foldangles]//AddTAssigned[types];
FoldAngleCreasePatternGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
LineRules::usage="LineRules is an option to FoldedFormLines3D that specifies how to render lines in the 3D form based on the line type.";
Options[FoldedFormLines3D]={
LineRules->TypeToVisibleFoldedFormStyleRules
};
FoldedFormLines3D[tobj_TObj,opts___]:=Module[{lr,verts3d,edges,types},
lr=LineRules/.{opts}/.Options[FoldedFormLines3D];
{verts3d,edges,types}=GetValues[tobj,{Vertices3D,Edges,EdgeTypes}];
MapThread[Style,{Line/@Embed[verts3d,edges],types}]/.lr]
Module[{verts, edges,types,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5},{1,-.5},{1,.5}};
edges={{1,2},{1,3},{1,4},{1,5},{5,6},{6,2},{2,7},{7,3},{3,4},{4,5}};
types={M,M,V,M,B,B,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTGraph3D[];(* unassigned *)
tobj2=MakeTGraphAssigned[verts,edges,{},types]//AddTGraph3D[]; (* assigned *)
Graphics3D[FoldedFormLines3D[tobj2]]/.OrigamiStyle[]
]//ShowExample
PaperOrientation::usage="PaperOrientation is an option to FoldedFormPolys3D that specifies which side of the paper faces up.";
WhiteUp::usage="WhiteUp is an option value for PaperOrientation that specifies to show the white side up.";
ColorUp::usage="ColorUp is an option value for PaperOrientation that specifies to show the colored side up.";
Options[FoldedFormPolys3D]={
PaperOrientation->WhiteUp
};
FoldedFormPolys3D[tobj_TObj,opts___]:=Module[{verts3d,faces,po},
{verts3d,faces}=GetValues[tobj,{Vertices3D,Faces}];
po=PaperOrientation/.{opts}/.Options[FoldedFormPolys3D];
Style[Polygon[verts3d[[If[po===WhiteUp,#,Reverse[#]]]]],Paper3DFill]&/@faces]
Module[{verts, edges,types,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5},{1,-.5},{1,.5}};
edges={{1,2},{1,3},{1,4},{1,5},{5,6},{6,2},{2,7},{7,3},{3,4},{4,5}};
types={M,M,V,M,B,B,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[];(* unassigned *)
tobj2=MakeTPlaneGraphAssigned[verts,edges,{},types]//AddTGraph3D[]; (* assigned *)
Print[GraphGraphics[tobj2]];
GraphicsRow[{
Graphics3D[FoldedFormPolys3D[tobj,PaperOrientation->WhiteUp]],Graphics3D[FoldedFormPolys3D[tobj2,PaperOrientation->ColorUp]]}]/.OrigamiStyle[]
]//ShowExample
Options[FoldedFormGraphics3D]=Options[FoldedFormPolys3D];
FoldedFormGraphics3D[tobj_TObj,opts___]:=Graphics3D[
{FoldedFormPolys3D[tobj,opts],
FoldedFormLines3D[tobj, opts]},FilterRules[{opts},Options[Graphics3D]]]
Module[{verts, edges,types,tobj,tobj1,tobj2},
verts={{0,0},{1,0},{-1,.5},{-1,0},{-1,-.5},{1,-.5},{1,.5}};
edges={{1,2},{1,3},{1,4},{1,5},{5,6},{6,2},{2,7},{7,3},{3,4},{4,5}};
types={M,M,V,M,B,B,B,B,B,B};
tobj=MakeTGraphAssigned[verts,edges]//AddTPlaneGraph//AddTGraph3D[];(* unassigned *)
tobj2=MakeTPlaneGraphAssigned[verts,edges,{},types]//AddTGraph3D[]; (* assigned *)
Print[GraphGraphics[tobj2]];
GraphicsRow[{
FoldedFormGraphics3D[tobj,PaperOrientation->ColorUp],FoldedFormGraphics3D[tobj2,LineRules->TypeToCreasePatternStyleRules,PaperOrientation->WhiteUp]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,verts3d,edges,faces,types,foldangles,tobj},
verts={{0,0},{1,0},{2,0},{3,0},{4,0},
{0,1},{1,1},{2,1},{3,1},{4,1}};
verts3d={{0,0,0},{1,0,0},{1,0,1},{2,0,1},{3,0,1},
{0,1,0},{1,1,0},{1,1,1},{2,1,1},{3,1,1}};
edges={{1,2},{2,3},{3,4},{4,5},
{1,6},{2,7},{3,8},{4,9},{5,10},
{6,7},{7,8},{8,9},{9,10}};
types={B,B,B,B,
B,V,M,U,B,
B,B,B,B};
foldangles={0,0,0,0,
0,90\[Degree],-90\[Degree],0,0,
0,0,0,0};
faces={{1,2,7,6},{2,3,8,7},{3,4,9,8},{4,5,10,9}};
tobj=MakeTGraph2D[verts,edges,faces]//AddTGraph3D[verts3d,foldangles]//AddTAssigned[types];
FoldedFormGraphics3D[tobj]/.OrigamiStyle[]
]//ShowExample
TweakFoldAnglesTo[tobj_TObj,types_List:{}]:=Module[{ty,fa,sfn},
AssertClass[tobj,TGraph3D,TweakFoldAnglesTo];
ty=If[ListEmptyQ[types],
AssertClass[tobj,TAssigned,TweakFoldAnglesTo];
GetValue[tobj,EdgeTypes],
types];
fa=GetValue[tobj,FoldAngles];
fa=MapThread[Switch[#1,V,Abs[#2],M,-Abs[#2],_,#2]&,{ty,fa}];
tobj//ReplaceProperty[FoldAngles->fa]
]
TweakFoldAngles[types_List:{}]:=TweakFoldAnglesTo[#,types]&
Module[{verts,edges,faces,verts3d,foldangles,types,tobj},
verts={{0,0},{2,0},{3,0},{5,0},{0,3},{2,3},{3,3},{5,3}};
edges={{1,2},{2,3},{3,4},{5,6},{6,7},{7,8},{1,5},{2,6},{3,7},{4,8}};
faces={{1,2,6,5},{2,3,7,6},{3,4,8,7}};
verts3d={{0,0,0},{2,0,0},{1,0,0},{3,0,0},{0,3,0},{2,3,0},{1,3,0},{3,3,0}};
foldangles={0,0,0,0,0,0,0,\[Pi],-\[Pi],0};
types={B,B,B,B,B,B,B,M,V,B};
tobj=MakeTGraph[verts,edges,faces]//AddTGraph3D[verts3d,foldangles]//AddTAssigned[types];
Print[GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]];
Print["fold angles (original) = ",tobj[FoldAngles]];
tobj=tobj//TweakFoldAngles[];
Print["fold angles (reassigned) = ",tobj[FoldAngles]];
]//ShowExample
Options[CreasePatternToGraph3DAssigned]={
SamePtTolerance->10^-6
};
CreasePatternToGraph3DAssigned::dupvert="The extracted edges `1` contain at least one edge with duplicate vertices `2`.";
CreasePatternToGraph3DAssigned[lines_List, stylemap_List, opts___]:=Module[{tol,styles,elist,eangles,edgetypes,verts,edges,tobj,faces,boundary,bedges},
tol=SamePtTolerance/.{opts}/.Options[CreasePatternToGraph3DAssigned];
elist=First/@lines;
eangles=Drop[#,1]&/@lines/.Style->List/.stylemap;
edgetypes=FoldAngleToType[eangles];
{verts,edges}=Indexify[First/@elist,2,SamePtTolerance->tol];
If[!Union[Length/@Union/@edges]==={2},Message[CreasePatternToGraph3DAssigned::dupvert,edges,verts]];
tobj=MakeTGraph[verts,edges]//AddTPlaneGraphTo;
{faces,boundary}=GetValues[tobj,{Faces,BoundaryVertices}];
bedges=Join@@({#,Reverse/@#}&@Transpose[{boundary,RotateLeft[boundary]}]);edgetypes=If[MemberQ[bedges,#[[1]]],B,#[[2]]]&/@Transpose[{edges,edgetypes}];
eangles=If[MemberQ[bedges,#[[1]]],0,#[[2]]]&/@Transpose[{edges,eangles}];
tobj//AddTAssigned[edgetypes]//AddTGraph3D[{},eangles]
]
Module[{cp,lines,styleargs,stylemap,tobj},
cp=Graphics[{
Style[Line[{{0,0},{1,0},{2,0},{3,0},{4,0},{4,1},{3,1},{2,1},{1,1},{0,1},{0,0}}],Black],
Style[Line[{{1,0},{1,1}}],Red,AbsoluteThickness[2]],
Style[Line[{{2,0},{2,1}}],Blue,AbsoluteThickness[2]],
Style[Line[{{3,0},{3,1}}],Blue,AbsoluteThickness[0.5]]
}];
Print[cp];
lines=ExtractFracturedStyledLines[cp];
styleargs=ExtractStyleArgs[lines,ShowSample->True];
stylemap=MapThread[Rule,{styleargs,{0,120\[Degree],-120\[Degree],-60\[Degree]}}];
tobj=CreasePatternToGraph3DAssigned[lines,stylemap]; 
(* note, Vertices3D and FoldAngles are initially inconsistent, but we can fold along the fold angles to make them consistent. *)
tobj=FoldGraph3D[tobj,tobj[FoldAngles]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{cp,tobj,verts3d},
cp=Graphics[{
Style[Line[{{0,0},{1,0}}],BorderLine],
Style[Line[{{1,0},{2,0}}],BorderLine],
Style[Line[{{2,0},{2,1}}],BorderLine],
Style[Line[{{2,1},{1,1}}],BorderLine],
Style[Line[{{1,1},{0,1}}],BorderLine],
Style[Line[{{0,1},{0,0}}],BorderLine],
Style[Line[{{1,0},{1,1}}],ValleyLine]}];
Print[cp/.OrigamiStyle[]];
tobj=CreasePatternToPlaneGraphAssigned[cp];
Print["vertices = ",tobj[Vertices]];
verts3d={{0,0,0},{1,0,0},{1,0,1},{1,1,1},{1,1,0},{0,1,0}};
tobj=tobj//AddTGraph3D[verts3d];
tobj=RecalcFoldAngles[tobj];
Print[FoldedFormGraphics3D[tobj]/.OrigamiStyle[]];
GetAllRules[tobj]//ColumnForm
]//ShowExample
Options[OrderMappingByVertices]={
SamePtTolerance->10^-6
};
OrderMappingByVertices::badlen="The length of `1` should match the number `2` of vertices.";
OrderMappingByVertices::notdist="The vertices of `1` do not map to distinct vertices of `2`.";
OrderMappingByVertices[tobj_TObj,vmap_List,opts___]:=Module[{tol,verts,vv,vi},
AssertClass[tobj,TGraph,OrderMappingByVertices];
tol=SamePtTolerance/.{opts}/.Options[OrderMappingByVertices];
verts=GetValue[tobj,Vertices];
If[Length[verts]!=Length[vmap],Message[OrderMappingByVertices::badlen,vmap,Length[verts]];Abort[]];
vv=First/@vmap;
vi=Indexify[verts,1,StartPoints->vv][[2]];
If[Length[Union[vi]]!=Length[verts],Message[OrderMappingByVertices::notdist,vmap,tobj];Abort[]];
(Last/@vmap)[[vi]]]
Module[{verts,edges,tobj,vmap},
verts={{0,0},{1,0},{2,0},{2,1},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,1},{2,5}};
tobj=MakeTGraph[verts,edges];
PrintThis[verts];
(* test on an intentionally scrambled mapping *)
vmap={{2,1}->{2,1,0},{2,0}->{2,0,0},{0,1}->{0,1,0},{1,1}->{1,1,0},{1,0}->{1,0,0},{0,0}->{0,0,0}};
OrderMappingByVertices[tobj,vmap]
]//ShowExample
ReassignGraph3D[tobj_TObj,opts___]:=Module[{tobj1,types,foldangles},
AssertClass[tobj,TGraph3D,ReassignGraph3D];
tobj1=tobj;
If[HasPropertyQ[tobj1,EdgeTypes],
types=GetValue[tobj1,EdgeTypes],
tobj1=tobj1//AddTAssigned[];types=GetValue[tobj1,EdgeTypes]];
If[!MemberQ[types,B],
If[!HasClassQ[tobj1,TPlaneGraph],
tobj1=tobj1//AddTPlaneGraph];
types=PlaneGraphTypes[tobj1];
tobj1=ReplacePropertyIn[tobj1,EdgeTypes->types]];
tobj1=tobj1//RecalcFoldAngles;
foldangles=GetValue[tobj1,FoldAngles];
ReassignGraphAssigned[tobj1,foldangles,opts]]
Module[{verts,edges,verts3d,tobj},
verts={{0,0},{1,0},{2,0},{0,1},{1,1},{2,1}};
edges={{1,2},{2,3},{1,4},{2,5},{3,6},{4,5},{5,6}};
verts3d={{0,0,0},{1,0,0},{1,0,1},{0,1,0},{1,1,0},{1,1,1}}//N;
tobj=MakeTGraph3D[verts,edges,{},verts3d];
tobj=tobj//ReassignGraph3D;
Print[GetValue[tobj,TClasses]];
GraphicsRow[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Graph2DAssignedToGraph3DAssigned[tobj_TObj]:=Module[{tobj1,foldangles},
AssertClasses[tobj,{TGraph2D,TAssigned},Graph2DAssignedToGraph3DAssigned];
tobj1=tobj//AddTGraph3D[];
foldangles=TypeToFlatFoldAngle/@tobj[EdgeTypes];
FoldGraph3D[tobj,foldangles]]
Module[{tobj},
tobj=RigidlyFoldableDuckGraph2DAssigned;
tobj=Graph2DAssignedToGraph3DAssigned[tobj];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Clear[SingleVertexGraph3DAssigned];
AddTGraphExample[SingleVertexGraph3DAssigned,Module[{verts,edges,faces,verts2d,verts3d,foldangles,types,tobj},
tobj=SingleVertexGraph//RebuildPlaneGraph;
verts3d={{0,0,0},{1,0,0},{1,1,0},{0,1,0},{-(1/2),1,-((\[Sqrt]3)/2)},{-(1/2),1/(\[Sqrt]3),-((\[Sqrt]3)/2)},{(1/8) (-5-\[Sqrt]3),(1/52) (-1+29 \[Sqrt]3),-(9/104) (-9+\[Sqrt]3)},{-(1/(\[Sqrt]3)),(2/13) (-1+3 \[Sqrt]3),Sin[2 ArcTan[1+2/(\[Sqrt]3)]]},{1,(2/13) (-1+3 \[Sqrt]3),Sin[2 ArcTan[1+2/(\[Sqrt]3)]]}}//N;
foldangles={2 ArcTan[1+2/(\[Sqrt]3)],-60 \[Degree],2 ArcTan[1+2/(\[Sqrt]3)],60 \[Degree],0,0,0,0,0,0,0,0}//N;
types={V,M,V,V,B,B,B,B,B,B,B,B};
tobj//AddTGraph3D[verts3d,foldangles]//AddTAssigned[types]]];
Module[{tobj},
tobj=SingleVertexGraph3DAssigned;
GraphicsGrid[{
{GraphGraphics[tobj],Graph3DGraphics3D[tobj]},
{FoldAngleCreasePatternGraphics[tobj,FoldAngleForm->FoldAngleDigits[2]],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]
}]
]//ShowExample
Clear[RigidlyFoldableDuckGraph3DAssigned];
AddTGraphExample[RigidlyFoldableDuckGraph3DAssigned,
Graph2DAssignedToGraph3DAssigned[RigidlyFoldableDuckGraph2DAssigned]]//Hold;
Module[{tobj},
tobj=RigidlyFoldableDuckGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
Clear[HexagonVertexGraph3DAssigned];
AddTGraphExample[HexagonVertexGraph3DAssigned,Module[{tobj,verts,edges,types,foldangles},
verts={{0,0},U[0.\[Degree]],U[60.\[Degree]],U[120.\[Degree]],U[180.\[Degree]],U[240.\[Degree]],U[300.\[Degree]]};
edges={{1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{2,3},{3,4},{4,5},{5,6},{6,7},{7,2}};
types={V,M,V,M,V,M,B,B,B,B,B,B};
foldangles={180.\[Degree],-60.\[Degree],180.\[Degree],-60.\[Degree],180.\[Degree],-60.\[Degree],0,0,0,0,0,0};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types]//AddTGraph3D[];
FoldGraph3D[tobj,foldangles]]];
Module[{tobj},
tobj=HexagonVertexGraph3DAssigned;
GraphicsRow[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
Clear[RandlettBirdGraph3DAssigned];AddTGraphExample[RandlettBirdGraph3DAssigned,Module[{tobj,faspecs,foldangles},
tobj=RandlettBirdGraphAssigned;
faspecs=MakeStdFoldAngleSpecs[tobj];
(* mostly folded *)
faspecs=faspecs/.{{1,90\[Degree]}->{1,170\[Degree]},{1,-90\[Degree]}->{1,-170\[Degree]}};
(* this is the "controlling" crease *)
faspecs[[13]]={\[Infinity],-90\[Degree]};
foldangles=MakeGraphFoldAngles[tobj,faspecs];
tobj=FoldGraph3D[tobj,foldangles,StationaryFace->13];
ReassignGraphAssigned[tobj,foldangles]]];
Module[{tobj},
tobj=RandlettBirdGraph3DAssigned;
GraphicsRow[{
FoldAngleCreasePatternGraphics[tobj,FoldAngleForm->FoldAngleDigits[1]],FoldedFormGraphics3D[tobj]
}]/.OrigamiStyle[]
]//ShowExample
ApplyMergeAssignedTo[tobj_TObj,tglist_List,mgdata_List]:=Module[{vlist,elist,ne,types,typelist,medges},
{vlist,elist}=mgdata;
ne=Length[tobj[Edges]];
(* Create EdgeTypes *)
types=Table[U,{ne}];
typelist=#[EdgeTypes]&/@tglist;
Do[MapThread[If[#1!=0,types[[#1]]=#2]&,{elist[[i]],typelist[[i]]}],{i,Length[tglist]}];
(* Reassign merged edges to U *)
medges=GetMergedEdges[elist];
(types[[#]]=U)&/@medges;
tobj//AddTAssigned[types]]
ApplyMergeAssigned[tglist_List,mgdata_List]:=ApplyMergeAssignedTo[#,tglist,mgdata]&;
MergeGraphAssigneds[tglist_List,opts___]:=Module[{mgdata,tobj},
AssertClasses[#,{TGraph,TAssigned},MergeGraphAssigneds]&/@tglist;
mgdata=MergeGraphsData[tglist,opts];
tobj=ApplyMergeTo[tglist,mgdata];
tobj//ApplyMergeAssigned[tglist,mgdata]]
Module[{verts1,edges1,types1,tobj1,verts2,edges2,types2,tobj2,tglist,vlist,elist,tobj},
verts1={{-1,0},{0,0},{0,1}};
edges1={{1,2},{2,3},{3,1}};
types1={B,B,B};
tobj1=MakeTGraphAssigned[verts1,edges1,{},types1]//AddTPlaneGraph;
verts2={{0,0},{1,1/2},{1,1},{0,1}};
edges2={{1,2},{2,3},{3,4},{4,1}};
types2={B,B,B,B};
tobj2=MakeTGraphAssigned[verts2,edges2,{},types2]//AddTPlaneGraph;
tglist={tobj1,tobj2};
tobj=MergeGraphAssigneds[tglist]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Merged"]
},{
CreasePatternGraphics[tobj1,PlotLabel->"Graph 1"],
CreasePatternGraphics[tobj2,PlotLabel->"Graph 2"],
CreasePatternGraphics[tobj,PlotLabel->"Merged"]
}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts1,edges1,types1,tobj1,verts2,edges2,types2,tobj2,tglist,vlist,elist,tobj},
verts1={{-1,0},{0,0},{0,1}};
edges1={{1,2},{2,3},{3,1}};
types1={B,B,B};
tobj1=MakeTGraphAssigned[verts1,edges1,{},types1]//AddTPlaneGraph;
verts2={{0,0},{1,1/2},{1,1},{0,1}};
edges2={{1,2},{2,3},{3,4},{4,1}};
types2={B,B,B,B};
tobj2=MakeTGraphAssigned[verts2,edges2,{},types2]//AddTPlaneGraph;
tglist={tobj1,tobj2};
tobj=MergeGraphAssigneds[tglist,KillMergedEdges->True]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Merged"]
},{
CreasePatternGraphics[tobj1,PlotLabel->"Graph 1"],
CreasePatternGraphics[tobj2,PlotLabel->"Graph 2"],
CreasePatternGraphics[tobj,PlotLabel->"Merged"]
}}]/.OrigamiStyle[]
]//ShowExample
ApplyMerge2DTo[tobj_TObj,tglist_List,mgdata_List]:=Module[{vlist,elist,verts2d,vertslist},
{vlist,elist}=mgdata;
(* Create Vertices2D from constituent graphs *)
verts2d=Table[{0,0},{Length[tobj[Vertices]]}];
vertslist=#[Vertices2D]&/@tglist;
Do[MapThread[If[#1!=0,verts2d[[#1]]=#2]&,{vlist[[i]],vertslist[[i]]}],{i,Length[tglist]}];
tobj//AddTGraph2D[verts2d]]
ApplyMerge2D[tglist_List,mgdata_List]:=ApplyMerge2DTo[#,tglist,mgdata]&;
MergeGraph2DAssigneds[tglist_List,opts___]:=Module[{mgdata,tobj},
AssertClasses[#,{TGraph,TGraph2D,TAssigned},MergeGraph2DAssigneds]&/@tglist;
mgdata=MergeGraphsData[tglist,opts];
tobj=ApplyMergeTo[tglist,mgdata];
tobj//ApplyMerge2D[tglist,mgdata]//ApplyMergeAssigned[tglist,mgdata]]
Module[{verts1,edges1,verts2d1,types1,tobj1,verts2,edges2,verts2d2,types2,tobj2,tglist,tobj},
verts1={{-1,0},{0,0},{0,1}};
edges1={{1,2},{2,3},{3,1}};
verts2d1=verts1;
types1={B,B,B};
tobj1=MakeTGraph2DAssigned[verts1,edges1,{},verts2d1,types1]//AddTPlaneGraph;
verts2={{0,0},{1,1/2},{1,1},{0,1}};
edges2={{1,2},{2,3},{3,4},{4,1}};
verts2d2=verts2;
types2={B,B,B,B};
tobj2=MakeTGraph2DAssigned[verts2,edges2,{},verts2d2,types2]//AddTPlaneGraph;
(* go *)
tglist={tobj1,tobj2};
tobj=MergeGraph2DAssigneds[tglist]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Merged"]
},{
CreasePatternGraphics[tobj1,PlotLabel->"Graph 1"],
CreasePatternGraphics[tobj2,PlotLabel->"Graph 2"],
CreasePatternGraphics[tobj,PlotLabel->"Merged"]
},{
GenericFoldedFormGraphics[tobj1,PlotLabel->"Graph 1"],
GenericFoldedFormGraphics[tobj2,PlotLabel->"Graph 2"],
GenericFoldedFormGraphics[tobj,PlotLabel->"Merged"]
}}]/.OrigamiStyle[]
]//ShowExample
ApplyMerge3DTo[tobj_TObj,tglist_List,mgdata_List]:=Module[{vlist,elist,verts3d,vertslist,angles,anglelist,medges},
{vlist,elist}=mgdata;
(* Create Vertices3D from subgraphs *)
verts3d=Table[{0,0},{Length[tobj[Vertices]]}];
vertslist=#[Vertices3D]&/@tglist;
Do[MapThread[If[#1!=0,verts3d[[#1]]=#2]&,{vlist[[i]],vertslist[[i]]}],{i,Length[tglist]}];
(* Create FoldAngles from subgraphs *)
angles=Table[0,{Length[tobj[Edges]]}];
anglelist=#[FoldAngles]&/@tglist;
Do[MapThread[If[#1!=0,angles[[#1]]=#2]&,{elist[[i]],anglelist[[i]]}],{i,Length[tglist]}];
(* Get merged edges and reassign their FoldAngle to 0. *)
medges=GetMergedEdges[elist];
(angles[[#]]=0)&/@medges;
(* And add the Vertices3D and EdgeTypes to the TGraph *)
tobj//AddTGraph3D[verts3d,angles]]
ApplyMerge3D[tglist_List,mgdata_List]:=ApplyMerge3DTo[#,tglist,mgdata]&;
MergeGraph3DAssigneds[tglist_List,opts___]:=Module[{mgdata,tobj},
AssertClasses[#,{TGraph,TGraph3D,TAssigned},MergeGraph3DAssigneds]&/@tglist;
mgdata=MergeGraphsData[tglist,opts];
tobj=ApplyMergeTo[tglist,mgdata];
tobj//ApplyMerge3D[tglist,mgdata]//ApplyMergeAssigned[tglist,mgdata]]
Module[{verts1,edges1,verts3d1,types1,tobj1,verts2,edges2,verts3d2,types2,tobj2,tglist,tobj},
verts1={{-1,0},{0,0},{0,1}};
edges1={{1,2},{2,3},{3,1}};
verts3d1=Append[#,0]&/@verts1;
types1={B,B,B};
tobj1=MakeTGraph3DAssigned[verts1,edges1,{},verts3d1,{},types1]//AddTPlaneGraph;
verts2={{0,0},{1,1/2},{1,1},{0,1}};
edges2={{1,2},{2,3},{3,4},{4,1}};
verts3d2=Append[#,0]&/@verts2;
types2={B,B,B,B};
tobj2=MakeTGraph3DAssigned[verts2,edges2,{},verts3d2,{},types2]//AddTPlaneGraph;
tglist={tobj1,tobj2};
tobj=MergeGraph3DAssigneds[tglist]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Merged"]
},{
FoldAngleCreasePatternGraphics[tobj1,PlotLabel->"Graph 1"],
FoldAngleCreasePatternGraphics[tobj2,PlotLabel->"Graph 2"],
FoldAngleCreasePatternGraphics[tobj,PlotLabel->"Merged"]
},{
FoldedFormGraphics3D[tobj1,PlotLabel->"Graph 1"],
FoldedFormGraphics3D[tobj2,PlotLabel->"Graph 2"],
FoldedFormGraphics3D[tobj,PlotLabel->"Merged"]
}}]/.OrigamiStyle[]
]//ShowExample
JoinGraphAssigneds[graphspecs_List,opts___]:=Module[{tglist},
tglist=JoinGraphsData[graphspecs];
MergeGraphAssigneds[tglist,opts]]
Module[{verts1,edges1,types1,tobj1,verts2,edges2,types2,tobj2,vlist,elist,tobj},
verts1={{0,0},{1,0},{.5,1}};
edges1={{1,2},{2,3},{3,1}};
types1={B,B,B};
tobj1=MakeTGraphAssigned[verts1,edges1,{},types1]//AddTPlaneGraph;
verts2={{0,0},{1,1/2},{1,1},{0,1}};
edges2={{1,2},{2,3},{3,4},{4,1}};
types2={B,B,B,B};
tobj2=MakeTGraphAssigned[verts2,edges2,{},types2]//AddTPlaneGraph;
tobj=JoinGraphAssigneds[{{tobj1,{}},{tobj2,{1,{2,3},{1,4}}}}]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Merged"]
},{
CreasePatternGraphics[tobj1,PlotLabel->"Graph 1"],
CreasePatternGraphics[tobj2,PlotLabel->"Graph 2"],
CreasePatternGraphics[tobj,PlotLabel->"Merged"]
}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts1,edges1,types1,tobj1,verts2,edges2,types2,tobj2,vlist,elist,tobj},
verts1={{0,0},{1,0},{.5,1}};
edges1={{1,2},{2,3},{3,1}};
types1={B,B,B};
tobj1=MakeTGraphAssigned[verts1,edges1,{},types1]//AddTPlaneGraph;
verts2={{0,0},{1,1/2},{1,1},{0,1}};
edges2={{1,2},{2,3},{3,4},{4,1}};
types2={B,B,B,B};
tobj2=MakeTGraphAssigned[verts2,edges2,{},types2]//AddTPlaneGraph;
tobj=JoinGraphAssigneds[{{tobj1,{}},{tobj2,{1,{2,3},{1,4}}}},KillMergedEdges->True]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Merged"]
},{
CreasePatternGraphics[tobj1,PlotLabel->"Graph 1"],
CreasePatternGraphics[tobj2,PlotLabel->"Graph 2"],
CreasePatternGraphics[tobj,PlotLabel->"Merged"]
}}]/.OrigamiStyle[]
]//ShowExample
JoinGraph2DAssigneds[graphspecs_List,opts___]:=Module[{tglist,i,j1,j2,k1,k2,vertsj,vertsk,rm,offset},
tglist=JoinGraphsData[graphspecs];
(* Find the transformed Vertex2D coordinates for each subgraph *)
Do[
{i,j1,j2,k1,k2}=Flatten[graphspecs[[l,2]]];
vertsj=tglist[[i]][Vertices2D];
vertsk=tglist[[l]][Vertices2D];
{rm,offset}=SimilarityPair2D[vertsk[[{k1,k2}]],vertsj[[{j1,j2}]]];
vertsk=(offset+rm . #)&/@vertsk;
tglist[[l]]=tglist[[l]]//ReplaceProperty[Vertices2D->vertsk];
,{l,2,Length[tglist]}];
MergeGraph2DAssigneds[tglist,opts]]
Module[{verts1,edges1,verts2d1,types1,tobj1,verts2,edges2,verts2d2,types2,tobj2,vlist,elist,tobj},
verts1={{0,0},{1,0},{.5,1}};
edges1={{1,2},{2,3},{3,1}};
verts2d1=verts1;
types1={B,B,B};
tobj1=MakeTGraph2DAssigned[verts1,edges1,{},verts2d1,types1]//AddTPlaneGraph;
verts2={{0,0},{1,1/2},{1,1},{0,1}};
edges2={{1,2},{2,3},{3,4},{4,1}};
verts2d2=verts2;
types2={B,B,B,B};
tobj2=MakeTGraph2DAssigned[verts2,edges2,{},verts2d2,types2]//AddTPlaneGraph;
tobj=JoinGraph2DAssigneds[{{tobj1,{}},{tobj2,{1,{2,3},{1,4}}}}]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Merged"]
},{
CreasePatternGraphics[tobj1,PlotLabel->"Graph 1 CP"],
CreasePatternGraphics[tobj2,PlotLabel->"Graph 2 CP"],
CreasePatternGraphics[tobj,PlotLabel->"Merged CP"]
},{
GenericFoldedFormGraphics[tobj1,PlotLabel->"Graph 1 FF"],
GenericFoldedFormGraphics[tobj2,PlotLabel->"Graph 2 FF"],
GenericFoldedFormGraphics[tobj,PlotLabel->"Merged FF"]
}}]/.OrigamiStyle[]
]//ShowExample
JoinGraph3DAssigneds::badspec="graphspec `1` has mismatched position information.";
JoinGraph3DAssigneds[graphspecs_List,opts___]:=Module[{gs,tglist,posinfo,i,j1,j2,j3,k1,k2,k3,vertsj,vertsk,rm,offset},
gs=Join[{graphspecs[[1]]},{#[[1]],{#[[2,1]],Take[#[[2,2]],2],Take[#[[2,3]],2]}}&/@Drop[graphspecs,1]];
tglist=JoinGraphsData[gs];
(* Construct transformed Vertex3D coordinates for each subgraph *)
Do[
posinfo=graphspecs[[l,2]];
If[Length[posinfo[[2]]]!=Length[posinfo[[3]]],Message[JoinGraph3DAssigneds::badspec,graphspecs[[l,2]]];Abort[]];
If[Length[posinfo[[2]]]==3,
(* match 3 vertices *)
{i,j1,j2,j3,k1,k2,k3}=Flatten[posinfo];
vertsj=tglist[[i]][Vertices3D];
vertsk=tglist[[l]][Vertices3D];
{rm,offset}=SimilarityPair3D[vertsk[[{k1,k2,k3}]],vertsj[[{j1,j2,j3}]]],
(* match 2 vertices, so do it in-plane *)
{i,j1,j2,k1,k2}=Flatten[posinfo];
vertsj=tglist[[i]][Vertices3D];
vertsk=tglist[[l]][Vertices3D];
(* get the in-plane similarity transformation *)
{rm,offset}=SimilarityPair2D[Drop[#,-1]&/@vertsk[[{k1,k2}]],Drop[#,-1]&/@vertsj[[{j1,j2}]]];
(* convert it to 3D *)
rm={Append[rm[[1]],0],Append[rm[[2]],0],{0,0,1}};
offset=Append[offset,vertsj[[k1,3]]-vertsk[[k1,3]]];
];
vertsk=(offset+rm . #)&/@vertsk;
tglist[[l]]=tglist[[l]]//ReplaceProperty[Vertices3D->vertsk];
,{l,2,Length[tglist]}];
MergeGraph3DAssigneds[tglist,opts]]
Module[{verts1,edges1,types1,verts3d1,angles1,tobj1,verts2,edges2,types2,verts3d2,angles2,tobj2,tobj},
verts1=verts2={{0,0},{1,0},{2,0},{0,1},{1,1},{2,1}};
edges1=edges2={{1,2},{2,3},{1,4},{2,5},{3,6},{4,5},{5,6}};
types1=types2={B,B,B,V,B,B,B};
verts3d1=verts3d2 = RotationYMatrix3D[45\[Degree]] . #&/@{{0,0,0},{1,0,0},{1,0,1},{0,1,0},{1,1,0},{1,1,1}};
angles1=angles2={0,0,0,90\[Degree],0,0,0};
(* To make life interesting, we'll offset and rotate Graph 2. *)
verts3d2= {.1,.2,.3}+RotationZMatrix3D[30.\[Degree]] . #&/@verts3d2;
tobj1=MakeTGraph3DAssigned[verts1,edges1,{},verts3d1,angles1,types1]//AddTPlaneGraph;
tobj2=MakeTGraph3DAssigned[verts2,edges2,{},verts3d2,angles2,types2]//AddTPlaneGraph;
(* Join graph 2 to graph 1 by aligning three pairs of points *)
tobj=JoinGraph3DAssigneds[{{tobj1,{}},{tobj2,{1,{4,5,6},{1,2,3}}}}]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Joined"]
},{
FoldAngleCreasePatternGraphics[tobj1,PlotLabel->"Graph 1 CP"],
FoldAngleCreasePatternGraphics[tobj2,PlotLabel->"Graph 2 CP"],
FoldAngleCreasePatternGraphics[tobj,PlotLabel->"Joined CP"]
},{
FoldedFormGraphics3D[tobj1,PlotLabel->"Graph 1 FF"],
FoldedFormGraphics3D[tobj2,PlotLabel->"Graph 2 FF"],
FoldedFormGraphics3D[tobj,PlotLabel->"Joined FF"]
}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts1,edges1,types1,verts3d1,angles1,tobj1,verts2,edges2,types2,verts3d2,angles2,tobj2,tobj},
verts1=verts2={{0,0},{1,0},{2,0},{0,1},{1,1},{2,1}};
edges1=edges2={{1,2},{2,3},{1,4},{2,5},{3,6},{4,5},{5,6}};
types1=types2={B,B,B,V,B,B,B};
verts3d1=verts3d2 = RotationYMatrix3D[45\[Degree]] . #&/@{{0,0,0},{1,0,0},{1,0,1},{0,1,0},{1,1,0},{1,1,1}};
angles1=angles2={0,0,0,90\[Degree],0,0,0};
(* To make life interesting, we'll offset and rotate Graph 2. *)
verts3d2= {.1,.2,.3}+RotationZMatrix3D[30.\[Degree]] . #&/@verts3d2;
tobj1=MakeTGraph3DAssigned[verts1,edges1,{},verts3d1,angles1,types1]//AddTPlaneGraph;
tobj2=MakeTGraph3DAssigned[verts2,edges2,{},verts3d2,angles2,types2]//AddTPlaneGraph;
(* Join graph 2 to graph 1 by aligning a pair of points, so use
xy-plane rotation/repositioning of the pair. *)
tobj=JoinGraph3DAssigneds[{{tobj1,{}},{tobj2,{1,{4,5},{1,2}}}}]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj1,PlotLabel->"Graph 1"],
GraphGraphics[tobj2,PlotLabel->"Graph 2"],
GraphGraphics[tobj,PlotLabel->"Joined"]
},{
FoldAngleCreasePatternGraphics[tobj1,PlotLabel->"Graph 1 CP"],
FoldAngleCreasePatternGraphics[tobj2,PlotLabel->"Graph 2 CP"],
FoldAngleCreasePatternGraphics[tobj,PlotLabel->"Joined CP"]
},{
FoldedFormGraphics3D[tobj1,PlotLabel->"Graph 1 FF"],
FoldedFormGraphics3D[tobj2,PlotLabel->"Graph 2 FF"],
FoldedFormGraphics3D[tobj,PlotLabel->"Joined FF"]
}}]/.OrigamiStyle[]
]//ShowExample
ApplyCollinearCleanupAssignedTo[tobj_TObj,ccdata_List]:=Module[{elist,types,ntypes},
elist=ccdata[[2]];
types=tobj[EdgeTypes];
ntypes=types[[#[[1]]]]&/@elist;
tobj//ReplaceProperty[EdgeTypes->ntypes]]
ApplyCollinearCleanupAssigned[ccdata_List]:=ApplyCollinearCleanupAssignedTo[#,ccdata]&;
Module[{verts,edges,types,tobj,ccdata,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
types={B,B,B,B,V,V,M,M,B,B,B,B};
tobj=MakeTGraphAssigned[verts,edges,{},types];
ccdata=CollinearCleanupData[tobj];
Print["vlist = ",ccdata[[1]]];
Print["elist = ",ccdata[[2]]];
tobj1=tobj//ApplyCollinearCleanup[ccdata]//ApplyCollinearCleanupAssigned[ccdata];
GraphicsGrid[{{
GraphGraphics[tobj],CreasePatternGraphics[tobj]},
{GraphGraphics[tobj1],CreasePatternGraphics[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
CollinearCleanupGraphAssigned[tobj_TObj,opts___]:=Module[{ccdata},
ccdata=CollinearCleanupData[tobj,opts];
tobj//ApplyCollinearCleanup[ccdata]//ApplyCollinearCleanupAssigned[ccdata]]
Module[{verts,edges,types,tobj,ccdata,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
types={B,B,B,B,V,V,M,M,B,B,B,B};
tobj=MakeTGraphAssigned[verts,edges,{},types];
ccdata=CollinearCleanupData[tobj];
Print["vlist = ",ccdata[[1]]];
Print["elist = ",ccdata[[2]]];
tobj1=CollinearCleanupGraphAssigned[tobj];
GraphicsGrid[{{
GraphGraphics[tobj],CreasePatternGraphics[tobj]},
{GraphGraphics[tobj1],CreasePatternGraphics[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
ApplyCollinearCleanup2DTo[tobj_TObj,ccdata_List]:=Module[{vlist,verts2d,nverts2d},
vlist=ccdata[[1]];
verts2d=tobj[Vertices2D];
nverts2d=verts2d[[#]]&/@vlist;
tobj//ReplaceProperty[Vertices2D->nverts2d]]
ApplyCollinearCleanup2D[ccdata_List]:=ApplyCollinearCleanup2DTo[#,ccdata]&;
Module[{verts,edges,types,verts2d,tobj,ccdata,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
types={B,B,B,B,V,V,M,M,B,B,B,B};
verts2d=verts;
tobj=MakeTGraph2D[verts,edges,{},verts2d];
ccdata=CollinearCleanupData[tobj];
Print["vlist = ",ccdata[[1]]];
Print["elist = ",ccdata[[2]]];
tobj1=tobj//ApplyCollinearCleanup[ccdata]//ApplyCollinearCleanup2D[ccdata];
GraphicsGrid[{{
GraphGraphics[tobj],Graph2DGraphics[tobj]},
{GraphGraphics[tobj1],Graph2DGraphics[tobj1]}}]
]//ShowExample
CollinearCleanupGraph2DAssigned[tobj_TObj,opts___]:=Module[{ccdata},
ccdata=CollinearCleanupData[tobj,opts];
tobj//ApplyCollinearCleanup[ccdata]//ApplyCollinearCleanupAssigned[ccdata]//ApplyCollinearCleanup2D[ccdata]]
Module[{verts,edges,types,verts2d,tobj,ccdata,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
verts2d=verts;
types={B,B,B,B,V,V,M,M,B,B,B,B};
tobj=MakeTGraph2DAssigned[verts,edges,{},verts2d,types];
ccdata=CollinearCleanupData[tobj];
Print["vlist = ",ccdata[[1]]];
Print["elist = ",ccdata[[2]]];
tobj1=CollinearCleanupGraph2DAssigned[tobj];
GraphicsGrid[{{
GraphGraphics[tobj],CreasePatternGraphics[tobj],Graph2DGraphics[tobj]},
{GraphGraphics[tobj1],CreasePatternGraphics[tobj1],Graph2DGraphics[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
ApplyCollinearCleanup3DTo[tobj_TObj,ccdata_List]:=Module[{vlist,elist,verts3d,nverts3d,angles,nangles},
{vlist,elist}=ccdata;
{verts3d,angles}=GetValues[tobj,{Vertices3D,FoldAngles}];
nverts3d=verts3d[[#]]&/@vlist;
nangles=angles[[#[[1]]]]&/@elist;
tobj//ReplaceProperties[{Vertices3D->nverts3d,FoldAngles->nangles}]]
ApplyCollinearCleanup3D[ccdata_List]:=ApplyCollinearCleanup3DTo[#,ccdata]&;
Module[{verts,edges,types,verts3d,angles,tobj,ccdata,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
types={B,B,B,B,V,V,M,M,B,B,B,B};
verts3d=Append[#,0]&/@verts;
angles=TypeToFlatFoldAngle[types];
tobj=MakeTGraph3D[verts,edges,{},verts3d,angles];
ccdata=CollinearCleanupData[tobj];
Print["vlist = ",ccdata[[1]]];
Print["elist = ",ccdata[[2]]];
tobj1=tobj//ApplyCollinearCleanup[ccdata]//ApplyCollinearCleanup3D[ccdata];
GraphicsGrid[{{
GraphGraphics[tobj],Graph3DGraphics3D[tobj]},
{GraphGraphics[tobj1],Graph3DGraphics3D[tobj1]}}]
]//ShowExample
CollinearCleanupGraph3DAssigned[tobj_TObj,opts___]:=Module[{ccdata},
ccdata=CollinearCleanupData[tobj,opts];
tobj//ApplyCollinearCleanup[ccdata]//ApplyCollinearCleanupAssigned[ccdata]//ApplyCollinearCleanup3D[ccdata]]
Module[{verts,edges,types,verts3d,angles,tobj,ccdata,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{1,.5},{2,1.5},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{1,7},{2,5},{5,8},{3,6},{6,9},{4,10},{7,8},{8,9},{9,10}};
verts3d=Append[#,0]&/@verts;
types={B,B,B,B,V,V,M,M,B,B,B,B};
angles=TypeToFlatFoldAngle[types];
tobj=MakeTGraph3DAssigned[verts,edges,{},verts3d,angles,types];
ccdata=CollinearCleanupData[tobj];
Print["vlist = ",ccdata[[1]]];
Print["elist = ",ccdata[[2]]];
tobj1=CollinearCleanupGraph3DAssigned[tobj];
GraphicsGrid[{{
GraphGraphics[tobj],CreasePatternGraphics[tobj],Graph3DGraphics3D[tobj]},
{GraphGraphics[tobj1],CreasePatternGraphics[tobj1],Graph3DGraphics3D[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
TTriangulated::usage=
"TTriangulated is a TObj class that describes a TGraph that has been triangulated.";
RegisterTClass[TTriangulated];
TriangulationEdges::usage="TriangulationEdges is a property of TTriangulated that specifies the edges in a TGraph that came from a triangulation.";
TriangulateGraph[tobj_TObj]:=Module[{verts,edges,faces,nedges,neo,nne,face,tobj1,foldangles,types},
AssertClass[tobj,TGraph,TriangulateGraph];
{verts,edges,faces}=GetValues[tobj,{Vertices,Edges,Faces}];
neo=Length[edges];
tobj1=tobj;
{nedges,faces}=TriangulatePolygons[verts,faces];
nne=Length[nedges];
JoinTo[edges,nedges];
tobj1=tobj//ReplaceProperty[Edges->edges]//RebuildPlaneGraph;
If[HasClassQ[tobj1,TGraph3D],
foldangles=Join[GetValue[tobj1,FoldAngles],Table[0,{nne}]];
tobj1=tobj1//ReplaceProperty[FoldAngles->foldangles]];
If[HasClassQ[tobj,TAssigned],
types=Join[GetValue[tobj1,EdgeTypes],Table[U,{nne}]];
tobj1=tobj1//ReplaceProperty[EdgeTypes->types]];
AddClassTo[tobj1,TTriangulated,{TriangulationEdges->Table[i,{i,neo+1,neo+nne}]}]]
Module[{tobj,te},
tobj=DuckGraph2D;
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]//Print;
tobj=TriangulateGraph[tobj];
te=GetValue[tobj,TriangulationEdges];
Print["TriangulationEdges = ",te];
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
CheckVertexAgainstAssignment[v_,p1_,p2_,p3_,p4_]:=With[{
(*
a1=Rangle[v,p1,p2],
a2=Rangle[v,p2,p3],
a3=Rangle[v,p3,p4],
a4=Rangle[v,p4,p1]
*)
a1=RotationAngle[p1-v,p2-v],
a2=RotationAngle[p2-v,p3-v],
a3=RotationAngle[p3-v,p4-v],
a4=RotationAngle[p4-v,p1-v]
},
{Min[a1,a4]<=Min[a2,a3],a1,a2,a3,a4}]
Module[{v,p1,p2,p3,p4},
v={0,0};
p1={1,0};
p2={1,1};
p3={-1,0};
p4={1,-1};
Print[Graphics[{
Style[{Line[{v,p1}]},Red],
Style[{Line[{v,p2}],Line[{v,p3}],Line[{v,p4}]},Blue]}]];
CheckVertexAgainstAssignment[v,p1,p2,p3,p4]
]//ShowExample

Module[{v,p1,p2,p3,p4},
v={0,0};
p1={1,0};
p2={-1,1};
p3={-1,0};
p4={-1,-1};
Print[Graphics[{
Style[{Line[{v,p1}]},Red],
Style[{Line[{v,p2}],Line[{v,p3}],Line[{v,p4}]},Blue]}]];
CheckVertexAgainstAssignment[v,p1,p2,p3,p4]
]//ShowExample

TLFFGraph::usage="TLFFGraph is a TObj class that specifies a local flat-foldability graph.";
RegisterTClass[TLFFGraph,{TPlaneGraph}];
LFFEdgeTypes::usage="LFFEdgeTypes is a TObj property that specifies the iso/anto parity (+1/-1) of an edge of an LFF graph.";
MakeTLFFGraph::badstars="The list of internal vertex adjacency, `1`, is not all degree-4.";
MakeTLFFGraph[tobj_TObj]:=Module[{verts,edges,faces,vva,boundary,everts,eedges,edgetypes,eind,ivva,star,alist,tobj1},
AssertClass[tobj,TPlaneGraph,MakeTLFFGraph];
{verts,edges,faces,vva,boundary}=GetValues[tobj,{Vertices,Edges,Faces,VertexVertexAdjacency,BoundaryVertices}];
everts=Plus@@verts[[#]]/2&/@edges;
eedges={};
edgetypes={};
(* need a lookup function that returns edge index from an index pair *)
Do[eind[edges[[i]]]=eind[Reverse[edges[[i]]]]=i,{i,Length[edges]}];
(* select the vertex adjacency stars that aren't on the boundary *)
ivva=Select[MapIndexed[{#2[[1]],#1}&,vva],!MemberQ[boundary,#[[1]]]&];
(* they better all be degree-4 *)
If[!And@@(Length[#[[2]]]==4&/@ivva),Message[MakeTLFFGraph::badstars,ivva];Abort[]];
Do[star=ivva[[i]];
(* Each element of alist describes a sector angle, consisting of the vertex index, indices of the 2 vertices that define the sector angle, and the value of the sector angle itself *)
alist=MapThread[{star[[1]],#1,#2,RotationAnglePositive[{verts[[star[[1]]]],verts[[#1]]},{verts[[star[[1]]]],verts[[#2]]}]/\[Degree]}&,{star[[2]],RotateLeft[star[[2]]]}];
alist=Sort[alist,Last[#1]<Last[#2]&];(* sort by sector angle, smallest first *)
If[alist[[1,4]]<alist[[2,4]],
(* add the anto sector edge *)
AppendTo[eedges,{eind[alist[[1]][[{1,2}]]],eind[alist[[1]][[{1,3}]]]}];AppendTo[edgetypes,-1];
(* add the iso sector edge *)
AppendTo[eedges,{eind[alist[[4]][[{1,2}]]],eind[alist[[4]][[{1,3}]]]}];AppendTo[edgetypes,+1]],
{i,Length[ivva]}];
tobj1=MakeTGraph[everts,eedges];
AddClassTo[tobj1,TLFFGraph,{LFFEdgeTypes->edgetypes}]
]
LFFGraphGraphics[tobj_TObj,opts___]:=Module[{everts,eedges,edgetypes},
{everts,eedges,edgetypes}=GetValues[tobj,{Vertices,Edges,LFFEdgeTypes}];
Graphics[{{AbsoluteThickness[2],MapThread[Style[Line[everts[[#1]]],If[#2==-1,Red,Blue]]&,{eedges,edgetypes}],AbsolutePointSize[4],Style[Point[#],Black]&/@everts}},FilterRules[{opts},Options[Graphics]]]]
Module[{verts,edges,tobj,everts,eedges,edgetypes,tobj1},
verts={{0,0},{1,0},{0.5,1}};
edges={{1,2},{2,3},{3,1}};
tobj=MakeTGraph[verts,edges];
everts={{0.5,0},{0.75,0.5},{0.25,0.5}};
eedges={{1,2},{2,3},{3,1}};
edgetypes={+1,-1,+1};
tobj1=TObj[{TClasses->{TLFFGraph},Vertices->everts,Edges->eedges,LFFEdgeTypes->edgetypes}];
Show[
GraphGraphics[tobj],
LFFGraphGraphics[tobj1]
]
]//ShowExample

Module[{verts,edges,tobj1,tobj2},
{verts,edges}={{{0.7305301909726896`,0.4741786746516021`},{0.6`,0.`},{1.`,0.4`},{0.5258213253483979`,0.7305301909726896`},{0.2694698090273105`,0.5258213253483979`},{0.4`,1.`},{0.`,0.6`},{0.4741786746516021`,0.2694698090273105`},{0.4`,0.`},{1.`,0.6`},{0.6`,1.`},{0.`,0.4`},{1.`,0.`},{1.`,1.`},{0.`,1.`},{0.`,0.`}},{{1,2},{3,1},{1,4},{5,6},{7,5},{5,8},{9,8},{8,1},{4,10},{11,4},{4,5},{8,12},{9,2},{3,10},{11,6},{7,12},{2,13},{13,3},{10,14},{14,11},{6,15},{15,7},{12,16},{16,9}}};
tobj1=MakeTPlaneGraph[verts,edges];
tobj2=MakeTLFFGraph[tobj1];
Print[Show[GraphGraphics[tobj1],LFFGraphGraphics[tobj2]]];
ColumnForm[GetAllRules[tobj2]]
]//ShowExample
LFFReduce[{any_List,slist_List}]:=Module[{n,ithis,iprev,inext,slistnew},
If[Length[slist]==0,Return[{{},{}}]];(* emptied out *)
If[Length[slist]==2,Return[{First/@slist,{}}]];(* final reduction *)
n=Length[slist];
ithis=0;
Do[
iprev=Mod[i-1,n,1];(* previous sector *)
inext=Mod[i+1,n,1];(* next sector *)
If[slist[[i,2]]<slist[[iprev,2]]&&slist[[i,2]]<slist[[inext,2]],ithis=i;Break[]],
{i,n}];(* find index of any BLB angle *)
If[ithis==0,Return[{{},slist}]];(* no BLBA found, so not further reducible *)
slistnew=slist;
(* replace old sector with a sector that has new angle *)
slistnew[[iprev]]={slist[[iprev,1]],slist[[iprev,2]]-slist[[ithis,2]]+slist[[inext,2]]};
(* drop the other two sectors, be careful of index order *)
slistnew=Drop[Drop[slistnew,{Max[ithis,inext]}],{Min[ithis,inext]}];
{{slist[[ithis,1]],slist[[inext,1]]},slistnew}
]
LFFReduce[{{},{{a,100},{b,20},{c,30},{d,40},{e,50},{f,120}}}]//ShowExample
LFFReduction::noteven="The vertex with sectors `1` is not of even degree.";
LFFReduction::notff="The vertex with sectors `1` is not flat foldable because it does not satisfy Kawasaki-Justin.";
LFFReduction[slist_List]:=Module[{angles},
If[Mod[Length[slist],2]!=0,Message[LFFReduction::noteven,slist];Abort[]];
angles=Last/@slist;
If[!Equal @@(Plus@@#&/@Transpose[Partition[angles,2]]),Message[LFFReduction::notff,angles];Abort[]];
Drop[FixedPointList[LFFReduce,{{},slist}],-1]
]
LFFReduction[{{a,100},{b,20},{c,30},{d,40},{e,50},{f,120}}]//ColumnForm//ShowExample
LFFReduction[{{a,60},{b,20},{c,30},{d,40},{e,50},{f,60},{g,40},{h,60}}]//ColumnForm//ShowExample
LFFReduction[{{a,60},{b,45},{c,40},{d,45},{e,40},{f,45},{g,40},{h,45}}]//ColumnForm//ShowExample
VertexRotateGraph3D[tobj,Take[Flatten[tobj[CornerIndices]],3]]//Hold;
TCornerIndices::usage="TCornerIndices is a TObj class that specifies a mesh of vertices that is arranged roughly rectangularly.";
RegisterTClass[TCornerIndices];
CornerIndices::usage="CornerIndices is a TObj property that specifies the four corners of a rectangular crease pattern grid.";
AddTCornerIndicesTo::badci="The corner indices `1` do not have the proper format to be CornerIndices.";
AddTCornerIndicesTo[tobj_TObj,ci_]:=Module[{},
AssertClass[tobj,TGraph,AddTCornerIndicesTo];
If[Head[ci]!=List||Dimensions[ci]!={2,2}||!(And@@(IntegerQ/@Flatten[ci])),Message[AddTCornerIndicesTo::badci];Abort[]];
AddClassTo[tobj,TCornerIndices,{CornerIndices->ci}]]
AddTCornerIndices[ci_]:=AddTCornerIndicesTo[#,ci]&
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,1}};
tobj=MakeTGraph[verts,edges]//AddTCornerIndices[{{1,2},{4,3}}];
ColumnForm[GetAllRules[tobj]]
]//ShowExample
VerticesFn::usage="VerticesFn is a option to MakeQuadMesh that returns the coordinates of the {i,j} vertex.";
Vertices3DFn::usage="Vertices3DFn is a option to MakeQuadMesh that returns the coordinates of the {i,j} vertex in 3D.";
HorizontalEdgeTypeFn::usage="HorizontalEdgeTypeFn is a option to MakeQuadMesh that returns the type to be assigned to the {i,j} horizontal edge.";
VerticalEdgeTypeFn::usage="HorizontalEdgeTypeFn is a option to MakeQuadMesh that returns the type to be assigned to the {i,j} vertical edge.";
HorizontalEdgeAngleFn::usage="HorizontalEdgeAngleFn is a option to MakeQuadMesh that returns the fold angle to be assigned to the {i,j} horizontal edge.";
VerticalEdgeAngleFn::usage="VerticalEdgeAngleFn is a option to MakeQuadMesh that returns the fold angle to be assigned to the {i,j} vertical edge.";
Options[MakeQuadMesh]={
VerticesFn->None,
Vertices3DFn->None,
HorizontalEdgeTypeFn->(U&),
VerticalEdgeTypeFn->(U&),
HorizontalEdgeAngleFn->(0&),
VerticalEdgeAngleFn->(0&),
BorderOverride->False,
SamePtTolerance->10^-6
};
MakeQuadMesh::badverts="At least one of VerticesFn and Vertices3DFn must be non-None in `1`.";
MakeQuadMesh[nh_, nv_, opts___]:=Module[{vfn,v3dfn,hetfn,vetfn,heafn,veafn,bo,spt,ivfn,iverts,si,verts,vifn,ne,edges,types,verts3d,angles},
vfn=VerticesFn/.{opts}/.Options[MakeQuadMesh];
v3dfn=Vertices3DFn/.{opts}/.Options[MakeQuadMesh];
hetfn=HorizontalEdgeTypeFn/.{opts}/.Options[MakeQuadMesh];
vetfn=VerticalEdgeTypeFn/.{opts}/.Options[MakeQuadMesh];
heafn=HorizontalEdgeAngleFn/.{opts}/.Options[MakeQuadMesh];
veafn=VerticalEdgeAngleFn/.{opts}/.Options[MakeQuadMesh];
bo=BorderOverride/.{opts}/.Options[MakeQuadMesh];
spt=SamePtTolerance/.{opts}/.Options[MakeQuadMesh];
verts=edges=types=verts3d=angles={};
(* which vertex function will be used for uniqueness tests *)
ivfn=Which[
!vfn===None,vfn,
!v3dfn===None,v3dfn,
True,Message[MakeQuadMesh::badverts,{opts}];Abort[]];
iverts={};
Do[
(* see if the point already exists *)
si=If[!spt===None,
Catch[MapIndexed[If[SamePtQ[ivfn[i,j],#1,SamePtTolerance->spt],Throw[#2[[1]]]]&,iverts];Throw[0]],0];
If[si==0,
(* it's a new point *)
AppendTo[iverts,ivfn[i,j]];
If[!vfn===None,AppendTo[verts,vfn[i,j]],AppendTo[verts,{i,j}]];
If[!v3dfn===None,AppendTo[verts3d,v3dfn[i,j]],AppendTo[verts3d,{i,j,0}]];
vifn[i,j]=Length[iverts],
(* it's a duplicate, so record the duplicate index *)
vifn[i,j]=si],{j,0,nv},{i,0,nh}];
(* ne[i,j] returns true if we should make a new edge from this vertex pair *)
ne[vi_,vj_]:=!((vi==vj)||MemberQ[edges,{vi,vj}]||MemberQ[edges,{vj,vi}]);
Do[(* horizontal edges *)
If[ne[vifn[i,j],vifn[i+1,j]],
AppendTo[edges,{vifn[i,j],vifn[i+1,j]}];AppendTo[types,If[bo&&(j==0||j==nv),B,hetfn[i,j]]];
AppendTo[angles,If[bo&&(j==0||j==nv),0,heafn[i,j]]];
],{j,0,nv},{i,0,nh-1}];
Do[(* vertical edges *)
If[ne[vifn[i,j],vifn[i,Mod[j+1,nv,1]]],
AppendTo[edges,{vifn[i,j],vifn[i,Mod[j+1,nv,1]]}];AppendTo[types,If[bo&&(i==0||i==nh),B,vetfn[i,j]]];
AppendTo[angles,If[bo&&(i==0||i==nh),0,veafn[i,j]]];
],{j,0,nv-1},{i,0,nh}];
MakeTGraph3DAssigned[verts,edges,{},verts3d,angles,types]//AddTCornerIndices[{{vifn[0,0],vifn[nh,0]},{vifn[0,nv],vifn[nh,nv]}}]]
Module[{nh,nv,vfn,tobj},
nh=3;
nv=3;
vfn[i_,j_]:={i,j};
tobj=MakeQuadMesh[nh,nv,VerticesFn->vfn];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj]/.OrigamiStyle[]}]
]//ShowExample
Module[{nh,nv,vfn,hetfn,vetfn,tobj},
nh=4;
nv=3;
vfn[i_,j_]:={2. i+If[EvenQ[j],-0.3,0], 3. j};
hetfn[i_,j_]:=If[EvenQ[i+j],M,V];
vetfn[i_,j_]:=If[EvenQ[i],V,M];
tobj=MakeQuadMesh[nh,nh,VerticesFn->vfn,HorizontalEdgeTypeFn->hetfn,VerticalEdgeTypeFn->vetfn,BorderOverride->True];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj]/.OrigamiStyle[]}]
]//ShowExample
Module[{nr,na,vfn,tobj},
nr=3;
na=5;
vfn[i_,j_]:=(i)U[2\[Pi] (j-1)/na];
tobj=MakeQuadMesh[nr,na,VerticesFn->vfn,SamePtTolerance->10^-6];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj]/.OrigamiStyle[]}]
]//ShowExample
HorizontalEdgeTypeFn::usage="HorizontalEdgeTypeFn is a option to MakeRectangularQuadMesh that returns the type to be assigned to the {i,j}\[Theta] horizontal edge.";
VerticalEdgeTypeFn::usage="HorizontalEdgeTypeFn is a option to MakeRectangularQuadMesh that returns the type to be assigned to the {i,j}\[Theta] vertical edge.";
Options[MakeRectangularQuadMesh]={
HorizontalEdgeTypeFn->(U&),
VerticalEdgeTypeFn->(U&),
BorderOverride->False
};
MakeRectangularQuadMesh[nh_, nv_, vfn_, opts___]:=Module[{hetfn,vetfn,bo,verts,edges,types,vifn},
hetfn=HorizontalEdgeTypeFn/.{opts}/.Options[MakeRectangularQuadMesh];
vetfn=VerticalEdgeTypeFn/.{opts}/.Options[MakeRectangularQuadMesh];
bo=BorderOverride/.{opts}/.Options[MakeRectangularQuadMesh];
verts=edges=types={};
Do[AppendTo[verts,vfn[i,j]];vifn[i,j]=Length[verts],{j,0,nv},{i,0,nh}];
Do[(* horizontal edges *)
AppendTo[edges,{vifn[i,j],vifn[i+1,j]}];AppendTo[types,If[bo&&(j==0||j==nv),B,hetfn[i,j]]],{j,0,nv},{i,0,nh-1}];
Do[(* vertical edges *)
AppendTo[edges,{vifn[i,j],vifn[i,Mod[j+1,nv,1]]}];AppendTo[types,If[bo&&(i==0||i==nh),B,vetfn[i,j]]],{j,0,nv-1},{i,0,nh}];
MakeTGraphAssigned[verts,edges,{},types]//AddTCornerIndices[{{1,nh+1},{(nh+1)nv+1,(nh+1)(nv+1)}}]
]
Module[{nw,nh,vfn,tobj},
nw=3;
nh=3;
vfn[i_,j_]:={i,j};
tobj=MakeRectangularQuadMesh[nw,nh,vfn];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj]/.OrigamiStyle[]}]
]//ShowExample
Module[{nw,nh,vfn,hetfn,vetfn,tobj},
nw=5;
nh=4;
vfn[i_,j_]:={2. i+If[EvenQ[j],-0.3,0], 3. j};
hetfn[i_,j_]:=If[EvenQ[i+j],M,V];
vetfn[i_,j_]:=If[EvenQ[i],V,M];
tobj=MakeRectangularQuadMesh[nw,nh,vfn,HorizontalEdgeTypeFn->hetfn,VerticalEdgeTypeFn->vetfn,BorderOverride->True];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj]/.OrigamiStyle[]}]
]//ShowExample
RadialEdgeFn::usage="RadialEdgeFn is a option to MakeRectangularQuadMesh that returns the type to be assigned to the {i,j}\[Theta] radial edge.";
AxialEdgeFn::usage="AxialEdgeFn is a option to MakeRectangularQuadMesh that returns the type to be assigned to the {i,j}\[Theta] axial edge.";
IncludeCenter::usage="IncludeCenter is an option to MakeRotationalMesh that specifies to include a central vertex in the grid.";
Options[MakeRotationalMesh]={
RadialEdgeFn->(U&),
AxialEdgeFn->(U&),
BorderOverride->False,
IncludeCenter->False
};
MakeRotationalMesh[nr_, na_, vfn_,opts___]:=Module[{ erfn,eafn,bo,ic,verts,edges,types,vifn},
erfn=RadialEdgeFn/.{opts}/.Options[MakeRotationalMesh];
eafn=AxialEdgeFn/.{opts}/.Options[MakeRotationalMesh];
bo=BorderOverride/.{opts}/.Options[MakeRotationalMesh];
ic=IncludeCenter/.{opts}/.Options[MakeRotationalMesh];
verts=edges=types={};
(* vifn is a lookup function that maps from {i,j} to index within verts *)
If[ic,AppendTo[verts,vfn[0,0]];vifn[0,_]=Length[verts]];
Do[AppendTo[verts,vfn[i,j]];vifn[i,j]=Length[verts],{j,na},{i,nr}];
(* radial edges *)
Do[AppendTo[edges,{vifn[i,j],vifn[i+1,j]}];AppendTo[types,erfn[i,j]],{j,na},{i,If[ic,0,1],nr-1}];
(* axial edges *)
Do[AppendTo[edges,{vifn[i,j],vifn[i,Mod[j+1,na,1]]}];AppendTo[types,If[i==nr&&bo,B,eafn[i,j]]],{j,na},{i,nr}];
MakeTGraphAssigned[verts,edges,{},types]
]
Module[{nr,na,vfn,tobj},
nr=4;
na=6;
vfn[i_,j_]:=(i)U[2\[Pi] (j-1)/na];
tobj=MakeRotationalMesh[nr,na,vfn];
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj]/.OrigamiStyle[]}]
]//ShowExample
Module[{nr,na,vfn,erfn,eafn,tobj},
nr=4;
na=6;
vfn[i_,j_]:=(i)U[2\[Pi] (j-1)/na];
erfn[i_,j_]:=M;
eafn[i_,j_]:=V;
tobj=MakeRotationalMesh[nr,na,vfn,RadialEdgeFn->erfn,AxialEdgeFn->eafn,IncludeCenter->True,BorderOverride->True];
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj]/.OrigamiStyle[]}]
]//ShowExample
DefaultMinimumEdgeLength::usage="DefaultMinimumEdgeLength is an option to RigidlyFoldableQuadMesh that specifies a default minimum edge length for all edges.";
MinimumEdgeLengths::usage="MinimumEdgeLengths is an option to RigidlyFoldableQuadMesh that lets you set a minimum edge length for specific edges.";
BaseFaces::usage="BaseFaces is an option to RigidlyFoldableQuadMesh that specifies a set of faces that should be in the same plane.";
Rectangular::usage="Rectangular is an option to RigidlyFoldableQuadMesh that specifies that the paper should be rectangular.";
CornerAngles::usage="CornerAngles is an option to RigidlyFoldableQuadMesh that specifies the corner angles for non-rectangular paper.";
AddPlaneGraph::usage="AddPlaneGraph is an option to RigidlyFoldableQuadMesh that specifies whether to construct the full plane graph for the pattern.";
PrintSectorsOnFail::usage="PrintSectorsOnFail is an option to RigidlyFoldableQuadMesh that specifies whether to print the sector angles if the optimization fails.";
Options[RigidlyFoldableQuadMesh]={
DefaultMinimumEdgeLength->1,
BaseFaces->{},
Rectangular->True,
CornerAngles->90\[Degree],
AddPlaneGraph->True,
PrintSectorsOnFail->False
};
RigidlyFoldableQuadMesh::badangles="Angles `1` and `2` have angles `3` in common.";
RigidlyFoldableQuadMesh::badlists="Lists `1` and `2` must have the same length.";
RigidlyFoldableQuadMesh[{\[Phi]b0_List,\[Gamma]b0_List},{\[Phi]l0_List,\[Gamma]l0_List},opts___]:=Module[{dmel,mels,bf,rect,ca,apg,psof,nh,nv,\[Gamma]c0,\[Phi]v,\[Phi]h,\[Gamma]h,\[Gamma]v,\[Gamma]b,\[Gamma]r,\[Gamma]t,\[Gamma]l,mjv,mbl,\[Alpha]3,\[Alpha]4,\[Alpha]1,\[Alpha]2,fh,fv,lh,lv,dbg,p,pp,uu,ddh,ddv,ff,veqns,melineqns,bfeqns,bfinds,bfineqns,caeqns,lvars,fhvars,fvvars,ltot,sys,soln,verts,verts3d,vifn,edges,types,angles,faces,tobj},
dmel=DefaultMinimumEdgeLength/.{opts}/.Options[RigidlyFoldableQuadMesh];
mels=MinimumEdgeLengths/.{opts}/.Options[RigidlyFoldableQuadMesh];
bf=BaseFaces/.{opts}/.Options[RigidlyFoldableQuadMesh];
rect=Rectangular/.{opts}/.Options[RigidlyFoldableQuadMesh];
ca=CornerAngles/.{opts}/.Options[RigidlyFoldableQuadMesh];
apg=AddPlaneGraph/.{opts}/.Options[RigidlyFoldableQuadMesh];
psof=PrintSectorsOnFail/.{opts}/.Options[RigidlyFoldableQuadMesh];
ca=If[Head[ca]===List,N[ca],Table[N[ca],{4}]];
nh=Length[\[Gamma]b0]+1;
nv=Length[\[Gamma]l0]+1;
(* Check list lengths *)
If[Length[\[Phi]b0]+1!=nh,Message[RigidlyFoldableQuadMesh::badlists,\[Gamma]b0,\[Phi]b0];Abort[]];
If[Length[\[Phi]l0]+1!=nv,Message[RigidlyFoldableQuadMesh::badlists,\[Gamma]l0,\[Phi]l0];Abort[]];
(* Check angles *)
\[Gamma]c0={};
Do[If[Abs[\[Gamma]b0[[i]]]==Abs[\[Gamma]l0[[j]]],AppendTo[\[Gamma]c0,Abs[\[Gamma]b0[[i]]]]],{i,nh-1},{j,nv-1}];
If[!ListEmptyQ[\[Gamma]c0],Message[RigidlyFoldableQuadMesh::badangles,\[Gamma]b0,\[Gamma]l0,Union[\[Gamma]c0]];Abort[]];
(* direction angles incremented along x-axis *)
Do[\[Phi]v[i,0]=N[\[Phi]b0[[i]]],{i,nh-1}];
(* direction angles incremented along y-axis *)
Do[\[Phi]h[0,j]=N[\[Phi]l0[[j]]],{j,nv-1}];
(* at each vertex, construct four fold angles around the vertex: right, top, left, bottom. Begin with the bottom and left edges, which come from initial conditions. *)
Do[\[Gamma]b[i,1]=N[\[Gamma]b0[[i]]],{i,nh-1}];
Do[\[Gamma]l[1,j]=N[\[Gamma]l0[[j]]],{j,nv-1}];
(* Now, for \[Phi]l vertices, construct remaining fold angles and whether the major angle is vertical or not. *)
Do[
(* mjv[i,j] is True if major is vertical *)
mjv[i,j]=Abs[\[Gamma]b[i,j]]>Abs[\[Gamma]l[i,j]];
(* set signs of fold angles around vertex *)
If[mjv[i,j],
\[Gamma]t[i,j]=\[Gamma]b[i,j];\[Gamma]r[i,j]=-\[Gamma]l[i,j],
\[Gamma]t[i,j]=-\[Gamma]b[i,j];\[Gamma]r[i,j]=\[Gamma]l[i,j]];
(* compute fold angle multipler at vertex *)
mbl[i,j]=Tan[\[Gamma]b[i,j]/2]/Tan[\[Gamma]l[i,j]/2];
(* compute 4 sector angles around the vertex *)
\[Alpha]1[i,j]=Mod[\[Phi]v[i,j-1]-\[Phi]h[i-1,j],2\[Pi]];
\[Alpha]3[i,j]=\[Pi]-\[Alpha]1[i,j];
If[mjv[i,j],
\[Alpha]2[i,j]=2 ArcCos[Abs[((1+mbl[i,j]) Cos[\[Alpha]1[i,j]/2])/(\[Sqrt](1+mbl[i,j]^2+2 mbl[i,j] Cos[\[Alpha]1[i,j]]))]];
\[Alpha]4[i,j]=\[Pi]-\[Alpha]2[i,j],
\[Alpha]4[i,j]=2 ArcCos[Abs[((1+mbl[i,j]) Cos[\[Alpha]1[i,j]/2])/(\[Sqrt](1+mbl[i,j]^2+2 mbl[i,j] Cos[\[Alpha]1[i,j]]))]];
\[Alpha]2[i,j]=\[Pi]-\[Alpha]4[i,j]];
(* use the 4 sector angles to compute outgoing directions *)
\[Phi]h[i,j]=\[Phi]v[i,j-1]-\[Pi]+\[Alpha]2[i,j];
\[Phi]v[i,j]=\[Phi]h[i,j]+\[Alpha]3[i,j];
(* set fold angles for vertices above and to the left *)
\[Gamma]b[i,j+1]=\[Gamma]t[i,j];
\[Gamma]l[i+1,j]=\[Gamma]r[i,j];
,{i,nh-1},{j,nv-1}];
(* set fold angles from one interior vertex to the next *)
Do[\[Gamma]h[i,j]=If[i==0,\[Gamma]l[i+1,j],\[Gamma]r[i,j]],{i,0,nh-1},{j,nv-1}];
Do[\[Gamma]v[i,j]=If[j==0,\[Gamma]b[i,j+1],\[Gamma]t[i,j]],{i,nh-1},{j,0,nv-1}];
(* Remaining fold angles (borders) have fold angle zero, for definiteness. *)
\[Gamma]h[_,_]:=0;
\[Gamma]v[_,_]:=0;
(* debugging function: make a plot of all information on a grid. q[i,j] should give the [i,j] grid point. *)
dbg[q_]:=Block[{rg=.20,ra=.14,rv=.07,Nf2=NumberForm[Chop[#//N],2]&,Nf4=NumberForm[Chop[#//N],4]&,eh,ev,fa},
eh[i_,j_]:=(q[i,j]+q[i+1,j])/2;(* horizontal edge midpoint *)
ev[i_,j_]:=(q[i,j]+q[i,j+1])/2;(* vertical edge midpoint *)
fa[i_,j_]:=(eh[i,j]+eh[i,j+1])/2;(* face centroid *)
Graphics[{
(* schematic grid *)
Style[{
Table[Line[Table[q[i,j],{j,0,nv}]],{i,0,nh}],
Table[Line[Table[q[i,j],{i,0,nh}]],{j,0,nv}]},Lighter[Red,.75]],
(* vertices *)
Style[Table[{
Text[ToString[""[i,j]],q[i,j]],
(*Text[p[i,j],q[i,j]+{0,-rv}],
Text[pp[i,j],q[i,j]+{0,-2rv}],
*){}},{i,0,nh},{j,0,nv}],Black],
(* fold angles on internal vertices *)
Style[Table[{
Text[ToString[\[Gamma]b[i,j]/\[Degree]//Nf4],q[i,j]+{0,-rg}],
Text[ToString[\[Gamma]r[i,j]/\[Degree]//Nf4],q[i,j]+{rg,0}],
Text[ToString[\[Gamma]t[i,j]/\[Degree]//Nf4],q[i,j]+{0,rg}],
Text[ToString[\[Gamma]l[i,j]/\[Degree]//Nf4],q[i,j]+{-rg,0}],
{}},{i,nh-1},{j,nv-1}],Gray],
(* sector angles on internal vertices*)
Style[Table[{
Text[ToString[\[Alpha]3[i,j]/\[Degree]//Nf4],q[i,j]+{ra,ra}],
Text[ToString[\[Alpha]4[i,j]/\[Degree]//Nf4],q[i,j]+{-ra,ra}],
Text[ToString[\[Alpha]1[i,j]/\[Degree]//Nf4],q[i,j]+{-ra,-ra}],
Text[ToString[\[Alpha]2[i,j]/\[Degree]//Nf4],q[i,j]+{ra,-ra}],
{}},{i,nh-1},{j,nv-1}],Red],
(* fold angle multipliers and major fold direction *)
Style[Table[{
Text[ToString[mbl[i,j]//Nf4],q[i,j]+{0,rv}],
Text[ToString[mjv[i,j]],q[i,j]+{0,-rv}],
{}},{i,nh-1},{j,nv-1}],Blue],
(* direction and fold angles on edges *)
Style[{
Table[{
Text[ToString[""[i,j]],eh[i,j]],
Text["\!\(\*SubscriptBox[\(\[Phi]\), \(h\)]\)="<>ToString[\[Phi]h[i,j]/\[Degree]//Nf4],eh[i,j]+{0,-rv}],
Text["\!\(\*SubscriptBox[\(\[Gamma]\), \(h\)]\)="<>ToString[\[Gamma]h[i,j]/\[Degree]//Nf4],eh[i,j]+{0,-2rv}],
Text["\!\(\*SubscriptBox[\(d\), \(h\)]\)="<>ToString[Nf2/@ddh[i,j]],eh[i,j]+{0,-3rv}],
{}},{i,0,nh-1},{j,0,nv}],
Table[{
Text[ToString[""[i,j]],ev[i,j]],
Text["\!\(\*SubscriptBox[\(\[Phi]\), \(v\)]\)="<>ToString[\[Phi]v[i,j]/\[Degree]//Nf4],ev[i,j]+{0,-rv}],
Text["\!\(\*SubscriptBox[\(\[Gamma]\), \(v\)]\)="<>ToString[\[Gamma]v[i,j]/\[Degree]//Nf4],ev[i,j]+{0,-2rv}],
Text["\!\(\*SubscriptBox[\(d\), \(v\)]\)="<>ToString[Nf2/@ddv[i,j]],ev[i,j]+{0,-3rv}],
{}},{i,0,nh},{j,0,nv-1}],
{}},Darker[Red]],
(* faces *)
Style[Table[{
Text[ToString[""[i,j]],fa[i,j]],
(*Text["u="<>ToString[Nf2/@uu[i,j]],fa[i,j]+{0,-rv}],
*){}},{i,0,nh-1},{j,0,nv-1}],Darker[Green]],
{}},Axes->False]];
(* Define \[Phi]h and \[Phi]v on boundary *)
If[rect,
(* rectangular, set to specific values *)
Do[\[Phi]h[i,0]=0,{i,0,nh-1}];(* bottom *)
Do[\[Phi]h[i,nv]=0,{i,0,nh-1}];(* top *)
Do[\[Phi]v[0,j]=90.\[Degree],{j,0,nv-1}];(* left *)
Do[\[Phi]v[nh,j]=90.\[Degree],{j,0,nv-1}],(* right *)
(* not rectangular, use variables fh and fv *)
Do[\[Phi]h[i,0]=fh[i,0],{i,0,nh-1}];(* bottom *)
Do[\[Phi]h[i,nv]=fh[i,nv],{i,0,nh-1}];(* top *)
Do[\[Phi]v[0,j]=fv[0,j],{j,0,nv-1}];(* left *)
Do[\[Phi]v[nh,j]=fv[nh,j],{j,0,nv-1}],(* right *)
];
dbg[{#1,#2}&]//Hold;
(* construct points of the CP *)
p[0,0]={0,0};
(* left side *)
Do[p[0,j]=p[0,j-1]+lv[0,j-1]U[\[Phi]v[0,j-1]],{j,nv}];
(* each row *)
Do[p[i,j]=p[i-1,j]+lh[i-1,j]U[\[Phi]h[i-1,j]],{i,nh},{j,0,nv}];
(* Direction vectors of the FF. Renormalize unit vectors at each step, otherwise numerical roundoff builds up for large arrays. *)
Do[
Which[
(* bottom edge, j\[Equal]0 *)
i==0&&j==0,
uu[0,0]={0,0,1};(* facet {0,0} is in x-y plane *)
ddv[1,0]={0,1,0};(* ddv[1,0] establishes overall orientation *)
ddh[0,1]=RotationMatrix3Du[\[Phi]h[0,1]-\[Phi]v[1,0],uu[0,0]] . ddv[1,0]//NormalizeReal;
(* back out the lower left corner boundary direction vectors *)
ddh[0,0]=RotationMatrix3Du[\[Phi]h[0,0]-\[Phi]v[1,0],uu[0,0]] . ddv[1,0]//NormalizeReal;
ddv[0,0]=RotationMatrix3Du[\[Phi]v[0,0]-\[Phi]h[0,1],uu[0,0]] . ddh[0,1]//NormalizeReal,
(* i>0 && *) j==0,
uu[i,0]=RotationMatrix3Du[-\[Gamma]v[i,0],ddv[i,0]] . uu[i-1,0]//NormalizeReal;
ddh[i,0]=RotationMatrix3Du[\[Phi]h[i,0]-\[Phi]v[i,0],uu[i,0]] . ddv[i,0]//NormalizeReal;
ddh[i,1]=RotationMatrix3Du[\[Phi]h[i,1]-\[Phi]v[i,0],uu[i,0]] . ddv[i,0]//NormalizeReal;
ddv[i+1,0]=RotationMatrix3Du[\[Phi]v[i+1,0]-\[Phi]h[i,1],uu[i,0]] . ddh[i,1]//NormalizeReal,
(* remaining rows, j>0 *)
i==0 (* && j>0 *),
uu[0,j]=RotationMatrix3Du[\[Gamma]h[0,j],ddh[0,j]] . uu[0,j-1]//NormalizeReal;
ddv[0,j]=RotationMatrix3Du[\[Phi]v[0,j]-\[Phi]h[0,j],uu[0,j]] . ddh[0,j]//NormalizeReal;
ddv[1,j]=RotationMatrix3Du[\[Phi]v[1,j]-\[Phi]h[0,j],uu[0,j]] . ddh[0,j]//NormalizeReal;
ddh[0,j+1]=RotationMatrix3Du[\[Phi]h[0,j+1]-\[Phi]v[1,j],uu[0,j]] . ddv[1,j]//NormalizeReal,
True ,(* i>0 && j>0 *)
uu[i,j]=RotationMatrix3Du[-\[Gamma]v[i,j],ddv[i,j]] . uu[i-1,j]//NormalizeReal;
ddv[i+1,j]=RotationMatrix3Du[\[Phi]v[i+1,j]-\[Phi]h[i,j],uu[i,j]] . ddh[i,j]//NormalizeReal;
ddh[i,j+1]=RotationMatrix3Du[\[Phi]h[i,j+1]-\[Phi]v[i,j],uu[i,j]] . ddv[i,j]//NormalizeReal
],{j,0,nv-1},{i,0,nh-1}];
dbg[{#1,#2}&]//Hold;
(* construct points of the FF *)
pp[0,0]={0,0,0};
(* left side *)
Do[pp[0,j]=pp[0,j-1]+lv[0,j-1]ddv[0,j-1],{j,nv}];
(* each row *)
Do[pp[i,j]=pp[i-1,j]+lh[i-1,j]ddh[i-1,j],{i,nh},{j,0,nv}];
(* face centroids *)
ff[i_,j_]:=(pp[i,j]+pp[i+1,j]+pp[i,j+1]+pp[i+1,j+1])/4;
(* length variables *)
lvars=Sort[Flatten[{
Table[lh[i,j],{i,0,nh-1},{j,0,nv}],
Table[lv[i,j],{i,0,nh},{j,0,nv-1}],
{}}]];
(* direction vector variables (not used if rectangular) *)
fhvars=Flatten[{
Table[fh[i,0],{i,0,nh-1}],(* bottom *)
Table[fh[i,nv],{i,0,nh-1}](* top *)
}];
fvvars=Flatten[{
Table[fv[0,j],{j,0,nv-1}],(* left *)
Table[fv[nh,j],{j,0,nv-1}](* right *)
}];
(* equations for vertical spacing between rows *)
veqns=Flatten[Table[#==0&/@(p[i,j]-(p[i,j-1]+lv[i,j-1]U[\[Phi]v[i,j-1]])),{i,nh},{j,nv}]];
(* minimum edge length constraints *)
melineqns={
Table[lh[i,j]>=dmel,{i,0,nh-1},{j,0,nv}],
Table[lv[i,j]>=dmel,{i,0,nh},{j,0,nv-1}],
{}};
Do[Module[{d,i,j,len},
{d,i,j,len}=mels[[k]];
melineqns[[d+1,i+1,j+1]]=If[d==0,lh[i,j],lv[i,j]]>=len],{k,Length[mels]}];
melineqns=Flatten[melineqns];
(* base face constraints, coplanarize base faces *)
bfeqns=Table[(ff@@bf[[i]]-ff@@bf[[1]]) . (uu@@bf[[1]])==0,{i,2,Length[bf]}];
(* get all vertex index pairs that are incident to a base face *)
bfinds=Flatten[{#,#+{1,0},#+{0,1},#+{1,1}}&/@bf,1];
(* construct inequality conditions on all vertices not incident to a base face *)
bfineqns=If[bf==={},{},Flatten[Table[If[!MemberQ[bfinds,{i,j}],(pp[i,j]-ff@@bf[[1]]) . (uu@@bf[[1]])>=0,{}],{i,0,nh},{j,0,nv}]]];
(* corner angle constraints *)
caeqns={
\[Phi]v[0,0]-\[Phi]h[0,0]==ca[[1]],
(\[Phi]h[nh-1,0]+\[Pi])-\[Phi]v[nh,0]==ca[[2]],
\[Phi]v[nh,nv-1]-\[Phi]h[nh-1,nv]==ca[[3]],
\[Phi]h[0,nv]-(\[Phi]v[0,nv-1]-\[Pi])==ca[[4]]
};
(* figure of merit: total edge length *)
ltot=Plus@@lvars;
(* Set up our system. Rectangular is simpler (in fact, it's an LP) so doesn't need initial conditions, but if the border direction angles are variables, it's nonlinear and so needs initial conditions. *)
sys=If[rect,
{Flatten[{ltot,veqns,bfeqns,melineqns,bfineqns}],lvars},
{Flatten[{ltot,veqns,bfeqns,caeqns,melineqns,bfineqns}],Join[{#,dmel}&/@lvars,{#,0}&/@fhvars,{#,90.\[Degree]}&/@fvvars]}
];
(* look for a solution. If none found, print some info and abort. *)
soln=Check[FindMinimum@@sys,
If[psof,
Print["Sector angles (\[Degree])"];
Do[Print[{i,j},":",{\[Alpha]1[i,j],\[Alpha]2[i,j],\[Alpha]3[i,j],\[Alpha]4[i,j]}/\[Degree]],{i,nh-1},{j,nv-1}]];
Abort[]];
(* Debugging, show pattern with CP points *)
dbg[p]/.soln[[2]]//Hold;
(* debugging of FF: show lines *)
Graphics3D[{
Table[Line[Table[pp[i,j],{i,0,nh}]],{j,0,nv}],
Table[Line[Table[pp[i,j],{j,0,nv}]],{i,0,nh}]}]/.soln[[2]]//Hold;
(* construct a TGraph3DAssigned to represent CP and FF together *)
tobj=MakeQuadMesh[nh,nv,
VerticesFn->(p[#1,#2]/.soln[[2]]&),
Vertices3DFn->(pp[#1,#2]/.soln[[2]]&),
HorizontalEdgeTypeFn->(If[#2==0||#2==nv,B,If[\[Gamma]h[#1,#2]>0,V,M]]&),
HorizontalEdgeAngleFn->\[Gamma]h,
VerticalEdgeTypeFn->(If[#1==0||#1==nh,B,If[\[Gamma]v[#1,#2]>0,V,M]]&),
VerticalEdgeAngleFn->\[Gamma]v,
BorderOverride->False,
opts];
If[apg,tobj//AddTPlaneGraph,tobj]]
Module[{x,\[Mu],gmn,gmj,\[Gamma]b,\[Gamma]l,\[Phi]b,\[Phi]l,tobj},
x=1;(* degree of foldedness *)
\[Mu]=2.0;(* fold angle multiplier for these sector angles *)
gmn=2ArcTan[x/\[Sqrt]\[Mu]];
gmj=2ArcTan[x \[Sqrt]\[Mu]];
\[Phi]l={30.\[Degree],30.\[Degree]};
\[Gamma]l={gmj,-gmj};
\[Phi]b={90.\[Degree],90.\[Degree]};
\[Gamma]b={-gmn,gmn};
tobj=RigidlyFoldableQuadMesh[{\[Phi]b,\[Gamma]b},{\[Phi]l,\[Gamma]l}];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{\[Gamma]b,\[Gamma]l,\[Phi]b,\[Phi]l,tobj},
\[Phi]b={90.\[Degree],90.\[Degree],90.\[Degree],90.\[Degree]};
\[Gamma]b={120.\[Degree],-120.\[Degree],-120.\[Degree],120.\[Degree]};
\[Phi]l={0.\[Degree],0.\[Degree],0.\[Degree],0.\[Degree]};
\[Gamma]l={90.\[Degree],-90.\[Degree],-90.\[Degree],90.\[Degree]};
tobj=RigidlyFoldableQuadMesh[{\[Phi]b,\[Gamma]b},{\[Phi]l,\[Gamma]l}];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{\[Gamma]b,\[Gamma]l,\[Phi]b,\[Phi]l,tobj},
\[Phi]b={90.\[Degree],90.\[Degree],90.\[Degree],90.\[Degree]};
\[Gamma]b={-120.\[Degree],120.\[Degree],-120.\[Degree],120.\[Degree]};
\[Phi]l={0.\[Degree],0.\[Degree],0.\[Degree],0.\[Degree]};
\[Gamma]l={90.\[Degree],-90.\[Degree],90.\[Degree],-90.\[Degree]};
tobj=RigidlyFoldableQuadMesh[{\[Phi]b,\[Gamma]b},{\[Phi]l,\[Gamma]l}];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{nb,d\[Gamma]b,\[Gamma]b,\[Gamma]l0,\[Gamma]l,\[Phi]b,\[Phi]l,tobj},
\[Gamma]l0=132.5\[Degree];
\[Gamma]l={\[Gamma]l0,-\[Gamma]l0,-\[Gamma]l0,\[Gamma]l0};
\[Phi]l=Table[0,{Length[\[Gamma]l]}];
nb=5;
d\[Gamma]b=2\[Pi]/nb;
\[Gamma]b=Join[{d\[Gamma]b (nb-2)/2},Table[-d\[Gamma]b,{nb-2}],{d\[Gamma]b (nb-2)/2}];
Print[N[\[Gamma]b/\[Degree]]];
\[Phi]b=Table[90.\[Degree],{Length[\[Gamma]b]}];
tobj=RigidlyFoldableQuadMesh[{\[Phi]b,\[Gamma]b},{\[Phi]l,\[Gamma]l},BaseFaces->{{0,0},{Length[\[Gamma]b],0}},MinimumEdgeLengths->{{1,6,2,0}}];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
RigidlyFoldableSingleVertexQuadMesh[{\[Phi]b0_,\[Gamma]b0_},{\[Phi]l0_,\[Gamma]l0_},opts___]:=RigidlyFoldableQuadMesh[{{\[Phi]b0},{\[Gamma]b0}},{{\[Phi]l0},{\[Gamma]l0}},opts]
Module[{\[Gamma]b,\[Gamma]l,\[Phi]b,\[Phi]l,tobj},
\[Gamma]l=135.\[Degree];
\[Phi]l=0.\[Degree];
\[Gamma]b=60.\[Degree];
\[Phi]b=90.\[Degree];
tobj=RigidlyFoldableSingleVertexQuadMesh[{\[Phi]b,\[Gamma]b},{\[Phi]l,\[Gamma]l}];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
BackPlaneFacet::usage="BackPlaneFacet is an option to BackPlaneGraphics that specifies the facet or vertex indices that the backplane should be coplanar with.";
BackPlaneTolerance::usage="BackPlaneTolerance is an option to BackPlaneGraphics that specifies the tolerance on border polygon vertices relative to the backplane.";
Options[BackPlaneGraphics]={
BackPlaneFacet->1,
BackPlaneTolerance->10^-6
};
BackPlaneGraphics::badfacet="Backplane vertex list `1` should have 3 entries.";
BackPlaneGraphics::badverts="Vertices `1` lie below the backplane facet `2`.";
BackPlaneGraphics::badpoly="The backplane `1` is not a valid polygon.";
BackPlaneGraphics[tobj_TObj,opts___]:=Module[{bpf,bpt,tobj1,bverts,verts3d,faces,f0,xx,yy,zz,p0,badverts,bpverts,gopts},
AssertClass[tobj,TGraph3D,BackPlaneGraphics];
bpf=BackPlaneFacet/.{opts}/.Options[BackPlaneGraphics];
bpt=BackPlaneTolerance/.{opts}/.Options[BackPlaneGraphics];
tobj1=If[HasClassQ[tobj,TPlaneGraph],tobj,tobj//AddTPlaneGraph];
{bverts,verts3d,faces}=GetValues[tobj1,{BoundaryVertices,Vertices3D,Faces}];
f0=If[Head[bpf]===List,
If[Length[bpf]!=3,Message[BackPlaneGraphics::badfacet,bpf];Abort[]];verts3d[[bpf]],Take[verts3d[[faces[[bpf]]]],3]];
zz=TriangleNormal3D@@f0;
xx=NormalizeReal[f0[[2]]-f0[[1]]];
yy=zz\[Cross]xx;
p0=f0[[1]];
(* Check to ensure that no vertices lie below the backplane face *)
badverts={};
MapIndexed[
If[(#1-p0) . zz<-bpt,AppendTo[badverts,#2[[1]]]]&,verts3d];
If[!ListEmptyQ[badverts],Message[BackPlaneGraphics::badverts,badverts,bpf];Abort[]];
(* build list of vertices of border polygon that are at that height, keeping only those vertices in the same plane. *)
bpverts={};
If[Abs[(#-p0) . zz]<=bpt,AppendTo[bpverts,{(#-p0) . xx,(#-p0) . yy}]]&/@verts3d[[bverts]];
(* check that we actually have a valid polygon *)
If[Length[bverts]<3||Abs[PolygonSignedArea2D[bverts]]<bpt,Message[BackPlaneGraphics::badpoly,bpverts];Abort[]];
(* return backplane. *)
gopts=Sequence@@FilterRules[{opts},Options[Graphics]];
Graphics[{Style[Line[AppendFirst[bpverts]],BorderLine]},Evaluate[gopts]]]
Module[{verts,edges,verts3d,tobj},
verts={{0,0},{1,0},{2,0},{3,-1},{4,0},{5,1},{6,1},
{6,2},{5,2},{4,3},{3,4},{2,3},{1,3},{0,3}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},
{1,14},{2,13},{3,12},{5,10},{6,9},{7,8},
{14,13},{13,12},{12,11},{11,10},{10,9},{9,8}};
verts3d={{0,0,0},{1,0,0},{1,0,1},{2,-1,1},{3,0,1},{3,1,0},{4,1,0},
{4,2,0},{3,2,0},{3,3,1},{2,4,1},{1,3,1},{1,3,0},{0,3,0}};
tobj=MakeTGraph3D[verts,edges,{},verts3d]//AddTAssigned[]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
FoldedFormGraphics3D[tobj,Axes->True],
BackPlaneGraphics[tobj,Axes->True]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,verts3d,tobj},
verts={{0,0},{1,0},{2,0},{3,-1},{4,0},{5,1},{6,1},
{6,2},{5,2},{4,3},{3,4},{2,3},{1,3},{0,3}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},
{1,14},{2,13},{3,12},{5,10},{6,9},{7,8},
{14,13},{13,12},{12,11},{11,10},{10,9},{9,8}};
verts3d={{0,0,0},{1,0,0},{1,0,1},{2,-1,1},{3,0,1},{3,1,0},{4,1,0},
{4,2,0},{3,2,0},{3,3,1},{2,4,1},{1,3,1},{1,3,0},{0,3,0}};
tobj=MakeTGraph3D[verts,edges,{},verts3d]//AddTAssigned[]//AddTPlaneGraph;
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
FoldedFormGraphics3D[tobj,Axes->True],
BackPlaneGraphics[tobj,BackPlaneFacet->{1,2,8},Axes->True]}}]/.OrigamiStyle[]
]//ShowExample
RigidlyScaleFoldAngles[glist_List,mu_]:=2 ArcTan[mu Tan[#/2]&/@glist]
Module[{glist},
glist={90.\[Degree],120.\[Degree]};
RigidlyScaleFoldAngles[glist,1/\[Sqrt]3]/\[Degree]
]//ShowExample
RigidlyScaleFoldAngles[glist_List,grule_Rule]:=Module[{ga,gb,mu},
{ga,gb}=List@@grule;
mu=Tan[gb/2]/Tan[ga/2];
RigidlyScaleFoldAngles[glist,mu]]
Module[{glist},
glist={90.\[Degree],120.\[Degree]};
RigidlyScaleFoldAngles[glist,120\[Degree]->90\[Degree]]/\[Degree]
]//ShowExample
TVertex::usage="TVertex is a TObj class that describes a 2D vertex.";
RegisterTClass[TVertex];
SectorAngles::usage="SectorAngles is a TObj property that specifies the sector angles around a vertex.";
DihedralAngles::usage="DihedralAngles is a TObj property that specifies the dihedral angles around a vertex.";
DihedralTypes::usage="DihedralTypes is a TObj property that specifies the dihedral fold types around a vertex.";
CreaseVectors::usage="CreaseVectors is a TObj property that specifies the 2D vectors along the creases around a vertex in the crease pattern.";
MakeTVertexFromCreaseVectors[creasevectors_List, foldangles_List] :=Module[{sectorangles},
sectorangles=MapThread[RotationAngle,{creasevectors,RotateLeft[creasevectors]}];
MakeTObj[TVertex,{
SectorAngles->sectorangles,
DihedralAngles->foldangles,
DihedralTypes->FoldAngleToType[foldangles],
CreaseVectors->creasevectors}]]
Module[{cv,da,tobj},
cv={U[0\[Degree]],U[120\[Degree]],U[180\[Degree]],U[240\[Degree]]};
da={\[Pi],\[Pi],-\[Pi],\[Pi]};
tobj=MakeTVertexFromCreaseVectors[cv,da];
tobj//GetAllRules//ColumnForm
]//ShowExample
OffsetAngle::usage="OffsetAngle is an option to MakeTVertexFromAngles that specifies the offset angle to use for the first crease relative to the x-axis.";
Options[MakeTVertexFromAngles]={
OffsetAngle->0
};
MakeTVertexFromAngles::badangles="Sector angles `1` and dihedral angles `2` must have the same number of entries.";
MakeTVertexFromAngles[sectorangles_List,foldangles_List,opts___]:=Module[{oa,nal,creasevectors},
If[Length[sectorangles]!=Length[foldangles],Message[MakeTVertexFromAngles::badangles,sectorangles,foldangles];Abort[]];
oa=OffsetAngle/.{opts}/.Options[MakeTVertexFromAngles];
nal=2\[Pi] sectorangles / (Plus@@sectorangles);(* sector angles normalized to sum to 2\[Pi] *)
creasevectors=U/@Drop[FoldList[Plus,oa,nal],-1];(* unit vectors along crease lines in 2D *)
MakeTObj[TVertex,{
SectorAngles->sectorangles,
DihedralAngles->foldangles,
DihedralTypes->FoldAngleToType[foldangles],
CreaseVectors->creasevectors}]]
Module[{sa,da,tobj},
sa={120\[Degree],60\[Degree],60\[Degree],120\[Degree]};
da={\[Pi],\[Pi],-\[Pi],\[Pi]};
tobj=MakeTVertexFromAngles[sa,da];
tobj//GetAllRules//ColumnForm
]//ShowExample
CircleRadius::usage="CircleRadius is an option to MakeCircularVertexGraph that specifies the radius of the circle.";
Options[MakeCircularVertexGraph]={
CircleRadius->1
};
MakeCircularVertexGraph[tobj_TObj, opts___]:=Module[{cr,cv,da,nv,verts,edges,faces,types},
AssertClass[tobj,TVertex,MakeCircularVertexGraph];
cr=CircleRadius/.{opts}/.Options[MakeCircularVertexGraph];
{cv,da}=GetValues[tobj,{CreaseVectors,DihedralAngles}];
nv=Length[cv];
verts=Prepend[N[cr cv],{0,0}];
edges=Table[{1,1+i},{i,nv}];
types=Table[Which[da[[i]]>0,V,da[[i]]<0,M,True,U],{i,nv}];
faces={};
Do[CircularlyCompletePoly[verts,edges,faces,{1+Mod[i+1,nv,1],1,i+1},{0,0},cr,opts],{i,nv}];
types=Join[types,Table[B,{Length[edges]-nv}]];
MakeTGraphAssigned[verts,edges,faces,types]]
Module[{sa,da,tobj,gobj},
sa={120\[Degree],60\[Degree],60\[Degree],120\[Degree]};
da={\[Pi],\[Pi],-\[Pi],\[Pi]};
tobj=MakeTVertexFromAngles[sa,da];
gobj=MakeCircularVertexGraph[tobj,CircleRadius->2];
Print[GraphGraphics[gobj,Axes->True]];
gobj//GetAllRules//ColumnForm
]//ShowExample
SectorAngleLabels::usage="SectorAngleLabels is an option to CircularAngleLabels that specifies labels for each sector angle.";
DihedralAngleLabels::usage="DihedralAngleLabels is an option to CircularAngleLabels that specifies labels for each dihedral angle.";
SectorAngleRadius::usage="SectorAngleRadius is an option to CircularAngleLabels that specifies the radius at which the sector angles appear.";
DihedralAngleRadius::usage="DihedralAngleRadius is an option to CircularAngleLabels that specifies the radius at which the sector angles appear.";
Options[CircularAngleLabels]={
SectorAngleLabels->Automatic,
DihedralAngleLabels->Automatic,
SectorAngleRadius->0.25,
DihedralAngleRadius->1.0
};
CircularAngleLabels[creasevectors_List, opts___]:=Module[{sal,dal,sar,dar,nn,sectorvectors},
sal=SectorAngleLabels/.{opts}/.Options[CircularAngleLabels];
dal=DihedralAngleLabels/.{opts}/.Options[CircularAngleLabels];
sar=SectorAngleRadius/.{opts}/.Options[CircularAngleLabels];
dar=DihedralAngleRadius/.{opts}/.Options[CircularAngleLabels];
nn=Length[creasevectors];
If[sal===Automatic,sal=Table[Style[Subscript["\!\(\*StyleBox[\"\[Alpha]\",FontFamily->\"Symbol\",FontWeight->\"Regular\"]\)", ToString[i]],16],{i,nn}]];
If[dal===Automatic,dal=Table[Style[Subscript["\!\(\*StyleBox[\"\[Gamma]\",FontFamily->\"Symbol\",FontWeight->\"Regular\"]\)", ToString[i]],16],{i,nn}]];
sectorvectors= NormalizeReal/@(creasevectors + RotateLeft[creasevectors]);
{If[sal===None,{},MapThread[Text,{sal,sar sectorvectors,-1.5sectorvectors}]],
If[dal===None,{},MapThread[Text,{dal,dar creasevectors,-1.5creasevectors}]]}]
Module[{creasevectors},
creasevectors={U[0\[Degree]],U[120\[Degree]],U[170\[Degree]],U[230\[Degree]]};
Graphics[{Style[Line[{{0,0},#}]&/@creasevectors,LightGray],CircularAngleLabels[creasevectors]}]
]//ShowExample
VertexCreasePatternGraphics[tobj_TObj, opts___]:=Module[{cv,gobj},
AssertClass[tobj,TVertex,VertexCreasePatternGraphics];
cv=GetValue[tobj,CreaseVectors];
gobj=MakeCircularVertexGraph[tobj];
Graphics[{
CreasePatternGraphics[gobj][[1]]/.BorderLine->NoLine,
Style[Point[{0,0}],Black,AbsolutePointSize[5]],
CircularAngleLabels[cv,opts]
},FilterRules[{opts},Options[Graphics]]]]
Module[{sa,da,tobj},
sa={90\[Degree],90\[Degree],90\[Degree]};
da={90\[Degree],90\[Degree],90\[Degree]};
tobj=MakeTVertexFromAngles[sa,da];
VertexCreasePatternGraphics[tobj,
DihedralAngleLabels->(Style[#,Italic, 16]&/@{"a" ,"b","c"}),
SectorAngleLabels->(Style[#,Italic, 16]&/@{"A","B","C"})]/.OrigamiStyle[]
]//ShowExample
Module[{sa,da,tobj},
sa={80\[Degree],90\[Degree],100\[Degree],90\[Degree]};
da={-90\[Degree],90\[Degree],90\[Degree],90\[Degree]};
tobj=MakeTVertexFromAngles[sa,da];
VertexCreasePatternGraphics[tobj,
DihedralAngleLabels->(Style[#,Italic, 16]&/@{"a" ,"b","c","d"}),
SectorAngleLabels->(Style[#,Italic, 16]&/@{"A","B","C","D"})]/.OrigamiStyle[]
]//ShowExample
Module[{sa,da,tobj},
sa={90\[Degree],90\[Degree],180\[Degree],90\[Degree],180\[Degree]};
da={-90\[Degree],90\[Degree],90\[Degree],90\[Degree],90\[Degree]};
tobj=MakeTVertexFromAngles[sa,da];
VertexCreasePatternGraphics[tobj,
DihedralAngleLabels->(Style[#,Italic, 16]&/@{"a" ,"b","c","d","e"}),
SectorAngleLabels->(Style[#,Italic, 16]&/@{"A","B","C","D","E"})]/.OrigamiStyle[]
]//ShowExample
Module[{sa,da,tobj},
sa={45\[Degree],45\[Degree],45\[Degree],45\[Degree],45\[Degree]};
da={-90\[Degree],90\[Degree],90\[Degree],90\[Degree],90\[Degree]};
tobj=MakeTVertexFromAngles[sa,da];
VertexCreasePatternGraphics[tobj,
DihedralAngleLabels->(Style[#,Italic, 16]&/@{"a" ,"b","c","d","e"}),
SectorAngleLabels->(Style[#,Italic, 16]&/@{"A","B","C","D","E"})]/.OrigamiStyle[]
]//ShowExample
VertexGenericFoldedFormGraphics[tobj_TObj, opts___]:=Module[{cv,gobj,fa},
AssertClass[tobj,TVertex,VertexGenericFoldedFormGraphics];
cv=GetValue[tobj,CreaseVectors];
gobj=MakeCircularVertexGraph[tobj];
fa=TypeToFlatFoldAngle[gobj[EdgeTypes]];

GraphGraphics[gobj]//Print;

gobj=FoldGraph2D[gobj,fa];

cv=Take[gobj[Vertices2D],{2,Length[cv]+1}];
Graphics[{
GenericFoldedFormGraphics[gobj][[1]],
Style[Point[{0,0}],Black,AbsolutePointSize[5]],
CircularAngleLabels[cv,opts]},FilterRules[{opts},Options[Graphics]]]]
Module[{sa,da,tobj},
sa={120\[Degree],90\[Degree],60\[Degree],90\[Degree]};
da={\[Pi],\[Pi],-\[Pi],\[Pi]};
tobj=MakeTVertexFromAngles[sa,da];
VertexGenericFoldedFormGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
TVertex3D::usage="TVertex3D is a TObj class that describes a 3D vertex, along with a description in its dual space, the Gaussian sphere.";
RegisterTClass[TVertex3D,{TVertex}];
SectorVectors::usage="SectorVectors is a TObj property that specifies the 3D vectors normal to the sector angle (face) planes around a vertex.";
FoldVectors::usage="FoldVectors is a TObj property that specifies the 3D vectors along the folds around a vertex in the folded form.";
MidfoldVectors::usage="MidfoldVectors is a TObj property that specifies the vectors to the midpoints of the dihedral arcs on the trace.";
MakeTVertex3DFromFoldVectors[foldvectors_List,opts___]:=Module[{gg,aa,\[Gamma],\[Alpha],mm},
gg=NormalizeReal/@foldvectors;(* properly normalized fold vectors *)
aa=NormalizeReal/@MapThread[Cross,{gg,RotateLeft[gg]}];(* normals to facets *)
\[Gamma]=MapThread[DirectedAngle3D,{RotateRight[aa],aa,gg}];(* dihedral angles *)
\[Alpha]=ArcCos/@MapThread[Dot,{gg,RotateLeft[gg]}];(* sector angles *)
mm=MapThread[RotationMatrix3D[#1/2,#2] . #3&,{\[Gamma],gg,RotateRight[aa]},1];(* midarc vectors *)
MakeTVertexFromAngles[\[Alpha],\[Gamma],opts]//AddClass[TVertex3D,{
SectorVectors->aa,FoldVectors->gg,MidfoldVectors->mm}]]
Module[{dirs,tobj},
dirs=RotationZMatrix3D[-10.\[Degree]] . #&/@{{1,0,0},{0,1,0},{0,0,1}};
tobj=MakeTVertex3DFromFoldVectors[dirs,OffsetAngle->20\[Degree]];
Print[GraphicsRow[{
VertexCreasePatternGraphics[tobj]/.OrigamiStyle[],
Graphics3D[{Red,Line[{{0,0,0},#}]&/@dirs},Axes->True]
}]];
tobj//GetAllRules//ColumnForm
]//ShowExample
OffsetAngle3D::usage="OffsetAngle3D is an option to MakeTVertex3DFromAngles that specifies the rotation angle in the x-y plane of the first fold.";
CheckConsistency::usage="CheckConsistency is an option to MakeTVertex3DFromAngles that specifies whether to check the consistency of the sector and dihedral angles.";
Options[MakeTVertex3DFromAngles]={
OffsetAngle3D->0,
CheckConsistency->True
};
MakeTVertex3DFromAngles::badangles="Sector angles `1` and dihedral angles `2` must have the same length.";
MakeTVertex3DFromAngles::inconsist="Sector angles `1` and dihedral angles `2` are not Kawasaki-consistent, giving a residual consistency matrix of `3`.";
MakeTVertex3DFromAngles[sectorangles_List, foldangles_List,opts___]:=Module[{oa,cc,n,mm,gg},
If[Length[sectorangles]!=Length[foldangles],Message[MakeTVertex3DFromAngles::badangles,sectorangles,foldangles];Abort[]];
oa=OffsetAngle3D/.{opts}/.Options[MakeTVertex3DFromAngles];
cc=CheckConsistency/.{opts}/.Options[MakeTVertex3DFromAngles];
If[cc,
mm=VertexConsistencyMatrix3D[foldangles,sectorangles];
If[Chop[mm-IdentityMatrix[3]]!={{0,0,0},{0,0,0},{0,0,0}},Message[MakeTVertex3DFromAngles::inconsist,sectorangles,foldangles,mm];Abort[]];
];
n=Length[sectorangles];
mm=IdentityMatrix[3] . RotationMatrix3Du[oa,{0,0,1}];
gg={};
Do[
AppendTo[gg,Transpose[mm][[1]]];
If[i!=1,mm=mm . RotationMatrix3Du[foldangles[[i]],{1,0,0}]];
mm = mm . RotationMatrix3Du[sectorangles[[i]],{0,0,1}];
,{i,n}];
MakeTVertex3DFromFoldVectors[gg,opts]]
Module[{al,gm,tobj,gg},
al={45.\[Degree],45.\[Degree],45.\[Degree],45.\[Degree],45.\[Degree]};
gm={30.\[Degree],30.\[Degree],30.\[Degree],30.\[Degree],30.\[Degree]};
tobj=MakeTVertex3DFromAngles[al,gm,OffsetAngle->5.\[Degree],OffsetAngle3D->5.\[Degree],CheckConsistency->False];
gg=GetValue[tobj,FoldVectors];
Print[GraphicsRow[{
VertexCreasePatternGraphics[tobj]/.OrigamiStyle[],
Graphics3D[{Red,Line[{{0,0,0},#}]&/@gg,Black,Table[Text[i,gg[[i]]],{i,Length[gg]}]},Axes->True]
}]];
tobj//GetAllRules//ColumnForm
]//ShowExample
Module[{al,gm,tobj,al1,gm1,gg},
al={0.8165869079343493`,1.437331070129374`,0.8165885649372293`,0.8521230921706928`,1.5084171807542006`,0.8521384913245504`};
gm={-1.1283891523711123`,1.5110965081320082`,1.5110857291055109`,-1.1283725344135453`,1.511083161370419`,1.5110990757718343`};
tobj=MakeTVertex3DFromAngles[al,gm];
(* verify that we didn't alter the sector or dihedral angles when we built the 3D vertex. *)
{al1,gm1}=GetValues[tobj,{SectorAngles,DihedralAngles}];
gg=GetValue[tobj,FoldVectors];
Print[VertexCreasePatternGraphics[tobj]/.OrigamiStyle[]];
Print[Graphics3D[{Red,Line[{{0,0,0},#}]&/@gg,Black,Table[Text[i,gg[[i]]],{i,Length[gg]}]},Axes->True]];
tobj//GetAllRules//ColumnForm
]//ShowExample
MakeTVertex3DFromTGraph3D::badadj="Vertex `1` is not adjacent to vertex `2`.";
MakeTVertex3DFromTGraph3D[tobj_TObj, i0_, i1_] :=Module[{tobj1,verts3d,vva,glist,tobj2},
tobj1=If[HasClassQ[tobj,TPlaneGraph],tobj,tobj//RebuildPlaneGraph];
{verts3d,vva}=GetValues[tobj1,{Vertices3D,VertexVertexAdjacency}];
If[!MemberQ[vva[[i0]],i1],Message[MakeTVertex3DFromTGraph3D::badadj,i1,i0];Abort[]];
glist=verts3d[[#]]-verts3d[[i0]]&/@vva[[i0]];
glist=RotateLeft[glist,Position[vva[[i0]],i1,1,1][[1,1]]-1];
MakeTVertex3DFromFoldVectors[glist]]
Module[{tobj,vtobj},
tobj=SingleVertexGraph3DAssigned;
Print[GraphicsRow[{GraphGraphics[tobj],Graph3DGraphics3D[tobj]}]];
vtobj=MakeTVertex3DFromTGraph3D[tobj,1,2];
vtobj//GetAllRules//ColumnForm
]//ShowExample
MakeSphericalVertexGraph3D[tobj_TObj, opts___]:=Module[{cv,fv,nn,gobj,verts,faces,verts3d,face,cvp,cvn,fvp,fvn,a2,x,z,y,a3,m,k,v2,a},
AssertClass[tobj,TVertex3D,MakeSphericalVertexGraph3D];
{cv,fv}=GetValues[tobj,{CreaseVectors,FoldVectors}];
nn=Length[cv];
gobj=MakeCircularVertexGraph[tobj,opts];
{verts,faces}=GetValues[gobj,{Vertices,Faces}];
verts3d=Table[{0,0,0},{Length[verts]}];
(* for each face, map and radially scale vertices in 3D *)
Do[
face=faces[[i]];
cvp=cv[[i]];cvn=cv[[Mod[i+1,nn,1]]];(* defines wedge in 2d *)
fvp=fv[[i]];fvn=fv[[Mod[i+1,nn,1]]]; (* defines wedge in 3d *)
a2=RotationAngle[cvp,cvn];(* wedge angle in 2d *)
x=fvp;
z=NormalizeReal[fvp\[Cross]fvn];
y=z\[Cross]x;
a3=OrientedAngle3D[fvp,fvn,z];
m=a3/a2;(* angular magnification from 2d to 3d *)
Do[
k=face[[j]];(* index of the vertex *)
If[k==1,Continue[]];
v2=verts[[k]];(* vertex to be transformed *)
a =m RotationAngle[cvp,v2];
verts3d[[k]]=Cos[a] x + Sin[a] y;
,{j,Length[face]}]
,{i,nn}];
(* Add verts3d to the graph *)
gobj//AddTGraph3D[verts3d]
]

Module[{dirs,tobj,gobj},
dirs=RotationZMatrix3D[-110.\[Degree]] . #&/@{{1,0,0},{0,1,0},{0,0,1}};
tobj=MakeTVertex3DFromFoldVectors[dirs];
gobj=MakeSphericalVertexGraph3D[tobj];
GraphicsRow[{GraphGraphics[gobj],Graph3DGraphics3D[gobj]}]
]//ShowExample
TracePoint::usage="TracePoint is a symbolic point style used for a point on the trace.";
TraceLine::usage="TraceLine is a symbolic line style used for a line on the trace.";
OsculatingPoint::usage="OsculatingPoint is a symbolic point style used for the osculating vector.";
OsculatingLine::usage="OsculatingLine is a symbolic line style used for the osculating vector.";
OsculatingFill::usage="OsculatingFill is a symbolic fill style used for the osculating plane.";
RulingPoint::usage="RulingPoint is a symbolic point style used for a ruling vector.";
RulingLine::usage="RulingLine is a symbolic line style used for a ruling vector.";
RulingFill::usage="RulingFill is a symbolic fill style used for the ruling plane.";
MidfoldNormalPoint::usage="MidfoldNormalPoint is a symbolic point style used for the tangent vector.";
MidfoldNormalLine::usage="MidfoldNormalLine is a symbolic line style used for the tangent vector.";
MidfoldNormalFill::usage="MidfoldNormalFill is a symbolic fill style used for the tangent plane.";
MidfoldPoint::usage="MidfoldPoint is a symbolic point style used for the midarc vector.";
MidfoldLine::usage="MidfoldLine is a symbolic line style used for the midarc vector.";
MidfoldFill::usage="MidfoldFill is a symbolic fill style used for the midarc plane.";
TraceColor::usage="TraceColor is an option to Vertex3DStyle that specifies color to use for the trace.";
OsculatingColor::usage="OsculatingColor is an option to Vertex3DStyle that specifies color to use for the trace.";
RulingColor::usage="RulingColor is an option to Vertex3DStyle that specifies color to use for the ruling vector and plane.";
MidfoldNormalColor::usage="MidfoldNormalColor is an option to Vertex3DStyle that specifies color to use for the tangent vector and plane.";
MidfoldColor::usage="MidfoldColor is an option to Vertex3DStyle that specifies color to use for the midarc vector and plane.";
Options[Vertex3DStyle]=Join[Options[OrigamiStyle],{
TraceColor->Green,
OsculatingColor->Purple,
RulingColor->Blue,
MidfoldNormalColor->Orange,
MidfoldColor->Pink
}];
Vertex3DStyle[opts___]:=Module[{x,trc,oc,rc,tc,mac,op2},
trc=TraceColor/.{opts}/.Options[Vertex3DStyle];
oc=OsculatingColor/.{opts}/.Options[Vertex3DStyle];
rc=RulingColor/.{opts}/.Options[Vertex3DStyle];
tc=MidfoldNormalColor/.{opts}/.Options[Vertex3DStyle];
mac=MidfoldColor/.{opts}/.Options[Vertex3DStyle];
op2=Opacity2D/.{opts}/.Options[OrigamiStyle];
Join[OrigamiStyle[opts],
{Style[x_,TracePoint]->Style[x,Darker[trc],AbsolutePointSize[3]],
Style[x_,TraceLine]->Style[x,trc,AbsoluteThickness[2],AbsoluteDashing[{}],CapForm["Round"],JoinForm["Round"]],
Style[x_,OsculatingPoint]->Style[x,Darker[oc],AbsolutePointSize[3]],
Style[x_,OsculatingLine]->Style[x,oc,AbsoluteThickness[0.5]],
Style[x_,OsculatingFill]->Style[x,EdgeForm[],FaceForm[Lighter[oc]],Opacity[op2]],
Style[x_,RulingPoint]->Style[x,Darker[rc],AbsolutePointSize[3]],
Style[x_,RulingLine]->Style[x,rc,AbsoluteThickness[0.5]],
Style[x_,RulingFill]->Style[x,EdgeForm[],FaceForm[Lighter[rc]],Opacity[op2]],
Style[x_,MidfoldNormalPoint]->Style[x,Darker[tc],AbsolutePointSize[3]],
Style[x_,MidfoldNormalLine]->Style[x,tc,AbsoluteThickness[0.5]],
Style[x_,MidfoldNormalFill]->Style[x,EdgeForm[],FaceForm[Lighter[tc]],Opacity[op2]],
Style[x_,MidfoldPoint]->Style[x,Darker[mac],AbsolutePointSize[5]],
Style[x_,MidfoldLine]->Style[x,mac,AbsoluteThickness[0.5]],
Style[x_,MidfoldFill]->Style[x,EdgeForm[],FaceForm[Lighter[mac]],Opacity[op2]]
}]]
Vertex3DCreasePatternGraphics[tobj_TObj, opts___]:=Module[{},
AssertClass[tobj,TVertex3D,Vertex3DCreasePatternGraphics];
VertexCreasePatternGraphics[tobj,opts]]
Module[{dirs,tobj},
dirs=RotationZMatrix3D[-110.\[Degree]] . #&/@{{1,0,0},{0,1,0},{0,0,1}};
tobj=MakeTVertex3DFromFoldVectors[dirs];
Vertex3DCreasePatternGraphics[tobj,
DihedralAngleLabels->(Style[#,Italic, 16]&/@{"a" ,"b","c"}),
SectorAngleLabels->(Style[#,Italic, 16]&/@{"A","B","C"})]/.Vertex3DStyle[]
]//ShowExample
Options[SphericalAngleLabels]={
SectorAngleLabels->Automatic,
DihedralAngleLabels->Automatic,
SectorAngleRadius->1.0,
DihedralAngleRadius->1.1
};
SphericalAngleLabels[foldvectors_List, opts___]:=Module[{sal,dal,sar,dar,nn,sectorvectors},
sal=SectorAngleLabels/.{opts}/.Options[SphericalAngleLabels];
dal=DihedralAngleLabels/.{opts}/.Options[SphericalAngleLabels];
sar=SectorAngleRadius/.{opts}/.Options[SphericalAngleLabels];
dar=DihedralAngleRadius/.{opts}/.Options[SphericalAngleLabels];
nn=Length[foldvectors];
If[sal===Automatic,sal=Table[Style[Subscript["\!\(\*StyleBox[\"\[Alpha]\",FontFamily->\"Symbol\",FontWeight->\"Regular\"]\)", ToString[i]],16],{i,nn}]];
If[dal===Automatic,dal=Table[Style[Subscript["\!\(\*StyleBox[\"\[Gamma]\",FontFamily->\"Symbol\",FontWeight->\"Regular\"]\)", ToString[i]],16],{i,nn}]];
sectorvectors= NormalizeReal/@(foldvectors + RotateLeft[foldvectors]);
{If[sal===None,{},MapThread[Text,{sal,sar sectorvectors}]],
If[dal===None,{},MapThread[Text,{dal,dar foldvectors}]]}]
Module[{dirs},
dirs=RotationZMatrix3D[-110.\[Degree]] . #&/@{{1,0,0},{0,1,0},{0,0,1}};
Graphics3D[{Style[Line[{{0,0,0},#}]&/@dirs,LightGray],
SphericalAngleLabels[dirs,
DihedralAngleLabels->(Style[#,Italic, 16]&/@{"a" ,"b","c"}),
SectorAngleLabels->(Style[#,Italic, 16]&/@{"A","B","C"})]}]
]//ShowExample
ShowRealSphere::usage="ShowRealSphere is an option to MakeTVertex3DFromFoldVectors that specifies whether to draw the bounding sphere of the vertex.";
ShowMidfoldPlanes::usage="ShowMidfoldPlanes is an option to MakeTVertex3DFromFoldVectors that specifies whether to show the midarc planes on the real sphere.";
RealSphereRadius::usage="RealSphereRadius is an option to MakeTVertex3DFromFoldVectors that specifies the radius of the real sphere.";
Options[Vertex3DFoldedFormGraphics3D]={
ShowRealSphere->True,
ShowMidfoldPlanes->False,
RealSphereRadius->0.999
};
Vertex3DFoldedFormGraphics3D[tobj_TObj, opts___]:=Module[{srs,smp,rsr,gobj,fv,mm,nn,oo},
AssertClass[tobj,TVertex3D,Vertex3DFoldedFormGraphics3D];
srs=ShowRealSphere/.{opts}/.Options[Vertex3DFoldedFormGraphics3D];
smp=ShowMidfoldPlanes/.{opts}/.Options[Vertex3DFoldedFormGraphics3D];
rsr=RealSphereRadius/.{opts}/.Options[Vertex3DFoldedFormGraphics3D];
gobj=MakeSphericalVertexGraph3D[tobj];
{fv,mm}=GetValues[tobj,{FoldVectors,MidfoldVectors}];
nn=Length[mm];
oo={0,0,0};
Graphics3D[{
If[srs,Style[Sphere[oo,rsr],Opacity[0.1]],{}],(* bounding sphere *)
If[smp,Styled3DUnitDiskFromNormal[#,LineStyle->MidfoldLine,FillStyle->MidfoldFill]&/@mm,{}],(* midarc planes *)
FoldedFormGraphics3D[gobj,opts][[1]],
SphericalAngleLabels[fv,opts],
Style[Point[oo],Black,AbsolutePointSize[5]](* central point *)
},FilterRules[{opts},Options[Graphics3D]]]
]
Module[{dirs,tobj},
dirs=RotationZMatrix3D[-110.\[Degree]] . #&/@{{1,0,0},{0,1,0},{0,0,1}};
tobj=MakeTVertex3DFromFoldVectors[dirs];
Vertex3DFoldedFormGraphics3D[tobj,
DihedralAngleLabels->(Style[#,Italic, 16]&/@{"a" ,"b","c"}),
SectorAngleLabels->(Style[#,Italic, 16]&/@{"A","B","C"})]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj,vp},
vp={0,0,1000};
(* sectors = {120\[Degree],90\[Degree],60\[Degree],90\[Degree]}, minor dihedral = 30.\[Degree] *)
dirs={{0.7522953764156599`,-0.07402862994944666`,0.6546536707079771`},{-0.5848104500843038`,0.8111699806281014`,2.775557561562892`*^-17},{-0.6131868684980109`,-0.4420751471528054`,0.6546536707079771`},{-0.09793067237253185`,-0.995193239229781`,-1.1102230246251568`*^-16}};
tobj=MakeTVertex3DFromFoldVectors[dirs];
Vertex3DFoldedFormGraphics3D[tobj,ViewPoint->vp]/.Vertex3DStyle[]
]//ShowExample
Options[GaussianSphericalAngleLabels]={
SectorAngleLabels->Automatic,
DihedralAngleLabels->Automatic,
SectorAngleRadius->1.1,
DihedralAngleRadius->1.0
};
GaussianSphericalAngleLabels[sectorvectors_List, opts___]:=Module[{sal,dal,sar,dar,nn,foldvectors},
sal=SectorAngleLabels/.{opts}/.Options[GaussianSphericalAngleLabels];
dal=DihedralAngleLabels/.{opts}/.Options[GaussianSphericalAngleLabels];
sar=SectorAngleRadius/.{opts}/.Options[GaussianSphericalAngleLabels];
dar=DihedralAngleRadius/.{opts}/.Options[GaussianSphericalAngleLabels];
nn=Length[sectorvectors];
If[sal===Automatic,sal=Table[Style[Subscript["\[Alpha]", ToString[i]],16],{i,nn}]];
If[dal===Automatic,dal=Table[Style[Subscript["\[Gamma]", ToString[i]],16],{i,nn}]];
foldvectors= NormalizeReal/@(sectorvectors + RotateLeft[sectorvectors]);
{If[sal===None,{},MapThread[Text,{sal,sar sectorvectors}]],
If[dal===None,{},MapThread[Text,{dal,dar foldvectors}]]}]
ShowGaussianSphere::usage="ShowGaussianSphere is an option to MakeTVertex3DFromFoldVectors that specifies whether to draw the bounding sphere of the Gaussian sphere.";
ShowMidfoldVectors::usage="ShowMidfoldVectors is an option to MakeTVertex3DFromFoldVectors that specifies whether to show the midarc vectors on the Gaussian sphere.";
GaussianSphereRadius::usage="GaussianSphereRadius is an option to MakeTVertex3DFromFoldVectors that specifies the radius of the Gaussian sphere.";
Options[Vertex3DGaussianSphereGraphics3D]={
ShowGaussianSphere->True,
ShowMidfoldVectors->False,
GaussianSphereRadius->0.999
};
Vertex3DGaussianSphereGraphics3D[tobj_TObj, opts___]:=Module[{sgs,smv,gsr,mm,aa,nn,oo},
AssertClass[tobj,TVertex3D,Vertex3DGaussianSphereGraphics3D];
sgs=ShowGaussianSphere/.{opts}/.Options[Vertex3DGaussianSphereGraphics3D];
smv=ShowMidfoldVectors/.{opts}/.Options[Vertex3DGaussianSphereGraphics3D];
gsr=GaussianSphereRadius/.{opts}/.Options[Vertex3DGaussianSphereGraphics3D];
{mm,aa}=GetValues[tobj,{MidfoldVectors,SectorVectors}];
nn=Length[mm];
oo={0,0,0};
Graphics3D[{
If[sgs,Style[Sphere[oo,gsr],Opacity[0.3]],{}],(* bounding sphere *)
MapThread[Styled3DArc,{aa,RotateRight[aa],
Table[LineStyle->TraceLine,{nn}]},1],(* trace *)
If[smv,Style[Point[#],MidfoldPoint]&/@mm,{}],(* midarc vectors *)
GaussianSphericalAngleLabels[aa,opts],
Style[Point[oo],Black,AbsolutePointSize[5]](* central point *)
},FilterRules[{opts},Options[Graphics3D]]]
]
Module[{dirs,tobj},
dirs=RotationZMatrix3D[-110.\[Degree]] . #&/@{{1,0,0},{0,1,0},{0,0,1}};
tobj=MakeTVertex3DFromFoldVectors[dirs];
Vertex3DGaussianSphereGraphics3D[tobj,
DihedralAngleLabels->(Style[#,Italic, 16]&/@{"a" ,"b","c"}),
SectorAngleLabels->(Style[#,Italic, 16]&/@{"A","B","C"})]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj,vp},
vp={0,0,1000};
(* sectors = {120\[Degree],90\[Degree],60\[Degree],90\[Degree]}, minor dihedral = 30.\[Degree] *)
dirs={{0.7522953764156599`,-0.07402862994944666`,0.6546536707079771`},{-0.5848104500843038`,0.8111699806281014`,2.775557561562892`*^-17},{-0.6131868684980109`,-0.4420751471528054`,0.6546536707079771`},{-0.09793067237253185`,-0.995193239229781`,-1.1102230246251568`*^-16}};
tobj=MakeTVertex3DFromFoldVectors[dirs];
Vertex3DGaussianSphereGraphics3D[tobj,ViewPoint->vp]/.Vertex3DStyle[]
]//ShowExample
Vertex3DGraphicsPair[tobj_TObj, opts___]:=Module[{},
AssertClass[tobj,TVertex3D,Vertex3DGraphicsPair];
GraphicsRow[{
Vertex3DCreasePatternGraphics[tobj,opts],
Vertex3DFoldedFormGraphics3D[tobj,opts]}]]
Module[{dirs,dal,sal,tobj},
dirs={{0,-1.`,0},{0.20598338218783738`,-0.7983036836917765`,-0.5659346913439743`},{0.7071067811865475`,0.7071067811865475`,0.`},{-0.6393258570250122`,0.10364390117735031`,-0.7619188869479304`}};
tobj=MakeTVertex3DFromFoldVectors[dirs];
dal=Style[#,Italic, 16]&/@{"a" ,"b","c","d"};
sal=Style[#,Italic, 16]&/@{"A","B","C","D"};
Print["SectorAngles/\[Degree] = ",tobj[SectorAngles]/\[Degree]];
Print["DihedralAngles/\[Degree] = ",tobj[DihedralAngles]/\[Degree]];
Vertex3DGraphicsPair[tobj,DihedralAngleLabels->dal,SectorAngleLabels->sal,
ShowMidfoldPlanes->True, (* real sphere *)
ShowMidfoldVectors->True (* gaussian sphere *) ]/.Vertex3DStyle[]
]//ShowExample
Vertex3DGraphicsTrio[tobj_TObj, opts___]:=Module[{},
AssertClass[tobj,TVertex3D,Vertex3DGraphicsTrio];
GraphicsRow[{
Vertex3DCreasePatternGraphics[tobj,opts],
Vertex3DFoldedFormGraphics3D[tobj,opts],
Vertex3DGaussianSphereGraphics3D[tobj,opts]}]]
Module[{dirs,dal,sal,tobj},
dirs={{0,-1.`,0},{0.20598338218783738`,-0.7983036836917765`,-0.5659346913439743`},{0.7071067811865475`,0.7071067811865475`,0.`},{-0.6393258570250122`,0.10364390117735031`,-0.7619188869479304`}};
tobj=MakeTVertex3DFromFoldVectors[dirs];
dal=Style[#,Italic, 16]&/@{"a" ,"b","c","d"};
sal=Style[#,Italic, 16]&/@{"A","B","C","D"};
Print["SectorAngles/\[Degree] = ",tobj[SectorAngles]/\[Degree]];
Print["DihedralAngles/\[Degree] = ",tobj[DihedralAngles]/\[Degree]];
Vertex3DGraphicsTrio[tobj,DihedralAngleLabels->dal,SectorAngleLabels->sal,
ShowMidfoldPlanes->True, (* real sphere *)
ShowMidfoldVectors->True (* gaussian sphere *) ]/.Vertex3DStyle[]
]//ShowExample
ForceFlatFoldable::usage="ForceFlatFoldable is an option to \!\(\*FormBox[\(MakeFoldVectorsDevelopable\),
TraditionalForm]\) that forces a 3D vertex to be flat-foldable.";
Options[MakeFoldVectorsDevelopable]={
ForceFlatFoldable->False
};
MakeFoldVectorsDevelopable[rlist_List,opts___]:=Module[{ff,nn,rz,ry,rr,dry,drz,\[Alpha],asum,fom,cons,vbls,soln},
ff=ForceFlatFoldable/.{opts}/.Options[MakeFoldVectorsDevelopable];
ff =ff &&(Mod[nn,2]==0);(* turn off flag if there's an odd number of vertices *)
nn=Length[rlist];
(* Get two unit vectors perpendicular to each initial vector *)
rz=NormalizeReal/@MapThread[Cross,{rlist,RotateLeft[rlist]}];
ry=MapThread[Cross,{rz,rlist}];
(* Symbolically perturbed vectors *)
rr=Table[RotationMatrix3Du[drz[i],rz[[i]]] . RotationMatrix3Du[dry[i],ry[[i]]] . rlist[[i]],{i,nn}]/.{dry[i_]:>dry[Round[i]],drz[i_]:>drz[Round[i]]};\[Alpha]=ArcCos/@MapThread[Dot,{rr,RotateLeft[rr]},1];(* sector angles *)
fom=Sum[dry[i]^2+drz[i]^2,{i,nn}];(* figure of merit, to minimize *)
asum=Plus@@\[Alpha]-2\[Pi]==0;(* equation that enforces sum of sector angles *)
cons=If[ff,asum&&Sum[\[Alpha][[i]](-1)^i,{i,nn}]==0,asum];
vbls=Flatten[Table[{{dry[i],0},{drz[i],0}},{i,nn}],1];
soln=FindMinimum[{fom,cons},vbls];(* nonlinear constrained minimization *)
rr/.soln[[2]] (* return the set of vectors that achieves the minimum *)
]
Module[{sal,dal,gfn,dirs,dirs2,dirs3},
sal=Style[#, 16]&/@{"\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(4\)]\)"};
dal=Style[#, 14]&/@{"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)" ,"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(4\)]\)"};
gfn[dirs1_,label_]:=Module[{tobj},
tobj=MakeTVertex3DFromFoldVectors[dirs1];
Print[label];
Print["Sector angles/\[Degree]"->tobj[SectorAngles]/\[Degree]];
Print["Fold angles/\[Degree]"->tobj[DihedralAngles]/\[Degree]];
Print["Developability excess/\[Degree]" ->DevelopabilityExcess[tobj[SectorAngles]]/\[Degree]];
Print["Flat-foldability excess/\[Degree]" ->FlatFoldabilityExcess[tobj[SectorAngles]]/\[Degree]];
Print[Vertex3DGraphicsTrio[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]/.Vertex3DStyle[]];
];
dirs=NormalizeReal/@{{1.,0,0},{-1.,1.,0},{-.2,-.2,1.},{-.5,-.5,.5}};
dirs=RotationXMatrix3D[50.\[Degree]] . #&/@dirs;
(* original vertex *)
gfn[dirs,"Initial vertex"];
(* developable, not necessarily flat foldable *)
dirs2=MakeFoldVectorsDevelopable[dirs,ForceFlatFoldable->False];
gfn[dirs2,"Developable vertex"];
(* developable and flat foldable *)
dirs3=MakeFoldVectorsDevelopable[dirs,ForceFlatFoldable->True];
gfn[dirs3,"Flat-foldable vertex"];
]//ShowExample
Module[{gfn,dirs,dirs2,dirs3},
gfn[dirs1_,label_]:=Module[{tobj},
tobj=MakeTVertex3DFromFoldVectors[dirs1];
Print[label];
Print["Sector angles/\[Degree]"->tobj[SectorAngles]/\[Degree]];
Print["Fold angles/\[Degree]"->tobj[DihedralAngles]/\[Degree]];
Print["Developability excess/\[Degree]" ->DevelopabilityExcess[tobj[SectorAngles]]/\[Degree]];
Print["Flat-foldability excess/\[Degree]" ->FlatFoldabilityExcess[tobj[SectorAngles]]/\[Degree]];
Print[Vertex3DGraphicsTrio[tobj]/.Vertex3DStyle[]];
];
dirs=NormalizeReal/@{{.5,0,1},{1,1,.5},{-1,1,.5},{-.5,0,1},{-1,-.8,.5},{1,-.8,.5}};
dirs=RotationXMatrix3D[50.\[Degree]] . #&/@dirs;
(* original vertex *)
gfn[dirs,"Initial vertex"];
(* developable, not necessarily flat foldable *)
dirs2=MakeFoldVectorsDevelopable[dirs,ForceFlatFoldable->False];
gfn[dirs2,"Developable vertex"];
(* developable and flat foldable *)
dirs3=MakeFoldVectorsDevelopable[dirs,ForceFlatFoldable->True];
gfn[dirs3,"Flat-foldable vertex"];
]//ShowExample
TDegree4Vertex3D::usage="TDegree4Vertex3D is a TObj class that represents a 3D degree-4 vertex embedded in a unit sphere.";
RegisterTClass[TDegree4Vertex3D,{TVertex3D}];
OddCreaseIndex::usage="OddCreaseIndex is a TObj property that specifies the crease whose direction differs from the other three.";
MajorCreaseIndices::usage="MajorCreaseIndices is a TObj property that specifies the two major creases in the vertex.";
MinorCreaseIndices::usage="MinorCreaseIndices is a TObj property that specifies the two minor creases in the vertex.";
OsculatingVector::usage="OsculatingVector is a TObj property that specifies the normal vector to the osculating plane.";
RulingVector::usage="RulingVector is a TObj property that specifies the normal vector to the ruling plane.";
OsculatingAngle::usage="OsculatingAngle is a TObj property that specifies the angle between the two major creases.";
RulingAngle::usage="RulingAngle is a TObj property that specifies the angle between the two minor creases.";
SubarcAngles::usage="SubarcAngles is a TObj property that specifies the four subarc angles";
BendAngleFF::usage="BendAngleFF is a TObj property that specifies the bend angle of the vertex in the folded form.";
BendAngleCP::usage="BendAngleCP is a TObj property that specifies the bend angle of the vertex in the crease pattern.";
MidfoldNormalVector::usage="MidfoldNormalVector is a TObj property that specifies the normal vector to the plane containing the midfold vectors.";
InfinitesimalMidfoldNormalAngle::usage="InfinitesimalMidfoldNormalAngle is a TObj property that specifies the infinitesimal tangent angle of the crease pattern.";
InfinitesimalMidfoldNormalVector::usage="InfinitesimalMidfoldNormalVector is a TObj property that specifies the infinitesimal tangent vector of the crease pattern.";
DihedralExpansion::usage="DihedralExpansion is a TObj property that specifies the ratio of the tangents of the subarc angles.";
MakeTDegree4Vertex3D::maekawa="Crease directions `1` give assignment `2` which does not satisfy Maekawa's Theorem.";
MakeTDegree4Vertex3D[{g1_,g2_,g3_,g4_}]:=Module[{tobj,aa,gg,\[Alpha],\[Gamma],mm,g,cd,od,odi,f,mji,mni,q,z,\[Theta],\[Zeta],\[Sigma],\[Beta]\[Beta],\[Beta],t,\[Rho],ss34,ss12,i\[Tau],it},
tobj=MakeTVertex3DFromFoldVectors[{g1,g2,g3,g4}];
{aa,gg,\[Alpha],\[Gamma],mm,g}=GetValues[tobj,{SectorVectors,FoldVectors,SectorAngles,DihedralAngles,MidfoldVectors,CreaseVectors}];
(* Identify the major and minor creases and the odd crease *)
cd=Sign/@\[Gamma]; (* crease directions as \[PlusMinus]1 *)
If[Abs[Count[cd,1]-Count[cd,-1]]!=2,
Message[MakeTDegree4Vertex3D::maekawa,{g1,g2,g3,g4},If[#===1,V,M]&/@cd];Print[Vertex3DGraphicsPair[tobj]/.OrigamiStyle[]];
Abort[]];
od=-(Plus@@cd)/2;(* direction of the odd crease *)
odi=Position[cd,od][[1,1]];(* index of the odd crease in the list of 4 creases *)
f=Mod[#+odi-3,4,1]&;(* rotates indexing so that f[i] gives the index of the crease or sector that corresponds to the one with index i in my "standard" drawing. *)
mji={f[2],f[4]};(* indices of the major creases, before and after the odd crease *)
mni={f[1],f[3]};(* indices of the minor creases, ending with the odd crease *)
q=NormalizeReal[gg[[f[2]]]\[Cross]gg[[f[4]]]]; (* osculating normal *)
z = NormalizeReal[gg[[f[1]]]\[Cross]gg[[f[3]]]]; (* ruling normal *)
\[Theta]=DirectedAngle3D[gg[[f[2]]],gg[[f[4]]],q];(* osculating (major) angle *)
\[Zeta] = DirectedAngle3D[gg[[f[1]]],gg[[f[3]]],z];(* ruling (minor) angle *)
\[Sigma]=RotateLeft[{DirectedAngle3D[aa[[f[1]]],q,gg[[f[2]]]],-DirectedAngle3D[aa[[f[2]]],q,gg[[f[2]]]],DirectedAngle3D[aa[[f[3]]],q,gg[[f[4]]]],-DirectedAngle3D[aa[[f[4]]],q,gg[[f[4]]]]},3-odi];
\[Beta]\[Beta]=\[Pi]-\[Theta];(* bend angle in 3D *)
\[Beta]=\[Alpha][[f[4]]]+\[Alpha][[f[1]]]-\[Pi];(* bend angle in 2D *)
t=NormalizeReal[mm[[f[1]]]\[Cross]mm[[f[3]]]];(* midfold normal vector *)
\[Rho]={Tan[\[Sigma][[f[1]]]/2]/Tan[\[Sigma][[f[3]]]/2],Tan[\[Sigma][[f[2]]]/2]/Tan[\[Sigma][[f[4]]]/2]};(* dihedral expansion \[Rho] for both pairs of subrcs *)
(* infinitesimal midfold normal angle and vector *)
ss34=\[Sqrt](Sin[\[Alpha][[f[3]]]]Sin[\[Alpha][[f[4]]]]);
ss12=\[Sqrt](Sin[\[Alpha][[f[1]]]]Sin[\[Alpha][[f[2]]]]);
i\[Tau]=ArcTan[Cos[\[Alpha][[f[1]]]]ss34-Cos[\[Alpha][[f[4]]]]ss12,Sin[\[Alpha][[f[1]]]]ss34+Sin[\[Alpha][[f[4]]]]ss12];
it=RotationMatrix2D[i\[Tau]] . g[[f[1]]];(* infinitesimal midfold normal vector *)
(* return value *)
AddClassTo[tobj,TDegree4Vertex3D,{
OddCreaseIndex->odi,MajorCreaseIndices->mji,MinorCreaseIndices->mni,OsculatingVector->q,RulingVector->z,OsculatingAngle->\[Theta],RulingAngle->\[Zeta],SubarcAngles->\[Sigma],BendAngleFF->\[Beta]\[Beta],BendAngleCP->\[Beta],MidfoldVectors->mm,MidfoldNormalVector->t,InfinitesimalMidfoldNormalAngle->i\[Tau],InfinitesimalMidfoldNormalVector->it,DihedralExpansion->\[Rho],MidfoldNormalVector->t
}]]
Module[{gg,tobj},
gg={
{0.9700104913750351`,-0.04225495452240546`,-0.23936199825684262`},
{-0.32376018506496596`,0.15916056242963283`,0.9326560231647507`},
{-0.10649560995357948`,-0.504184109771602`,0.8570047068588076`},
{-0.6888959099547768`,-0.7221685381587115`,-0.062410158430039`}};
tobj=MakeTDegree4Vertex3D[gg];
Print[Vertex3DGraphicsTrio[tobj]/.Vertex3DStyle[]];
tobj//GetAllRules//ColumnForm
]//ShowExample
Module[{gg,tobj},
gg={{1,0,0},
{-0.1736481776669303`,0.492403876506104`,0.8528685319524432`},{0.6533631710606677`,-0.6840402866513394`,0.3243539007619673`},{-0.1736481776669303`,-0.492403876506104`,0.8528685319524432`}};
tobj=MakeTDegree4Vertex3D[gg];
]//ShowErrorExample
MakeTDegree4Vertex3DFromTGraph3D::baddeg="Vertex `1` of `2` is not degree 4.";
MakeTDegree4Vertex3DFromTGraph3D::badadj="Vertex `1` is not adjacent to vertex `2`.";
MakeTDegree4Vertex3DFromTGraph3D[tobj_TObj, i0_, i1_] :=Module[{tobj1,verts3d,vva,glist,tobj2},
tobj1=If[HasClassQ[tobj,TPlaneGraph],tobj,tobj//RebuildPlaneGraph];
{verts3d,vva}=GetValues[tobj1,{Vertices3D,VertexVertexAdjacency}];
If[Length[vva[[i0]]]!=4,Message[MakeTDegree4Vertex3DFromTGraph3D::baddeg,i0,tobj];Abort[]];
If[!MemberQ[vva[[i0]],i1],Message[MakeTDegree4Vertex3DFromTGraph3D::badadj,i1,i0];Abort[]];
glist=verts3d[[#]]-verts3d[[i0]]&/@vva[[i0]];
glist=RotateLeft[glist,Position[vva[[i0]],i1,1,1][[1,1]]-1];
MakeTDegree4Vertex3D[glist]]
Module[{tobj,vtobj},
tobj=SingleVertexGraph3DAssigned;
Print[GraphicsRow[{GraphGraphics[tobj],Graph3DGraphics3D[tobj]}]];
vtobj=MakeTDegree4Vertex3DFromTGraph3D[tobj,1,2];
vtobj//GetAllRules//ColumnForm
]//ShowExample
Degree4Vertex3DCreasePatternGraphics[tobj_TObj, opts___]:=Module[{},
AssertClass[tobj,TDegree4Vertex3D,Degree4Vertex3DCreasePatternGraphics];
Vertex3DCreasePatternGraphics[tobj,opts]]
Module[{rlist,tobj},
rlist={
{0.9700104913750351`,-0.04225495452240546`,-0.23936199825684262`},
{-0.32376018506496596`,0.15916056242963283`,0.9326560231647507`},
{-0.10649560995357948`,-0.504184109771602`,0.8570047068588076`},
{-0.6888959099547768`,-0.7221685381587115`,-0.062410158430039`}};
tobj=MakeTDegree4Vertex3D[rlist];
Degree4Vertex3DCreasePatternGraphics[tobj]/.Vertex3DStyle[]
]//ShowExample
ShowOsculatingVector::usage="ShowOsculatingVector is an option to Degree4Vertex3DFoldedFormGraphics3D that specifies whether to show the osculating normal on the Gaussian sphere.";
ShowRulingVector::usage="ShowRulingVector is an option to Degree4Vertex3DFoldedFormGraphics3D that specifies whether to show the normal plane's normal vector on the Gaussian sphere.";
ShowTangentVector::usage="ShowTangentVector is an option to Degree4Vertex3DFoldedFormGraphics3D that specifies whether to show the tangent vector on the Gaussian sphere.";
ShowOsculatingPlane::usage="ShowOsculatingPlane is an option to Degree4Vertex3DFoldedFormGraphics3D that specifies whether to add a representation of the osculating plane in the folded form.";
ShowRulingPlane::usage="ShowRulingPlane is an option to Degree4Vertex3DFoldedFormGraphics3D that specifies whether to add a representation of the ruling plane in the folded form.";
ShowTangentPlane::usage="ShowTangentPlane is an option to Degree4Vertex3DFoldedFormGraphics3D that specifies whether to show the tangent plane in the folded form.";
Options[Degree4Vertex3DFoldedFormGraphics3D]={
ShowOsculatingVector->False,
ShowRulingVector->False,
ShowTangentVector->False,
ShowOsculatingPlane->False,
ShowRulingPlane->False,
ShowTangentPlane->False
};
Degree4Vertex3DFoldedFormGraphics3D[tobj_TObj, opts___]:=Module[{sov,srv,stv,sop,srp,stp,odi,q,z,t,gg,mm,mji,mni,glist},
AssertClass[tobj,TDegree4Vertex3D,Degree4Vertex3DFoldedFormGraphics3D];
sov=ShowOsculatingVector/.{opts}/.Options[Degree4Vertex3DFoldedFormGraphics3D];
srv=ShowRulingVector/.{opts}/.Options[Degree4Vertex3DFoldedFormGraphics3D];
stv=ShowTangentVector/.{opts}/.Options[Degree4Vertex3DFoldedFormGraphics3D];
sop=ShowOsculatingPlane/.{opts}/.Options[Degree4Vertex3DFoldedFormGraphics3D];
srp=ShowRulingPlane/.{opts}/.Options[Degree4Vertex3DFoldedFormGraphics3D];
stp=ShowTangentPlane/.{opts}/.Options[Degree4Vertex3DFoldedFormGraphics3D];
{q,z,t,gg,mm,mji,mni}=GetValues[tobj,{OsculatingVector,RulingVector,MidfoldNormalVector,FoldVectors,MidfoldVectors,MajorCreaseIndices,MinorCreaseIndices}];
glist=Vertex3DFoldedFormGraphics3D[tobj,opts][[1]];
Graphics3D[Join[
If[sov,{StyledLine[{{0,0,0},q},LineStyle->OsculatingLine]},{}],(* osculating vector *)
If[srv,{StyledLine[{-z,z},LineStyle->RulingLine]},{}],(* ruling vector *)
If[stv,{StyledLine[{-t,t},LineStyle->MidfoldNormalLine]},{}],(* tangent vector *)
If[sop,{Styled3DUnitDiskFromInPlaneVectors[gg[[mji[[1]]]],gg[[mji[[2]]]],LineStyle->OsculatingLine,FillStyle->OsculatingFill]},{}],(* osculating plane *)
If[srp,{Styled3DUnitDiskFromInPlaneVectors[gg[[mni[[1]]]],gg[[mni[[2]]]],LineStyle->RulingLine,FillStyle->RulingFill]},{}],(* ruling plane *)
If[stp,{Styled3DUnitDiskFromInPlaneVectors[mm[[mni[[1]]]],mm[[mni[[2]]]],LineStyle->MidfoldNormalLine,FillStyle->MidfoldNormalFill]},{}],(* tangent plane *)
glist],FilterRules[{opts},Options[Graphics3D]]]]
Module[{rlist,tobj},
rlist={
{0.9700104913750351`,-0.04225495452240546`,-0.23936199825684262`},
{-0.32376018506496596`,0.15916056242963283`,0.9326560231647507`},
{-0.10649560995357948`,-0.504184109771602`,0.8570047068588076`},
{-0.6888959099547768`,-0.7221685381587115`,-0.062410158430039`}};
tobj=MakeTDegree4Vertex3D[rlist];
Degree4Vertex3DFoldedFormGraphics3D[tobj,
ShowOsculatingVector->True,
ShowRulingVector->True,
ShowTangentVector->True,
ShowOsculatingPlane->True,
ShowRulingPlane->True,
ShowTangentPlane->True
]/.Vertex3DStyle[]
]//ShowExample
ShowRulingGreatCircles::usage="ShowRulingGreatCircles is an option to Degree4Vertex3DGaussianSphereGraphics3D that specifies whether to show the great circles whose intersection defines the normal to the ruling plane on the Gaussian sphere.";
Options[Degree4Vertex3DGaussianSphereGraphics3D]={
ShowOsculatingVector->False,
ShowRulingVector->False,
ShowTangentVector->False,
ShowOsculatingPlane->False,
ShowRulingPlane->False,
ShowTangentPlane->False,
ShowRulingGreatCircles->False
};
Degree4Vertex3DGaussianSphereGraphics3D[tobj_TObj, opts___]:=Module[{sov,srv,stv,sop,srp,stp,srgc,q,z,t,gg,aa,mji,mni,glist},
AssertClass[tobj,TDegree4Vertex3D,Degree4Vertex3DGaussianSphereGraphics3D];
sov=ShowOsculatingVector/.{opts}/.Options[Degree4Vertex3DGaussianSphereGraphics3D];
srv=ShowRulingVector/.{opts}/.Options[Degree4Vertex3DGaussianSphereGraphics3D];
stv=ShowTangentVector/.{opts}/.Options[Degree4Vertex3DGaussianSphereGraphics3D];
sop=ShowOsculatingPlane/.{opts}/.Options[Degree4Vertex3DGaussianSphereGraphics3D];
srp=ShowRulingPlane/.{opts}/.Options[Degree4Vertex3DGaussianSphereGraphics3D];
stp=ShowTangentPlane/.{opts}/.Options[Degree4Vertex3DGaussianSphereGraphics3D];
srgc=ShowRulingGreatCircles/.{opts}/.Options[Degree4Vertex3DGaussianSphereGraphics3D];
{q,z,t,gg,aa,mji,mni}=GetValues[tobj,{OsculatingVector,RulingVector,MidfoldNormalVector,FoldVectors,SectorVectors,MajorCreaseIndices,MinorCreaseIndices}];
glist=Vertex3DGaussianSphereGraphics3D[tobj,opts][[1]];
Graphics3D[Join[
If[sov,{StyledPoint[q,PointStyle->OsculatingPoint]},{}],(* osculating vector *)
If[srv,{StyledPoint[#,PointStyle->RulingPoint]&/@{-z,z}},{}],(* ruling vector *)
If[stv,{StyledPoint[#,PointStyle->MidfoldNormalPoint]&/@{-t,t}},{}],(* tangent vector *)
If[sop,{Styled3DUnitCircleFromInPlaneVectors[NormalizeReal[q\[Cross]gg[[mji[[1]]]]],NormalizeReal[q\[Cross]gg[[mji[[2]]]]],LineStyle->OsculatingLine]},{}],(* osculating plane *)
If[srp,{Styled3DUnitCircleFromInPlaneVectors[NormalizeReal[z\[Cross]gg[[mji[[1]]]]],NormalizeReal[z\[Cross]gg[[mji[[2]]]]],LineStyle->RulingLine]},{}],(* ruling plane *)
If[stp,{Styled3DUnitCircleFromInPlaneVectors[NormalizeReal[t\[Cross]gg[[mji[[1]]]]],NormalizeReal[t\[Cross]gg[[mji[[2]]]]],LineStyle->MidfoldNormalLine]},{}],(* tangent plane *)
If[srgc,{{Styled3DUnitCircleFromInPlaneVectors[aa[[mni[[1]]]],aa[[mji[[2]]]],LineStyle->CreaseLine],Styled3DUnitCircleFromInPlaneVectors[aa[[mji[[1]]]],aa[[mni[[2]]]],LineStyle->CreaseLine]}},{}],(* ruling great circles *)
glist],FilterRules[{opts},Options[Graphics3D]]]]
Module[{rlist,tobj},
rlist={
{0.9700104913750351`,-0.04225495452240546`,-0.23936199825684262`},
{-0.32376018506496596`,0.15916056242963283`,0.9326560231647507`},
{-0.10649560995357948`,-0.504184109771602`,0.8570047068588076`},
{-0.6888959099547768`,-0.7221685381587115`,-0.062410158430039`}};
tobj=MakeTDegree4Vertex3D[rlist];
Degree4Vertex3DGaussianSphereGraphics3D[tobj,
ShowOsculatingVector->True,
ShowRulingVector->True,
ShowTangentVector->True,
ShowOsculatingPlane->True,
ShowRulingPlane->True,
ShowTangentPlane->True,
ShowRulingGreatCircles->True
]/.Vertex3DStyle[]
]//ShowExample
Degree4Vertex3DGraphicsTrio[tobj_TObj, opts___]:=Module[{},
AssertClass[tobj,TDegree4Vertex3D,Degree4Vertex3DGraphicsTrio];
GraphicsRow[{
Degree4Vertex3DCreasePatternGraphics[tobj,opts],
Degree4Vertex3DFoldedFormGraphics3D[tobj,opts],
Degree4Vertex3DGaussianSphereGraphics3D[tobj,opts]}]]
Module[{dirs,dal,sal,tobj},
dirs={{0.9700104913750351`,-0.04225495452240546`,-0.23936199825684262`},
{-0.32376018506496596`,0.15916056242963283`,0.9326560231647507`},
{-0.10649560995357948`,-0.504184109771602`,0.8570047068588076`},
{-0.6888959099547768`,-0.7221685381587115`,-0.062410158430039`}};
tobj=MakeTDegree4Vertex3D[dirs];
dal=Style[#,Italic, 14]&/@{"a" ,"b","c","d"};
sal=Style[#,Italic, 14]&/@{"A","B","C","D"};
Print["SectorAngles/\[Degree] = ",tobj[SectorAngles]/\[Degree]];
Print["DihedralAngles/\[Degree] = ",tobj[DihedralAngles]/\[Degree]];
Degree4Vertex3DGraphicsTrio[tobj,
DihedralAngleLabels->dal,
SectorAngleLabels->sal,
ShowOsculatingVector->True,
ShowRulingVector->True,
ShowTangentVector->True,
ShowOsculatingPlane->True,
ShowRulingPlane->True,
ShowTangentPlane->True,
ShowRulingGreatCircles->True
 ]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,dal,sal,tobj},
dirs={{0,-1.`,0},
{0.20598338218783738`,-0.7983036836917765`,-0.5659346913439743`},
{0.7071067811865475`,0.7071067811865475`,0.`},
{-0.6393258570250122`,0.10364390117735031`,-0.7619188869479304`}};
tobj=MakeTDegree4Vertex3D[dirs];
dal=Style[#,Italic, 14]&/@{"a" ,"b","c","d"};
sal=Style[#,Italic, 14]&/@{"A","B","C","D"};
Print["SectorAngles/\[Degree] = ",tobj[SectorAngles]/\[Degree]];
Print["DihedralAngles/\[Degree] = ",tobj[DihedralAngles]/\[Degree]];
Degree4Vertex3DGraphicsTrio[tobj,
DihedralAngleLabels->dal,
SectorAngleLabels->sal,
ShowOsculatingVector->True,
ShowRulingVector->True,
ShowTangentVector->True,
ShowOsculatingPlane->True,
ShowRulingPlane->True,
ShowTangentPlane->True,
ShowRulingGreatCircles->True
 ]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj,sal,dal,\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4,\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4,\[Zeta],\[Theta]},
(* This is a set of vertex directions for a computed developable, non-flat-foldable vertex. *)
dirs={{0.9972215532662916`,-0.03575020412413242`,0.06535362733810356`},{-0.6708746129934421`,0.4126653780055379`,0.6161449013312116`},{-0.2779109459922161`,-0.8460225167640658`,0.4549850626404195`},{-0.49522944528027024`,-0.8687605191174532`,0.0017195784858716062`}};
tobj=MakeTDegree4Vertex3D[dirs];
{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}=tobj[SectorAngles];
{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}=tobj[DihedralAngles];
\[Zeta]=tobj[RulingAngle];
\[Theta]=tobj[OsculatingAngle];
Print["OsculatingAngle/\[Degree] = ",\[Zeta]/\[Degree]];
Print["RulingAngle/\[Degree] = ",\[Theta]/\[Degree]];
Print["SectorAngles/\[Degree] = ",tobj[SectorAngles]/\[Degree]];
Print["DihedralAngles/\[Degree] = ",tobj[DihedralAngles]/\[Degree]];
(* Identities *)
Print["Huffman's Major-Angle \[CapitalDelta] = ",Sin[\[Gamma]2/2]^2/Sin[\[Gamma]4/2]^2-(Sin[\[Alpha]3]Sin[\[Alpha]4])/(Sin[\[Alpha]1]Sin[\[Alpha]2])];
Print["Huffman's Minor-Angle \[CapitalDelta] = ",Sin[\[Gamma]1/2]^2/Sin[\[Gamma]3/2]^2-(Sin[\[Alpha]2]Sin[\[Alpha]3])/(Sin[\[Alpha]1]Sin[\[Alpha]4])];
Print["Eqn 8.51 \[CapitalDelta] = ",(Cot[\[Gamma]1/2]Cot[\[Gamma]2/2]Csc[\[Pi]-\[Alpha]1]+Cot[\[Pi]-\[Alpha]1])-(Cot[\[Gamma]4/2]Cot[-(\[Gamma]3/2)]Csc[\[Alpha]3]+Cot[\[Alpha]3])];Print["Eqn 8.52 \[CapitalDelta] = ",(Cot[\[Gamma]1/2]Cot[\[Gamma]4/2]Csc[\[Pi]-\[Alpha]4]+Cot[\[Pi]-\[Alpha]4])-(Cot[\[Gamma]2/2]Cot[-(\[Gamma]3/2)]Csc[\[Alpha]2]+Cot[\[Alpha]2])];Print["Adjacent Cot[\[Gamma]1/2] \[CapitalDelta] = ",Cot[\[Gamma]1/2]-(Cot[\[Gamma]2/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]2]-Cot[\[Gamma]4/2](Cot[\[Alpha]2]+Cot[\[Alpha]4])Csc[\[Alpha]3])/(Csc[\[Alpha]3]Csc[\[Alpha]4]-Csc[\[Alpha]1]Csc[\[Alpha]2])];
Print["Adjacent Cot[\[Gamma]2/2] \[CapitalDelta] = ",Cot[\[Gamma]2/2]-(Cot[\[Gamma]3/2](Cot[\[Alpha]2]+Cot[\[Alpha]4])Csc[\[Alpha]3]-Cot[\[Gamma]1/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]4])/(Csc[\[Alpha]1]Csc[\[Alpha]4]-Csc[\[Alpha]2]Csc[\[Alpha]3])];
Print["Adjacent Cot[\[Gamma]3/2] \[CapitalDelta] = ",Cot[\[Gamma]3/2]-(Cot[\[Gamma]2/2](Cot[\[Alpha]2]+Cot[\[Alpha]4])Csc[\[Alpha]1]-Cot[\[Gamma]4/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]4])/(Csc[\[Alpha]3]Csc[\[Alpha]4]-Csc[\[Alpha]1]Csc[\[Alpha]2])];
Print["Adjacent Cot[\[Gamma]4/2] \[CapitalDelta] = ",Cot[\[Gamma]4/2]-(Cot[\[Gamma]3/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]2]-Cot[\[Gamma]1/2](Cot[\[Alpha]2]+Cot[\[Alpha]4])Csc[\[Alpha]1])/(Csc[\[Alpha]1]Csc[\[Alpha]4]-Csc[\[Alpha]2]Csc[\[Alpha]3])];
Print["Hav[\[Zeta]] \[CapitalDelta] = ",Hav[\[Zeta]]-(Hav[\[Alpha]1-\[Alpha]2]+Sin[\[Alpha]1]Sin[\[Alpha]2]Hav[\[Pi]-\[Gamma]2])];
Print["Cos[\[Zeta]] \[CapitalDelta] = ",Cos[\[Zeta]]-(Cos[\[Alpha]1]Cos[\[Alpha]2]-Sin[\[Alpha]1]Sin[\[Alpha]2]Cos[\[Gamma]2])];
Print["Cos[\[Zeta]] \[CapitalDelta] = ",Cos[\[Zeta]]-(Cos[\[Alpha]3]Cos[\[Alpha]4]-Sin[\[Alpha]3]Sin[\[Alpha]4]Cos[\[Gamma]4])];
Print["Hav[\[Theta]] \[CapitalDelta] = ",Hav[\[Theta]]-(Hav[\[Alpha]1-\[Alpha]4]+Sin[\[Alpha]1]Sin[\[Alpha]4]Hav[\[Pi]-\[Gamma]1])];
Print["Cos[\[Theta]] \[CapitalDelta] = ",Cos[\[Theta]]-(Cos[\[Alpha]1]Cos[\[Alpha]4]-Sin[\[Alpha]1]Sin[\[Alpha]4]Cos[\[Gamma]1])];
Print["Cos[\[Theta]] \[CapitalDelta] = ",Cos[\[Theta]]-(Cos[\[Alpha]2]Cos[\[Alpha]3]-Sin[\[Alpha]2]Sin[\[Alpha]3]Cos[\[Gamma]3])];
(* show the example *)
sal=Style[#, 16]&/@{"\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(4\)]\)"};
dal=Style[#, 14]&/@{"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)" ,"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(4\)]\)"};
Degree4Vertex3DGraphicsTrio[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj,sal,dal,\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4,\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4},
(* This is a set of vertex directions for a computed developable, non-flat-foldable, straight-minor vertex. *)
dirs={{1,0,0},{0,0.8660254037844387`,0.49999999999999994`},{-0.14285714285714338`,-0.49487165930539334`,0.8571428571428572`},{-0.7071067811865475`,-0.6123724356957946`,0.35355339059327373`}};
tobj=MakeTDegree4Vertex3D[dirs];
{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}=tobj[SectorAngles];
{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}=tobj[DihedralAngles];
Print["SectorAngles/\[Degree] = ",tobj[SectorAngles]/\[Degree]];
Print["DihedralAngles/\[Degree] = ",tobj[DihedralAngles]/\[Degree]];
(* Identities *)
Print["Adjacent Tan[\[Gamma]1/2] \[CapitalDelta]= ",Tan[\[Gamma]1/2]-((-Csc[\[Alpha]1]^2+Csc[\[Alpha]3]^2)/((Cot[\[Alpha]1]+Cot[\[Alpha]3]) (Cot[\[Gamma]4/2] Csc[\[Alpha]3]+Csc[\[Alpha]1] \[Sqrt](-1+Csc[\[Alpha]3]^2 Csc[\[Gamma]4/2]^2 Sin[\[Alpha]1]^2))))];
Print["Adjacent Tan[\[Gamma]2/2] \[CapitalDelta]= ",Tan[\[Gamma]2/2]-((2 Cot[\[Gamma]1/2] Csc[\[Alpha]1])/(Cot[\[Alpha]1]-Cot[\[Alpha]1] Cot[\[Gamma]1/2]^2+Cot[\[Alpha]3] Csc[\[Gamma]1/2]^2))];
Print["Adjacent Tan[\[Gamma]3/2] \[CapitalDelta]= ",Tan[\[Gamma]3/2]-((Csc[\[Alpha]1]^2-Csc[\[Alpha]3]^2)/((Cot[\[Alpha]1]+Cot[\[Alpha]3]) (Cot[\[Gamma]4/2] Csc[\[Alpha]3]+Csc[\[Alpha]1] \[Sqrt](-1+Csc[\[Alpha]3]^2 Csc[\[Gamma]4/2]^2 Sin[\[Alpha]1]^2))))];
Print["Adjacent Tan[\[Gamma]4/2] \[CapitalDelta]= ",Tan[\[Gamma]4/2]-(-((2 Cot[\[Gamma]1/2] Csc[\[Alpha]3])/(Cot[\[Alpha]3]-Cot[\[Alpha]3] Cot[\[Gamma]1/2]^2+Cot[\[Alpha]1] Csc[\[Gamma]1/2]^2)))];
(* show the example *)
sal=Style[#, 16]&/@{"\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(4\)]\)"};
dal=Style[#, 14]&/@{"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)" ,"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(4\)]\)"};
Degree4Vertex3DGraphicsTrio[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]/.Vertex3DStyle[]
]//ShowExample
Module[{\[Alpha],\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4,gp,gm,\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4,tobj,\[Zeta],\[Theta],\[Beta]},
\[Alpha]=60\[Degree];
{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}={\[Pi]-\[Alpha],\[Alpha],\[Alpha],\[Pi]-\[Alpha]};
gp=90\[Degree];
gm=2ArcCot[Sec[\[Alpha]]Cot[gp/2]];
{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}={gm,gp,-gm,gp};
tobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4},{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}];
\[Theta]=tobj[OsculatingAngle];
\[Zeta]=tobj[RulingAngle];
\[Beta]=\[Pi]-\[Zeta];(* bend angle of minor creases *)

Print[Degree4Vertex3DFoldedFormGraphics3D[tobj]/.Vertex3DStyle[]];
(* check our two formulas for ruling angle \[Zeta] *)
Print["(computed) \[Zeta]/\[Degree] = ",\[Zeta]/\[Degree]//N];
Print["(algebraic) \[Zeta]/\[Degree] = ",ArcCos[Cos[\[Alpha]1]Cos[\[Alpha]2]-Sin[\[Alpha]1]Sin[\[Alpha]2]Cos[\[Gamma]2]]/\[Degree]//N];
Print["Osculating angle: \[CapitalDelta] = ",(Sin[\[Theta]/2]-Sin[\[Alpha]]Cos[\[Gamma]1/2])//N];
Print["Ruling angle: \[CapitalDelta] = ",(Cos[\[Zeta]/2]-Sin[\[Alpha]]Sin[\[Gamma]2/2])//N];
Print["Sector/Minor fold/bend angle: \[CapitalDelta] = ",(Tan[\[Alpha]]-Sin[\[Gamma]3/2]Tan[\[Beta]/2])//N];
]//ShowExample
MaximumDihedralAngles[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_}]:={
2ArcSin[Min[\[Sqrt]((Sin[\[Alpha]2]Sin[\[Alpha]3])/(Sin[\[Alpha]1]Sin[\[Alpha]4])),1]],2ArcSin[Min[\[Sqrt]((Sin[\[Alpha]3]Sin[\[Alpha]4])/(Sin[\[Alpha]1]Sin[\[Alpha]2])),1]] ,
2ArcSin[Min[\[Sqrt]((Sin[\[Alpha]1]Sin[\[Alpha]4])/(Sin[\[Alpha]2]Sin[\[Alpha]3])),1]],2ArcSin[Min[\[Sqrt]((Sin[\[Alpha]1]Sin[\[Alpha]2])/(Sin[\[Alpha]3]Sin[\[Alpha]4])),1]]}
Module[{sa},
sa={90\[Degree],45\[Degree],135\[Degree],90\[Degree]};
MaximumDihedralAngles[sa]/\[Degree]//N
]//ShowExample
Module[{sa},
sa={90.\[Degree],91.\[Degree],30.\[Degree],149.\[Degree]};
MaximumDihedralAngles[sa]/\[Degree]//N
]//ShowExample
MinorFirstStraightMinorAnglesQ[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_}]:=(\[Alpha]1+\[Alpha]2==\[Pi])
MinorFirstStraightMinorAnglesQ[{135\[Degree],45\[Degree],90\[Degree],90\[Degree]}]//ShowExample
MinorFirstStraightMajorAnglesQ[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_}]:=(\[Alpha]1+\[Alpha]4==\[Pi])
MinorFirstStraightMajorAnglesQ[{90\[Degree],45\[Degree],135\[Degree],90\[Degree]}]//ShowExample
MajorFirstStraightMinorAnglesQ[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_}]:=(\[Alpha]1+\[Alpha]4==\[Pi])
MajorFirstStraightMinorAnglesQ[{90\[Degree],135\[Degree],45\[Degree],90\[Degree]}]//ShowExample
MajorFirstStraightMajorAnglesQ[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_}]:=(\[Alpha]1+\[Alpha]2==\[Pi])
MajorFirstStraightMajorAnglesQ[{90\[Degree],90\[Degree],45\[Degree],135\[Degree]}]//ShowExample
MinorFirstBindingDihedralAngles[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_}]:=Module[{r,\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4},
If[FlatFoldableAnglesQ[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}] (* flat-foldable *),
Return[{\[Pi],\[Pi],\[Pi],\[Pi]}]];
If[MinorFirstStraightMajorAnglesQ[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}],(* straignt-major but not flat-foldable *)
Return[{0,\[Pi],0,\[Pi]}]];
r=\[Sqrt]((Sin[\[Alpha]1]Sin[\[Alpha]2])/(Sin[\[Alpha]3]Sin[\[Alpha]4]));
If[
r<1 (* \[Gamma]2 binds first *),
\[Gamma]2=\[Pi];
\[Gamma]4=2 ArcSin[r],
(* r > 1, \[Gamma]4 binds first *)
\[Gamma]4=\[Pi];
\[Gamma]2=2 ArcSin[1/r]
];
If[MinorFirstStraightMinorAnglesQ[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}],
(* straight-minor, use simpler formulas *)
\[Gamma]1=2ArcCot[((Cot[\[Gamma]2/2] Csc[\[Alpha]1]+Cot[\[Gamma]4/2]Csc[\[Alpha]4])(Cot[\[Alpha]1]+Cot[\[Alpha]3]))/(Csc[\[Alpha]3]^2-Csc[\[Alpha]2]^2)];
\[Gamma]3=-\[Gamma]1,
(* general vertex *)
\[Gamma]1=2ArcCot[(Cot[\[Gamma]2/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]2]-Cot[\[Gamma]4/2](Cot[\[Alpha]2]+Cot[\[Alpha]4])Csc[\[Alpha]3])/(Csc[\[Alpha]3]Csc[\[Alpha]4]-Csc[\[Alpha]1]Csc[\[Alpha]2])];
\[Gamma]3=2 ArcCot[(Cot[\[Gamma]2/2](Cot[\[Alpha]2]+Cot[\[Alpha]4])Csc[\[Alpha]1]-Cot[\[Gamma]4/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]4])/(Csc[\[Alpha]3]Csc[\[Alpha]4]-Csc[\[Alpha]1]Csc[\[Alpha]2])]];
Abs/@{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}]
MinorFirstBindingDihedralAngles[{120\[Degree],65\[Degree],60\[Degree],115\[Degree]}]/\[Degree]//N//ShowExample
MinorFirstBindingDihedralAngles[{90\[Degree],100\[Degree],80\[Degree],90\[Degree]}]/\[Degree]//N//ShowExample
MinorFirstBindingDihedralAngles[{120\[Degree],30\[Degree],90\[Degree],120\[Degree]}]/\[Degree]//N//ShowExample
MinorFirstBindingDihedralAngles[{120\[Degree],90\[Degree],40\[Degree],110\[Degree]}]/\[Degree]//N//ShowExample
MinorFirstBindingDihedralAngles[{135\[Degree],45\[Degree],90\[Degree],90\[Degree]}]/\[Degree]//N//ShowExample
MinorFirstBindingDihedralAngles[{90\[Degree],90\[Degree],120\[Degree],60\[Degree]}]/\[Degree]//N//ShowExample
Module[{sa},
sa={120\[Degree],65\[Degree],60\[Degree],115\[Degree]};
Print["Maximum angles/\[Degree] = ",MaximumDihedralAngles[sa]/\[Degree]//N];
Print["Binding angles/\[Degree] = ",MinorFirstBindingDihedralAngles[sa]/\[Degree]//N];
]//ShowExample
Module[{sa},
sa={90\[Degree],100\[Degree],80\[Degree],90\[Degree]};
Print["Maximum angles/\[Degree] = ",MaximumDihedralAngles[sa]/\[Degree]//N];
Print["Binding angles/\[Degree] = ",MinorFirstBindingDihedralAngles[sa]/\[Degree]//N];
]//ShowExample
Module[{sa},
sa={120\[Degree],30\[Degree],90\[Degree],120\[Degree]};
Print["Maximum angles/\[Degree] = ",MaximumDihedralAngles[sa]/\[Degree]//N];
Print["Binding angles/\[Degree] = ",MinorFirstBindingDihedralAngles[sa]/\[Degree]//N];
]//ShowExample
Module[{sa},
sa={120\[Degree],90\[Degree],40\[Degree],110\[Degree]};
Print["Maximum angles/\[Degree] = ",MaximumDihedralAngles[sa]/\[Degree]//N];
Print["Binding angles/\[Degree] = ",MinorFirstBindingDihedralAngles[sa]/\[Degree]//N];
]//ShowExample
Module[{sa},
sa={135\[Degree],45\[Degree],90\[Degree],90\[Degree]};
Print["Maximum angles/\[Degree] = ",MaximumDihedralAngles[sa]/\[Degree]//N];
Print["Binding angles/\[Degree] = ",MinorFirstBindingDihedralAngles[sa]/\[Degree]//N];
]//ShowExample
Module[{sa},
sa={90\[Degree],90\[Degree],120\[Degree],60\[Degree]};
Print["Maximum angles/\[Degree] = ",MaximumDihedralAngles[sa]/\[Degree]//N];
Print["Binding angles/\[Degree] = ",MinorFirstBindingDihedralAngles[sa]/\[Degree]//N];
]//ShowExample
MajorFirstBindingDihedralAngles[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_}]:=RotateRight[MinorFirstBindingDihedralAngles[{\[Alpha]2,\[Alpha]3,\[Alpha]4,\[Alpha]1}],1]
MinorFirstBindingDihedralAngles[{120\[Degree],30\[Degree],90\[Degree],120\[Degree]}]/\[Degree]//N//ShowExample
MajorFirstBindingDihedralAngles[{120\[Degree],30\[Degree],90\[Degree],120\[Degree]}]/\[Degree]//N//ShowExample
MajorFirstBindingDihedralAngles[{120\[Degree],120\[Degree],30\[Degree],90\[Degree]}]/\[Degree]//N//ShowExample
AllowSelfIntersection::usage="AllowSelfIntersection is an option to MakeDihedralsFromSectorsAndMinorDihedral that specifies whether to return successfully if the resulting vertex is self-intersecting, i.e., beyond the binding condition.";
MakeDihedralsFromSectorsAndMinorDihedral::baddev="Sector angles `1` are not developable.";
MakeDihedralsFromSectorsAndMinorDihedral::strtmjr="Cannot compute dihedrals because sector angles `1` are straight-major.";
MakeDihedralsFromSectorsAndMinorDihedral::maxangle="Dihedral angle `1` is beyond the maximum angle `2` for sector angles `3`.";
MakeDihedralsFromSectorsAndMinorDihedral::binding="Dihedral angle `1` is beyond the binding angle `2` for sector angles `3`.";
Options[MakeDihedralsFromSectorsAndMinorDihedral]={
AllowSelfIntersection->True
};
MakeDihedralsFromSectorsAndMinorDihedral[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_},\[Gamma]1_,opts___]:=Module[{asi,ma,ba,mu,\[Gamma]2,\[Gamma]3,\[Gamma]4},
asi=AllowSelfIntersection/.{opts}/.Options[MakeDihedralsFromSectorsAndMinorDihedral];
If[!DevelopableAnglesQ[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}],Message[MakeDihedralsFromSectorsAndMinorDihedral::baddev,{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];Abort[]];
If[MinorFirstStraightMajorAnglesQ[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}],Message[MakeDihedralsFromSectorsAndMinorDihedral::strtmjr,{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];Abort[]];
ma=MaximumDihedralAngles[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];
If[Abs[\[Gamma]1]>ma[[1]],Message[MakeDihedralsFromSectorsAndMinorDihedral::maxangle,\[Gamma]1,ma[[1]],{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];Abort[]];
ba=MinorFirstBindingDihedralAngles[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];
If[!asi&&Abs[\[Gamma]1]>ba[[1]],Message[MakeDihedralsFromSectorsAndMinorDihedral::binding,\[Gamma]1,ba[[1]],{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];Abort[]];
Which[\[Alpha]1+\[Alpha]3==\[Pi],(* flat-foldable, formulas simplify a lot *)
mu=Sin[(\[Alpha]1+\[Alpha]2)/2]/Sin[(\[Alpha]1-\[Alpha]2)/2];\[Gamma]3=-\[Gamma]1;\[Gamma]2=\[Gamma]4=2ArcTan[mu Tan[\[Gamma]1/2]],
\[Alpha]1+\[Alpha]2==\[Pi],(* straight-minor, though not flat-foldable *)
\[Gamma]3=-\[Gamma]1;
\[Gamma]2=2ArcTan[(2 Cot[\[Gamma]1/2] Csc[\[Alpha]1])/(Cot[\[Alpha]1]-Cot[\[Alpha]1] Cot[\[Gamma]1/2]^2+Cot[\[Alpha]3] Csc[\[Gamma]1/2]^2)];
\[Gamma]4=2ArcTan[-((2 Cot[\[Gamma]1/2] Csc[\[Alpha]3])/(Cot[\[Alpha]3]-Cot[\[Alpha]3] Cot[\[Gamma]1/2]^2+Cot[\[Alpha]1] Csc[\[Gamma]1/2]^2))],
True,(* not flat-foldable, but we still have formulas *)
\[Gamma]3=-2ArcSin[Sin[\[Gamma]1/2]\[Sqrt]((Sin[\[Alpha]1]Sin[\[Alpha]4])/(Sin[\[Alpha]2]Sin[\[Alpha]3]))];(* from Huffman's Minor-Angle Identity *)
\[Gamma]2=2ArcCot[(Cot[\[Gamma]3/2](Cot[\[Alpha]2]+Cot[\[Alpha]4])Csc[\[Alpha]3]-Cot[\[Gamma]1/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]4])/(Csc[\[Alpha]1]Csc[\[Alpha]4]-Csc[\[Alpha]2]Csc[\[Alpha]3])];(* from general adjacent-angle identity *)
\[Gamma]4=2ArcCot[(Cot[\[Gamma]3/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]2]-Cot[\[Gamma]1/2](Cot[\[Alpha]2]+Cot[\[Alpha]4])Csc[\[Alpha]1])/(Csc[\[Alpha]1]Csc[\[Alpha]4]-Csc[\[Alpha]2]Csc[\[Alpha]3])](* from general adjacent-angle identity *)
];
{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}]
Module[{sa1,sa2,sa3,\[Gamma]1,gfn},
sa1={120\[Degree],65\[Degree],60\[Degree],115\[Degree]};
sa2={120\[Degree],60\[Degree],65\[Degree],115\[Degree]};
sa3={120\[Degree],70\[Degree],65\[Degree],105\[Degree]};
\[Gamma]1=90.\[Degree];
(* gfn computes dihedrals and draws and labels the CP *)
gfn[sa_]:=Module[{da,cv,sal,dal,tobj},
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,\[Gamma]1];
cv=Drop[U/@FoldList[Plus,0,sa],-1];
sal=#&/@sa/\[Degree];
dal=NumberForm[#,{5,2}]&/@(da/\[Degree]);
tobj=MakeTVertexFromCreaseVectors[cv,da];
VertexCreasePatternGraphics[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]
];
GraphicsRow[{gfn[sa1],gfn[sa2],gfn[sa3]}/.OrigamiStyle[]]
]//ShowExample
Module[{sa1,sa2,sa3,\[Gamma]1,gfn},
sa1={65\[Degree],120\[Degree],115\[Degree],60\[Degree]};
sa2={60\[Degree],120\[Degree],115\[Degree],65\[Degree]};
sa3={70\[Degree],120\[Degree],105\[Degree],65\[Degree]};
\[Gamma]1=90.\[Degree];
(* gfn computes dihedrals and draws and labels the CP *)
gfn[sa_]:=Module[{da,cv,sal,dal,tobj},
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,\[Gamma]1];
cv=Drop[U/@FoldList[Plus,0,sa],-1];
sal=#&/@sa/\[Degree];
dal=NumberForm[#,{5,2}]&/@(da/\[Degree]);
tobj=MakeTVertexFromCreaseVectors[cv,da];
VertexCreasePatternGraphics[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]
];
GraphicsRow[{gfn[sa1],gfn[sa2],gfn[sa3]}/.OrigamiStyle[]]
]//ShowExample
Module[{sa1,sa2,sa3,\[Gamma]1,gfn},
sa1={120\[Degree],61\[Degree],60\[Degree],119\[Degree]};(* flat-foldable, Subscript[\[Alpha], 1]+Subscript[\[Alpha], 3]\[Equal]180\[Degree] *)
sa2={120\[Degree],60\[Degree],61\[Degree],119\[Degree]};(* straight-minor, Subscript[\[Alpha], 1]+Subscript[\[Alpha], 2]\[Equal]180\[Degree] *)
sa3={120\[Degree],61\[Degree],61\[Degree],118\[Degree]};(* general *)
\[Gamma]1=90.\[Degree];
(* gfn computes dihedrals and draws and labels the CP *)
gfn[sa_]:=Module[{da,cv,sal,dal,tobj},
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,\[Gamma]1];
cv=Drop[U/@FoldList[Plus,0,sa],-1];
sal=#&/@sa/\[Degree];
dal=NumberForm[#,{5,2}]&/@(da/\[Degree]);
tobj=MakeTVertexFromCreaseVectors[cv,da];
VertexCreasePatternGraphics[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]
];
GraphicsRow[{gfn[sa1],gfn[sa2],gfn[sa3]}/.OrigamiStyle[]]
]//ShowExample
Module[{sa1,sa2,sa3,\[Gamma]1,gfn},
sa2={90.\[Degree],90.\[Degree],45.\[Degree],135.\[Degree]};(* straight-minor, Subscript[\[Alpha], 1]+Subscript[\[Alpha], 2]\[Equal]180\[Degree] *)
sa3={91.\[Degree],90.\[Degree],45.\[Degree],134.\[Degree]};(* general *)
\[Gamma]1=89.99\[Degree];
(* gfn computes dihedrals and draws and labels the CP *)
gfn[sa_]:=Module[{da,cv,sal,dal,tobj},
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,\[Gamma]1];
cv=Drop[U/@FoldList[Plus,0,sa],-1];
sal=#&/@sa/\[Degree];
dal=NumberForm[#,{5,2}]&/@(da/\[Degree]);
tobj=MakeTVertexFromCreaseVectors[cv,da];
VertexCreasePatternGraphics[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]
];
GraphicsRow[{gfn[sa2],gfn[sa3]}/.OrigamiStyle[]]
]//ShowExample
MakeDihedralsFromSectorsAndMajorDihedral::baddev="Sector angles `1` are not developable.";
MakeDihedralsFromSectorsAndMajorDihedral::strtmjr="Cannot compute dihedrals because sector angles `1` are straight-major.";
MakeDihedralsFromSectorsAndMajorDihedral::maxangle="Dihedral angle `1` is beyond the maximum angle `2` for sector angles `3`.";
MakeDihedralsFromSectorsAndMajorDihedral::binding="Dihedral angle `1` is beyond the binding angle `2` for sector angles `3`.";
Options[MakeDihedralsFromSectorsAndMajorDihedral]={
AllowSelfIntersection->True
};
MakeDihedralsFromSectorsAndMajorDihedral[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_},\[Gamma]1_,opts___]:=Module[{asi,ma,ba,mu,\[Gamma]2,\[Gamma]3,\[Gamma]4},
asi=AllowSelfIntersection/.{opts}/.Options[MakeDihedralsFromSectorsAndMajorDihedral];
If[!DevelopableAnglesQ[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}],Message[MakeDihedralsFromSectorsAndMajorDihedral::baddev,{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];Abort[]];
If[MajorFirstStraightMajorAnglesQ[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}],Message[MakeDihedralsFromSectorsAndMajorDihedral::strtmjr,{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];Abort[]];
ma=MaximumDihedralAngles[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];
If[Abs[\[Gamma]1]>ma[[1]],Message[MakeDihedralsFromSectorsAndMajorDihedral::maxangle,\[Gamma]1,ma[[1]],{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];Abort[]];
ba=MajorFirstBindingDihedralAngles[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];
If[!asi&&Abs[\[Gamma]1]>ba[[1]],Message[MakeDihedralsFromSectorsAndMajorDihedral::binding,\[Gamma]1,ba[[1]],{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4}];Abort[]];
Which[\[Alpha]1+\[Alpha]3==\[Pi],(* flat-foldable, formulas simplify a lot *)
mu=Sin[(\[Alpha]4+\[Alpha]1)/2]/Sin[(\[Alpha]4-\[Alpha]1)/2];\[Gamma]3=\[Gamma]1;\[Gamma]4=2ArcTan[ Tan[\[Gamma]1/2]/mu];\[Gamma]2=-\[Gamma]4,
\[Alpha]4+\[Alpha]1==\[Pi],(* straight-minor, though not flat-foldable *)
\[Gamma]3=2 ArcSin[ Sin[\[Gamma]1/2](Sin[\[Alpha]4]/Sin[\[Alpha]2])];
\[Gamma]4=2ArcCot[((Cot[\[Gamma]1/2] Csc[\[Alpha]4]+Cot[\[Gamma]3/2]Csc[\[Alpha]3])(Cot[\[Alpha]4]+Cot[\[Alpha]2]))/(Csc[\[Alpha]2]^2-Csc[\[Alpha]1]^2)];
\[Gamma]2=-\[Gamma]4;
,
True,(* not flat-foldable, but we still have formulas *)
\[Gamma]3=2ArcSin[Sin[\[Gamma]1/2]\[Sqrt]((Sin[\[Alpha]4]Sin[\[Alpha]1])/(Sin[\[Alpha]2]Sin[\[Alpha]3]))];(* from Huffman's Major-Angle Identity *)
\[Gamma]4=2ArcCot[(Cot[\[Gamma]1/2](Cot[\[Alpha]4]+Cot[\[Alpha]2])Csc[\[Alpha]1]-Cot[\[Gamma]3/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]2])/(Csc[\[Alpha]2]Csc[\[Alpha]3]-Csc[\[Alpha]4]Csc[\[Alpha]1])];(* from general adjacent-angle identity *)
\[Gamma]2=2ArcCot[(Cot[\[Gamma]1/2](Cot[\[Alpha]1]+Cot[\[Alpha]3])Csc[\[Alpha]4]-Cot[\[Gamma]3/2](Cot[\[Alpha]4]+Cot[\[Alpha]2])Csc[\[Alpha]3])/(Csc[\[Alpha]2]Csc[\[Alpha]3]-Csc[\[Alpha]4]Csc[\[Alpha]1])](* from general adjacent-angle identity *)
];
{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}]
Module[{sa1,sa2,sa3,gfn},
sa1={65\[Degree],60\[Degree],115\[Degree],120\[Degree]};
sa2={60\[Degree],65\[Degree],115\[Degree],120\[Degree]};
sa3={70\[Degree],65\[Degree],105\[Degree],120\[Degree]};
(* gfn computes dihedrals and draws and labels the CP *)
gfn[sa_,\[Gamma]1_]:=Module[{da,cv,sal,dal,tobj},
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]1];
cv=Drop[U/@FoldList[Plus,0,sa],-1];
sal=#&/@sa/\[Degree];
dal=NumberForm[#,{5,2}]&/@(da/\[Degree]);
tobj=MakeTVertexFromCreaseVectors[cv,da];
VertexCreasePatternGraphics[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]
];
GraphicsRow[{gfn[sa1,130.39\[Degree]],gfn[sa2,136.02\[Degree]],gfn[sa3,142.98\[Degree]]}/.OrigamiStyle[]]
]//ShowExample
Module[{sa1,sa2,sa3,gfn},
sa1={120\[Degree],115\[Degree],60\[Degree],65\[Degree]};
sa2={120\[Degree],115\[Degree],65\[Degree],60\[Degree]};
sa3={120\[Degree],105\[Degree],65\[Degree],70\[Degree]};
(* gfn computes dihedrals and draws and labels the CP *)
gfn[sa_,\[Gamma]1_]:=Module[{da,cv,sal,dal,tobj},
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]1];
cv=Drop[U/@FoldList[Plus,0,sa],-1];
sal=#&/@sa/\[Degree];
dal=NumberForm[#,{5,2}]&/@(da/\[Degree]);
tobj=MakeTVertexFromCreaseVectors[cv,da];
VertexCreasePatternGraphics[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]
];
GraphicsRow[{gfn[sa1,-130.39\[Degree]],gfn[sa2,-136.02\[Degree]],gfn[sa3,-143.76\[Degree]]}/.OrigamiStyle[]]
]//ShowExample
Module[{sa1,sa2,sa3,gfn},
sa1={61\[Degree],60\[Degree],119\[Degree],120\[Degree]};
sa2={60\[Degree],61\[Degree],119\[Degree],120\[Degree]};
sa3={61\[Degree],61\[Degree],118\[Degree],120\[Degree]};
(* gfn computes dihedrals and draws and labels the CP *)
gfn[sa_,\[Gamma]1_]:=Module[{da,cv,sal,dal,tobj},
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]1];
cv=Drop[U/@FoldList[Plus,0,sa],-1];
sal=#&/@sa/\[Degree];
dal=NumberForm[#,{5,2}]&/@(da/\[Degree]);
tobj=MakeTVertexFromCreaseVectors[cv,da];
VertexCreasePatternGraphics[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]
];
GraphicsRow[{gfn[sa1,127.56\[Degree]],gfn[sa2,128.71\[Degree]],gfn[sa3,129.40\[Degree]]}/.OrigamiStyle[]]
]//ShowExample
Module[{sa1,sa2,sa3,gfn},
sa2={90.\[Degree],45.\[Degree],135.\[Degree],90.\[Degree]};
sa3={90.\[Degree],45.\[Degree],134.\[Degree],91.\[Degree]};
(* gfn computes dihedrals and draws and labels the CP *)
gfn[sa_,\[Gamma]1_]:=Module[{da,cv,sal,dal,tobj},
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]1];
cv=Drop[U/@FoldList[Plus,0,sa],-1];
sal=#&/@sa/\[Degree];
dal=NumberForm[#,{5,2}]&/@(da/\[Degree]);
tobj=MakeTVertexFromCreaseVectors[cv,da];
VertexCreasePatternGraphics[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal]
];
GraphicsRow[{gfn[sa2,90\[Degree]],gfn[sa3,91\[Degree]]}/.OrigamiStyle[]]
]//ShowExample
Module[{sa1,sa2,sa3,\[Gamma],gfn},
sa1={120\[Degree],65\[Degree],60\[Degree],115\[Degree]};
sa2={90.\[Degree],90.\[Degree],45.\[Degree],135.\[Degree]};
sa3={91.\[Degree],90.\[Degree],45.\[Degree],134.\[Degree]};
\[Gamma]=88.99\[Degree];
gfn[sa_,\[Gamma]1_]:=Module[{da1,da2},
da1=MakeDihedralsFromSectorsAndMinorDihedral[sa,\[Gamma]1];
da2=RotateRight[MakeDihedralsFromSectorsAndMajorDihedral[RotateLeft[sa,1],da1[[2]]],1];
Print["(dihedrals from minor)/\[Degree] = ",da1/\[Degree]];
Print["(dihedrals from major)/\[Degree] = ",da2/\[Degree]];
];
gfn[sa1,\[Gamma]];
gfn[sa2,\[Gamma]];
gfn[sa3,\[Gamma]];
]//ShowExample
OsculatingVectorNear::usage="OsculatingVectorNear is an option to MakeFoldVectorsFromSectorsAndDihedrals that specifies the desired direction for the osculating vector.";
Options[MakeFoldVectorsFromSectorsAndDihedrals]={
OsculatingVectorNear->None
};
MakeFoldVectorsFromSectorsAndDihedrals[{a1_, a2_,a3_,a4_},{gm1_,gm2_,gm3_,gm4_},opts___]:=Module[{ovn,g1,g2,g3,g4,aa,bb,gg,tobj},
ovn=OsculatingVectorNear/.{opts}/.Options[MakeFoldVectorsFromSectorsAndDihedrals];
g1=U3D[0];
g2=RotationXMatrix3D[gm1/2] . U3D[a1];
g3=RotationXMatrix3D[gm1/2] . RotationMatrix3Du[gm2,U3D[a1]] . U3D[a1+a2];
g4=RotationXMatrix3D[-gm1/2] . U3D[-a4];
gg={g1,g2,g3,g4};
(*
Print["{a1, a2, a3, a4}/\[Degree] (input) =",{a1, a2, a3, a4}/\[Degree]];(* compare input and computed *)
Print["{a1, a2, a3, a4}/\[Degree] (computed) =",{ArcCos[g1.g2], ArcCos[g2.g3], ArcCos[g3.g4], ArcCos[g4.g1]}/\[Degree]];
*)
If[ovn===None, Return[gg]];
tobj=MakeTDegree4Vertex3D[gg];
RotationMatrix3DTwixt[tobj[OsculatingVector],ovn] . #&/@gg]
Module[{sal,dal,sa,da,dirs,tobj},
sal=Style[#, 16]&/@{"\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(4\)]\)"};
dal=Style[#, 14]&/@{"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)" ,"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(4\)]\)"};
sa={140.\[Degree],30.\[Degree],90.\[Degree],100.\[Degree]};
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,60.\[Degree]];
Print["(sector angles)/\[Degree] = ",sa/\[Degree]];
Print["(dihedral angles)/\[Degree] = ",da/\[Degree]];
dirs=MakeFoldVectorsFromSectorsAndDihedrals[sa,da];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Module[{sal,dal,sa,da,dirs,tobj},
sal=Style[#, 16]&/@{"\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(4\)]\)"};
dal=Style[#, 14]&/@{"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)" ,"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(4\)]\)"};
sa={140.\[Degree],30.\[Degree],90.\[Degree],100.\[Degree]};
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,60.\[Degree]];
Print["(sector angles)/\[Degree] = ",sa/\[Degree]];
Print["(dihedral angles)/\[Degree] = ",da/\[Degree]];
dirs=MakeFoldVectorsFromSectorsAndDihedrals[sa,da,OsculatingVectorNear->{0,0,1}];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,SectorAngleLabels->sal,DihedralAngleLabels->dal,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
MakeFoldVectorsFromSectorsAndMinorDihedral[{\[Alpha]1_, \[Alpha]2_,\[Alpha]3_,\[Alpha]4_},\[Gamma]1_,opts___]:=Module[{da},
da=MakeDihedralsFromSectorsAndMinorDihedral[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4},\[Gamma]1,opts];
MakeFoldVectorsFromSectorsAndDihedrals[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4},da,opts]
]
Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSectorsAndMinorDihedral[{140.\[Degree],30.\[Degree],90.\[Degree],100.\[Degree]},60.\[Degree]];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSectorsAndMinorDihedral[{140.\[Degree],30.\[Degree],90.\[Degree],100.\[Degree]},50.\[Degree],OsculatingVectorNear->{0,0,1}];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSectorsAndMinorDihedral[{90.\[Degree],91.\[Degree],30.\[Degree],149.\[Degree]},50.\[Degree]];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSectorsAndMinorDihedral[{140.\[Degree],30.\[Degree],90.\[Degree],100.\[Degree]},-50.\[Degree],OsculatingVectorNear->{0,0,1}];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Options[MakeFoldVectorsFromSectorsAndMajorDihedral]={
OsculatingVectorNear->None
};
MakeFoldVectorsFromSectorsAndMajorDihedral::norotate="MakeFoldVectorsFromSectorsAndMajorDihedral could not rotate the system to the desired osculating vector.";
MakeFoldVectorsFromSectorsAndMajorDihedral[{\[Alpha]1_, \[Alpha]2_,\[Alpha]3_,\[Alpha]4_},\[Gamma]1_,opts___]:=Module[{da},
da=MakeDihedralsFromSectorsAndMajorDihedral[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4},\[Gamma]1,opts];
MakeFoldVectorsFromSectorsAndDihedrals[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4},da,opts]
]
Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSectorsAndMajorDihedral[{30.\[Degree],90.\[Degree],100.\[Degree],140.\[Degree]},90.\[Degree]];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSectorsAndMajorDihedral[{30.\[Degree],90.\[Degree],100.\[Degree],140.\[Degree]},90.\[Degree],OsculatingVectorNear->{0,0,1}];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSectorsAndMajorDihedral[{91.\[Degree],30.\[Degree],149.\[Degree],90.\[Degree]},60.\[Degree]];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSectorsAndMajorDihedral[{30.\[Degree],90.\[Degree],100.\[Degree],140.\[Degree]},-50.\[Degree],OsculatingVectorNear->{0,0,1}];
tobj=MakeTDegree4Vertex3D[dirs];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
]//ShowExample
Options[MakeFoldVectorsFromSubarcs]={
OsculatingVectorNear->None
};
MakeFoldVectorsFromSubarcs::badsubs="Subarcs `1` and `2` must have the same sign.";
MakeFoldVectorsFromSubarcs[g4_List,g2_List,s3_,s4_,\[Rho]_,opts___]:=Module[{ovn,ss,s1,s2,qq,a1,a2,a3,a4,g1,g3},
ovn=OsculatingVectorNear/.{opts}/.Options[MakeFoldVectorsFromSubarcs];
ss=Sign[s3];
If[ss!=Sign[s4],Message[MakeFoldVectorsFromSubarcs::badsubs,s3,s4];Abort[]];
s1=2 ArcTan[\[Rho] Tan[s3/2]];
s2=2 ArcTan[\[Rho] Tan[s4/2]];
qq=NormalizeReal[g2\[Cross]g4];If[!(ovn===None)&&qq . ovn<0,qq=-qq];(* osculating vector *)
a1=RotationMatrix3Du[-s1,g2] . qq;(* sector normal vectors *)
a2=RotationMatrix3Du[+s2,g2] . qq;
a3=RotationMatrix3Du[-s3,g4] . qq;
a4=RotationMatrix3Du[+s4,g4] . qq;
g1=NormalizeReal[a4\[Cross]a1];
g3=NormalizeReal[a3\[Cross]a2];
If[g1 . qq*ss<0,g1=-g1;g3=-g3];
{g1,g2,g3,g4}
]
(TestMakeT3DDegree4VertexCreaseVectorsFromSubarcs[args___]:=Module[{dirs,tobj},
dirs=MakeFoldVectorsFromSubarcs[args];
tobj=MakeTDegree4Vertex3D[dirs];
Print["OsculatingVector = ",tobj[OsculatingVector]];
Print["SectorAngles/\[Degree] = ",tobj[SectorAngles]/\[Degree]];
Print["DihedralAngles/\[Degree] = ",tobj[DihedralAngles]/\[Degree]];
Print["SubarcAngles/\[Degree] = ",tobj[SubarcAngles]/\[Degree]];
Degree4Vertex3DGraphicsTrio[tobj,ShowOsculatingVector->True]/.Vertex3DStyle[]
])//ShowExample;
TestMakeT3DDegree4VertexCreaseVectorsFromSubarcs[{0,-1.,0},NormalizeReal[{1.,1.,0}],70.\[Degree],50.\[Degree],0.75,OsculatingVectorNear->{0,0,1}]//ShowExample
TestMakeT3DDegree4VertexCreaseVectorsFromSubarcs[{0,-1.,0},NormalizeReal[{1.,1.,0}],70.\[Degree],50.\[Degree],0.75,OsculatingVectorNear->{0,0,-1}]//ShowExample
TestMakeT3DDegree4VertexCreaseVectorsFromSubarcs[{0,-1.,0},NormalizeReal[{-1.,1.,0}],70.\[Degree],50.\[Degree],0.75,OsculatingVectorNear->{0,0,1}]//ShowExample
TestMakeT3DDegree4VertexCreaseVectorsFromSubarcs[{0,-1.,0},NormalizeReal[{-1.,1.,0}],70.\[Degree],50.\[Degree],0.75,OsculatingVectorNear->{0,0,-1}]//ShowExample
TestMakeT3DDegree4VertexCreaseVectorsFromSubarcs[{0,-1.,0},NormalizeReal[{1.,1.,0}],-70.\[Degree],-50.\[Degree],0.75,OsculatingVectorNear->{0,0,1}]//ShowExample
TestMakeT3DDegree4VertexCreaseVectorsFromSubarcs[{0,-1.,0},NormalizeReal[{-1.,1.,0}],-70.\[Degree],-50.\[Degree],0.75,OsculatingVectorNear->{0,0,1}]//ShowExample
TestMakeT3DDegree4VertexCreaseVectorsFromSubarcs[{-0.6644630243886748`,-0.745606732423814`,0.05059140030220981`},{0.`,0.9659258262890683`,0.25881904510252063`},1.0471975511965976`,1.0471975511965976`,1,OsculatingVectorNear->{0.34202014332566855`,-0.24321034680169382`,0.9076733711903686`}]//ShowExample
MakeTDegree4Vertex3DFromSectorsAndDihedrals[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_},{\[Gamma]1_,\[Gamma]2_,\[Gamma]3_,\[Gamma]4_},opts___]:=Module[{gg},
gg=MakeFoldVectorsFromSectorsAndDihedrals[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4},{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4},opts];
MakeTDegree4Vertex3D[gg]
]
Module[{sa,da,tobj,gg,hg},
sa=MakeDevelopableAngles[{70.\[Degree],40.\[Degree],120.\[Degree]}];
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,-40.\[Degree]];
tobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da,OsculatingVectorNear->{0,0,1}];
Degree4Vertex3DGraphicsTrio[tobj]/.Vertex3DStyle[]
]//ShowExample
Options[MakeTDegree4Vertex3DFromSectorsAndMinorDihedral]={
OsculatingVectorNear->None
};
MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_},\[Gamma]1_,opts___]:=Module[{gg},
gg=MakeFoldVectorsFromSectorsAndMinorDihedral[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4},\[Gamma]1,opts];
MakeTDegree4Vertex3D[gg]
]
Module[{tobj,gg,hg},
tobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{70.\[Degree],40.\[Degree],120.\[Degree],130.\[Degree]},-40.\[Degree],OsculatingVectorNear->{0,0,1}];
Degree4Vertex3DGraphicsTrio[tobj]/.Vertex3DStyle[]
]//ShowExample
Options[MakeTDegree4Vertex3DFromSectorsAndMajorDihedral]={
OsculatingVectorNear->None
};
MakeTDegree4Vertex3DFromSectorsAndMajorDihedral[{\[Alpha]1_,\[Alpha]2_,\[Alpha]3_,\[Alpha]4_},\[Gamma]1_,opts___]:=Module[{gg},
gg=MakeFoldVectorsFromSectorsAndMajorDihedral[{\[Alpha]1,\[Alpha]2,\[Alpha]3,\[Alpha]4},\[Gamma]1,opts];
MakeTDegree4Vertex3D[gg]
]
Module[{tobj,gg,hg},
tobj=MakeTDegree4Vertex3DFromSectorsAndMajorDihedral[{40.\[Degree],120.\[Degree],130.\[Degree],70.\[Degree]},-90.\[Degree],OsculatingVectorNear->{0,0,1}];
Degree4Vertex3DGraphicsTrio[tobj]/.Vertex3DStyle[]
]//ShowExample
MakeTDegree4Vertex3DFromSubarcs[g4_List,g2_List,s3_,s4_,\[Rho]_,opts___]:=Module[{gg},
gg=MakeFoldVectorsFromSubarcs[g4,g2,s3,s4,\[Rho],opts];
MakeTDegree4Vertex3D[gg]]
Module[{tobj},
tobj=MakeTDegree4Vertex3DFromSubarcs[{-0.7071067811865475`,-0.7071067811865475`,0.`},{0.,1.,0.},10 \[Degree],10 \[Degree],1,OsculatingVectorNear->{0.,0.,-1.}];
Degree4Vertex3DGraphicsTrio[tobj,SectorAngleLabels->(Style[#, 16]&/@{"\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(4\)]\)"}),DihedralAngleLabels->(Style[#, 14]&/@{"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)" ,"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(4\)]\)"})]/.Vertex3DStyle[]
]//ShowExample
Module[{tobj},
tobj=MakeTDegree4Vertex3DFromSubarcs[NormalizeReal[{0,-1.,0}],NormalizeReal[{1.,1.,0}],40.\[Degree],60.\[Degree],1.0,OsculatingVectorNear->{0,0,1}];
Degree4Vertex3DGraphicsTrio[tobj,SectorAngleLabels->(Style[#, 16]&/@{"\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Alpha]\), \(4\)]\)"}),DihedralAngleLabels->(Style[#, 14]&/@{"\!\(\*SubscriptBox[\(\[Gamma]\), \(1\)]\)" ,"\!\(\*SubscriptBox[\(\[Gamma]\), \(2\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(3\)]\)","\!\(\*SubscriptBox[\(\[Gamma]\), \(4\)]\)"})]/.Vertex3DStyle[]
]//ShowExample
Manipulate[
Module[{tobj,vp,rs,gs},
vp={0,0,1000};
tobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{120\[Degree],90\[Degree],60\[Degree],90\[Degree]},g1 \[Degree], OsculatingVectorNear->vp];
rs=Vertex3DFoldedFormGraphics3D[tobj,ViewPoint->vp]/.Vertex3DStyle[];
gs=Vertex3DGaussianSphereGraphics3D[tobj,DihedralAngleLabels->None,ShowMidfoldVectors->True,ViewPoint->vp]/.Vertex3DStyle[];
GraphicsRow[{rs,gs}]],
{g1,0.1,179.9}]//ShowExample
DynamicModule[{sa,ba},
sa={120\[Degree],90\[Degree],40\[Degree],110\[Degree]};
ba=MinorFirstBindingDihedralAngles[sa];
Print["Binding angles/\[Degree] = ",ba/\[Degree]//N];
Manipulate[
Module[{tobj,vp,rs,gs},
vp={0,0,1000};
tobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[sa,g1 \[Degree], OsculatingVectorNear->vp];
rs=Vertex3DFoldedFormGraphics3D[tobj,ViewPoint->vp]/.Vertex3DStyle[];
gs=Vertex3DGaussianSphereGraphics3D[tobj,ShowMidfoldVectors->True,ViewPoint->vp]/.Vertex3DStyle[];
GraphicsRow[{rs,gs}]],
{g1,0.1,ba[[1]]/\[Degree]-1}]]//ShowExample
DynamicModule[{sa,ba},
sa={120\[Degree],30\[Degree],90\[Degree],120\[Degree]};
ba=MinorFirstBindingDihedralAngles[sa];
Print["Binding angles/\[Degree] = ",ba/\[Degree]//N];
Manipulate[
Module[{tobj,vp,rs,gs},
vp={0,0,1000};
tobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[sa,g1 \[Degree], OsculatingVectorNear->vp];
rs=Vertex3DFoldedFormGraphics3D[tobj,ViewPoint->vp]/.Vertex3DStyle[];
gs=Vertex3DGaussianSphereGraphics3D[tobj,ShowMidfoldVectors->True,ViewPoint->vp]/.Vertex3DStyle[];
GraphicsRow[{rs,gs}]],
{g1,0.1,ba[[1]]/\[Degree]-1}]]//ShowExample
Module[{sa,\[Gamma],n,w,ma,ba,da,vtobj},
sa={100.\[Degree],100.\[Degree],60.\[Degree],100.\[Degree]};(* sector angles *)
\[Gamma]=120\[Degree];
ma=MaximumDihedralAngles[sa];
Print["maximum angles/\[Degree] = ", ma/\[Degree]//N];
ba=MinorFirstBindingDihedralAngles[sa];
Print["binding angles/\[Degree] = ", ba/\[Degree]//N];
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,\[Gamma]];
Print["dihedral angles/\[Degree] = ", da/\[Degree]//N];
vtobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da];
GraphicsRow[{Vertex3DCreasePatternGraphics[vtobj],Vertex3DFoldedFormGraphics3D[vtobj]}/.Vertex3DStyle[]]
]//ShowErrorExample
BottomVertices::usage="TopVertices is a property of some TGraphs that identifies the bottom row of vertices in the pattern.";
TopVertices::usage="TopVertices is a property of some TGraphs that identifies the top row of vertices in the pattern.";
Options[MakeFlatFoldedStrip]={
EdgeTypes->Automatic
};
MakeFlatFoldedStrip::badbot="Bottom vertex positions `1` must be nondecreasing.";
MakeFlatFoldedStrip::badtop="Top vertex positions `1` must be nondecreasing.";
MakeFlatFoldedStrip::badtyp="EdgeType list `1` must have exactly 2 fewer entries than the number of points `2`.";
MakeFlatFoldedStrip[pts_List,{w_,\[Phi]_},opts___]:=Module[{et,tol,dlist,blist,alist,xctr,vbot,vtop,errg,verts,edges,types,addv,ibot,itop,tlist,tobj,verts2d},
et=EdgeTypes/.{opts}/.Options[MakeFlatFoldedStrip];
tol=SamePtTolerance/.{opts}/.Options[SamePtQ];
(* distances between points *)
dlist=Mag/@(Drop[pts,1]-Drop[pts,-1]);
(* bend angles at interior points *)
blist=MapThread[RotationAngle[#2-#1,#3-#2]&,{Drop[pts,-2],Drop[Drop[pts,-1],1],Drop[pts,2]}];
(* \[Alpha]1 sector angles at each vertex *)
alist=Join[{90\[Degree]},Table[With[{b=blist[[i]]},If[OddQ[i],If[b>=0,b/2,\[Pi]+b/2],\[Pi]-b/2]],{i,Length[blist]}],{90\[Degree]}];
(* vertices of cp *)
xctr=FoldList[Plus,0,dlist];
vbot=MapThread[LineInt2D[{0,-w/2},U[-\[Phi]/2],{#1,0},U[#2]]&,{xctr,alist}];
vtop=MapThread[LineInt2D[{0,w/2},U[\[Phi]/2],{#1,0},U[#2]]&,
{xctr,alist}];
errg:=Graphics[{Style[{Line[vbot],Line[vtop],MapThread[Line[{#1,#2}]&,{vbot,vtop}]},Red],Style[{Point/@vbot,Point/@vtop},Darker[Red],PointSize[.01]],Style[Point[{#,0}]&/@xctr,Black,PointSize[.01]]},Axes->True];
If[Or@@(#<-tol&/@(Drop[First/@vbot,1]-Drop[First/@vbot,-1])),Print[errg];Message[MakeFlatFoldedStrip::badbot,First/@vbot];Abort[]];
If[Or@@(#<-tol&/@(Drop[First/@vtop,1]-Drop[First/@vtop,-1])),Print[errg];Message[MakeFlatFoldedStrip::badtop,First/@vtop];Abort[]];
verts=edges=types={};
(* addv returns the index of a vertex in verts, adding if needed *)
addv[p_]:=Catch[Do[If[SamePtQ[verts[[i]],p,opts],Throw[i]],{i,Length[verts]}];AppendTo[verts,p];Throw[Length[verts]]];
ibot=addv/@vbot;(* indices of bottom vertices *)
itop=addv/@vtop;(* indices of top vertices *)
(* build edge and types lists *)
tlist=If[et===Automatic,Table[If[OddQ[i],V,M],{i,Length[blist]}],et];
If[Length[tlist]!=Length[blist],Message[MakeFlatFoldedStrip::badtyp,tlist,pts];Abort[]];
(* bottom edges *)
Do[If[ibot[[i]]!=ibot[[i+1]],AppendTo[edges,{ibot[[i]],ibot[[i+1]]}];AppendTo[types,B]],{i,Length[ibot]-1}];
(* cross edges *)
Do[If[ibot[[i]]!=itop[[i]],AppendTo[edges,{ibot[[i]],itop[[i]]}];AppendTo[types,If[i==1||i==Length[ibot],B,tlist[[i-1]]]]],{i,Length[ibot]}];
(* top edges *)
Do[If[itop[[i]]!=itop[[i+1]],AppendTo[edges,{itop[[i]],itop[[i+1]]}];AppendTo[types,B]],{i,Length[itop]-1}];
tobj=MakeTPlaneGraphAssigned[verts,edges,{},types];
tobj=FoldGraph2D[tobj,TypeToFlatFoldAngle[types]];
(* translate folded form to align with original path *)
verts2d=tobj[Vertices2D];
verts2d=pts[[1]]+RotationMatrix2D[AbsoluteAngle[pts[[2]]-pts[[1]]]] . #&/@verts2d;
tobj//ReplaceProperty[Vertices2D->verts2d]//AddProperties[{BottomVertices->Union[ibot],TopVertices->Union[itop]}]]
Module[{pts,w,tobj},
pts={{0,0},{1,.2},{1,1},{.5,.5}};
w=.3;
tobj=MakeFlatFoldedStrip[pts,{w,0}];
GraphicsRow[{
CreasePatternGraphics[tobj],
Show[VisibleFoldedFormGraphics[tobj],Graphics[
Style[Line[pts],Red,Thickness[.02]]]]}]/.OrigamiStyle[]
]//ShowExample
Module[{pts,w,tobj},
pts={{0,0},{1,-.2},{1,-1},{.5,-.5}};
w=.3;
tobj=MakeFlatFoldedStrip[pts,{w,0}];
GraphicsRow[{
CreasePatternGraphics[tobj],
Show[VisibleFoldedFormGraphics[tobj],Graphics[
Style[Line[pts],Red,Thickness[.02]]]]}]/.OrigamiStyle[]
]//ShowExample
Module[{pts,w,tobj},
SeedRandom[0];
pts=Table[{Random[],Random[]},{10}];
w=.08;
tobj=MakeFlatFoldedStrip[pts,{w,0}];
GraphicsRow[{
CreasePatternGraphics[tobj],
Show[VisibleFoldedFormGraphics[tobj],Graphics[
Style[Line[pts],Red,Thickness[.02]]]]}]/.OrigamiStyle[]
]//ShowExample
Module[{pts,w,tobj},
pts={{0,0},{1,.2},{1,1},{.5,.5}};
w=.3;
tobj=MakeFlatFoldedStrip[pts,{0,10\[Degree]}];
GraphicsRow[{
CreasePatternGraphics[tobj],
Show[VisibleFoldedFormGraphics[tobj],Graphics[
Style[Line[pts],Red,Thickness[.02]]]]}]/.OrigamiStyle[]
]//ShowExample
Module[{pts,w,tobj},
pts={{0,0},{1,.2},{1,1},{.5,.5}};
w=.3;
tobj=MakeFlatFoldedStrip[pts,{.2,5\[Degree]}];
GraphicsRow[{
CreasePatternGraphics[tobj],
Show[VisibleFoldedFormGraphics[tobj],Graphics[
Style[Line[pts],Red,Thickness[.02]]]]}]/.OrigamiStyle[]
]//ShowExample
MakeFlatFoldedStrip[pts_List,w_,opts___]:=MakeFlatFoldedStrip[pts,{w,0},opts]
MakeTroublewitStrip::badlists="The distances `1` and angles `2` must have the sam number of entries.";
MakeTroublewitStrip[p_List,dists_List,angles_List]:=Module[{rr,pts},
If[Length[dists]!=Length[angles],Message[MakeTroublewitStrip::badlists,dists,angles];Abort[]];
rr=MapThread[#1 U[#2]&,{dists,angles}];
pts=FoldList[Plus,p,rr];
MakeFlatFoldedStrip[pts,1]]
Module[{p,dists,angles,tobj},
p={1.1,0};
dists={3,3,7,3,3};
angles={179\[Degree],0\[Degree],80\[Degree],170\[Degree],50\[Degree]};
tobj=MakeTroublewitStrip[p,dists,angles];
GraphicsRow[{
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
MakeCanonicalTroublewitStrip[p_List,angles_List]:=MakeTroublewitStrip[p,{3,3,7,3,3},angles]
Module[{p,angles,tobj},
p={1.1,0};
angles={179\[Degree],0\[Degree],80\[Degree],170\[Degree],50\[Degree]};
tobj=MakeCanonicalTroublewitStrip[p,angles];
GraphicsRow[{
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,v1,v2,rm,types,verts3d,tobj1,tobj2,soln,\[Theta]0},
verts=Join[{{0,0}},Table[U[i \[Pi]/3],{i,0,5}]];
edges={{1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{2,3},{3,4},{4,5},{5,6},{6,7},{7,2}};
v1={Cos[\[Theta]],0,Sin[\[Theta]]};
v2={Cos[\[Psi]],0,Sin[\[Psi]]};
rm[i_]:=RotationZMatrix3D[i \[Pi]/3];
types=Which[
\[Theta]>0,{V,M,V,M,V,M,B,B,B,B,B,B},
\[Theta]<0,{M,V,M,V,M,V,B,B,B,B,B,B},
True,{U,U,U,U,U,U,B,B,B,B,B,B}];
v1={Cos[\[Theta]],0,Sin[\[Theta]]};
v2={Cos[\[Psi]],0,Sin[\[Psi]]};
rm[i_]:=RotationZMatrix3D[i \[Pi]/3];
verts3d={{0,0,0},v1,rm[1] . v2,rm[2] . v1,rm[3] . v2,rm[4] . v1,rm[5] . v2};
(* solve for \[Psi]. In general, there will be two solutions. *)
soln=Simplify[Solve[Mag2[v1-rm[1] . v2]==1,\[Psi]]/.{ArcTan[x_,y_]:>ArcTan[y/x],C[1]->0},{\[Theta]>-\[Pi]/2,\[Theta]<\[Pi]/2}];
Print["Solutions are: ",soln];
(* Plot the two solutions. Note that for \[Theta] less than about 0.5, there are two solutions, corresponding to the two possible positions of the v2 vertices. *)
Plot[\[Psi]/.#&/@soln,{\[Theta],-\[Pi]/2,\[Pi]/2}]//Print;
(* At the discontinuities, the solution switches to a spurious solution. Check this by plotting the error function for our equation; it should be zero for a valid solution. *)
Plot[(Mag2[v1-rm[1] . v2]-1)/.#&/@soln,{\[Theta],-\[Pi]/2,\[Pi]/2}]//Print;
(* Now show two examples within the valid range. *)
\[Theta]0=25.\[Degree];
tobj1=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types/.\[Theta]->\[Theta]0]//AddTGraph3D[verts3d/.soln[[1]]/.\[Theta]->\[Theta]0]//RecalcFoldAngles//TweakFoldAngles[types/.\[Theta]->\[Theta]0];
tobj2=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types/.\[Theta]->\[Theta]0]//AddTGraph3D[verts3d/.soln[[2]]/.\[Theta]->\[Theta]0]//RecalcFoldAngles//TweakFoldAngles[types/.\[Theta]->\[Theta]0];
GraphicsRow[{FoldedFormGraphics3D[tobj1],FoldedFormGraphics3D[tobj2]}]/.OrigamiStyle[]
]//ShowExample
MakeHexagonVertex[\[Theta]_]:=Module[{verts,edges,v1,\[Psi],v2,rm,types,verts3d,foldangles,tobj},
verts=Join[{{0,0}},Table[U[i \[Pi]/3],{i,0,5}]];
edges={{1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{2,3},{3,4},{4,5},{5,6},{6,7},{7,2}};
types=Which[
\[Theta]>0,{V,M,V,M,V,M,B,B,B,B,B,B},
\[Theta]<0,{M,V,M,V,M,V,B,B,B,B,B,B},
True,{U,U,U,U,U,U,B,B,B,B,B,B}];
v1={Cos[\[Theta]],0,Sin[\[Theta]]};
v2={Cos[\[Psi]],0,Sin[\[Psi]]}/.\[Psi]->ArcTan[((2-\[Sqrt]3 Cos[\[Theta]]) Sin[\[Theta]])/(Cos[\[Theta]]+2 \[Sqrt]3 Sin[\[Theta]]^2)];
rm[i_]:=RotationZMatrix3D[i \[Pi]/3];
verts3d={{0,0,0},v1,rm[1] . v2,rm[2] . v1,rm[3] . v2,rm[4] . v1,rm[5] . v2};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types]//AddTGraph3D[verts3d]//RecalcFoldAngles//TweakFoldAngles[types]]
DynamicModule[{tobj},
Manipulate[
tobj=MakeHexagonVertex[qq \[Degree]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[],
{{qq,0},-90,90}]
]//ShowExample
MakeCubeBox[\[Gamma]_]:=Module[{verts,edges,f,types,foldangles,tobj},
verts={{0,0},{1,0},{2,0},{3,0},{3,1},{2,1},{1,1},{0,1},{-1,1},{-1,0},{0,-1},{1,-1},{1,2},{0,2}};
edges={{8,1},{1,2},{2,7},{7,8},{3,6},
{1,11},{11,12},{12,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,13},{13,14},{14,8},{8,9},{9,10},{10,1}};
f=FoldAngleToType[\[Gamma]];
types={f,f,f,f,f,B,B,B,B,B,B,B,B,B,B,B,B,B,B};
foldangles={\[Gamma],\[Gamma],\[Gamma],\[Gamma],\[Gamma],0,0,0,0,0,0,0,0,0,0,0,0,0,0};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types]//AddTGraph3D[];
FoldGraph3D[tobj,foldangles]]
DynamicModule[{tobj},
Manipulate[
tobj=MakeCubeBox[gg \[Degree]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[],
{{gg,0},-90,90}]
]//ShowExample
Clear[CubeBoxGraph3DAssigned];
AddTGraphExample[CubeBoxGraph3DAssigned,MakeCubeBox[90\[Degree]]];
Module[{tobj},
tobj=CubeBoxGraph3DAssigned;
GraphicsRow[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
FlapFoldAngle::usage="FlapFoldAngle is an option to MakeFlapCubeBox that specifies the final fold angle to be used on the box flaps.";
FlapAngle::usage="FlapAngle is an option to MakeFlapCubeBox that specifies the bevel angle to be used on the box flaps.";
FlapWidth::usage="FlapWidth is an option to MakeFlapCubeBox that specifies the width of the box flaps.";
Options[MakeFlapCubeBox]={
FlapFoldAngle->45\[Degree],
FlapAngle->45\[Degree],
FlapWidth->1/5
};
MakeFlapCubeBox::badflap="Flap width `1` is too large for flap angle `2`.";
MakeFlapCubeBox[\[Gamma]_,opts___]:=Module[{ffa,fa,fw,fi,verts,edges,f,ff,types,foldangles,tobj},
ffa=FlapFoldAngle/.{opts}/.Options[MakeFlapCubeBox];
fa=FlapAngle/.{opts}/.Options[MakeFlapCubeBox];
fw=FlapWidth/.{opts}/.Options[MakeFlapCubeBox];
fi=fw Cot[fa];(* inset distance *)
If[fi>=1/2,Message[MakeFlapCubeBox::badflap,fw,fa];Abort[]];
verts={{0,0},{1,0},{2,0},{3,0},{3,1},{2,1},{1,1},{0,1},{-1,1},{-1,0},{0,-1},{1,-1},{1,2},{0,2},
{1+fi,-fw},{2-fi,-fw},{2+fi,-fw},{3-fi,-fw},{3+fw,fi},{3+fw,1-fi},{3-fi,1+fw},{2+fi,1+fw},{2-fi,1+fw},{1+fi,1+fw},{-fi,1+fw},{-1+fi,1+fw},{-1+fi,-fw},{-fi,-fw}};
edges={{8,1},{1,2},{2,7},{7,8},{3,6},
{1,11},{11,12},{12,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,13},{13,14},{14,8},{8,9},{9,10},{10,1},
{2,15},{15,16},{16,3},{3,17},{17,18},{18,4},{4,19},{19,20},{20,5},{5,21},{21,22},{22,6},{6,23},{23,24},{24,7},{8,25},{25,26},{26,9},{10,27},{27,28},{28,1}};
f=FoldAngleToType[\[Gamma]];
ff=FoldAngleToType[ffa];
types={f,f,f,f,f,B,B,B,ff,ff,ff,ff,ff,B,B,B,ff,ff,ff,
B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B,B};
foldangles={\[Gamma],\[Gamma],\[Gamma],\[Gamma],\[Gamma],0,0,0,ffa,ffa,ffa,ffa,ffa,0,0,0,ffa,ffa,ffa,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types]//AddTGraph3D[];
FoldGraph3D[tobj,foldangles]]
DynamicModule[{tobj},
Manipulate[
tobj=MakeFlapCubeBox[gg \[Degree],FlapFoldAngle->45\[Degree](gg/90)];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[],
{{gg,0},-90,90}]
]//ShowExample
Clear[FlapCubeBoxGraph3DAssigned];
AddTGraphExample[FlapCubeBoxGraph3DAssigned,MakeFlapCubeBox[90\[Degree],FlapFoldAngle->45\[Degree]]];
Module[{tobj},
tobj=FlapCubeBoxGraph3DAssigned;
GraphicsRow[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
MakeUnitTetrahedron[\[Gamma]_]:=Module[{verts,edges,tobj,a,types,foldangles},
verts={{0,0},{1,0},{2,0},{1/2,\[Sqrt]3/2},{3/2,\[Sqrt]3/2},{1,\[Sqrt]3}};
edges={{1,2},{2,3},{1,4},{2,4},{2,5},{3,5},{4,5},{4,6},{5,6}};
types={B,B,B,V,V,B,V,B,B};
tobj=MakeTGraphAssigned[verts,edges,{},types]//AddTPlaneGraph;
foldangles={0,0,0,\[Gamma],\[Gamma],0,\[Gamma],0,0};
tobj=FoldGraph3D[tobj,foldangles,StationaryFace->3];
tobj=ReassignGraphAssigned[tobj,foldangles]]
DynamicModule[{gmax,tobj},
gmax=N[(\[Pi]-ArcSec[3])/\[Degree]];
Manipulate[
tobj=MakeUnitTetrahedron[gg \[Degree]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[],
{{gg,0},-gmax,gmax}]
]//ShowExample
Clear[UnitTetrahedronGraph3DAssigned];
AddTGraphExample[UnitTetrahedronGraph3DAssigned,MakeUnitTetrahedron[N[\[Pi]-ArcSec[3]]]];
Module[{tobj},
tobj=UnitTetrahedronGraph3DAssigned;
GraphicsRow[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
OricepsDimensions::usage="OricepsDimensions is an option to MakeOriceps that specifies the dimensions of the Oriceps.";
Options[MakeOriceps]={
OricepsDimensions->{.5,1.0,5.0,.5,1.0,2.2}
};
MakeOriceps[\[Gamma]_,opts___]:=Module[{od,x1,x2,x3,y1,y2,y3,verts,edges,tobj,a,g1,g2,g3,g4,types,sangles,foldangles},
od=OricepsDimensions/.{opts}/.Options[MakeOriceps];
{x1,x2,x3,y1,y2,y3}=od;
verts={{-x1,-y3},{x1,-y3},
{-x3,-y1},{-x2,-y2},{x2,-y2},{x3,-y1},
{-x3,y1},{-x2,y2},{x2,y2},{x3,y1},
{-x1,y3},{x1,y3}};
edges={{3,1},{1,2},{2,6},{1,4},{2,5},{3,4},{4,5},{5,6},{3,7},{4,8},{5,9},{6,10},{7,8},{8,9},{9,10},{8,11},{9,12},{7,11},{11,12},{12,10}};
types={B,B,B,V,V,V,M,V,B,V,V,B,V,M,V,V,V,B,B,B};
tobj=MakeTGraphAssigned[verts,edges,{},types]//AddTPlaneGraph;
(* compute relevant dihedral angles *)
sangles=RotationAngles[verts[[9]],verts[[{5,10,12,8}]]];
{g1,g2,g3,g4}=MakeDihedralsFromSectorsAndMajorDihedral[sangles,\[Gamma],AllowSelfIntersection->True];
foldangles={0,0,0,g3,g3,g2,g4,g2,0,g1,g1,0,g2,g4,g2,g3,g3,0,0,0};
tobj=FoldGraph3D[tobj,foldangles,StationaryFace->5];
tobj=ReassignGraphAssigned[tobj,foldangles];
(* Rotate to point in +x direction *)
ReplacePropertyIn[tobj,Vertices3D->(RotationYMatrix3D[\[Pi]/2] . #&/@tobj[Vertices3D])]]
DynamicModule[{gmax,tobj},
gmax=103.0;
Manipulate[
tobj=MakeOriceps[gg \[Degree]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[],
{{gg,0.1},0.1,gmax}]
]//ShowExample
Clear[OricepsGraph3DAssigned];
AddTGraphExample[OricepsGraph3DAssigned,MakeOriceps[103.0\[Degree]]];
Module[{tobj},
tobj=OricepsGraph3DAssigned;
GraphicsRow[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
TLinearChain::usage="TLinearChain is a TObj class that describes a 2xN quad mesh.";
RegisterTClass[TLinearChain,{TGraph,TAssigned}];
VerticesSectorAngles::usage="VerticesSectorAngles is a TLinearChain property that describes the four sector angles at each of the vertices along the spine of the linear chain.";
MakeTLinearChain::badsecs="Vertex sectors list `1` should be a non-empty list of length-4 lists of sector angles.";
MakeTLinearChain::badlists="Length `1` of vertex sectors list `2` should be 1 more than length `3` of lengths list `4`.";
MakeTLinearChain::badtypes="Length `1` of lengths list `2` should be equal to length `3` of types list `4`.";
MakeTLinearChain[aa_List,dd_List,tt_List,{wr_,wl_}]:=Module[{wrd,wld,p,\[Phi],verts,edges,faces,types,nv,t2,t4},
If[ListEmptyQ[aa]||Union[Length/@aa]!={4},Message[MakeTLinearChain::badsecs,aa];Abort[]];
If[Length[aa]!=Length[dd]+1,Message[MakeTLinearChain::badlists,Length[aa],aa,Length[dd],dd];Abort[]];
If[Length[dd]!=Length[tt],Message[MakeTLinearChain::badtypes,Length[dd],dd,Length[tt],tt];Abort[]];
(* initialize *)
wrd=wr Csc[aa[[1,1]]];
wld=wl Csc[aa[[1,4]]];
p={0,0};(* current vertex on spine *)
\[Phi]=0;(* absolute angle to next vertex *)
verts={wrd U[-aa[[1,4]]],p,wld U[aa[[1,1]]]};
edges={{1,2},{2,3}};
faces={};
types={B,B};
(* loop *)
Do[
nv=Length[verts];
p+=dd[[i]]U[\[Phi]];
\[Phi]+=(\[Pi]-(aa[[i+1,1]]+aa[[i+1,2]]));
wrd=wr \[Sqrt](Csc[aa[[i+1,1]]]Csc[aa[[i+1,2]]]);
wld=wl \[Sqrt](Csc[aa[[i+1,4]]]Csc[aa[[i+1,3]]]);
JoinTo[verts,{p+wrd U[\[Phi]-aa[[i+1,4]]],p,p+wld U[\[Phi]+aa[[i+1,1]]]}];
JoinTo[edges,{{nv-2,nv+1},{nv-1,nv+2},{nv,nv+3}}];
JoinTo[types,{B,tt[[i]],B}];
JoinTo[faces,{{nv-2,nv+1,nv+2,nv-1},{nv-1,nv+2,nv+3,nv}}];

JoinTo[edges,{{nv+1,nv+2},{nv+2,nv+3}}];
If[i!=Length[dd],
If[tt[[i]]===tt[[i+1]],
If[Min[aa[[i+1,1]],aa[[i+1,2]]]<Min[aa[[i+1,3]],aa[[i+1,4]]],
t4=tt[[i]];t2=InvertFoldType[tt[[i]]],
t2=tt[[i]];t4=InvertFoldType[tt[[i]]]
],
(* tt\[LeftDoubleBracket]i\[RightDoubleBracket] \[NotEqual] tt\[LeftDoubleBracket]i+1\[RightDoubleBracket] *)
If[Min[aa[[i+1,2]],aa[[i+1,3]]]<Min[aa[[i+1,1]],aa[[i+1,4]]],
t4=tt[[i+1]];t2=tt[[i+1]],
t2=tt[[i]];t4=tt[[i]]]
];
JoinTo[types,{t4,t2}],
JoinTo[types,{B,B}]
];
,{i,Length[dd]}];
MakeTGraphAssigned[verts,edges,faces,types]//AddProperty[VerticesSectorAngles->aa]//AddClass[TLinearChain]]
MakeTLinearChain[aa_List,dd_List,tt_List,w_]:=MakeTLinearChain[aa,dd,tt,{w,w}]
Module[{aa,dd,tt,tobj},
aa={
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]},
{60\[Degree],120\[Degree],120\[Degree],60\[Degree]},
{120\[Degree],60\[Degree],60\[Degree],120\[Degree]},
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]}};
dd={1,1,1};
tt={V,M,V};
tobj=MakeTLinearChain[aa,dd,tt,0.33];
Print[GetAllRules[tobj]//ColumnForm];
Print[GraphGraphics[tobj]];
CreasePatternGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
Module[{aa,dd,tt,tobj},
aa={
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]},
{80\[Degree],80\[Degree],100\[Degree],100\[Degree]},
{80\[Degree],80\[Degree],100\[Degree],100\[Degree]},
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]}};
dd={1,1,1};
tt={V,V,V};
tobj=MakeTLinearChain[aa,dd,tt,0.33];
CreasePatternGraphics[tobj]/.OrigamiStyle[]
]//ShowExample
RotateToZ::usage="RotateToZ is an option to FoldLinearChain that specifies to rotate the folded form so that the first fold is oriented toward the +z direction.";
Options[FoldLinearChain]={
RotateToZ->True
};
FoldLinearChain::badtypes="Unassigned types `1` encountered along spine of linear chain.";
FoldLinearChain[tobj_TObj,\[Gamma]_,opts___]:=Module[{rz,aa,types,foldangles,\[Gamma]\[Gamma],gg,tobj1},
AssertClass[tobj,TLinearChain];
rz=RotateToZ/.{opts}/.Options[FoldLinearChain];
{aa,types}=GetValues[tobj,{VerticesSectorAngles,EdgeTypes}];
foldangles=Table[0,{Length[types]}];
foldangles[[4]]=\[Gamma]\[Gamma]=\[Gamma];
Do[
(*
Print["types across vertex = ",{types\[LeftDoubleBracket]5i-6\[RightDoubleBracket],types\[LeftDoubleBracket]5i-1\[RightDoubleBracket]}];
Print["sector angles/\[Degree] = ",aa\[LeftDoubleBracket]i\[RightDoubleBracket]/\[Degree]//N];
*)
If[!(TypeFoldedQ[types[[5i-6]]]&&TypeFoldedQ[types[[5i-1]]]),Message[FoldLinearChain::badtypes,{types[[5i-6]],types[[5i-1]]}];Abort[]];
If[types[[5i-6]]===types[[5i-1]],
(* same type, so major *)
gg=RotateRight[MakeDihedralsFromSectorsAndMajorDihedral[RotateLeft[aa[[i]],2],\[Gamma]\[Gamma]],2],
(* opposite type, so minor *)
gg=RotateRight[MakeDihedralsFromSectorsAndMinorDihedral[RotateLeft[aa[[i]],2],\[Gamma]\[Gamma]],2]
];
(*
Print["dihedral angles at vertex = ",gg/\[Degree]//N];
*)
\[Gamma]\[Gamma]=foldangles[[5i-1]]=gg[[1]];
foldangles[[5i-3]]=gg[[2]];
foldangles[[5i-4]]=gg[[4]];
,{i,2,Length[aa]-1}];
tobj1=FoldGraph3D[tobj,foldangles];
tobj1=tobj1//ReplaceProperty[EdgeTypes->FoldAngleToType[foldangles]];
If[rz,
tobj1//ReplaceProperty[Vertices3D->(RotationMatrix3Du[-\[Gamma]/2,{1,0,0}] . #&/@tobj1[Vertices3D])],
tobj1]]
DynamicModule[{aa,dd,tt,tobj,tobj1},
aa={
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]},
{60\[Degree],120\[Degree],120\[Degree],60\[Degree]},
{120\[Degree],60\[Degree],60\[Degree],120\[Degree]},
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]}};
dd={1,2,1};
tt={V,M,V};
tobj=MakeTLinearChain[aa,dd,tt,0.33];
CreasePatternGraphics[tobj]/.OrigamiStyle[]//Print;
Manipulate[
tobj1=FoldLinearChain[tobj,\[Gamma] \[Degree]];
FoldedFormGraphics3D[tobj1]/.OrigamiStyle[],
{\[Gamma],1,179}]
]//ShowExample
DynamicModule[{aa,dd,tt,tobj,tobj1},
aa={
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]},
{60\[Degree],120\[Degree],120\[Degree],60\[Degree]},
{120\[Degree],60\[Degree],60\[Degree],120\[Degree]},
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]}};
dd={1,2,1};
tt={M,V,M};
tobj=MakeTLinearChain[aa,dd,tt,0.33];
CreasePatternGraphics[tobj]/.OrigamiStyle[]//Print;
Manipulate[
tobj1=FoldLinearChain[tobj,\[Gamma] \[Degree]];
FoldedFormGraphics3D[tobj1]/.OrigamiStyle[],
{\[Gamma],-1,-179}]
]//ShowExample
DynamicModule[{aa,dd,tt,tobj,tobj1},
aa={
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]},
{80\[Degree],80\[Degree],100\[Degree],100\[Degree]},
{80\[Degree],80\[Degree],100\[Degree],100\[Degree]},
{90\[Degree],90\[Degree],90\[Degree],90\[Degree]}};
dd={1,2,1};
tt={V,V,V};
tobj=MakeTLinearChain[aa,dd,tt,0.33];
CreasePatternGraphics[tobj]/.OrigamiStyle[]//Print;
Manipulate[
tobj1=FoldLinearChain[tobj,\[Gamma] \[Degree]];
FoldedFormGraphics3D[tobj1]/.OrigamiStyle[],
{\[Gamma],1,179}]
]//ShowExample
MakeMajorConnectedUnitChain[sectorangles_List, type_,n_, {wr_,wl_}]:=MakeTLinearChain[Table[sectorangles,{n+1}],Table[1,{n}],Table[type,{n}],{wr,wl}]
MakeMajorConnectedUnitChain[sectorangles_List, type_,n_, w_]:=MakeMajorConnectedUnitChain[sectorangles,type,n,{w,w}]
Module[{sa,\[Gamma],n,w,da,vtobj,tobj},
sa={70.\[Degree],70.\[Degree],110.\[Degree],110.\[Degree]};(* sector angles *)
\[Gamma]=90\[Degree];
n=6;
w=0.33;
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]];
vtobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da];
tobj=MakeMajorConnectedUnitChain[sa,FoldAngleToType[\[Gamma]],n,w];
tobj=FoldLinearChain[tobj,\[Gamma]];
GraphicsRow[{Vertex3DCreasePatternGraphics[vtobj],Vertex3DFoldedFormGraphics3D[vtobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.Vertex3DStyle[]]
]//ShowExample
Module[{sa,\[Gamma],n,w,da,vtobj,tobj},
sa={70.\[Degree],70.\[Degree],110.\[Degree],110.\[Degree]};(* sector angles *)
\[Gamma]=-90\[Degree];
n=6;
w=0.33;
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]];
vtobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da];
tobj=MakeMajorConnectedUnitChain[sa,FoldAngleToType[\[Gamma]],n,w];
tobj=FoldLinearChain[tobj,\[Gamma]];
GraphicsRow[{Vertex3DCreasePatternGraphics[vtobj],Vertex3DFoldedFormGraphics3D[vtobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.Vertex3DStyle[]]
]//ShowExample
Module[{sa,\[Gamma],n,w,da,vtobj,tobj},
sa={70.\[Degree],40.\[Degree],110.\[Degree],140.\[Degree]};(* sector angles *)
\[Gamma]=90\[Degree];
n=5;
w=0.33;
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]];
vtobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da];
tobj=MakeMajorConnectedUnitChain[sa,FoldAngleToType[\[Gamma]],n,w];
tobj=FoldLinearChain[tobj,\[Gamma]];
GraphicsRow[{Vertex3DCreasePatternGraphics[vtobj],Vertex3DFoldedFormGraphics3D[vtobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.Vertex3DStyle[]]
]//ShowExample
Module[{sa,\[Gamma],n,w,da,vtobj,tobj},
sa={70.\[Degree],40.\[Degree],120.\[Degree],130.\[Degree]};(* sector angles *)
\[Gamma]=70.\[Degree];
n=5;
w=0.33;
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]];
vtobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da];
tobj=MakeMajorConnectedUnitChain[sa,FoldAngleToType[\[Gamma]],n,w];
tobj=FoldLinearChain[tobj,\[Gamma]];
GraphicsRow[{Vertex3DCreasePatternGraphics[vtobj],Vertex3DFoldedFormGraphics3D[vtobj],FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.Vertex3DStyle[]]
]//ShowExample
MakeMinorConnectedUnitChain[sectorangles_List, type_,n_, {wr_,wl_}]:=MakeTLinearChain[Table[sectorangles,{n+1}],Table[1,{n}],Table[If[Mod[i,2]==1,type,InvertFoldType[type]],{i,n}],{wr,wl}]
MakeMinorConnectedUnitChain[sectorangles_List, type_,n_, w_]:=MakeMinorConnectedUnitChain[sectorangles,type,n,{w,w}]
Module[{sa,\[Gamma],n,w,da,vtobj,tobj},
sa={70.\[Degree],40.\[Degree],120.\[Degree],130.\[Degree]};(* sector angles *)
\[Gamma]=40.\[Degree];
n=5;
w=0.33;
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,\[Gamma]];
vtobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da];
tobj=MakeMinorConnectedUnitChain[sa,FoldAngleToType[\[Gamma]],n,w];
tobj=FoldLinearChain[tobj,\[Gamma]];
GraphicsRow[{Vertex3DCreasePatternGraphics[vtobj],Vertex3DFoldedFormGraphics3D[vtobj],FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.Vertex3DStyle[]]
]//ShowExample
MakeAlternatingMajorConnectedUnitChain[sectorangles_List, type_,n_, {wr_,wl_}]:=MakeTLinearChain[Table[If[Mod[i,2]==1,sectorangles,RotateLeft[sectorangles,2]],{i,n+1}],Table[1,{n}],Table[type,{n}],{wr,wl}]
MakeAlternatingMajorConnectedUnitChain[sectorangles_List, type_,n_, w_]:=MakeAlternatingMajorConnectedUnitChain[sectorangles,type,n,{w,w}]
Module[{sa,\[Gamma],n,w,da,vtobj,tobj},
sa={100.\[Degree],60.\[Degree],100.\[Degree],100.\[Degree]};(* sector angles *)
\[Gamma]=120\[Degree];
n=6;
w=0.5;
da=MakeDihedralsFromSectorsAndMajorDihedral[sa,\[Gamma]];
vtobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da];
tobj=MakeAlternatingMajorConnectedUnitChain[sa,FoldAngleToType[\[Gamma]],n,w];
tobj=FoldLinearChain[tobj,\[Gamma]];
GraphicsRow[{Vertex3DCreasePatternGraphics[vtobj],Vertex3DFoldedFormGraphics3D[vtobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.Vertex3DStyle[]]
]//ShowExample
MakeAlternatingMinorConnectedUnitChain[sectorangles_List, type_,n_, {wr_,wl_}]:=MakeTLinearChain[Table[If[Mod[i,2]==1,sectorangles,RotateLeft[sectorangles,2]],{i,n+1}],Table[1,{n}],Table[If[Mod[i,2]==1,type,InvertFoldType[type]],{i,n}],{wr,wl}]
MakeAlternatingMinorConnectedUnitChain[sectorangles_List, type_,n_, w_]:=MakeAlternatingMinorConnectedUnitChain[sectorangles,type,n,{w,w}]
Module[{sa,\[Gamma],n,w,da,vtobj,tobj},
sa={100.\[Degree],100.\[Degree],60.\[Degree],100.\[Degree]};(* sector angles *)
\[Gamma]=10\[Degree];
n=6;
w=0.5;
da=MakeDihedralsFromSectorsAndMinorDihedral[sa,\[Gamma]];
vtobj=MakeTDegree4Vertex3DFromSectorsAndDihedrals[sa,da];
tobj=MakeAlternatingMinorConnectedUnitChain[sa,FoldAngleToType[\[Gamma]],n,w];
tobj=FoldLinearChain[tobj,\[Gamma]];
GraphicsRow[{Vertex3DCreasePatternGraphics[vtobj],Vertex3DFoldedFormGraphics3D[vtobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.Vertex3DStyle[]]
]//ShowExample
TSpaceCurve::usage="TSpaceCurve is a TObj class that describes a folded V-shaped trough in 3D that follows a specified space curve.";
RegisterTClass[TSpaceCurve,{TGraph3D,TAssigned}];
SpaceCurveMaximumWidth::usage="SpaceCurveMaximumWidth is a TObj property that specifies the maximum width of the unfolded space curve.";
SpaceCurveInteriorVertices::usage="SpaceCurveInteriorVertices is a TObj property that specifies the vertex parameters for all of the interior vertices of a space curve.";
SpaceCurveTorsion::usage="SpaceCurveTorsion is a TObj property that specifies the torsion values for all of the line segments of the space curve.";
SpaceCurveFirstCreaseAngle::usage="SpaceCurveFirstCreaseAngle is an option to MakeTSpaceCurve that specifies the angle of the first crease in the crease pattern with respect to the \!\(\*StyleBox[\"x\",FontSlant->\"Italic\"]\) axis.";
Options[MakeTSpaceCurve]={
SpaceCurveFirstCreaseAngle->0\[Degree],
OsculatingVectorNear->None
};
MakeTSpaceCurve::badwid="Warning: input widths `1` exceed maximum limits `2` so the ruling lines cross.";
MakeTSpaceCurve[plist_List,w_, s_,opts___]:=Module[{fca,ovn,wl,wr,sl,sr,op,nn,pp,rr,ll,qq,ta,\[Gamma],\[Sigma],\[Alpha],aa,gg,tl,tr,ppl,ppr,itobj,p,pl,pr,r,g,wlm,wrm,dn,wm0,verts,edges,faces,verts3d,foldangles,types,tobj},
fca=SpaceCurveFirstCreaseAngle/.{opts}/.Options[MakeTSpaceCurve];
ovn=OsculatingVectorNear/.{opts}/.Options[MakeTSpaceCurve];
(* get left and right angles and widths *)
If[Head[w]===List,wl=w[[1]];wr=w[[2]], wl=wr=w];
If[Head[s]===List,sl=s[[1]];sr=s[[2]], sl=sr=s];
(* start building lists *)
nn=Length[plist]-1;(* index of the vertices runs from 0 to nn *)
Do[pp[i]=plist[[i+1]],{i,0,nn}];(* variable pp[i] is just for convenience & consistency of [] versus \[LeftDoubleBracket]\[RightDoubleBracket]. *)
Do[rr[i]=NormalizeReal[pp[i]-pp[i-1]],{i,nn}]; (* direction vectors along the curve *)
Do[ll[i]=Mag[pp[i]-pp[i-1]],{i,nn}];(* segment lengths along the curve *)
(* first vertex *)
qq[0]=NormalizeReal[rr[1]\[Cross]rr[2]];(* initial osculating vector *)
qq[0]=If[ovn===None,qq[0],If[qq[0] . ovn>0,qq[0],-qq[0]]];
\[Sigma][0]={sr,sl,Null,Null};(* subarc angles *)
\[Gamma][0]={0,sr+sl,0,sr+sl}; (* dihedral angles *)
gg[0]={RotationMatrix3Du[(\[Pi]/2-sr),rr[1]] . qq[0],rr[1],RotationMatrix3Du[-(\[Pi]/2-sl),rr[1]] . qq[0],-rr[1]}; (* fold vectors *)
aa[0]={RotationMatrix3Du[sr,gg[0][[2]]] . qq[0],RotationMatrix3Du[-sl,gg[0][[2]]] . qq[0],RotationMatrix3Du[-sl,gg[0][[4]]] . qq[0],RotationMatrix3Du[sr,gg[0][[4]]] . qq[0]};(* sector vectors *)
\[Alpha][0]={\[Pi]/2,\[Pi]/2,\[Pi]/2,\[Pi]/2};(* sector angles *)
tl[0]=wl;(* distance along left-side crease *)
tr[0]=wr;(* distance along right-side crease *)
(* interior vertices *)
Do[(* compute torsion *)
qq[i]=NormalizeReal[rr[i]\[Cross]rr[i+1]];If[qq[i] . qq[i-1]<0,qq[i]=-qq[i]];
ta[i]=DirectedAngle3D[qq[i-1],qq[i],rr[i]];
(* construct the next vertex *)
itobj[i]=MakeTDegree4Vertex3DFromSubarcs[-rr[i],rr[i+1],\[Sigma][i-1][[2]]-ta[i],\[Sigma][i-1][[1]]+ta[i],1,OsculatingVectorNear->qq[i-1]];
{\[Sigma][i],\[Gamma][i],\[Alpha][i],aa[i],gg[i],qq[i]}=GetValues[itobj[i],{SubarcAngles,DihedralAngles,SectorAngles,SectorVectors,FoldVectors,OsculatingVector}];
tl[i]=wl/(\[Sqrt](Sin[\[Alpha][i][[2]]]Sin[\[Alpha][i][[3]]]));
tr[i]=wr/(\[Sqrt](Sin[\[Alpha][i][[1]]]Sin[\[Alpha][i][[4]]]));
,{i,nn-1}];
(* last vertex *)
qq[nn]=qq[nn-1];
sl=\[Sigma][nn-1][[2]];sr=\[Sigma][nn-1][[1]];
\[Sigma][nn]={Null,Null,sl,sr};
\[Gamma][nn]={0,sr+sl,0,sr+sl};
gg[nn]={RotationMatrix3Du[(\[Pi]/2-sr),rr[nn]] . qq[nn],rr[nn],RotationMatrix3Du[-(\[Pi]/2-sl),rr[nn]] . qq[nn],-rr[nn]};
 aa[nn]={RotationMatrix3Du[sr,gg[nn][[2]]] . qq[nn],RotationMatrix3Du[-sl,gg[nn][[2]]] . qq[nn],
RotationMatrix3Du[-sl,gg[nn][[4]]] . qq[nn],RotationMatrix3Du[sr,gg[nn][[4]]] . qq[nn]};
\[Alpha][nn]={\[Pi]/2,\[Pi]/2,\[Pi]/2,\[Pi]/2};(* sector angles *)
tl[nn]=wl;
tr[nn]=wr;
(* left and right side of folded form *)
Do[ppl[i]=pp[i]+ tl[i]gg[i][[3]];
ppr[i]=pp[i]+ tr[i]gg[i][[1]],{i,0,nn}];
(* minimum widths on left and right *)
wlm=\[Infinity];wrm=\[Infinity];
Do[dn=Cot[\[Alpha][i-1][[2]]]+Cot[\[Alpha][i][[3]]];If[dn!=0,wm0=ll[i]/dn;If[wm0>0&&wm0<wlm,wlm=wm0]];(*left side, max width *)
dn=Cot[\[Alpha][i-1][[1]]]+Cot[\[Alpha][i][[4]]];If[dn!=0,wm0=ll[i]/dn;If[wm0>0&&wm0<wrm,wrm=wm0]];(* right side, max width *)
,{i,nn}];
(* If requested width is too wide, issue warning, but it's not fatal. *)
If[wl>wlm||wr>wrm,Message[MakeTSpaceCurve::badwid,{wl,wr},{wlm,wrm}]];
(* variables that define the 2D crease pattern *)
r[1]=U[fca];
Do[r[i+1]=RotationMatrix2D[\[Alpha][i][[4]]+\[Alpha][i][[1]]-\[Pi]] . r[i],{i,nn-1}];
p[0]={0,0};
Do[p[i]=p[i-1]+ll[i]r[i],{i,nn}];
g[0]={RotationMatrix2D[-\[Pi]/2] . r[1],r[1],RotationMatrix2D[\[Pi]/2] . r[1],-r[1]};
Do[g[i]={RotationMatrix2D[-\[Alpha][i][[1]]] . r[i+1],r[i+1],RotationMatrix2D[\[Alpha][i][[2]]] . r[i+1],-r[i-1]},{i,nn-1}];
g[nn]={RotationMatrix2D[-\[Pi]/2] . r[nn],-r[nn],RotationMatrix2D[\[Pi]/2] . r[nn],r[nn]};
Do[pl[i]=p[i]+ tl[i]g[i][[3]];
pr[i]=p[i]+ tr[i]g[i][[1]],{i,0,nn}];
(* build up the graph *)
verts=Flatten[Table[{pl[i],p[i],pr[i]},{i,0,nn}],1];
edges={{1,2},{2,3}};
faces={};
verts3d=Flatten[Table[{ppl[i],pp[i],ppr[i]},{i,0,nn}],1];
foldangles={0,0};
types={B,B};
Do[
(* longitudinal folds *)
JoinTo[edges,{{3i-2,3i+1},{3i-1,3i+2},{3i,3i+3}}];
JoinTo[types,{B,FoldAngleToType[\[Gamma][0][[2]]],B}];
JoinTo[foldangles,{0,\[Gamma][0][[2]],0}];
(* crossing folds *)
JoinTo[edges,{{3i+1,3i+2},{3i+2,3i+3}}];
If[i<nn-1,
JoinTo[types,{FoldAngleToType[\[Gamma][i][[3]]],FoldAngleToType[\[Gamma][i][[1]]]}];
JoinTo[foldangles,{\[Gamma][i][[3]],\[Gamma][i][[1]]}],
JoinTo[types,{B,B}];
JoinTo[foldangles,{0,0}]];
(* faces *)
JoinTo[faces,{{3i-2,3i-1,3i+2,3i+1},{3i-1,3i,3i+3,3i+2}}]
,{i,nn}];
tobj=MakeTGraph[verts,edges,faces]//AddTGraph3D[verts3d,foldangles]//AddTAssigned[types]//AddClass[TSpaceCurve,{
SpaceCurveMaximumWidth->{wlm,wrm},
SpaceCurveInteriorVertices->Table[itobj[i],{i,nn-1}],SpaceCurveTorsion->Append[Table[ta[i],{i,nn-1}],0]}]]
Module[{m=2.5,mm=RotationXMatrix3D[15.\[Degree]] . RotationYMatrix3D[20.\[Degree]],p,plist,tobj},
p[0]=m *mm . {0,0,0};
p[1]=m *mm . {1,1,0};
p[2]=m *mm . {1,2,0};
p[3]=m *mm . {0,3,0};
plist={p[0],p[1],p[2],p[3]};
tobj=MakeTSpaceCurve[plist,1.0,{60\[Degree],30\[Degree]},OsculatingVectorNear->{0,0,1}];
Print["SpaceCurveMaximumWidth"->tobj[SpaceCurveMaximumWidth]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{m=2.5,mm=RotationXMatrix3D[15.\[Degree]] . RotationYMatrix3D[20.\[Degree]],p,plist,tobj},
p[0]=m *mm . {0,0,0};
p[1]=m *mm . {1,1,0};
p[2]=m *mm . {1,2,0};
p[3]=m *mm . {0,3,-0.3};
plist={p[0],p[1],p[2],p[3]};
tobj=MakeTSpaceCurve[plist,1.0,{60\[Degree],30\[Degree]},OsculatingVectorNear->{0,0,1}];
Print["SpaceCurveMaximumWidth"->tobj[SpaceCurveMaximumWidth]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{m=2.5,mm=RotationXMatrix3D[15.\[Degree]] . RotationYMatrix3D[20.\[Degree]],p,plist,tobj},
p[0]=m *mm . {0,0,0};
p[1]=m *mm . {1,1,0};
p[2]=m *mm . {1,2,0};
p[3]=m *mm . {0,3,+0.3};
plist={p[0],p[1],p[2],p[3]};
tobj=MakeTSpaceCurve[plist,0.65,{60\[Degree],30\[Degree]},OsculatingVectorNear->{0,0,1}];
Print["SpaceCurveMaximumWidth"->tobj[SpaceCurveMaximumWidth]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{f,plist,tobj,tobj1},
f={Cos[#],Sin[#],0}&;
plist=Table[f[\[Phi]],{\[Phi],0.,1.92\[Pi],1.92\[Pi]/30}];
(* break the first segment in the middle so there's no bend or torsion at the endpoints. *)
tobj=MakeTSpaceCurve[plist,0.8,{60\[Degree],60\[Degree]}];
tobj1=tobj[SpaceCurveInteriorVertices][[1]];
Print["BendAngleFF/\[Degree]=",tobj1[BendAngleFF]/\[Degree]];
Print["BendAngleCP/\[Degree]=",tobj1[BendAngleCP]/\[Degree]];
Print["SubarcAngles/\[Degree]=",tobj1[SubarcAngles]/\[Degree]];
Print["SpaceCurveMaximumWidth"->tobj[SpaceCurveMaximumWidth]]; 
GraphicsRow[{
Graphics3D[{Line[plist],Point[plist[[1]]]},Axes->True],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{f,plist,tobj,tobj1,\[Sigma]=60\[Degree],\[Tau]=5.2\[Degree]},
f={Cos[#],Sin[#],-0.3#}&;
plist=Table[f[\[Phi]],{\[Phi],0,4\[Pi],\[Pi]/10}]//N;
(* break the first segment in the middle so there's no bend or torsion at the endpoints. *)
tobj=MakeTSpaceCurve[plist,0.75,{\[Sigma]+\[Tau]/2,\[Sigma]-\[Tau]/2}];
tobj1=tobj[SpaceCurveInteriorVertices][[1]];
Print["BendAngleFF/\[Degree]=",tobj1[BendAngleFF]/\[Degree]];
Print["BendAngleCP/\[Degree]=",tobj1[BendAngleCP]/\[Degree]];
Print["SubarcAngles/\[Degree]=",tobj1[SubarcAngles]/\[Degree]];
Print["SpaceCurveMaximumWidth"->tobj[SpaceCurveMaximumWidth]]; 
GraphicsRow[{
Graphics3D[{Line[plist],Point[plist[[1]]]},Axes->True],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{f,plist,plist1,\[Sigma]=63.4\[Degree],\[Tau]=4\[Degree],tobj},
f=KnotData["Trefoil","SpaceCurve"];
plist=Table[f[\[Phi]+\[Pi]/3],{\[Phi],0,2\[Pi],\[Pi]/40}]//N;
(* break the first segment in the middle so there's no bend or torsion at the endpoints. *)
plist1=Module[{x=0.1,p0},
p0=(1-x) plist[[1]]+(x)plist[[2]];
Join[{p0},Drop[plist,1],{p0}]];
tobj=MakeTSpaceCurve[plist1,0.58,{\[Sigma]+\[Tau]/2,\[Sigma]-\[Tau]/2}];
Print["SpaceCurveMaximumWidth"->tobj[SpaceCurveMaximumWidth]]; 
GraphicsRow[{
Graphics3D[{Line[plist],Point[plist[[1]]]},Axes->True],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Clear[TrefoilGraph3DAssigned];
AddTGraphExample[TrefoilGraph3DAssigned,Module[{f,plist,plist1,\[Sigma]=63.4\[Degree],\[Tau]=4\[Degree],tobj},
f=KnotData["Trefoil","SpaceCurve"];
plist=Table[f[\[Phi]+\[Pi]/3],{\[Phi],0,2\[Pi],\[Pi]/40}]//N;
plist1=Module[{x=0.1,p0},
p0=(1-x) plist[[1]]+(x)plist[[2]];
Join[{p0},Drop[plist,1],{p0}]];
MakeTSpaceCurve[plist1,0.58,{\[Sigma]+\[Tau]/2,\[Sigma]-\[Tau]/2}]]];
Module[{tobj},
tobj=TrefoilGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
TGeneratingVertex::usage="TGeneratingVertex is a TObj class that represents a graph build up from a single vertex."
RegisterTClass[TGeneratingVertex];
GeneratingVertex::usage="GeneratingVertex is a TObj property that specifies a TVertex that is replicated to create a larger crease pattern."
AddTGeneratingVertexTo[tobj_TObj,vtobj_]:=Module[{},
AssertClass[tobj,TGraph,AddTGeneratingVertexTo];
AssertClass[vtobj,TVertex,AddTGeneratingVertexTo];
AddClassTo[tobj,TGeneratingVertex,{GeneratingVertex->vtobj}]]
AddTGeneratingVertex[vtobj_]:=AddTGeneratingVertexTo[#,vtobj]&
THuffmanGrid::usage="THuffmanGrid is a TObj class that specifies a periodic grid of identical degree-4 vertices.";
RegisterTClass[THuffmanGrid,{TGraph3D,TAssigned,TCornerIndices,TGeneratingVertex}];
FoldLengths::usage="FoldLengths is a TObj property that specifies the four sides of a Huffman grid quadrilateral.";
MakeTHuffmanGrid::badsize="TVertex `1` must be degree-4; its degree is `2`.";
MakeTHuffmanGrid::badlens="Lengths `1` give one or more negative values in `2`.";
MakeTHuffmanGrid[vtobj_TObj,{d1_,d2_},{nh_,nv_}]:=Module[{da,cv,d3,d4,dd,vfn,gtobj,types,foldangles,ei},
AssertClass[vtobj,TVertex,MakeTHuffmanGrid];
{da,cv}=GetValues[vtobj,{DihedralAngles,CreaseVectors}];
If[Length[da]!=4,Message[MakeTHuffmanGrid::badsize,vtobj,Length[da]];Abort[]];
(* quadrilateral side lengths *)
{d3,d4}={d3,d4}/.Solve[d1 cv[[1]]-d2 cv[[2]]+d3 cv[[3]]-d4 cv[[4]]=={0,0},{d3,d4}][[1]];
dd={d1,d2,d3,d4};
If[d3<=0!!d4<=0,Message[MakeTHuffmanGrid::badlens,{d1,d2},dd];Abort[]];
vfn[i_,j_]:=Floor[i/2](d1 cv[[1]]-d3 cv[[3]])+Floor[j/2](d2 cv[[2]]-d4 cv[[4]])+
Which[EvenQ[i]&&EvenQ[j],{0,0},
OddQ[i]&&EvenQ[j],d1 cv[[1]],
EvenQ[i]&&OddQ[j],d2 cv[[2]],
True,d1 cv[[1]]-d4 cv[[4]]];
gtobj=MakeRectangularQuadMesh[nh,nv,vfn,BorderOverride->True];
(* Go back and assign edge types and fold angles *)
types=gtobj[EdgeTypes];(* mostly U, but borders are B *)
foldangles=Table[0,{Length[types]}];
Do[(* "horizontal" folds *)
Do[
ei=i+j nh;
If[!(types[[ei]]===B),
If[OddQ[i+j],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=da[[1]]],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=da[[3]]]]]
,{i,nh}]
,{j,0,nv}];
Do[(* "vertical" folds *)
Do[
ei=nh(nv+1)+(j-1)(nh+1)+i+1;
If[!(types[[ei]]===B),
If[OddQ[i+j],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=da[[2]]],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=da[[4]]]]]
,{j,nv}]
,{i,0,nh}];
gtobj=gtobj//ReplaceProperty[EdgeTypes->types]//AddTPlaneGraph//AddTGeneratingVertex[vtobj]//AddClass[THuffmanGrid,{FoldLengths->dd}];
(* Now fold the graph into 3D *)
If[And@@(#==0&/@foldangles),
gtobj//AddTGraph3D,
FoldGraph3D[gtobj,foldangles]]]
Module[{vtobj,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{120.\[Degree],60.\[Degree],60\[Degree],120.\[Degree]},30\[Degree]];
tobj=MakeTHuffmanGrid[vtobj,{1,1},{4,7}];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}/.OrigamiStyle[]]
]//ShowExample
DynamicModule[{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4,da,vrules,vtobj,tobj},
Manipulate[
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{120.\[Degree],60.\[Degree],60\[Degree],120.\[Degree]},gm];
tobj=MakeTHuffmanGrid[vtobj,{1,1},{4,8}];
FoldedFormGraphics3D[tobj]/.OrigamiStyle[],
{gm,0.1\[Degree],90.\[Degree]}]
]//ShowExample
Module[{vtobj,ita,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{150.\[Degree],80.\[Degree],30\[Degree],100.\[Degree]},-40.\[Degree]];
ita=vtobj[InfinitesimalMidfoldNormalAngle];
tobj=MakeTHuffmanGrid[vtobj,{1,1},{6,5}];
GraphicsRow[{
Show[CreasePatternGraphics[tobj],Graphics[Style[Arrow[{{0,0},3.U[ita]}],MidfoldNormalLine]]],
FoldedFormGraphics3D[tobj]
}/.Vertex3DStyle[]]
]//ShowExample
Clear[ChickenWireGraph3DAssigned];
AddTGraphExample[ChickenWireGraph3DAssigned,Module[{angles,edges,array,tobj},
angles={120.\[Degree],60.\[Degree],60\[Degree],120.\[Degree]};
edges={1,2};
array={6,6};
MakeTHuffmanGrid[MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[angles,39\[Degree]],edges,array]]];
Module[{tobj},
tobj=ChickenWireGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample

TMiuraMarsOri::usage="TMiuraMarsOri is a TObj class that specifies a periodic grid of alternating degree-4 vertices.";
RegisterTClass[TMiuraMarsOri,{TGraph3D,TAssigned,TCornerIndices,TGeneratingVertex}];
MakeTMiuraMarsOri::badsize="TVertex `1` must be degree-4; its degree is `2`.";
MakeTMiuraMarsOri::badminor="The first dihedral of TVertex `1` must be minor; its dihedrals are `2`.";
MakeTMiuraMarsOri::notflatf="TVertex `1` is not flat-foldable.";
MakeTMiuraMarsOri::notsym="TVertex `1` is not mirror-symmetric.";
MakeTMiuraMarsOri[vtobj_TObj,{dlist1_List,dlist2_List}]:=Module[{sa,da,dt,cv,nh,nv,vfn,gtobj,types,foldangles,ei},
AssertClass[vtobj,TVertex,MakeTMiuraMarsOri];
{sa,da,dt,cv}=GetValues[vtobj,{SectorAngles,DihedralAngles,DihedralTypes,CreaseVectors}];
If[Length[da]!=4,Message[MakeTMiuraMarsOri::badsize,vtobj,Length[da]];Abort[]];
If[Sign[da[[1]]]==Sign[da[[3]]],Message[MakeTMiuraMarsOri::badminor,vtobj,da];Abort[]];
If[sa[[1]]+sa[[3]]!=\[Pi],Message[MakeTMiuraMarsOri::notflatf,vtobj];Abort[]];
If[!((sa[[1]]==sa[[4]])||(sa[[1]]==sa[[3]]==\[Pi]/2)||(sa[[2]]==sa[[4]]==\[Pi]/2)),Message[MakeTMiuraMarsOri::notsym,vtobj];Abort[]];
nh=Length[dlist1];
nv=Length[dlist2];
vfn[0,0]={0,0};
vfn[i_,0]:=vfn[i,0]=vfn[i-1,0]+dlist1[[i]]If[OddQ[i],cv[[1]],-cv[[3]]];
vfn[i_,j_]:=vfn[i,j]=vfn[i,j-1]+dlist2[[j]]If[OddQ[j],cv[[2]],-cv[[4]]];
gtobj=MakeRectangularQuadMesh[nh,nv,vfn,BorderOverride->True];
(* Go back and assign edge types and fold angles *)
types=gtobj[EdgeTypes];(* mostly U, but borders are B *)
foldangles=Table[0,{Length[types]}];
Do[(* "horizontal" folds *)
Do[
ei=i+j nh;
If[!(types[[ei]]===B),
If[OddQ[i],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=If[EvenQ[j],1,-1]da[[1]]],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=If[EvenQ[j],1,-1]da[[3]]]]]
,{i,nh}]
,{j,0,nv}];
Do[(* "vertical" folds *)
Do[
ei=nh(nv+1)+(j-1)(nh+1)+i+1;
If[!(types[[ei]]===B),
If[OddQ[j],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=If[EvenQ[i],1,-1]da[[2]]],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=If[EvenQ[i],1,-1]da[[4]]]]]
,{j,nv}]
,{i,0,nh}];
gtobj=gtobj//ReplaceProperty[EdgeTypes->types]//AddTPlaneGraph//AddTGeneratingVertex[vtobj]//AddClass[TMiuraMarsOri];
(* Now fold the graph into 3D *)
If[And@@(#==0&/@foldangles),
gtobj//AddTGraph3D,
FoldGraph3D[gtobj,foldangles]]]
Module[{vtobj,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{70.\[Degree],90.\[Degree],110.\[Degree],90.\[Degree]},-30\[Degree]];
tobj=MakeTMiuraMarsOri[vtobj,{{1,1.5,1,1.5},{2,2.5,2,2.5}}];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}/.OrigamiStyle[]]
]//ShowExample
MakeTMiuraMarsOri[tobj_TObj,{d1_,d2_}, {nh_,nv_}]:=MakeTMiuraMarsOri[tobj,{Table[d1,{nh}],Table[d2,{nv}]}]
Module[{vtobj,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{70.\[Degree],90.\[Degree],110.\[Degree],90.\[Degree]},-30\[Degree]];
tobj=MakeTMiuraMarsOri[vtobj,{1.5,1},{4,6}];
GraphicsRow[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}/.OrigamiStyle[]]
]//ShowExample
MakeTMiuraMarsOri[tobj_TObj,{d1_,d2_,d3_,d4_}, {nh_,nv_}]:=MakeTMiuraMarsOri[tobj,{Take[Flatten[Table[{d1,d3},{Ceiling[nh/2]}],1],nh],Take[Flatten[Table[{d2,d4},{Ceiling[nv/2]}],1],nv]}]
Module[{vtobj,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{70.\[Degree],90.\[Degree],110.\[Degree],90.\[Degree]},-30\[Degree]];
tobj=MakeTMiuraMarsOri[vtobj,{1.5,1,0.5,1},{7,7}];
GraphicsRow[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}/.OrigamiStyle[]]
]//ShowExample
Module[{vtobj,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{60.\[Degree],120.\[Degree],120\[Degree],60.\[Degree]},30\[Degree]];
tobj=MakeTMiuraMarsOri[vtobj,{1,1},{4,6}];
GraphicsRow[{
CreasePatternGraphics[tobj,Axes->True],
FoldedFormGraphics3D[tobj]
}/.OrigamiStyle[]]
]//ShowExample
DynamicModule[{vtobj,\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4,tobj,da,vrules},
Manipulate[
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{60.\[Degree],120.\[Degree],120\[Degree],60.\[Degree]},gm];
tobj=MakeTMiuraMarsOri[vtobj,{1,1},{4,6}];
FoldedFormGraphics3D[tobj,PlotRange->{{0,5},{-1,6},{-2,2}}]/.OrigamiStyle[],{gm,1.\[Degree],179.\[Degree]}]
]//ShowExample
MakeGeneralTMiuraMarsOri::badsize="TVertex `1` must be degree-4; its degree is `2`.";
MakeGeneralTMiuraMarsOri::badminor="The first dihedral of TVertex `1` must be minor; its dihedrals are `2`.";
MakeGeneralTMiuraMarsOri::notflatf="TVertex `1` is not flat-foldable.";
MakeGeneralTMiuraMarsOri[vtobj_TObj,{dlist1_List,dlist2_List}]:=Module[{sa,da,dt,cv,nh,nv,vfn,gtobj,types,foldangles,ei},
AssertClass[vtobj,TVertex,MakeGeneralTMiuraMarsOri];
{sa,da,dt,cv}=GetValues[vtobj,{SectorAngles,DihedralAngles,DihedralTypes,CreaseVectors}];
If[Length[da]!=4,Message[MakeGeneralTMiuraMarsOri::badsize,vtobj,Length[da]];Abort[]];
If[Sign[da[[1]]]==Sign[da[[3]]],Message[MakeGeneralTMiuraMarsOri::badminor,vtobj,da];Abort[]];
If[sa[[1]]+sa[[3]]!=\[Pi],Message[MakeGeneralTMiuraMarsOri::notflatf,vtobj];Abort[]];
nh=Length[dlist1];
nv=Length[dlist2];
vfn[0,0]={0,0};
vfn[i_,0]:=vfn[i,0]=vfn[i-1,0]+dlist1[[i]]If[OddQ[i],cv[[1]],-cv[[3]]];
vfn[0,j_]:=vfn[0,j]=vfn[0,j-1]+dlist2[[j]]If[OddQ[j],cv[[2]],-cv[[4]]];
vfn[i_,j_]:=vfn[i,j]=LineInt2D[vfn[i-1,j],If[EvenQ[i+j],cv[[3]],cv[[1]]],vfn[i,j-1],If[OddQ[j],cv[[2]],cv[[4]]]];
gtobj=MakeRectangularQuadMesh[nh,nv,vfn,BorderOverride->True];
(* Go back and assign edge types and fold angles *)
types=gtobj[EdgeTypes];(* mostly U, but borders are B *)
foldangles=Table[0,{Length[types]}];
Do[(* "horizontal" folds *)
Do[
ei=i+j nh;
If[!(types[[ei]]===B),
If[OddQ[i],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=If[EvenQ[j],1,-1]da[[1]]],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=If[EvenQ[j],1,-1]da[[3]]]]]
,{i,nh}]
,{j,0,nv}];
Do[(* "vertical" folds *)
Do[
ei=nh(nv+1)+(j-1)(nh+1)+i+1;
If[!(types[[ei]]===B),
If[OddQ[j],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=If[EvenQ[i],1,-1]da[[2]]],
types[[ei]]=FoldAngleToType[foldangles[[ei]]=If[EvenQ[i],1,-1]da[[4]]]]]
,{j,nv}]
,{i,0,nh}];
gtobj=gtobj//ReplaceProperty[EdgeTypes->types]//AddTPlaneGraph//AddTGeneratingVertex[vtobj]//AddClass[TMiuraMarsOri];
(* Now fold the graph into 3D *)
If[And@@(#==0&/@foldangles),
gtobj//AddTGraph3D,
FoldGraph3D[gtobj,foldangles]]]
MakeGeneralTMiuraMarsOri[vtobj_TObj,{d1_,d2_}, {nh_,nv_}]:=MakeGeneralTMiuraMarsOri[vtobj,{Table[d1,{nh}],Table[d2,{nv}]}]
Module[{vtobj,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{60.\[Degree],128.\[Degree],120.\[Degree],52.\[Degree]},-30\[Degree]];
tobj=MakeGeneralTMiuraMarsOri[vtobj,{1,1},{6,6}];
Print["Corner Indices = ",tobj[CornerIndices]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}/.OrigamiStyle[]]
]//ShowExample
Module[{vtobj,d1,d2,dlist1,dlist2,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{130.\[Degree],60.\[Degree],50.\[Degree],120.\[Degree]},-30\[Degree]];
d1=1;
d2=1.3;
dlist1={d1,d2,d1,d2,d1,d2};
dlist2={d2,d1,d2,d1,d2,d1};
tobj=MakeGeneralTMiuraMarsOri[vtobj,{dlist1,dlist2}];
GraphicsRow[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}/.OrigamiStyle[]]
]//ShowExample
TYoshimuraOri::usage="TYoshimuraOri is a TObj class that specifies a periodic grid of alternating degree-6 vertices.";
RegisterTClass[TYoshimuraOri,{TGraph3D,TAssigned}];
MakeYoshimuraVertex::badsectors="The sector angle list `1` must contain 6 angles.";
MakeYoshimuraVertex::badangles="The dihedral angles `1` and `2` must have the same sign.";
MakeYoshimuraVertex::badfirst="The dihedral angles `1`, must sum to \[Pi].";
MakeYoshimuraVertex::badlast="The dihedral angles `1`, must sum to \[Pi].";
MakeYoshimuraVertex[sectorangles_List,{gm2_,gm6_},opts___]:=Module[{mm,gm1,gm3,gm4,gm5,m11,m22,m33,soln,foldangles},
If[Length[sectorangles]!=6,Message[MakeYoshimuraVertex::badsectors,sectorangles];Abort[]];
If[Sign[gm2]!=Sign[gm6],Message[MakeYoshimuraVertex::badangles,gm2,gm6];Abort[]];
If[Plus@@Take[sectorangles,3]!=\[Pi],Message[MakeYoshimuraVertex::badfirst,Take[sectorangles,3]];Abort[]];
If[Plus@@Take[sectorangles,-3]!=\[Pi],Message[MakeYoshimuraVertex::badfirst,Take[sectorangles,-3]];Abort[]];
(* Solve for fold angles in 3D that satisfy vertex consistency. *)
(* Add slack variables on diagonal elements *)
mm=VertexConsistencyMatrix3D[{gm4,gm2,gm3,gm4,gm5,gm6},sectorangles];
soln=Switch[Sign[gm2],
0,{gm3->0,gm4->0,gm5->0},
1,FindRoot[{mm[[1,2]],mm[[1,3]],mm[[2,3]],mm[[1,1]]-m11^2,mm[[2,2]]-m22^2,mm[[3,3]]-m33^2},{gm3,.1},{gm4,-.1},{gm5,.1},{m11,1},{m22,1},{m33,1}],
-1,FindRoot[{mm[[1,2]],mm[[1,3]],mm[[2,3]],mm[[1,1]]-m11^2,mm[[2,2]]-m22^2,mm[[3,3]]-m33^2},{gm3,-.1},{gm4,.1},{gm5,-.1},{m11,1},{m22,1},{m33,1}]];
(* Print["mm = ",Chop[mm/.soln]]; *)
foldangles={gm4,gm2,gm3,gm4,gm5,gm6}/.soln;
MakeTVertex3DFromAngles[sectorangles,foldangles,opts]]
Module[{sectorangles,gm2,gm6,vtobj},
sectorangles={45.\[Degree],90.\[Degree],45.\[Degree],45.\[Degree],90.\[Degree],45.\[Degree]};
{gm2,gm6}={80.\[Degree],80.\[Degree]};
vtobj=MakeYoshimuraVertex[sectorangles,{gm2,gm6}];
GraphicsRow[{
Vertex3DCreasePatternGraphics[vtobj],
Vertex3DFoldedFormGraphics3D[vtobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{sectorangles,gm2,gm6,vtobj},
sectorangles={40.\[Degree],80.\[Degree],60.\[Degree],50.\[Degree],100.\[Degree],30.\[Degree]};
{gm2,gm6}={-45.\[Degree],-50.\[Degree]};
vtobj=MakeYoshimuraVertex[sectorangles,{gm2,gm6}];
GraphicsRow[{
Vertex3DCreasePatternGraphics[vtobj],
Vertex3DFoldedFormGraphics3D[vtobj]}]/.OrigamiStyle[]
]//ShowExample
MakeTYoshimuraOri::badsize="TVertex `1` must be degree-6; its degree is `2`.";
MakeTYoshimuraOri[vtobj_TObj,d1_,{nh_,nv_}]:=Module[{al,gm,cv,d2,d3,d5,d6,ta,tb,ft1,ft2,verts,edges,faces,types,angles,gtobj},
AssertClass[vtobj,TVertex];
{al,gm,cv}=GetValues[vtobj,{SectorAngles,DihedralAngles,CreaseVectors}];
If[Length[al]!=6,Message[MakeTYoshimuraOri::badsize,vtobj,Length[al]];Abort[]];
(* translation vectors in cp *)
{d2,d3,d5,d6}={d2,d3,d5,d6}/.Solve[{d2 cv[[2]]-d3 cv[[3]]==d1 cv[[1]],d2 cv[[2]]-d6 cv[[6]]==d3 cv[[3]]-d5 cv[[5]]},{d2,d3,d5,d6}][[1]];
ta=d1 cv[[1]];
tb=d2 cv[[2]]-d6 cv[[6]];
(* build the graph *)
If[al[[1]]>0,ft1=M;ft2=V,ft1=V;ft2=M];
verts=edges=types=angles={};
Do[
JoinTo[verts,Table[j ta+i tb,{j,0,nh}]];
JoinTo[verts,Table[j ta+i tb+d2 cv[[2]],{j,0,nh}]]
,{i,0,nv-1}];
JoinTo[verts,Table[j ta+nv tb,{j,0,nh}]];
Do[
(AppendTo[edges,{1+j+2 i (1+nh),2+j+2 i (1+nh)}];
AppendTo[types,If[i==0,B,ft1]];AppendTo[angles,If[i==0,0,gm[[1]]]]);
(AppendTo[edges,{1+(nh+1)+2i (nh+1)+j,2+(nh+1)+2i (nh+1)+j}];
AppendTo[types,ft1];AppendTo[angles,gm[[1]]]);
(AppendTo[edges,{2+j+2 i (1+nh),2+j+nh+2 i (1+nh)}];
AppendTo[types,ft2];AppendTo[angles,gm[[3]]]);
(AppendTo[edges,{2+j+nh+2 i (1+nh),4+j+2nh+2 i (1+nh)}];
AppendTo[types,ft2];AppendTo[angles,gm[[5]]]);
,{i,0,nv-1},{j,0,nh-1}];
Do[
(AppendTo[edges,{1+j+2 i (1+nh),2+j+nh+2 i (1+nh)}];
AppendTo[types,If[j==0||j==nh,B,ft2]];AppendTo[angles,If[j==0||j==nh,0,gm[[2]]]]);
(AppendTo[edges,{2+j+nh+2 i (1+nh),3+j+2nh+2 i (1+nh)}];
AppendTo[types,If[j==0||j==nh,0,ft2]];AppendTo[angles,If[j==0||j==nh,0,gm[[6]]]]);
,{i,0,nv-1},{j,0,nh}];
Do[
(AppendTo[edges,{1+2nv (nh+1)+j,2+2nv (nh+1)+j}];
AppendTo[types,B];AppendTo[angles,0]);
,{j,0,nh-1}];
gtobj=MakeTPlaneGraphAssigned[verts,edges,{},types]//AddTCornerIndices[{{1,nh+1},{(nh+1)(2nv)+1,(nh+1)(2nv+1)}}]//AddTGeneratingVertex[vtobj]//AddClass[TYoshimuraOri];
FoldGraph3D[gtobj,angles]
]
Module[{sectorangles,gm2,gm6,nh,nv,vtobj,tobj},
sectorangles={30.\[Degree],120.\[Degree],30.\[Degree],30.\[Degree],120.\[Degree],30.\[Degree]};
{gm2,gm6}={45\[Degree],45\[Degree]};
vtobj=MakeYoshimuraVertex[sectorangles,{gm2,gm6}];
Print[GraphicsRow[{
Vertex3DCreasePatternGraphics[vtobj],
Vertex3DFoldedFormGraphics3D[vtobj]}]/.OrigamiStyle[]];
{nh,nv}={3,4};
tobj=MakeTYoshimuraOri[vtobj,1,{nh,nv}];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{sectorangles,gm2,gm6,nh,nv,vtobj,tobj},
sectorangles={50\[Degree],100.\[Degree],30.\[Degree],30.\[Degree],100.\[Degree],50.\[Degree]};
{gm2,gm6}={45\[Degree],45\[Degree]};
vtobj=MakeYoshimuraVertex[sectorangles,{gm2,gm6}];
Print[GraphicsRow[{
Vertex3DCreasePatternGraphics[vtobj],
Vertex3DFoldedFormGraphics3D[vtobj]}]/.OrigamiStyle[]];
{nh,nv}={5,5};
tobj=MakeTYoshimuraOri[vtobj,1,{nh,nv}];
Print[GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]];
]//ShowExample
Module[{sectorangles,gm2,gm6,nh,nv,vtobj,tobj},
sectorangles={60\[Degree],90.\[Degree],30.\[Degree],60.\[Degree],90\[Degree],30.\[Degree]};
{gm2,gm6}={45\[Degree],45\[Degree]};
vtobj=MakeYoshimuraVertex[sectorangles,{gm2,gm6}];
Print[GraphicsRow[{
Vertex3DCreasePatternGraphics[vtobj],
Vertex3DFoldedFormGraphics3D[vtobj]}]/.OrigamiStyle[]];
{nh,nv}={5,5};
tobj=MakeTYoshimuraOri[vtobj,1,{nh,nv}];
Print[GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]];
]//ShowExample
Module[{sectorangles,gm2,gm6,nh,nv,vtobj,tobj},
sectorangles={40.\[Degree],80.\[Degree],60.\[Degree],30.\[Degree],120.\[Degree],30.\[Degree]};
{gm2,gm6}={30.\[Degree],40.\[Degree]};
vtobj=MakeYoshimuraVertex[sectorangles,{gm2,gm6}];
Print[GraphicsRow[{
Vertex3DCreasePatternGraphics[vtobj],
Vertex3DFoldedFormGraphics3D[vtobj]}]/.OrigamiStyle[]];
{nh,nv}={5,5};
tobj=MakeTYoshimuraOri[vtobj,1.,{nh,nv}];
Print[GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]];
]//ShowExample

Manipulate[
Module[{sectorangles,nh,nv,vtobj,tobj},
sectorangles={60\[Degree],90.\[Degree],30.\[Degree],60.\[Degree],90\[Degree],30.\[Degree]};
vtobj=MakeYoshimuraVertex[sectorangles,{gm2,gm6}];
{nh,nv}={5,5};
tobj=MakeTYoshimuraOri[vtobj,1,{nh,nv}];
FoldedFormGraphics3D[tobj]/.OrigamiStyle[]
],{{gm2,45.\[Degree]},30.\[Degree],60.\[Degree]},{{gm6,45.\[Degree]},30.\[Degree],60.\[Degree]}]//ShowExample
MajorFoldAngle::usage="MajorFoldAngle is an option to MakeMiuraOri that specifies the major fold angle of the first vertical fold in the 3D form.";
Options[MakeMiuraOri]={
MajorFoldAngle->90\[Degree]
};
MakeMiuraOri[\[Alpha]_,{dh_,dv_},{nh_,nv_},opts___]:=Module[{gmj,ca,sa,gmn,gmjp,gmnp,vfn,v3dfn,hetfn,vetfn,heafn,veafn,tobj},
gmj=MajorFoldAngle/.{opts}/.Options[MakeMiuraOri];
{ca,sa}={Cos[\[Alpha]],Sin[\[Alpha]]};
gmn=2 ArcTan[ca Tan[gmj/2]];
vfn[i_,j_]:={i dh+If[Mod[j,2]==1,dv ca,0],j dv sa};
gmjp=If[gmj>=0,0,1];(* initial major fold parity *)
gmnp=If[gmn>=0,0,1];(* initial minor fold parity *)
vetfn[i_,j_]:=If[Mod[i+gmjp,2]==1,V,M];
hetfn[i_,j_]:=If[Mod[i+j+gmnp,2]==0,V,M];
veafn[i_,j_]:=If[Mod[i,2]==1,gmj,-gmj];
heafn[i_,j_]:=If[Mod[i+j,2]==0,gmn,-gmn];
tobj=MakeQuadMesh[nh,nv,
VerticesFn->vfn,
HorizontalEdgeTypeFn->hetfn,
VerticalEdgeTypeFn->vetfn,
HorizontalEdgeAngleFn->heafn,
VerticalEdgeAngleFn->veafn,
BorderOverride->True]//AddTPlaneGraph;
tobj=FoldGraph3D[tobj,tobj[FoldAngles],opts];
tobj]
Module[{\[Alpha],dh,dv,nh,nv,\[Gamma],tobj},
\[Alpha]=60.\[Degree];
{dh,dv}={1,1};
{nh,nv}={6,4};
\[Gamma]=-90\[Degree];
tobj=MakeMiuraOri[\[Alpha],{dh,dv},{nh,nv},MajorFoldAngle->\[Gamma]];
tobj=VertexRotateGraph3D[tobj,Take[Flatten[tobj[CornerIndices]],3]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Clear[MiuraOriPartiallyFoldedGraph3DAssigned];
AddTGraphExample[MiuraOriPartiallyFoldedGraph3DAssigned,Module[{\[Alpha],dh,dv,nh,nv,\[Gamma],tobj},
\[Alpha]=60.\[Degree];
{dh,dv}={1,1};
{nh,nv}={6,6};
\[Gamma]=-120\[Degree];
tobj=MakeMiuraOri[\[Alpha],{dh,dv},{nh,nv},MajorFoldAngle->\[Gamma]];
VertexRotateGraph3D[tobj,Take[Flatten[tobj[CornerIndices]],3]]]];
Module[{tobj},
tobj=MiuraOriPartiallyFoldedGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
Clear[MiuraOriFullyFoldedGraph3DAssigned];
AddTGraphExample[MiuraOriFullyFoldedGraph3DAssigned,Module[{\[Alpha],dh,dv,nh,nv,\[Gamma],tobj},
\[Alpha]=60.\[Degree];
{dh,dv}={1,1};
{nh,nv}={6,6};
\[Gamma]=-179\[Degree];
tobj=MakeMiuraOri[\[Alpha],{dh,dv},{nh,nv},MajorFoldAngle->\[Gamma]];
VertexRotateGraph3D[tobj,Take[Flatten[tobj[CornerIndices]],3]]]];
Module[{tobj},
tobj=MiuraOriFullyFoldedGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
SpacerMiuraOriOffset::usage="SpacerMiuraOriOffset is an option to MakeSpacerMiuraOri that specifies the row offset that determines what type of facet is in the first row.";
Options[MakeSpacerMiuraOri]={
MajorFoldAngle->90\[Degree],
SpacerMiuraOriOffset->0
};
MakeSpacerMiuraOri[\[Alpha]_,{dh_,dv_,ds_},{nh_,nv_},opts___]:=Module[{so,gmj,\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4,ca,sa,vfn,v3dfn,hetfn,vetfn,heafn,veafn,tobj},
so=SpacerMiuraOriOffset/.{opts}/.Options[MakeSpacerMiuraOri];
gmj=MajorFoldAngle/.{opts}/.Options[MakeSpacerMiuraOri];
{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}=MakeDihedralsFromSectorsAndMajorDihedral[{\[Pi]-\[Alpha],\[Pi]/2,\[Pi]/2,\[Alpha]},gmj];
Print["fold angles: ",N[{\[Gamma]1,\[Gamma]2,\[Gamma]3,\[Gamma]4}/\[Degree]]]//Hold;
{ca,sa}={Cos[\[Alpha]],Sin[\[Alpha]]};
vfn[i_,0]:={i dh,0};
vfn[i_,j_]:=vfn[i,j]=Switch[Mod[j+so,4],
0,vfn[i,j-1]+ds{0,1},
1,vfn[i,j-1]+dh{ca,sa},
2,vfn[i,j-1]+ds{0,1},
3,vfn[i,j-1]+dh{-ca,sa}];
veafn[i_,j_]:=veafn[i,j]=Switch[Mod[j+so,2],
0,\[Gamma]1,
1,\[Gamma]3]If[Mod[i,2]==1,1,-1];
vetfn[i_,j_]:=FoldAngleToType[veafn[i,j]];
heafn[i_,j_]:=heafn[i,j]=Switch[Mod[Ceiling[(j+so)/2],2],
0,\[Gamma]2,
1,\[Gamma]4]If[Mod[i,2]==0,1,-1];
hetfn[i_,j_]:=FoldAngleToType[heafn[i,j]];
tobj=MakeQuadMesh[nh,nv,
VerticesFn->vfn,
HorizontalEdgeTypeFn->hetfn,
VerticalEdgeTypeFn->vetfn,
HorizontalEdgeAngleFn->heafn,
VerticalEdgeAngleFn->veafn,
BorderOverride->True]//AddTPlaneGraph;
FoldGraph3D[tobj,tobj[FoldAngles],opts]]
Module[{\[Alpha],dh,dv,ds,nh,nv,\[Gamma],tobj},
\[Alpha]=60.\[Degree];
{dh,dv,ds}={1,1,1};
{nh,nv}={6,7};
\[Gamma]=-150\[Degree];
tobj=MakeSpacerMiuraOri[\[Alpha],{dh,dv,ds},{nh,nv},MajorFoldAngle->\[Gamma]];
tobj=VertexRotateGraph3D[tobj,Take[Flatten[tobj[CornerIndices]],3]];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Clear[SpacerMiuraOriFullyFoldedGraph3DAssigned];
AddTGraphExample[SpacerMiuraOriFullyFoldedGraph3DAssigned,Module[{\[Alpha],dh,dv,ds,nh,nv,\[Gamma],tobj},
\[Alpha]=60.\[Degree];
{dh,dv,ds}={1,1,1};
{nh,nv}={6,7};
\[Gamma]=-179\[Degree];
tobj=MakeSpacerMiuraOri[\[Alpha],{dh,dv,ds},{nh,nv},MajorFoldAngle->\[Gamma]];
VertexRotateGraph3D[tobj,Take[Flatten[tobj[CornerIndices]],3]]]];
Module[{tobj},
tobj=SpacerMiuraOriFullyFoldedGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
MakeYoshimuraMiuraOri[alist_List,nv_,\[Gamma]_,opts___]:=Module[{nh,gp,vertfn,verts,edges,foldangles,types,tbase,tilt,asign,ibl,ibr,tobj},
nh=Length[alist];(* number of columns *)
(* build a grid of vertices *)
vertfn[0,j_]:=vertfn[0,j]={0,j};
vertfn[i_,j_]:=vertfn[i,j]=vertfn[i-1,j]+{Abs[Cot[alist[[i]]]],0};
verts=Flatten[Table[vertfn[i,j],{i,0,nh},{j,0,nv}],1];
edges=foldangles=types={};
(* add edges and fold angles *)
Do[(* left edge *)
AppendTo[edges,{j,j+1}];AppendTo[foldangles,0];AppendTo[types,B],
{j,1,nv}];
Do[(* each full column *)
(* bottom edge *)
AppendTo[edges,{1+(i-1)(nv+1),1+(i)(nv+1)}];AppendTo[foldangles,0];AppendTo[types,B];
(* column *)
tbase = If[i==1,Sign[alist[[1]]],If[Sign[alist[[i]]]!=Sign[alist[[i-1]]],-tbase,tbase]];(* tilt of bottom row *)
asign=If[i==1,Sign[\[Gamma]],If[Sign[alist[[i]]]!=Sign[alist[[i-1]]],asign,-asign]];(* sign of fold angles *)
Do[
ibl=(i-1)(nv+1)+j;(* index of bottom left corner *)
ibr=ibl+(1+nv);(* index of bottom right corner *)
(* diagonal *)
tilt=tbase*If[Mod[j,2]==1,1,-1];(* tilt within this cell: +1=up, -1=down *)
AppendTo[edges,If[tilt>0,{ibl,ibr+1},{ibl+1,ibr}]];
gp=-2 ArcCot[Cos[alist[[i]]]Cot[\[Gamma]/2]];(* signed major fold angle *)
AppendTo[foldangles,asign*gp];
AppendTo[types,Switch[Sign[asign*gp],1,V,-1,M,0,U]];
(* top of cell *)
AppendTo[edges,{ibr+1,ibl+1}];
AppendTo[foldangles,If[j==nv,0,asign*\[Gamma]]];
AppendTo[types,If[j==nv,B,Switch[Sign[asign*\[Gamma]],1,V,-1,M,0,U]]];
,{j,1,nv}];
,{i,1,nh}];
Do[(* right edge *)
AppendTo[edges,{nh(nv+1)+j,nh(nv+1)+j+1}];AppendTo[foldangles,0];AppendTo[types,B],
{j,1,nv}];
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types]//AddTCornerIndices[{{1,(nv+1)nh+1},{nv+1,(nv+1)(nh+1)}}];
FoldGraph3D[tobj,foldangles,opts]]
Module[{tobj},
tobj=MakeYoshimuraMiuraOri[{-25.\[Degree],30.\[Degree],-35.\[Degree], -40.\[Degree],45.\[Degree],-50.\[Degree]},2,45.\[Degree]];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}]/.OrigamiStyle[]
]//ShowExample
MakeYoshimuraMiuraOri[\[Alpha]_,{runs_List,nv_},\[Gamma]_,opts___]:=Module[{hlist,nh,dv,gp,verts,edges,foldangles,types,tbase,tilt,asign,ibl,ibr,tobj},
hlist=Sign[\[Gamma]] Flatten[Table[Table[(-1)^(i-1),{runs[[i]]}],{i,Length[runs]}]];
nh=Length[hlist];(* number of columns *)
dv=Abs[Tan[\[Alpha]]];(* height of each column *)
gp=-2 ArcCot[Cos[\[Alpha]]Cot[\[Gamma]/2]];(* signed major fold angle *)
(* build a grid of vertices *)
verts=Flatten[Table[{i, j dv},{i,0,nh},{j,0,nv}],1];
edges=foldangles=types={};
(* add edges and fold angles *)
Do[(* left edge *)
AppendTo[edges,{j,j+1}];AppendTo[foldangles,0];AppendTo[types,B],
{j,1,nv}];
Do[(* each full column *)
(* bottom edge *)
AppendTo[edges,{1+(i-1)(nv+1),1+(i)(nv+1)}];AppendTo[foldangles,0];AppendTo[types,B];
(* column *)
tbase = If[i==1,Sign[\[Alpha]],If[hlist[[i]]==hlist[[i-1]],-tbase,tbase]];(* tilt of bottom row *)
asign=If[i==1,Sign[\[Gamma]],If[hlist[[i]]==hlist[[i-1]],asign,-asign]];(* sign of fold angles *)
Do[
ibl=(i-1)(nv+1)+j;(* index of bottom left corner *)
ibr=ibl+(1+nv);(* index of bottom right corner *)
(* diagonal *)
tilt=tbase*If[Mod[j,2]==1,1,-1];(* tilt within this cell: +1=up, -1=down *)
AppendTo[edges,If[tilt>0,{ibl,ibr+1},{ibl+1,ibr}]];
AppendTo[foldangles,asign*gp];
AppendTo[types,Switch[Sign[asign*gp],1,V,-1,M,0,U]];
(* top of cell *)
AppendTo[edges,{ibr+1,ibl+1}];
AppendTo[foldangles,If[j==nv,0,asign*\[Gamma]]];
AppendTo[types,If[j==nv,B,Switch[Sign[asign*\[Gamma]],1,V,-1,M,0,U]]];
,{j,1,nv}];
,{i,1,nh}];
Do[(* right edge *)
AppendTo[edges,{nh(nv+1)+j,nh(nv+1)+j+1}];AppendTo[foldangles,0];AppendTo[types,B],
{j,1,nv}];
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types]//AddTCornerIndices[{{1,(nv+1)nh+1},{nv+1,(nv+1)(nh+1)}}];
FoldGraph3D[tobj,foldangles,opts]]
Module[{tobj},
tobj=MakeYoshimuraMiuraOri[30.\[Degree],{{2,2},6},45.\[Degree]];
Print["CornerIndices = ",tobj[CornerIndices]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj},
tobj=MakeYoshimuraMiuraOri[30.\[Degree],{{7,7},16},70.\[Degree]];
GraphicsRow[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}]/.OrigamiStyle[]
]//ShowExample
Clear[DoubleSpiralGraph3DAssigned];
AddTGraphExample[DoubleSpiralGraph3DAssigned,
Module[{alist},
alist=Table[(-1)^i (30.\[Degree]+i 4.\[Degree]),{i,0,10}];
alist=Join[Reverse[alist],alist];
MakeYoshimuraMiuraOri[alist,10,60.\[Degree]]]];
Module[{tobj},
tobj=DoubleSpiralGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
MakeSemigeneralizedMiuraOriA::badangs="Angle list `1` contains invalid angles.";
MakeSemigeneralizedMiuraOriA::badlens="Angle list `1` of length `2` should be 1 element longer than distance list `3` of length `4`.";
MakeSemigeneralizedMiuraOriA[alist_List,dlist_List,w_,nw_,\[Gamma]_,opts___]:=Module[{na,nd,rlist,vfn,hetfn,vetfn,tobj,foldangles,types,ei,gm},
na=Length[alist];
nd=Length[dlist];
Do[
If[alist[[i]]<=0||(i!=1&&i!=na&&alist[[i]]==90\[Degree])||alist[[i]]>180\[Degree],Message[MakeSemigeneralizedMiuraOriA::badangs,alist];Abort[]],{i,na}];
If[Length[alist]!=Length[dlist]+1,Message[MakeSemigeneralizedMiuraOriA::badlens,alist,na,dlist,nd];Abort[]];
rlist=FoldList[Plus,0,dlist];(* distances down middle of each strip *)
vfn[i_,j_]:={rlist[[i+1]],j w} +{If[EvenQ[j],w Cot[alist[[i+1]]],0],0};
hetfn[i_,j_]:=If[Xor[EvenQ[i+j],\[Gamma]>0],V,M];
vetfn[i_,j_]:=If[Xor[EvenQ[i],alist[[i+1]]>90\[Degree],\[Gamma]>0],V,M];
tobj=MakeRectangularQuadMesh[nd,2nw,vfn,HorizontalEdgeTypeFn->hetfn,VerticalEdgeTypeFn->vetfn,BorderOverride->True]//AddTPlaneGraph;
foldangles={};
types=tobj[EdgeTypes];
ei=0;
Do[(* horizontal edges *)
ei++;(* index of the edge *)
AppendTo[foldangles,If[j==0||j==2 nw,0,If[Xor[EvenQ[i+j],\[Gamma]>0],Abs[\[Gamma]],-Abs[\[Gamma]]]]];(Print[ei->{i,j}]//Hold)
,{j,0,2nw},{i,0,nd-1}];
Do[(* vertical edges *)
ei++;(* index of the edge *)
gm=Abs[2 ArcCot[Cos[alist[[i+1]]]Cot[\[Gamma]/2]]];(* magnitude of major fold angle *)
AppendTo[foldangles,If[i==0||i==nd,0,If[Xor[EvenQ[i],alist[[i+1]]>90\[Degree],\[Gamma]>0],gm,-gm]]];
(Print[ei->{i,j}]//Hold)
,{j,0,2nw-1},{i,0,nd}];
(* we implement a trick here to take advantage of the periodicity. Instead of folding the entire structure, we fold a single strip and then use its vertex coordinates to assign the rest of the vertices. *)
If[nw==1,
FoldGraph3D[tobj,foldangles,opts],
Module[{tobj1,verts3d1,ci1,dv,verts3d},
tobj1=MakeSemigeneralizedMiuraOriA[alist,dlist,w,1,\[Gamma],opts];
{verts3d1,ci1}=GetValues[tobj1,{Vertices3D,CornerIndices}];
dv=verts3d1[[ci1[[2,1]]]]-verts3d1[[ci1[[1,1]]]];(* periodicity vector *)
verts3d={};
Do[AppendTo[verts3d,verts3d1[[1+Mod[(k-1),2na]]]+dv Floor[(k-1)/(2na)]],{k,na(2nw+1)}];
tobj//AddTGraph3D[verts3d,foldangles]
]]]
Module[{alist,dlist,w,nw,\[Gamma],tobj,ci},
alist={90\[Degree],120\[Degree],60\[Degree],89\[Degree],90\[Degree]};
dlist={1,1,1,1};
w=0.5;
nw=1;
\[Gamma]=45.\[Degree];
tobj=MakeSemigeneralizedMiuraOriA[alist,dlist,w,nw,\[Gamma]];
ci=tobj[CornerIndices];
Print["CornerIndices = ",ci];
Print[FoldAngleGraphics[tobj]/.OrigamiStyle[]];
Print[CreasePatternGraphics[tobj]/.OrigamiStyle[]];
Print[FoldedFormGraphics3D[VertexRotateGraph3D[tobj,{1,4,11}]]/.OrigamiStyle[]];
]//ShowExample
Module[{alist,dlist,w,nw,\[Gamma],tobj,ci},
alist={90\[Degree],120\[Degree],60\[Degree],89\[Degree],90\[Degree]};
dlist={1,1,1,1};
w=0.5;
nw=3;
\[Gamma]=45.\[Degree];
tobj=MakeSemigeneralizedMiuraOriA[alist,dlist,w,nw,\[Gamma]];
ci=tobj[CornerIndices];
Print["CornerIndices = ",ci];
Print[FoldAngleGraphics[tobj]/.OrigamiStyle[]];
Print[CreasePatternGraphics[tobj]/.OrigamiStyle[]];
Print[FoldedFormGraphics3D[VertexRotateGraph3D[tobj,{1,4,21}]]/.OrigamiStyle[]];
]//ShowExample
MakeSemigeneralizedMiuraOriB[blist_List,dlist_List,w_,nw_,\[Gamma]_,opts___]:=Module[{alist,mfi},
alist=Table[
mfi=Xor[\[Gamma]>0,OddQ[i]];(* True = minor fold incident on vertex is valley *)
If[blist[[i]]>0,If[mfi,blist[[i]]/2,\[Pi]-blist[[i]]/2],If[mfi,\[Pi]+blist[[i]]/2,-blist[[i]]/2]]
,{i,Length[blist]}];
MakeSemigeneralizedMiuraOriA[alist,dlist,w,nw,\[Gamma],opts]]
Module[{blist,dlist,w,nw,\[Gamma],tobj},
blist={180\[Degree],-120\[Degree],-120\[Degree],179\[Degree],-180\[Degree]};
dlist={1,1,1,1};
w=0.25;
nw=2;
\[Gamma]=45.\[Degree];
tobj=MakeSemigeneralizedMiuraOriB[blist,dlist,w,nw,\[Gamma]];
Print["CornerIndices = ",tobj[CornerIndices]];
Print[FoldAngleGraphics[tobj]/.OrigamiStyle[]];
Print[CreasePatternGraphics[tobj]/.OrigamiStyle[]];
Print[FoldedFormGraphics3D[VertexRotateGraph3D[tobj,{1,4,21}]]/.OrigamiStyle[]];
]//ShowExample
Module[{blist,dlist,w,nw,\[Gamma],tobj},
blist={-180\[Degree],120\[Degree],120\[Degree],-179\[Degree],180\[Degree]};
dlist={1,1,1,1};
w=0.25;
nw=2;
\[Gamma]=45.\[Degree];
tobj=MakeSemigeneralizedMiuraOriB[blist,dlist,w,nw,\[Gamma]];
Print["CornerIndices = ",tobj[CornerIndices]];
Print[FoldAngleGraphics[tobj]/.OrigamiStyle[]];
Print[CreasePatternGraphics[tobj]/.OrigamiStyle[]];
Print[FoldedFormGraphics3D[VertexRotateGraph3D[tobj,{1,4,21}]]/.OrigamiStyle[]];
]//ShowExample
FirstBendAngle::usage="FirstBendAngle is an option to MakeSemigeneralizedMiuraOriP that specifies the bend angle that would apply to the first vertex of the path.";
LastBendAngle::usage="LastBendAngle is an option to MakeSemigeneralizedMiuraOriP that specifies the bend angle that would apply to the last vertex of the path.";
Options[MakeSemigeneralizedMiuraOriP]={
FirstBendAngle->180\[Degree],
LastBendAngle->180\[Degree]
};
MakeSemigeneralizedMiuraOriP[pts_List,w_,nw_,{\[Gamma]0_,\[Gamma]_},opts___]:=Module[{fb,lb,gd,blist,dlist,gm,alist},
fb=FirstBendAngle/.{opts}/.Options[MakeSemigeneralizedMiuraOriP];
lb=LastBendAngle/.{opts}/.Options[MakeSemigeneralizedMiuraOriP];
dlist=Drop[MapThread[Mag[#2-#1]&,{pts,RotateLeft[pts]}],-1];
blist=Drop[MapThread[RotationAngle[#2-#1,#3-#2]&,{pts,RotateLeft[pts],RotateLeft[pts,2]}],-2];
blist=Join[{fb},blist,{lb}];
alist=Table[
gm=\[Gamma]0 (-1)^i;(* fold angle incident on the vertex *)
If[blist[[i]]==\[Pi]||blist[[i]]==-\[Pi],\[Pi]/2,Mod[ArcTan[Csc[gm/2]Tan[blist[[i]]/2]],\[Pi]]]
,{i,Length[blist]}];
dlist=dlist-(w/2)(Cot/@Drop[alist,1])+(w/2)(Cot/@Drop[alist,-1]);
MakeSemigeneralizedMiuraOriA[alist,dlist,w,nw,\[Gamma],opts]]
MakeSemigeneralizedMiuraOriP[pts_List,w_,nw_,\[Gamma]_,opts___]:=MakeSemigeneralizedMiuraOriP[pts,w,nw,{\[Gamma],\[Gamma]},opts]
Module[{pts,w,nw,\[Gamma],tobj},
pts={{0,0},{1,0},{1,1},{2,1}};
w=0.25;
nw=2;
\[Gamma]=90.\[Degree];
tobj=MakeSemigeneralizedMiuraOriP[pts,w,nw,\[Gamma]];
Print["CornerIndices = ",tobj[CornerIndices]];
Print[FoldAngleGraphics[tobj]/.OrigamiStyle[]];
Print[CreasePatternGraphics[tobj]/.OrigamiStyle[]];
Print[FoldedFormGraphics3D[VertexRotateGraph3D[tobj,{1,2,17}],ViewPoint->{0,-\[Infinity],0},Axes->True]/.OrigamiStyle[]];
]//ShowExample
Module[{pts,w,nw,\[Gamma]0,\[Gamma],tobj},
pts={{0,0},{1,0},{1,1},{2,1}};
w=0.25;
nw=2;
\[Gamma]0=90.\[Degree];
\[Gamma]=120.\[Degree];
tobj=MakeSemigeneralizedMiuraOriP[pts,w,nw,{\[Gamma]0,\[Gamma]}];
Print["CornerIndices = ",tobj[CornerIndices]];
Print[FoldAngleGraphics[tobj]/.OrigamiStyle[]];
Print[CreasePatternGraphics[tobj]/.OrigamiStyle[]];
Print[FoldedFormGraphics3D[VertexRotateGraph3D[tobj,{1,2,17}]]/.OrigamiStyle[]];
Print[FoldedFormGraphics3D[VertexRotateGraph3D[tobj,{1,2,17}],ViewPoint->{0,-\[Infinity],0},Axes->True]/.OrigamiStyle[]];
]//ShowExample
StackGap::usage="StackGap is an option to MakeTachiMiuraPolyhedraGraphics3D and MakeTachiMiuraStackGraphics3D that specifies the vertical gap between successive layers.";
Options[MakeTachiMiuraPolyhedronGraphics3D]={
StackGap->0.001
};
MakeTachiMiuraPolyhedronGraphics3D[\[Beta]0_, {\[Gamma]0_, \[Gamma]_}, {d1_,d2_,d3_}, w_,nw_, opts___] :=Module[{sg,pts,tobj1,tobj2},
sg=StackGap/.{opts}/.Options[MakeTachiMiuraPolyhedronGraphics3D];
pts={{0,0},{d1,0}};
AppendTo[pts,pts[[-1]]+d2 U[-\[Beta]0]];
AppendTo[pts,pts[[-1]]+{d3,0}];
AppendTo[pts,pts[[-1]]+d2 U[\[Beta]0]];
AppendTo[pts,pts[[-1]]+{d1,0}];
Print[Graphics[Line[pts],Axes->True]]//Hold;
tobj1=MakeSemigeneralizedMiuraOriP[pts,w,nw,{\[Gamma]0,\[Gamma]},opts];(* bottom layer *)
tobj1=VertexRotateGraph3D[tobj1,Take[Flatten[tobj1[CornerIndices]],3]];
tobj2=MakeSemigeneralizedMiuraOriP[{1,-1}#&/@pts,w,nw,{\[Gamma]0,\[Gamma]},opts];(* top layer *)
tobj2=TranslateGraph3D[VertexRotateGraph3D[tobj2,Take[Flatten[tobj2[CornerIndices]],3]],{0,0,sg d1}];
Graphics3D[{
FoldedFormGraphics3D[tobj1][[1]],
FoldedFormGraphics3D[tobj2][[1]]}]]
Module[{gg},
gg=MakeTachiMiuraPolyhedronGraphics3D[90.\[Degree],{90.\[Degree],90.\[Degree]},{0.25,0.5,1},.5,4];
gg/.OrigamiStyle[]
]//ShowExample
MakeTachiMiuraSheet[\[Beta]0_,{\[Gamma]0_,\[Gamma]_},{dh_,dd_},w_,{nl_,nw_}]:=Module[{\[Zeta]0,\[Alpha],\[Zeta],\[Beta],h,pts,dpts,tobj,ci,vrg},
\[Zeta]0=\[Pi]-Abs[\[Beta]0];(* ruling angle *)
\[Alpha]=ArcTan[Cot[\[Zeta]0/2]Csc[\[Gamma]0/2]];(* sector angle *)
\[Zeta]=2 ArcTan[Cot[\[Alpha]]Csc[\[Gamma]/2]];
\[Beta]=\[Pi]-\[Zeta];
h=Sec[\[Zeta]0]Sin[\[Zeta]];(* height at current size *)
(* construct the target path *)
pts={{0,0},{dh,0}};
dpts={dd U[\[Pi]-\[Zeta]]};
AppendTo[dpts,dpts[[-1]]+{2dh,0}];
AppendTo[dpts,dpts[[-1]]+dd U[\[Pi]+\[Zeta]]];
AppendTo[dpts,dpts[[-1]]+{2dh,0}];
Do[
pts=Join[pts,pts[[-1]]+#&/@dpts];
,{i,nl}];
pts[[-1]]=pts[[-1]]+{-dh,0};
Print[Graphics[Line[pts],Axes->True]]//Hold;
(* make the first layer *)
tobj=MakeSemigeneralizedMiuraOriP[{1,Sign[\[Beta]0]}#&/@pts,w,nw,\[Gamma]];
ci=tobj[CornerIndices];
Print["CornerIndices = ",ci]//Hold;
vrg=Take[Flatten[ci],3];
Print[CreasePatternGraphics[tobj,Axes->True]/.OrigamiStyle[]]//Hold;
tobj=VertexRotateGraph3D[tobj,vrg];
Print[FoldedFormGraphics3D[tobj]/.OrigamiStyle[]]//Hold;
tobj]
Module[{tobj},
tobj=MakeTachiMiuraSheet[60.\[Degree],{90.\[Degree],105.\[Degree]},{1,1},1.2,{2,2}];
GraphicsRow[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]
}]/.OrigamiStyle[]
]//ShowExample
StackGap::usage="StackGap is an option to MakeTachiMiuraStackGraphics3D that specifies the vertical gap between successive layers.";
Options[MakeTachiMiuraStackGraphics3D]={
StackGap->0.001
};
MakeTachiMiuraStackGraphics3D[\[Beta]0_,{\[Gamma]0_,\[Gamma]_},{dh_,dd_},w_,{nl_,nw_,nh_},opts___]:=Module[{sg,tobj1,tobj2,h,gg1,gg2},
sg=StackGap/.{opts}/.Options[MakeTachiMiuraStackGraphics3D];
tobj1=MakeTachiMiuraSheet[\[Beta]0,{\[Gamma]0,\[Gamma]},{dh,dd},w,{nl,nw}];(* layer points up *)
tobj2=MakeTachiMiuraSheet[-\[Beta]0,{\[Gamma]0,\[Gamma]},{dh,dd},w,{nl,nw}];(* layer points down *)
h=With[{v=tobj1[Vertices3D]},Abs[v[[3,3]]-v[[1,3]]]]+sg dh;(* vertical layer spacing *)
gg1=FoldedFormGraphics3D[tobj1];
gg2=FoldedFormGraphics3D[tobj2];
Graphics3D[Table[
If[EvenQ[i],Translate3D[gg1[[1]],{0,0,i h}],Translate3D[gg2[[1]],{0,0,(i+1) h}]],{i,0,nh-1}]]]
Module[{gg},
gg=MakeTachiMiuraStackGraphics3D[60.\[Degree],{90.\[Degree],105.\[Degree]},{1,1},1.2,{2,4,5}];
gg/.OrigamiStyle[]
]//ShowExample
TwistTubeParameters::badhs="Height spec `1` is invalid because the height difference is too large.";
TwistTubeParametersRH[m_,{h1_,h2_}]:=Module[{\[Phi],x1,x2,d\[Phi]1,d\[Phi]2,r,\[Alpha]},
\[Phi]=\[Pi]/m;
If[Abs[h1^2-h2^2]>Cot[\[Phi]]Csc[\[Phi]],Message[TwistTubeParameters::badhs,{h1,h2}];Abort[]];
x1=(2 Sin[\[Phi]] (-Cos[\[Phi]]+\[Sqrt](-(h1^2-h2^2)^2+Cot[\[Phi]]^2 Csc[\[Phi]]^2) Sin[\[Phi]]))/(1+(h1^2-h2^2)+(1-(h1^2-h2^2)) Cos[2 \[Phi]]);
x2= (2 Sin[\[Phi]] (-Cos[\[Phi]]+\[Sqrt](-(h1^2-h2^2)^2+Cot[\[Phi]]^2 Csc[\[Phi]]^2) Sin[\[Phi]]))/(1-(h1^2-h2^2)+(1+(h1^2-h2^2)) Cos[2 \[Phi]]);
d\[Phi]1=2 ArcTan[x1];
d\[Phi]2=2ArcTan[x2];
r=\[Sqrt](h2^2+(x2^2 Csc[\[Phi]]^2)/(1+x2^2));
\[Alpha]=\[Pi]-ArcCos[(x2 (x2-Cot[\[Phi]]))/(\[Sqrt]((1+x2^2) (h2^2 (1+x2^2)+x2^2 Csc[\[Phi]]^2)))];
{\[Alpha],r,{d\[Phi]1,d\[Phi]2}}]
Module[{m,h1,h2,\[Alpha],r,d\[Phi]1,d\[Phi]2},
m=5;
h1=.9;
h2=.1;
{\[Alpha],r,d\[Phi]1,d\[Phi]2}=Flatten[TwistTubeParametersRH[m,{h1,h2}]];
{"h1"->h1,"h2"->h2,"\[Alpha]/\[Degree]"->\[Alpha]/\[Degree],"r"->r,"d\[Phi]1/\[Degree]"->d\[Phi]1/\[Degree],"d\[Phi]2/\[Degree]"->d\[Phi]2/\[Degree]}//ColumnForm
]//ShowExample
TwistTubeParametersLH[m_,{h1_,h2_}]:=Module[{\[Alpha],r,d\[Phi]1,d\[Phi]2},
{\[Alpha],r,d\[Phi]1,d\[Phi]2}=Flatten[TwistTubeParametersRH[m,{h1,h2}]];
{\[Pi]-\[Alpha],r,{-d\[Phi]1,-d\[Phi]2}}]
Module[{m,h1,h2,\[Alpha],r,d\[Phi]1,d\[Phi]2},
m=5;
h1=.9;
h2=.1;
{\[Alpha],r,d\[Phi]1,d\[Phi]2}=Flatten[TwistTubeParametersLH[m,{h1,h2}]];
{"h1"->h1,"h2"->h2,"\[Alpha]/\[Degree]"->\[Alpha]/\[Degree],"r"->r,"d\[Phi]1/\[Degree]"->d\[Phi]1/\[Degree],"d\[Phi]2/\[Degree]"->d\[Phi]2/\[Degree]}//ColumnForm
]//ShowExample
TwistTubeParameters[m_,{h1_,h2_,dir_}]:=If[dir>0,TwistTubeParametersRH[m,{h1,h2}],TwistTubeParametersLH[m,{h1,h2}]]
Module[{m,h1,h2,dir,\[Phi],\[Alpha],r,d\[Phi]1,d\[Phi]2,h0,cp,ff1,ff2},
m=5;
h1=0.8;
h2=0.2;
dir=+1;
\[Phi]=\[Pi]/m;
{\[Alpha],r,d\[Phi]1,d\[Phi]2}=Flatten[TwistTubeParameters[m,{h1,h2,dir}]];
h0=r Sin[\[Alpha]];(* altitude of parallelogram in CP *)
(* cp *)
cp=Graphics[{
Style[Line[{{0,0},{1,0},{1,0}+r U[\[Alpha]],r U[\[Alpha]],{0,0}}],MountainLine],
Style[Line[If[dir>0,{{0,0},{1,0}+r U[\[Alpha]]},{{1,0},r U[\[Alpha]]}]],ValleyLine]
}];
ff1=Graphics3D[{
Style[Line[Table[((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]],{i,0,m}]],MountainLine],
Style[Line[Table[{0,0,h1}+((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]+d\[Phi]1],{i,0,m}]],MountainLine],
Style[Table[Line[{((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]],{0,0,h1}+((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]+d\[Phi]1]}],{i,0,m-1}],MountainLine],Style[Table[Line[If[dir>0,{((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]],{0,0,h1}+((1/2)Csc[\[Phi]])U3D[(2i+1)\[Phi]+d\[Phi]1]},{((1/2)Csc[\[Phi]])U3D[(2i+1)\[Phi]],{0,0,h1}+((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]+d\[Phi]1]}]],{i,0,m-1}],ValleyLine]
}];
ff2=Graphics3D[{
Style[Line[Table[((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]],{i,0,m}]],MountainLine],
Style[Line[Table[{0,0,h2}+((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]+d\[Phi]2],{i,0,m}]],MountainLine],
Style[Table[Line[{((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]],{0,0,h2}+((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]+d\[Phi]2]}],{i,0,m-1}],MountainLine],Style[Table[Line[If[dir>0,{((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]],{0,0,h2}+((1/2)Csc[\[Phi]])U3D[(2i+1)\[Phi]+d\[Phi]2]},{((1/2)Csc[\[Phi]])U3D[(2i+1)\[Phi]],{0,0,h2}+((1/2)Csc[\[Phi]])U3D[(2i-1)\[Phi]+d\[Phi]2]}]],{i,0,m-1}],ValleyLine]
}];
GraphicsRow[{cp,ff1,ff2}]/.OrigamiStyle[]
]//ShowExample
MakeTwistTube[m_,hlist_List]:=Module[{\[Phi],verts,edges,types,verts3d,nv,\[Alpha],r,d\[Phi]1,d\[Phi]2,h2,dir,rr,tobj},
(* bottom row *)
\[Phi]=\[Pi]/m;
verts=Table[{i,0},{i,m+1}];
edges=Table[{i,i+1},{i,m}];
types=Table[B,{i,m}];
verts3d=Table[RotationZMatrix3D[2 i \[Phi]] . {(1/2)Cot[\[Phi]],-(1/2),0},{i,0,m}];
(* add each row in order *)
Do[
nv=Length[verts];
{\[Alpha],r,d\[Phi]1,d\[Phi]2}=Flatten[TwistTubeParameters[m, hlist[[j]]]];
h2=hlist[[j,2]];
dir=hlist[[j,3]];
rr=r U[\[Alpha]];
Do[
AppendTo[verts,verts[[nv-(m+1)+i]]+rr];
AppendTo[verts3d,{0,0,h2}+RotationZMatrix3D[d\[Phi]2] . verts3d[[nv-(m+1)+i]]];
(* verticals *)
AppendTo[edges,{nv-(m+1)+i,nv+i}];
AppendTo[types,If[i==0||i==m+1,B,M]];
,{i,m+1}];
(* diagonals *)
If[
dir>0,
Do[AppendTo[edges,{nv+i-(m+1),nv+i+1}];AppendTo[types,V],{i,m}];,
Do[AppendTo[edges,{nv+i+1-(m+1),nv+i}];AppendTo[types,V];,{i,m}]];
(* tops *)
Do[AppendTo[edges,{nv+i,nv+i+1}];AppendTo[types,If[j==Length[hlist],B,M]],{i,m}];
,{j,Length[hlist]}];
tobj=MakeTGraph3D[verts,edges,{},verts3d]//AddTPlaneGraph//AddTAssigned[types];
RecalcFoldAngles[tobj]]/;Length[Dimensions[hlist]]==2
Module[{tobj},
tobj=MakeTwistTube[4,{{.5,.5,+1},{.2,.8,+1},{.8,.2,-1},{.5,.5,+1}}];
GraphicsGrid[{{GraphGraphics[tobj],FoldAngleGraphics[tobj]},{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}}]/.OrigamiStyle[]
]//ShowExample
MakeTwistTube[m_,{h1_,h2_,dir_},nh_]:=MakeTwistTube[m,Table[{h1,h2,dir},{nh}]]
Module[{tobj},
tobj=MakeTwistTube[4,{.2,.8,+1},3];
GraphicsGrid[{{GraphGraphics[tobj],FoldAngleGraphics[tobj]},{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}}]/.OrigamiStyle[]
]//ShowExample
MakeFlutedConeCreaseVectors[m_,k_,qmin_,qmax_]:=Module[{qa=(qmax+qmin)/2,qb=(qmax-qmin)/2,qfn},
qfn=qa + qb Cos[m #]&;
Table[With[{\[Phi]=2\[Pi] i/(2 m k)},{Sin[qfn[\[Phi]]]Cos[\[Phi]],Sin[qfn[\[Phi]]]Sin[\[Phi]],Cos[qfn[\[Phi]]]}],{i,0,2 m k-1}]
]
Module[{gg,tobj},
gg=MakeFlutedConeCreaseVectors[4,3,20.\[Degree],60.\[Degree]];
Print["Max Angle/\[Degree]=",ArcTan[gg[[1,3]],gg[[1,1]]]/\[Degree]];
tobj=MakeTVertex3DFromFoldVectors[gg];
Vertex3DGraphicsTrio[tobj]/.Vertex3DStyle[]
]//ShowExample
MakeFlutedConeCreaseVectors[m_,k_,qmin_]:=Module[{qmax,gg,gg0,alt},
gg=MakeFlutedConeCreaseVectors[m,k,qmin,qmax];(* the full vertex with symbolic qmax *)
gg0=Take[gg,k+1];(* just one section of the fluting *)
alt=2 m Plus@@ArcSin/@Mag/@MapThread[Cross,{Drop[gg0,1],Drop[gg0,-1]},1];(* total vertex angle *)
gg/.FindRoot[alt-2\[Pi],{qmax,90\[Degree]}]
]
Module[{gg,tobj},
gg=MakeFlutedConeCreaseVectors[6,3,20.\[Degree]];
Print["Max Angle/\[Degree]=",ArcTan[gg[[1,3]],gg[[1,1]]]/\[Degree]];
tobj=MakeTVertex3DFromFoldVectors[gg];
Vertex3DGraphicsTrio[tobj]/.Vertex3DStyle[]
]//ShowExample
MaxSliceAngle[glist_]:=Module[{tobj,aa},
tobj=MakeTVertex3DFromFoldVectors[glist];
aa=#[[3]]&/@tobj[SectorVectors];
\[Pi]/2-ArcCos[Sort[aa][[1]]]
]
SliceLine::usage="SliceLine is an option to SlicedVertexGraphicsTrio that specifies the type of line to use at the slicing plane.";
Options[SlicedVertexGraphicsTrio]={
SliceLine->CreaseLine
};
SlicedVertexGraphicsTrio[glist_,r_,opts___]:=Module[{sl,tobj,vv,rn,dd,gr,gr2,cp,ff,gs},
sl=SliceLine/.{opts}/.Options[SlicedVertexGraphicsTrio];
tobj=MakeTVertex3DFromFoldVectors[glist,opts];(* create all the parts of the vertex *)
vv=GetAllRules[tobj];
rn=NormalizeReal[r];
dd=r . r/(# . r)&/@glist;(* distances out each crease *)
gr=dd*glist;(* vectors out to the planar ring in the folded form *)
gr2=dd*(CreaseVectors/.vv);(* vectors out to the planar ring in the crease pattern *)
(* Build imagery *)
cp=Vertex3DCreasePatternGraphics[tobj];
ff=Vertex3DFoldedFormGraphics3D[tobj];
gs=Vertex3DGaussianSphereGraphics3D[tobj];
GraphicsRow[{
Graphics[Join[cp[[1]],{Style[Line[Append[gr2,gr2[[1]]]],sl]}],FilterRules[{opts},Options[Graphics]]],
Graphics3D[Join[ff[[1]],{Style[Line[Append[gr,gr[[1]]]],sl]}],FilterRules[{opts},Options[Graphics3D]]],
Graphics3D[Join[gs[[1]],{Style[Point[rn],AbsolutePointSize[3]],Style[Styled3DUnitCircleFromNormal[rn],CreaseLine]}],FilterRules[{opts},Options[Graphics3D]] ]
}]]
Module[{glist,rslice},
glist=MakeFlutedConeCreaseVectors[6,3,30.\[Degree]];
rslice={0,0,1};
SlicedVertexGraphicsTrio[glist,0.4 rslice]/.Vertex3DStyle[]
]//ShowExample
Module[{glist,amax,rslice},
glist=MakeFlutedConeCreaseVectors[16,5,30.\[Degree]];
amax=MaxSliceAngle[glist];
Print["amax/\[Degree]=",amax/\[Degree]];
rslice={-Sin[amax],0,Cos[amax]};
SlicedVertexGraphicsTrio[glist,0.4 rslice]/.Vertex3DStyle[]
]//ShowExample
ConePhaseShift::usage="ConePhaseShift is an option to MakeSimpleFlutedCone that specifies the rotational phase shift of the crease pattern and folded form relative to the x-axis.";
Options[MakeSimpleFlutedCone]={
ConePhaseShift->0
};
MakeSimpleFlutedCone[m_,\[Alpha]_,opts___]:=Module[{ps,\[Phi]=\[Pi]/m,bt,verts,verts3d,edges,types,tobj},
ps=ConePhaseShift/.{opts}/.Options[MakeSimpleFlutedCone];
bt=ArcCos[(Cos[\[Pi]/m] Cos[\[Alpha]])/(1+Sin[\[Pi]/m] Sin[\[Alpha]])];
verts=Append[Flatten[Table[{{Cos[2 i \[Phi]+ps],Sin[2 i \[Phi]+ps]},{Cos[(2i+1 )\[Phi]+ps],Sin[(2i+1) \[Phi]+ps]}},{i,0,m-1}],1],{0,0}];
verts3d=Append[Flatten[Table[{{Sin[bt]Cos[2i \[Phi]+ps],Sin[bt]Sin[2i \[Phi]+ps],Cos[bt]},{Sin[\[Alpha]]Cos[(2i+1 )\[Phi]+ps],Sin[\[Alpha]]Sin[(2i+1) \[Phi]+ps],Cos[\[Alpha]]}},{i,0,m-1}],1],{0,0,0}];
edges=Join[Table[{i,2m+1},{i,2m}],Table[{i,Mod[i+1,2m,1]},{i,2m}]];
types=Join[Table[If[OddQ[i],M,V],{i,2m}],Table[B,{i,2m}]];
MakeTPlaneGraph[verts,edges]//AddTGraph3D[verts3d]//AddTAssigned[types]]
Module[{tobj},
tobj=MakeSimpleFlutedCone[8,30\[Degree],ConePhaseShift->0];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
ConeReduction::usage="ConeReduction is an option to SliceCone that specifies the relative distance of the slice plane from the tip.";
Options[SliceCone]={
ConeReduction->1
};
SliceCone[{vrtx_, pts_}, nr_,opts___]:=Module[{re,dd,pavg,rr1,dd1,r,pts1,vrtx1},
re=ConeReduction/.{opts}/.Options[SliceCone];
dd=Mag[#-vrtx]&/@pts;
pavg=(Plus@@pts)/Length[pts];
rr1=(#-vrtx)((pavg-vrtx) . nr /(#-vrtx) . nr)&/@pts;
dd1=Mag/@rr1;
r=re * Min[Select[dd/dd1,#>0&]];
pts1=vrtx+r #&/@rr1;
pavg=vrtx+r(pavg-vrtx);
vrtx1=vrtx-2nr((vrtx-pavg) . nr);
{vrtx1, pts1}]
Module[{tobj,verts3d,pts,vrtx,pts1,vrtx1,\[Gamma]=-10\[Degree]},
tobj=MakeSimpleFlutedCone[8,30\[Degree],ConePhaseShift->0];
verts3d=GetValue[tobj,Vertices3D];
vrtx=verts3d[[-1]];
pts=Drop[verts3d,-1];
{vrtx1,pts1}=SliceCone[{vrtx,pts}, {Sin[\[Gamma]],0,Cos[\[Gamma]]},ConeReduction->0.9];
Show[Graphics3D[{
EdgeForm[],
Polygon/@Transpose[{pts,RotateLeft[pts],Table[vrtx,{Length[pts]}]}],
Red,Line[{vrtx,#}]&/@pts,
Blue,Line[{vrtx1,#}]&/@pts1,
Black,Line[pts],
AbsolutePointSize[5],Green,Point/@pts1,
AbsolutePointSize[5],Black,Point[vrtx1],
AbsoluteThickness[5],Line[Append[pts1,pts1[[1]]]]
}]]
]//ShowExample
ConeSlicePlanes::usage = "ConeSlicePlanes is an option to MakeMultiSlicedCone that specifies a vector or list of vectors to slice the cone.";
ConeReductions::usage="ConeReductions is an option to MakeMultiSlicedCone that specifies the relative reduction from one slice to the next.";
Options[MakeMultiSlicedCone]={
ConeSlicePlanes->{0,0,1},
ConeReductions->0.9
};
MakeMultiSlicedCone[{vrtx_,pts_},n_,opts___]:=Module[{sp,re,mm,mmod,verts,edges,verts3d,types,v,p,ps,wa,uu,pp,vi},
sp=ConeSlicePlanes/.{opts}/.Options[MakeMultiSlicedCone];
re=ConeReductions/.{opts}/.Options[MakeMultiSlicedCone];
If[!(Length[Dimensions[sp]]==2 ),sp=Table[sp,{n}]];
If[!(Head[re]===List),re=Table[re,{n}]];
mm=Length[pts];
mmod=Mod[#,mm,1]&;(* for wrap-around indexing *)
(* 3D POINTS *)
v[0]=vrtx;
verts3d=p[0]=pts;
Do[{v[i],p[i]}=SliceCone[{v[i-1],p[i-1]},sp[[i]],ConeReduction->re[[i]]];JoinTo[verts3d,p[i]],{i,n}];
AppendTo[verts3d,v[n]];
(* 2D POINTS *)
ps=ArcTan[p[0][[1,1]],p[0][[1,2]]];
wa=MapThread[ArcCos[#1 . #2/(\[Sqrt]((#1 . #1)(#2 . #2)))]&,{#-vrtx&/@p[0],#-vrtx&/@RotateLeft[p[0]]},1];(* angles between wedges *)
uu={Cos[#],Sin[#]}&/@Drop[FoldList[Plus,ps,wa],-1];(* unit vectors of cp *)
verts={};
Do[pp[i]=MapThread[Times,{uu,Mag[#-v[i]]&/@p[i]},1];JoinTo[verts,pp[i]],{i,0,n}];
AppendTo[verts,{0,0}];
vi[i_,j_]:=1+mm i+If[i!=n+1,Mod[j-1,mm],0];(* maps (i,j) to index into verts or verts3d *)
edges=Join[
Flatten[Table[{vi[i,j],vi[i,j+1]},{i,0,n},{j,mm}],1],
Flatten[Table[{vi[i,j],vi[i+1,j]},{i,0,n},{j,mm}],1]
];
types=Join[
Flatten[Table[If[i==0,B,If[OddQ[i],M,V]],{i,0,n},{j,mm}],1],
Flatten[Table[If[EvenQ[i+j],M,V],{i,0,n},{j,mm}],1]
];
MakeTPlaneGraph[verts,edges]//AddTGraph3D[verts3d]//AddTAssigned[types]
]
Module[{mspc,verts3d,pts,vrtx,pts1,vrtx1,n,sp,re,tobj},
(* start with a generic cone *)
mspc=MakeSimpleFlutedCone[16,30.\[Degree],ConePhaseShift->0\[Degree]];
verts3d=GetValue[mspc,Vertices3D];
vrtx=verts3d[[-1]];
pts=Drop[verts3d,-1];
(* slice off the top and invert it so that it's flat with the peak on top *)
{vrtx1,pts1}=SliceCone[{vrtx,pts}, {0,0,1}];
(* and now make it into a multi-sliced object *)
n=4;(* number of slices *)
sp={Sin[#],0,Cos[#]}&/@Table[10\[Degree]*i,{i,n}];
re=Join[{0.83},Table[0.95,{n-1}]];
tobj=MakeMultiSlicedCone[{vrtx1,pts1},n,ConeSlicePlanes->sp,ConeReductions->re];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj,PaperOrientation->ColorUp]}]/.OrigamiStyle[]
]//ShowExample
Module[{mspc,verts3d,pts,vrtx,pts1,vrtx1,n=15,sp,re,tobj},
(* start with a generic cone *)
mspc=MakeSimpleFlutedCone[24,30.\[Degree],ConePhaseShift->0\[Degree]];
verts3d=GetValue[mspc,Vertices3D];
vrtx=verts3d[[-1]];
pts=Drop[verts3d,-1];
(* slice off the top and invert it so that it's flat with the peak on top *)
{vrtx1,pts1}=SliceCone[{vrtx,pts}, {0,0,1}];
(* and now make it into a multi-sliced object *)
sp={Sin[#],0,Cos[#]}&/@Table[10\[Degree]*i,{i,n}];
re=Join[{0.83},Table[0.98,{n-1}]];
tobj=MakeMultiSlicedCone[{vrtx1,pts1},n,ConeSlicePlanes->sp,ConeReductions->re];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj,PaperOrientation->ColorUp]}]/.OrigamiStyle[]
]//ShowExample
MakeWaterbombTessellation[nx_,ny_,t_]:=Module[{h,p1,p2,p3,p4,p5,p6,p7,q1,q2,q3,q4,q5,q6,q7,q8,xfrm,verts,verts3d,edges,types,foldangles,vi,makev,makee},
h=1/2;
(* 3d point values for waterbomb unit, from analytic analysis *)
{p1,p2,p3,p4,p5,p6,p7}={{-(1/2),-(1/2) \[Sqrt](1-t^2),0},{1/2,-(1/2) \[Sqrt](1-t^2),0},{1/2-1/(1+t^2),0,t (-(1/2)+1/(1+t^2))},{0,0,-(t/2)},{-(1/2)+1/(1+t^2),0,t (-(1/2)+1/(1+t^2))},{-(1/2),(\[Sqrt](1-t^2))/2,0},{1/2,(\[Sqrt](1-t^2))/2,0}};
(* 3d point values for blintz unit *)
{q1,q2,q3,q4,q5,q6,q7,q8}={{1/2-1/(1+t^2),-(1/2) \[Sqrt](1-t^2),0},{0,-((1-t^2)^(3/2)/(2+6 t^2)),-((t+t^3+2 t^5)/(1+4 t^2+3 t^4))},{-(1/2)+1/(1+t^2),-(1/2) \[Sqrt](1-t^2),0},{-(1/2),0,t (-(1/2)+1/(1+t^2))},{1/2,0,t (-(1/2)+1/(1+t^2))},{1/2-1/(1+t^2),(\[Sqrt](1-t^2))/2,0},{0,(1-t^2)^(3/2)/(2+6 t^2),-((t+t^3+2 t^5)/(1+4 t^2+3 t^4))},{-(1/2)+1/(1+t^2),(\[Sqrt](1-t^2))/2,0}};
(* transformation function that applies to any point in the 3d unit cell *)
xfrm[p_,i_,j_]:=If[t==0,
{1/2+i,1/2+j,0}+p,
{1/2+i/(1+t^2),(\[Sqrt](1-t^2))/2,-((1+t^2+2 t^4)/(4 (t+t^3)))}+RotationXMatrix3D[-4 j ArcCot[(1+t^2)/(t \[Sqrt](1-t^2))]] . (p+{0,0,(1+t^2+2 t^4)/(4 (t+t^3))})];
verts=verts3d=edges=types={};
(* vertices *)
makev[p_,pp_]:=(AppendTo[verts,p];AppendTo[verts3d,pp];vi[p]=Length[verts]);
Do[If[EvenQ[i],
(* even columns of waterbombs, p-points in 3d *)
If[i==0&&j==0,makev[{0,0},xfrm[p1,i,j]]];(* bottom left *)
If[i==0,makev[{0,j+h},xfrm[p3,i,j]];makev[{0,j+1},xfrm[p6,i,j]]];(* left middle and upper *)
If[j==0,makev[{i+1,j},xfrm[p2,i,j]]];(* bottom right *)
makev[{i+h,j+h},xfrm[p4,i,j]];makev[{i+1,j+h},xfrm[p5,i,j]];(*middle and right *)
makev[{i+1,j+1},xfrm[p7,i,j]] (* upper left *),
(* odd columns of blintzes, q-points in 3d *)
If[j==0,makev[{i+h,j},xfrm[q2,i,j]];makev[{i+1,j},xfrm[q3,i,j]]];(* bottom middle and right *)
makev[{i+1,j+h},xfrm[q5,i,j]];(* middle right *)
makev[{i+h,j+1},xfrm[q7,i,j]];makev[{i+1,j+1},xfrm[q8,i,j]]](* top middle and right *),
{j,0,ny-1},{i,0,nx-1}];
(* edges *)
makee[p1_,p2_,ty_]:=(AppendTo[edges,{vi[p1],vi[p2]}];AppendTo[types,ty]);
Do[
If[EvenQ[i],
(* waterbomb unit *)
If[j==0,makee[{i,j},{i+1,j},B]];
If[i==0,makee[{i,j},{i,j+h},B]];
makee[{i,j},{i+h,j+h},V];
makee[{i+h,j+h},{i+1,j},V];
makee[{i+1,j},{i+1,j+h},If[i==nx-1,B,M]];
makee[{i,j+h},{i+h,j+h},M];
makee[{i+h,j+h},{i+1,j+h},M];
If[i==0,makee[{i,j+h},{i,j+1},B]];
makee[{i,j+1},{i+h,j+h},V];
makee[{i+h,j+h},{i+1,j+1},V];
makee[{i+1,j+h},{i+1,j+1},If[i==nx-1,B,M]];
makee[{i,j+1},{i+1,j+1},If[j==ny-1,B,M]],
(* blintz unit *)
If[j==0,makee[{i,j},{i+h,j},B];makee[{i+h,j},{i+1,j},B]];
makee[{i,j+h},{i+h,j},V];
makee[{i+h,j},{i+1,j+h},V];
makee[{i+1,j},{i+1,j+h},If[i==nx-1,B,M]];
makee[{i,j+h},{i+1,j+h},M];
makee[{i,j+h},{i+h,j+1},V];
makee[{i+h,j+1},{i+1,j+h},V];
makee[{i+1,j+h},{i+1,j+1},If[i==nx-1,B,M]];
makee[{i,j+1},{i+h,j+1},If[j==ny-1,B,M]];
makee[{i+h,j+1},{i+1,j+1},If[j==ny-1,B,M]]],{j,0,ny-1},{i,0,nx-1}];
foldangles=TypeToFlatFoldAngle[types];
MakeTGraph3DAssigned[verts,edges,{},verts3d,foldangles,types]]//AddTPlaneGraph
Module[{nx,ny,tobj},
nx=3;
ny=3;
tobj=MakeWaterbombTessellation[nx,ny,.1];
GraphicsRow[{GraphGraphics[tobj],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
DynamicModule[{nx,ny,tobj,t,gg},
nx=3;
ny=3;
tobj=MakeWaterbombTessellation[nx,ny,t];
gg=GraphicsRow[{CreasePatternGraphics[tobj],
MatrixTransform[FoldedFormGraphics3D[tobj],RotationXMatrix3D[\[Pi]/2]]}]/.OrigamiStyle[];
Manipulate[gg/.t->tt,{{tt,0.25},0,.999}]
]//ShowExample
Clear[WaterbombTessellationGraph3DAssigned];
AddTGraphExample[WaterbombTessellationGraph3DAssigned,
MakeWaterbombTessellation[4,4,.5]];
Module[{tobj},
tobj=WaterbombTessellationGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
Options[GaussMapGraphics3D]={
ShowGaussianSphere->True,
GaussianSphereRadius->0.99
};
GaussMapGraphics3D[tobj_TObj,opts___]:=Module[{sgs,gsr,angles,verts3d,dverts3d,iedges,dedges,p1s,p2s,ras,dirs},
AssertClasses[tobj,{TPrimalDualGraph,TGraph3D},GaussMapGraphics3D];
sgs=ShowGaussianSphere/.{opts}/.Options[GaussMapGraphics3D];
gsr=GaussianSphereRadius/.{opts}/.Options[GaussMapGraphics3D];
{angles,verts3d,iedges,dedges}=GetValues[tobj,{FoldAngles,Vertices3D,InteriorEdges,DualEdges}];
(* face normals *)
dverts3d=FaceNormals3D[tobj];
(* face normal pairs *)
{p1s,p2s}=Transpose[dverts3d[[#]]&/@dedges];
(* rotation axes *)
ras=NormalizeReal[-Subtract@@verts3d[[#]]]&/@iedges;
(* rotation directions *)
dirs=If[#>=0,CCW,CW]&/@angles[[InteriorEdgeMap[tobj]]];
Graphics3D[{
If[sgs,Style[Sphere[{0,0,0},gsr],Opacity[0.5]],{}],
MapThread[Styled3DArc[#1,#2,RotationAxis->#3,ArcDirection->#4,LineStyle->TraceLine,FillStyle->None,opts]&,{p1s,p2s,ras,dirs}]
},FilterRules[{opts},Options[Graphics3D]]]]
Module[{verts,edges,foldangles,tobj},
verts={{0,0},{1,0},{1,1},{0,1},{-1,1},{-1,Tan[30\[Degree]]},{-1,-1},{-Tan[30\[Degree]],-1},{1,-1}};
edges={{1,2},{1,4},{1,6},{1,8},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,2}};
foldangles={2 ArcTan[1+2/(\[Sqrt]3)],-60 \[Degree],2 ArcTan[1+2/(\[Sqrt]3)],60 \[Degree],0,0,0,0,0,0,0,0}//N;
foldangles=2 ArcTan[0.3Tan[#/2]]&/@foldangles;
tobj=MakeTGraph[verts,edges]//AddTAssigned[FoldAngleToType[foldangles]]//AddTPlaneGraph//AddTGraph3D[]//AddTPrimalDualGraph;
tobj=FoldGraph3D[tobj,foldangles];
tobj=RotateGraph3D[tobj,70\[Degree],{1,0,0}];
GraphicsGrid[{
{GraphGraphics[tobj],
CreasePatternGraphics[tobj]},
{FoldedFormGraphics3D[tobj],
GaussMapGraphics3D[tobj]}}]/.Vertex3DStyle[]]
Module[{vtobj,tobj},
vtobj=MakeTDegree4Vertex3DFromSectorsAndMinorDihedral[{150.\[Degree],80.\[Degree],30\[Degree],100.\[Degree]},-40.\[Degree]];
tobj=MakeTHuffmanGrid[vtobj,{1,1},{8,5}]//AddTPrimalDualGraph;
GraphicsRow[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj],
GaussMapGraphics3D[tobj]
}/.Vertex3DStyle[]]
]//ShowExample
VertexPointEqualityConstraints[i_,p_List]:=Function[verts,#==0&/@(verts[[i]]-p)]
Module[{vpcf,x,verts},
vpcf=VertexPointEqualityConstraints[1,{3,4,5}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vpcf[verts]
]//ShowExample
VertexLineEqualityConstraints[i_,p_List,r_List]:=Function[verts,{(verts[[i]]-p) . (Normals3D[r][[1]])==0,(verts[[i]]-p) . (Normals3D[r][[2]])==0}]
Module[{vpcf,x,verts},
vpcf=VertexLineEqualityConstraints[1,{3,4,5},{0,0,1}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vpcf[verts]
]//ShowExample
VerticesLineEqualityConstraints[ilist_List,p_List,r_List]:=Function[verts,Flatten[{(verts[[#]]-p) . (Normals3D[r][[1]])==0,(verts[[#]]-p) . (Normals3D[r][[2]])==0}&/@ilist]]
Module[{vpcf,x,verts},
vpcf=VerticesLineEqualityConstraints[{1,2},{3,4,5},{0,0,1}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vpcf[verts]
]//ShowExample
VertexPlaneEqualityConstraints[i_,p_List,u_List]:=Function[verts,{(verts[[i]]-p) . u==0}]
Module[{vpcf,x,verts},
vpcf=VertexPlaneEqualityConstraints[1,{3,4,5},{0,0,1}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vpcf[verts]
]//ShowExample
VerticesPlaneEqualityConstraints[ilist_List,p_List,u_List]:=Function[verts,(verts[[#]]-p) . u==0&/@ilist]
Module[{vpcf,x,verts},
vpcf=VerticesPlaneEqualityConstraints[{1,2},{3,4,5},{0,0,1}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vpcf[verts]
]//ShowExample
VertexPlaneInequalityConstraints[i_,p_List,u_List]:=Function[verts,{(verts[[i]]-p) . u>=0}]
Module[{vpcf,x,verts},
vpcf=VertexPlaneInequalityConstraints[1,{3,4,5},{0,0,1}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vpcf[verts]
]//ShowExample
VerticesPlaneInequalityConstraints[ilist_List,p_List,u_List]:=Function[verts,(verts[[#]]-p) . u>=0&/@ilist]
Module[{vpcf,x,verts},
vpcf=VerticesPlaneInequalityConstraints[{1,2},{3,4,5},{0,0,1}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vpcf[verts]
]//ShowExample
VertexZRadiusEqualityConstraints[i_,r_]:=Function[verts,{Mag[verts[[i,{1,2}]]]-r==0}]
Module[{vzrcf,x,verts},
vzrcf=VertexZRadiusEqualityConstraints[1,2.];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vzrcf[verts]
]//ShowExample
VerticesZRadiusEqualityConstraints[ilist_List,r_]:=
Function[verts,Mag[verts[[#,{1,2}]]]-r==0&/@ilist]
Module[{vzrcf,x,verts},
vzrcf=VerticesZRadiusEqualityConstraints[{1,2},3.];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vzrcf[verts]
]//ShowExample
VertexZRadiusPairConstraints[{i_,j_}]:=Function[verts,{Mag[verts[[i,{1,2}]]]-Mag[verts[[j,{1,2}]]]==0}]
Module[{vzrpf,x,verts},
vzrpf=VertexZRadiusPairConstraints[{1,2}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]}};
vzrpf[verts]
]//ShowExample
VerticesZRadiusPairConstraints[ijlist_List]:=
Function[verts,Mag[verts[[#[[1]],{1,2}]]]-Mag[verts[[#[[2]],{1,2}]]]==0&/@ijlist]
Module[{vzrpf,x,verts},
vzrpf=VerticesZRadiusPairConstraints[{{1,2},{3,4}}];
verts={{x[1],x[2],x[3]},{x[4],x[5],x[6]},{x[7],x[8],x[9]},{x[10],x[22],x[12]}};
vzrpf[verts]
]//ShowExample
InteriorEdgeVertexNeighborhoods[tobj_TObj]:=Module[{edges,efi,faces,ieinfo},
{edges,efi,faces}=GetValues[tobj,{Edges,EdgeFaceIncidence,Faces}];
Table[If[efi[[i,1]]==0||efi[[i,2]]==0,{},{edges[[i,1]],faces[[efi[[i,1]]]],edges[[i,2]],faces[[efi[[i,2]]]]}],{i,Length[edges]}]]
Module[{verts,edges,faces,tobj},
verts={{0,0},{1,0},{1,1},{0,1},{-1,1},{-1,1/\[Sqrt]3},{-1,-1},{-1/\[Sqrt]3,-1},{1,-1}};
edges={{1,2},{1,4},{1,6},{1,8},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,2}};
faces={{1,2,3,4},{1,4,5,6},{1,6,7,8},{1,8,9,2}};
tobj=MakeTGraph[verts,edges,faces]//RebuildPlaneGraph;
Print[GraphGraphics[tobj]];
InteriorEdgeVertexNeighborhoods[tobj]
]//ShowExample
EdgeValleyFoldConstraints[{i1_,f1_,i2_,f2_},verts_List]:=Module[{p1,p2,p3,p4,u2,u4,r13},
p1=verts[[i1]];
p2=Plus@@verts[[f1]]/Length[f1];
p3=verts[[i2]];
p4=Plus@@verts[[f2]]/Length[f2];
u2=(p2-p1)\[Cross](p3-p1);u2=u2/Mag[u2];
u4=(p3-p1)\[Cross](p4-p1);u4=u4/Mag[u4];
r13=p3-p1;
{(u2\[Cross]u4) . r13/Mag[r13]>=0}]
DynamicModule[{verts,qvfc},
Manipulate[
verts={{0,0,0},{Cos[\[Theta]],.5,Sin[\[Theta]]},{0,1,0},{-1,.5,0}};
qvfc=EdgeValleyFoldConstraints[{1,{1,2,3},3,{1,3,4}},verts];
Graphics3D[{
Polygon[verts[[{1,2,3}]]],Polygon[verts[[{1,3,4}]]]},PlotRange->{{-1,1},{0,1},{-1,1}},PlotLabel->qvfc],
{{\[Theta],0},-\[Pi],\[Pi]}]
]//ShowExample
EdgeMountainFoldConstraints[{i1_,f1_,i2_,f2_},verts_List]:=Module[{p1,p2,p3,p4,u2,u4,r13},
p1=verts[[i1]];
p2=Plus@@verts[[f1]]/Length[f1];
p3=verts[[i2]];
p4=Plus@@verts[[f2]]/Length[f2];
u2=(p2-p1)\[Cross](p3-p1);u2=u2/Mag[u2];
u4=(p3-p1)\[Cross](p4-p1);u4=u4/Mag[u4];
r13=p3-p1;
{-(u2\[Cross]u4) . r13/Mag[r13]>=0}]
DynamicModule[{verts,qmfc},
Manipulate[
verts={{0,0,0},{Cos[\[Theta]],.5,Sin[\[Theta]]},{0,1,0},{-1,.5,0}};
qmfc=EdgeMountainFoldConstraints[{1,{1,2,3},3,{1,3,4}},verts];
Graphics3D[{
Polygon[verts[[{1,2,3}]]],Polygon[verts[[{1,3,4}]]]},PlotRange->{{-1,1},{0,1},{-1,1}},PlotLabel->qmfc],
{{\[Theta],0},-\[Pi],\[Pi]}]
]//ShowExample
QuadBendEnergy13[p_List,q_List,r_List,s_List]:=Module[{qp,rp,sp,cos},
{qp,rp,sp}={q-p,r-p,s-p};
cos=(qp\[Cross]rp) . (rp\[Cross]sp)/(Mag[(qp\[Cross]rp)]Mag[(rp\[Cross]sp)]);(* cosine of fold angle *)
Mag[rp](1-cos)/2]
DynamicModule[{p,q,r,s,qfe},
Manipulate[
{p,q,r,s}={{0,0,0},{Cos[\[Theta]],.5,Sin[\[Theta]]},{0,1,0},{-1,.5,0}};
qfe=QuadBendEnergy13[p,q,r,s];
Graphics3D[{
Polygon[{p,q,r}],Polygon[{p,r,s}]},PlotRange->{{-1,1},{0,1},{-1,1}},PlotLabel->Chop[qfe]],
{{\[Theta],0},-\[Pi],\[Pi]}]
]//ShowExample
QuadBendEnergy[p1_,p2_,p3_,p4_]:=QuadBendEnergy13[p1,p2,p3,p4]+QuadBendEnergy13[p2,p3,p4,p1]
QuadFlatFoldEnergy[p_List,q_List,r_List,s_List]:=Module[{qp,rp,sp,cos},
{qp,rp,sp}={q-p,r-p,s-p};
cos=(qp\[Cross]rp) . (rp\[Cross]sp)/(Mag[(qp\[Cross]rp)]Mag[(rp\[Cross]sp)]);(* cosine of fold angle *)
Mag[rp](1+cos)/2]
DynamicModule[{p,q,r,s,qfe},
Manipulate[
{p,q,r,s}={{0,0,0},{Cos[\[Theta]],.5,Sin[\[Theta]]},{0,1,0},{-1,.5,0}};
qfe=QuadFlatFoldEnergy[p,q,r,s];
Graphics3D[{
Polygon[{p,q,r}],Polygon[{p,r,s}]},PlotRange->{{-1,1},{0,1},{-1,1}},PlotLabel->Chop[qfe]],
{{\[Theta],0},-\[Pi],\[Pi]}]
]//ShowExample
EdgeFlatFoldEnergy[{i1_,f1_,i2_,f2_},verts_List]:=
Module[{p1,p2,p3,p4,u2,u4,r13},
p1=verts[[i1]];
p2=Plus@@verts[[f1]]/Length[f1];
p3=verts[[i2]];
p4=Plus@@verts[[f2]]/Length[f2];
QuadFlatFoldEnergy[p1,p2,p3,p4]]
DynamicModule[{verts,effe},
Manipulate[
verts={{0,0,0},{Cos[\[Theta]],.5,Sin[\[Theta]]},{0,1,0},{-1,.5,0}};
effe=EdgeFlatFoldEnergy[{1,{1,2,3},3,{1,3,4}},verts];
Graphics3D[{
Polygon[verts[[{1,2,3}]]],Polygon[verts[[{1,3,4}]]]},PlotRange->{{-1,1},{0,1},{-1,1}},PlotLabel->Chop[effe]],
{{\[Theta],0},-\[Pi],\[Pi]}]
]//ShowExample
TQMeshQ[tobj_TObj] := With[{faces=tobj[Faces]},!ListEmptyQ[faces]&& (And@@(Length[#]<=4&/@faces))]
ConstrainFromAssignment::usage="ConstrainFromAssignment is an option to StrainTQMesh that specifies whether to constrain fold angles from the initial crease assignment.";
StrainGravity::usage="StrainGravity is an option to StrainTQMesh that specifies the strength of gravity acting on a strained TQ mesh.";
GravityDirection::usage="GravityDirection is an option to StrainTQMesh that specifies the direction that gravity points for a strained TQ mesh.";
QuadBendStiffness::usage="QuadBendStiffness is an option to StrainTQMesh that specifies the relative stiffness of quadrilateral faces against bending along their diagonals.";
FlatFoldStiffness::usage="FlatFoldStiffness is an option to StrainTQMesh that specifies the relative stiffness of folds to stay in their flat-folded configuration.";
SplitBentFaces::usage="SplitBentFaces is an option to BendQuadMeshPlanely that specifies whether bent quad faces should be split into pairs of triangles.";
SplitBendTolerance::usage="SplitBendTolerance is an option to BendQuadMeshPlanely that specifies the bend angle at or above which we split a quad into triangles.";
Options[StrainTQMesh]={
ConstrainFromAssignment->False,
StrainGravity->1,
GravityDirection->{0,0,-1},
QuadBendStiffness->1,
FlatFoldStiffness->1,
SplitBentFaces->True,
SplitBendTolerance->1\[Degree]
};
StrainTQMesh[tobj_TObj,cons_List,opts___]:=Module[{cfa,qbs,ffs,sbf,sbt,verts,edges,faces,types,verts3d,qfaces,ievns,vars,vars0,vverts,x,econds,dconds,faconds,exconds,genergy,benergy,iequads,ffenergy,fom,soln,tobj1,nedges},
cfa=ConstrainFromAssignment/.{opts}/.Options[StrainTQMesh];
qbs=QuadBendStiffness/.{opts}/.Options[StrainTQMesh];
ffs=FlatFoldStiffness/.{opts}/.Options[StrainTQMesh];
sbf=SplitBentFaces/.{opts}/.Options[StrainTQMesh];
sbt=SplitBendTolerance/.{opts}/.Options[StrainTQMesh];
AssertClass[tobj,TGraph3D,StrainTQMesh];
AssertClass[tobj,TPlaneGraph,StrainTQMesh];
If[cfa,AssertProperty[tobj,EdgeTypes,StrainTQMesh]];
{verts,edges,faces,verts3d}=GetValues[tobj,{Vertices,Edges,Faces,Vertices3D}];
qfaces=Select[faces,Length[#]==4&];(* quadrilateral faces *)
ievns=InteriorEdgeVertexNeighborhoods[tobj];
(* VARIABLES *)
vars=Table[x[i],{i,3Length[verts]}];(* all variables *)
vars0=Flatten[verts3d,1];(* initial values *)
vverts=Partition[vars,3];(* vertices as variables *)
(* CONSTRAINTS *)
(* edge isometry constraints *)
econds=Mag[vverts[[#[[1]]]]-vverts[[#[[2]]]]]/Mag[verts[[#[[1]]]]-verts[[#[[2]]]]]-1==0&/@edges;
(* diagonal isometry constraints for quads *)
dconds=If[qbs===\[Infinity],
(* infinitely stiff quads, no bending on either diagonal *)
Flatten[{Mag[vverts[[#[[1]]]]-vverts[[#[[3]]]]]/Mag[verts[[#[[1]]]]-verts[[#[[3]]]]]-1==0,Mag[vverts[[#[[2]]]]-vverts[[#[[4]]]]]/Mag[verts[[#[[2]]]]-verts[[#[[4]]]]]-1==0}&/@qfaces],
(* allow bending, either diagonal is isometric *)
(Mag[vverts[[#[[1]]]]-vverts[[#[[3]]]]]/Mag[verts[[#[[1]]]]-verts[[#[[3]]]]]-1)(Mag[vverts[[#[[2]]]]-vverts[[#[[4]]]]]/Mag[verts[[#[[2]]]]-verts[[#[[4]]]]]-1)==0&/@qfaces];
(* fold angle constraints from from assignment *)
faconds=If[cfa,
types=GetValue[tobj,EdgeTypes];
faconds=Flatten[MapThread[Switch[#1,
V,If[!ListEmptyQ[#2],EdgeValleyFoldConstraints[#2,vverts],{}],
M,If[!ListEmptyQ[#2],EdgeMountainFoldConstraints[#2,vverts],{}],
_,{}]&,{types,ievns}]],{}];
(* external constraints *)
exconds=Flatten[#[vverts]&/@cons];
(* FIGURE OF MERIT *)
(* bend energy of quads *)
benergy=If[qbs==0||qbs===\[Infinity],0,qbs Plus@@(Apply[QuadBendEnergy,vverts[[#]]]&/@qfaces)];
(* flat fold energy *)
ffenergy=If[ffs==0,0,ffs Plus@@(EdgeFlatFoldEnergy[#,vverts]&/@Select[ievns,!ListEmptyQ[#]&])];
fom=benergy+ffenergy;
(* find a solution *)
Print["# vars = ",Length[vars]]//Hold;
Print["# conds = ",Length[Join[econds,dconds,faconds,exconds]]]//Hold;
soln=FindMinimum@@{{fom,Join[econds,dconds,faconds,exconds]},Transpose[{vars,vars0}]};
(* make a new object with the new vertices *)
verts3d=vverts/.soln[[2]];
tobj1=tobj//ReplaceProperty[Vertices3D->verts3d];
nedges={};
If[sbf,
(* Seek new edges as those whose bend angle exceeds the tolerance *)
With[{ba13=SkewQuadrilateralAngle@@verts3d[[#]],ba24=SkewQuadrilateralAngle@@verts3d[[RotateLeft[#]]]},If[ba13>=sbt,AppendTo[nedges,#[[{1,3}]]],If[ba24>=sbt,AppendTo[nedges,#[[{2,4}]]]]]]&/@qfaces];
If[sbf&&!ListEmptyQ[nedges],
tobj1=tobj1//ReplaceProperties[{Edges->Join[edges,nedges],EdgeTypes->Join[tobj1[EdgeTypes],Table[U,{Length[nedges]}]]}]//RebuildPlaneGraph];
tobj1=tobj1//RecalcFoldAngles;
tobj1=ReassignGraphAssigned[tobj1,tobj1[FoldAngles]];
tobj1]
Module[{verts,edges,verts3d,types,foldangles,tobj,cons,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{0,1},{1,1},{2,1},{3,1}}//N;
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8}};
types={B,B,B,B,V,M,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types];
foldangles=TypeToFlatFoldAngle[types];
tobj=FoldGraph3D[tobj,foldangles];
tobj1=StrainTQMesh[tobj,
{VertexPointEqualityConstraints[1,{0,0,0}],
VertexPointEqualityConstraints[5,{0,1,0}],
VertexPointEqualityConstraints[8,{1,1,1}]},
ConstrainFromAssignment->False,
QuadBendStiffness->\[Infinity],
FlatFoldStiffness->0,
SplitBentFaces->True];
GraphicsGrid[{{GraphGraphics[tobj],GraphGraphics[tobj1]},
{CreasePatternGraphics[tobj],CreasePatternGraphics[tobj1]},
{FoldedFormGraphics3D[tobj],FoldedFormGraphics3D[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,verts3d,types,foldangles,tobj,cons,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{0,1},{1,1},{2,1},{3,1}}//N;
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8}};
types={B,B,B,B,V,M,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types];
foldangles=TypeToFlatFoldAngle[types];
tobj=FoldGraph3D[tobj,foldangles];
tobj1=StrainTQMesh[tobj,
{VertexPointEqualityConstraints[1,{0,0,0}],
VertexPointEqualityConstraints[5,{0,1,0}],
VertexPointEqualityConstraints[8,{1,1,1}]},
ConstrainFromAssignment->False,
QuadBendStiffness->\[Infinity],
FlatFoldStiffness->1,
SplitBentFaces->True];
GraphicsGrid[{{GraphGraphics[tobj],GraphGraphics[tobj1]},
{CreasePatternGraphics[tobj],CreasePatternGraphics[tobj1]},
{FoldedFormGraphics3D[tobj],FoldedFormGraphics3D[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,verts3d,types,foldangles,tobj,cons,tobj1},
verts={{0,0},{1,0},{2,0},{3,0},{0,1},{1,1},{2,1},{3,1}}//N;
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8}};
types={B,B,B,B,V,M,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types];
foldangles=TypeToFlatFoldAngle[types];
tobj=FoldGraph3D[tobj,foldangles];
tobj1=StrainTQMesh[tobj,
{VertexPointEqualityConstraints[1,{0,0,0}],
VertexPointEqualityConstraints[5,{0,1,0}],
VertexPointEqualityConstraints[8,{1,1.5,1}]},
QuadBendStiffness->1,
FlatFoldStiffness->0,
SplitBentFaces->True];
GraphicsGrid[{{GraphGraphics[tobj],GraphGraphics[tobj1]},
{CreasePatternGraphics[tobj],CreasePatternGraphics[tobj1]},
{FoldedFormGraphics3D[tobj],FoldedFormGraphics3D[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,verts3d,types,foldangles,tobj,cons,tobj1},
verts={{0,0},{1,0},{3,0},{5,0},{0,1},{2,1},{4,1},{5,1},{0,2},{1,2},{3,2},{5,2}}//N;
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8},{5,9},{6,10},{7,11},{8,12},{9,10},{10,11},{11,12}};
types={B,B,B,B,V,M,B,M,V,M,B,V,M,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types];
foldangles=TypeToFlatFoldAngle[types];
tobj=FoldGraph3D[tobj,foldangles];
tobj1=StrainTQMesh[tobj,
{VertexPointEqualityConstraints[1,{0,0,0}],
VerticesPlaneEqualityConstraints[{2,3,4},{0,0,0},{0,0,1}],
VerticesPlaneEqualityConstraints[{9,10,11,12},{0,0,-1.},NormalizeReal[{.5,0,1}]]},
QuadBendStiffness->1,
FlatFoldStiffness->0,
SplitBentFaces->True];
GraphicsGrid[{{GraphGraphics[tobj],GraphGraphics[tobj1]},
{CreasePatternGraphics[tobj],CreasePatternGraphics[tobj1]},
{FoldedFormGraphics3D[tobj],FoldedFormGraphics3D[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,verts3d,types,foldangles,tobj,cons,tobj1},
verts={{0,0},{1,0},{3,0},{5,0},{0,1},{2,1},{4,1},{5,1},{0,2},{1,2},{3,2},{5,2}}//N;
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8},{5,9},{6,10},{7,11},{8,12},{9,10},{10,11},{11,12}};
types={B,B,B,B,V,M,B,M,V,M,B,V,M,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types];
foldangles=TypeToFlatFoldAngle[types];
tobj=FoldGraph3D[tobj,foldangles];
tobj1=StrainTQMesh[tobj,
{VertexPointEqualityConstraints[1,{0,0,0}],
VerticesPlaneEqualityConstraints[{2,3,4},{0,0,0},{0,0,1}],
VertexPointEqualityConstraints[9,{0,0,-1}]},
QuadBendStiffness->1,
FlatFoldStiffness->1,
SplitBentFaces->True,
SplitBendTolerance->1\[Degree]];
GraphicsGrid[{{GraphGraphics[tobj],GraphGraphics[tobj1]},
{CreasePatternGraphics[tobj],CreasePatternGraphics[tobj1]},
{FoldedFormGraphics3D[tobj],FoldedFormGraphics3D[tobj1]}}]/.OrigamiStyle[]
]//ShowExample
Module[{nx,ny,r,tobj,verts3d},
nx=3;
ny=3;
r=1.1;
tobj=MakeWaterbombTessellation[nx,ny,0.95];
verts3d=GetValue[tobj,Vertices3D];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]//Print;
tobj=StrainTQMesh[tobj,
{(* constrain two vertices to their original position *)
VertexPointEqualityConstraints[4,verts3d[[4]]],
VertexPointEqualityConstraints[9,verts3d[[9]]],
(* stretch two vertices away from their original position *)
VertexPointEqualityConstraints[32,verts3d[[32]]-{0,0,r}],
VertexPointEqualityConstraints[35,verts3d[[35]]-{0,0,r}]},
QuadBendStiffness->0,
FlatFoldStiffness->1,
SplitBentFaces->False];
GraphicsRow[{CreasePatternGraphics[tobj],
MatrixTransform[FoldedFormGraphics3D[tobj],RotationXMatrix3D[.75\[Pi]]]}]/.OrigamiStyle[]
]//ShowExample
Module[{nx,ny,tobj,verts3d},
nx=5;
ny=5;
tobj=MakeWaterbombTessellation[nx,ny,0.95];
verts3d=GetValue[tobj,Vertices3D];
GraphicsRow[{
GraphGraphics[tobj],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[]}]//Print;
tobj=StrainTQMesh[tobj,
{(* constrain two vertices to their original position *)
VertexPointEqualityConstraints[9,verts3d[[9]]],
VertexPointEqualityConstraints[13,verts3d[[13]]],
(* stretch two vertices away from their original position *)
VertexPointEqualityConstraints[84,verts3d[[84]]-{0,0,1}],
VertexPointEqualityConstraints[87,verts3d[[87]]-{0,0,1}]},
QuadBendStiffness->0,
FlatFoldStiffness->1,
SplitBentFaces->False];
GraphicsRow[{CreasePatternGraphics[tobj],
MatrixTransform[FoldedFormGraphics3D[tobj],RotationXMatrix3D[\[Pi]]]}]/.OrigamiStyle[]
]//Hold;
MakeWaterbombBase[\[Theta]1_,\[Theta]2_,\[Theta]3_]:=Module[{verts,edges,types,verts3d,foldangles,tobj},
verts={{0,0},{1,0},{0,1/2},{1/2,1/2},{1,1/2},{0,1},{1,1}};
edges={{1,2},{1,3},{1,4},{2,4},{2,5},{3,4},{4,5},{3,6},{4,6},{4,7},{5,7},{6,7}};
types={B,B,V,V,B,M,M,B,V,V,B,B};
foldangles={0,0,\[Pi],\[Pi],0,-\[Pi],-\[Pi],0,\[Pi],\[Pi],0,0};
(* verts3d are perturbed to get away from singular state *)
verts3d={{0,0,0},{1,0,0},{1/2,0,0},{1/2,1/2,0},{1/2,0,0},{0,0,.1},{1,0,.1}};
tobj=MakeTGraph3DAssigned[verts,edges,{},verts3d,foldangles,types]//AddTPlaneGraph;
StrainTQMesh[tobj,
{VertexPointEqualityConstraints[1,{0,0,0}],
Function[vv,{vv[[4,3]]==0}],
Function[vv,{vv[[2,3]]==0}],
Function[vv,{NormalizeReal[vv[[6]]-vv[[4]]] . NormalizeReal[vv[[1]]-vv[[4]]]==Cos[\[Theta]1]}],
Function[vv,{NormalizeReal[vv[[7]]-vv[[4]]] . NormalizeReal[vv[[2]]-vv[[4]]]==Cos[\[Theta]1]}],
Function[vv,{(((vv[[1]]+vv[[2]])/2-vv[[4]])\[Cross]NormalizeReal[((vv[[6]]+vv[[7]])/2-vv[[4]]){1,1,0}]) . {0,0,1}==Sin[\[Theta]3]}]},
ConstrainFromAssignment->False,
QuadBendStiffness->\[Infinity],
FlatFoldStiffness->0,
SplitBentFaces->False]]
Module[{\[Theta]1,\[Theta]2,\[Theta]3,tobj},
\[Theta]1=40.\[Degree]; (* angle between vertices 1 and 6 *)
\[Theta]2=40.\[Degree];(* angle between vertices 2 and 7 *)
\[Theta]3=-10.\[Degree];(* skew angle between top and bottom *)
tobj=MakeWaterbombBase[\[Theta]1,\[Theta]2,\[Theta]3];
GraphicsRow[{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Options[RotationalPleats]={
SplitBentFaces->True,
SplitBendTolerance->1\[Degree]
};
RotationalPleats[tobj_TObj, n_,\[Phi]_,opts___]:=Module[{sbf,sbt,verts,edges,faces,types,verts2d,bverts,tverts,nb,nt,nbt,d\[Phi],verts3d,foldangles,tobj1,qfaces,vars,x,vars0,vvars,econds,dconds,sconds,soln,nedges,bedges,tedges,cedges,cpfn,fffn,vpfn,gedges,vpairs,tobj2},
AssertClass[tobj,TGraph2D,RotationalPleats];
AssertProperties[tobj,{BottomVertices,TopVertices},RotationalPleats];
sbf=SplitBentFaces/.{opts}/.Options[RotationalPleats];
sbt=SplitBendTolerance/.{opts}/.Options[RotationalPleats];
d\[Phi]=\[Phi]/(2n);
{verts,edges,faces,types,verts2d,bverts,tverts}=GetValues[tobj,{Vertices,Edges,Faces,EdgeTypes,Vertices2D,BottomVertices,TopVertices}];
nb=Length[bverts];
nt=Length[tverts];
(* Make a vertically oriented 3D version of the flat fold *)
verts3d=RotationXMatrix3D[90\[Degree]] . Append[#,0]&/@verts2d;
foldangles=TypeToFlatFoldAngle[types];
tobj1=tobj//AddTGraph3D[verts3d,foldangles];

(* create symbolic variables for 3d vertices *)
vars=Table[x[i],{i,3Length[verts]}];(* all variables *)
vars0=Flatten[verts3d,1];(* initial values *)
vvars=Partition[vars,3];(* vertices as variables *)
(* edge isometry functions *)
econds=Mag[vvars[[#[[1]]]]-vvars[[#[[2]]]]]/Mag[verts[[#[[1]]]]-verts[[#[[2]]]]]-1&/@edges;
(* diagonal isometry functions for quads *)
qfaces=Select[faces,Length[#]==4&];(* quadrilateral faces *)
dconds=(Mag[vvars[[#[[1]]]]-vvars[[#[[3]]]]]/Mag[verts[[#[[1]]]]-verts[[#[[3]]]]]-1)(Mag[vvars[[#[[2]]]]-vvars[[#[[4]]]]]/Mag[verts[[#[[2]]]]-verts[[#[[4]]]]]-1)&/@qfaces;
(* shape constraint functions that define the stretched shape *)
sconds=Flatten[{
(* lower left vertex to its original position *)
vvars[[bverts[[1]]]]-verts3d[[bverts[[1]]]],
(* remaining bottom row of vertices to x-z plane *)
(# . {0,1,0})&/@vvars[[Drop[bverts,1]]],
(* top row of vertices to rotated x-y plane *)
(# . U3D[\[Pi]/2+d\[Phi]])&/@vvars[[If[bverts[[1]]==tverts[[1]],Drop[tverts,1],tverts]]],
(* upper right vertex constrained to its original radius from z-axis *)
Mag[vvars[[tverts[[-1]],{1,2}]]]-Mag[verts3d[[tverts[[-1]],{1,2}]]]}];
(* Double-check that #vars = #eqns *)
With[{nv=Length[vars],ne=Length[Join[econds,dconds,sconds]]},If[nv!=ne,Print["ERROR: nv = ",nv,", ne = ",ne];Abort[]]];
(* Solve all equations for new shape *)
soln=FindRoot@@{Join[sconds,econds,dconds],Transpose[{vars,vars0}]};
verts3d=vvars/.soln;
tobj1=tobj1//ReplaceProperty[Vertices3D->verts3d];
(* Break bent quads into triangles whose bend exceeds tolerance *)
nedges={};
If[sbf,
With[{ba13=SkewQuadrilateralAngle@@verts3d[[#]],ba24=SkewQuadrilateralAngle@@verts3d[[RotateLeft[#]]]},If[ba13>=sbt,AppendTo[nedges,#[[{1,3}]]],If[ba24>=sbt,AppendTo[nedges,#[[{2,4}]]]]]]&/@qfaces];
If[sbf&&!ListEmptyQ[nedges],
edges=Join[edges,nedges];
tobj1=tobj1//ReplaceProperties[{Edges->edges,EdgeTypes->Join[tobj1[EdgeTypes],Table[U,{Length[nedges]}]]}]//RebuildPlaneGraph];
(* Here's the fully constructed 3D folded strip *)
tobj1=tobj1//RecalcFoldAngles;
tobj1=ReassignGraphAssigned[tobj1,tobj1[FoldAngles]];
GraphicsRow[{CreasePatternGraphics[tobj1],FoldedFormGraphics3D[tobj1]}]/.OrigamiStyle[]//HoldFirst;
(* Now, with this new 3D strip, build a new CP and FF that consists of multiple repetitions of the pattern. *)
(* start by partitioning edges into bottom, top, and crosswise *)
bedges=tedges=cedges={};
(If[MemberQ[bverts,#[[1]]]&&MemberQ[bverts,#[[2]]],AppendTo[bedges,#]];
If[MemberQ[tverts,#[[1]]]&&MemberQ[tverts,#[[2]]],AppendTo[tedges,#]];
If[MemberQ[bverts,#[[1]]]&&!MemberQ[tverts,#[[1]]]&&MemberQ[tverts,#[[2]]]&&!MemberQ[bverts,#[[2]]],AppendTo[cedges,#]];
If[MemberQ[tverts,#[[1]]]&&!MemberQ[bverts,#[[1]]]&&MemberQ[bverts,#[[2]]]&&!MemberQ[tverts,#[[2]]],AppendTo[cedges,Reverse[#]]])&/@edges;
(* transformation to jth row of CP. *)
Module[{\[Theta],c},
\[Theta]=RotationAngle[verts[[bverts[[-1]]]]-verts[[bverts[[1]]]],verts[[tverts[[-1]]]]-verts[[tverts[[1]]]]];
If[\[Theta]==0,
(* rectangular strip *)
cpfn[p_,j_]:=p+2 j (verts[[tverts[[1]]]]-verts[[bverts[[1]]]]),
(* trapezoid or wedge *)
c=If[bverts[[1]]==tverts[[1]],verts[[bverts[[1]]]],
c=LineInt2D[verts[[bverts[[-1]]]],verts[[bverts[[1]]]],verts[[tverts[[-1]]]],verts[[tverts[[1]]]]]];
cpfn[p_,j_]:=c+RotationMatrix2D[2 j \[Theta]] . (p-c)]];
(* transformation to jth row of FF *)
fffn[p_,j_]:=RotationZMatrix3D[2 j d\[Phi]] . p;
(* vertex 2D and 3D pair function, i is index, j is row *)
vpfn[i_,j_]:={cpfn[verts[[i]],j],fffn[verts3d[[i]],j]};
(* Build up all edges as 2D,3D pairs. *)
gedges={};
Do[
Do[AppendTo[gedges,{vpfn[bedges[[i,1]],j],vpfn[bedges[[i,2]],j]}],{i,Length[bedges]}];
Do[AppendTo[gedges,{vpfn[cedges[[i,1]],j],vpfn[cedges[[i,2]],j]}],{i,Length[cedges]}];
Do[AppendTo[gedges,{vpfn[tedges[[i,1]],j],vpfn[tedges[[i,2]],j]}],{i,Length[tedges]}];
Do[AppendTo[gedges,{vpfn[cedges[[i,1]],j+1],vpfn[cedges[[i,2]],j]}],{i,Length[cedges]}];
,{j,0,n-1}];
Do[AppendTo[gedges,{vpfn[bedges[[i,1]],n],vpfn[bedges[[i,2]],n]}],{i,Length[bedges]}];
(* Indexify on vertex pairs to find distinct vertices *)
{vpairs,gedges}=Indexify[gedges,2,SameTest->(SamePtQ[#1[[1]],#2[[1]],opts]&)];
(* Build new verts and verts3d *)
{verts,verts3d}=Transpose[vpairs];
(* Build new edges, eliminating duplicates *)
edges={};
If[!MemberQ[edges,#],AppendTo[edges,#]]&/@gedges;
(* Finally ,construct the CP and FF and additional information *)
tobj2=MakeTGraph[verts,edges]//AddTPlaneGraph //AddTGraph3D[verts3d];
tobj2=tobj2//AddTAssigned[PlaneGraphTypes[tobj2]];
tobj2=tobj2//RecalcFoldAngles;
tobj2=ReassignGraphAssigned[tobj2,tobj2[FoldAngles]];
GraphicsRow[{CreasePatternGraphics[tobj2],FoldedFormGraphics3D[tobj2]}]/.OrigamiStyle[]//Hold;
tobj2]
Module[{pts,w,n,\[Phi],tobj,tobj1},
pts={{.1,0},{1,0},{1,1},{.5,1.2}};
w=0.4;
tobj=MakeFlatFoldedStrip[pts,{w,0\[Degree]}];
GraphicsRow[{GraphGraphics[tobj],
CreasePatternGraphics[tobj],Show[VisibleFoldedFormGraphics[tobj],Graphics[Style[Line[pts],Red,Thickness[.02]]]]}]/.OrigamiStyle[]//Print;
n=2;
\[Phi]=\[Pi]/3;
tobj1=RotationalPleats[tobj,n,\[Phi],SplitBentFaces->False];
GraphicsRow[{CreasePatternGraphics[tobj1],FoldedFormGraphics3D[tobj1]}]/.OrigamiStyle[]
]//ShowExample
Module[{pts,n,\[Phi],tobj,tobj1},
pts={{0,0},{1,0},{1,1},{.5,1.2}};
tobj=MakeFlatFoldedStrip[pts,{0,10.\[Degree]}];
GraphicsRow[{GraphGraphics[tobj],
CreasePatternGraphics[tobj],Show[VisibleFoldedFormGraphics[tobj],Graphics[Style[Line[pts],Red,Thickness[.02]]]]}]/.OrigamiStyle[]//Print;
n=18;
\[Phi]=2\[Pi];
tobj1=RotationalPleats[tobj,n,\[Phi],SplitBentFaces->False];
GraphicsRow[{CreasePatternGraphics[tobj1],FoldedFormGraphics3D[tobj1]}]/.OrigamiStyle[]
]//ShowExample
Module[{p,angles,tobj,n,\[Phi],tobj1},
p={3.1,0};
angles={179\[Degree],0\[Degree],80\[Degree],170\[Degree],50\[Degree]};
tobj=MakeCanonicalTroublewitStrip[p,angles];
GraphicsRow[{
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}]/.OrigamiStyle[]//Print;
n=14;
\[Phi]=2\[Pi];
tobj1=RotationalPleats[tobj,n,\[Phi],SplitBentFaces->False];
GraphicsRow[{CreasePatternGraphics[tobj1],FoldedFormGraphics3D[tobj1]}]/.OrigamiStyle[]
]//ShowExample
Clear[GobletGraph3DAssigned];
AddTGraphExample[GobletGraph3DAssigned,
Module[{d,tobj},
tobj=MakeTroublewitStrip[
{2.3,.50},
1.1{1,1.3,1,1,1,1,2.5,2,1}//N,{210\[Degree],150\[Degree],30\[Degree],150\[Degree],30\[Degree],150\[Degree],30\[Degree],90\[Degree],150\[Degree]}];
GraphicsRow[{
CreasePatternGraphics[tobj],
Show[VisibleFoldedFormGraphics[tobj,Axes->True],Graphics[Style[Line[{{0,0},{0,1}}],Orange]]]}]/.OrigamiStyle[]//Hold;
RotationalPleats[tobj,12,2\[Pi],SplitBentFaces->False]]];
Module[{tobj},
tobj=GobletGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
PolarInt2D[rfn_,p_,d_]:=Module[{r,\[Phi]},
p+r d /.FindRoot[p+r d - rfn[\[Phi]],{r,1},{\[Phi],ArcTan@@p}]]
Module[{rfn,p,d,q},
rfn[\[Phi]_]:=2{Cos[\[Phi]],Sin[\[Phi]]}; (* a circle *)
p={1,0};
d={1,1};
q=PolarInt2D[rfn,p,d];
Graphics[{
Style[{Line[{p,p+d}],Point[p]},AbsolutePointSize[5],Gray],
Style[Line[Table[rfn[\[Phi]],{\[Phi],0,2\[Pi],.02\[Pi]}]],Black],
Style[Point[q],AbsolutePointSize[8],Red]
}]
]//ShowExample
RingFunctionGraphics[pfn_, rfn_, n_, opts___]:=Module[{},
Graphics[{
Style[Table[Line[Table[pfn[i][\[Phi]],{\[Phi],0,2\[Pi],.02\[Pi]}]],{i,0,n}],Gray],Style[Table[Line[Table[rfn[i][\[Phi]],{\[Phi],0,2\[Pi],.02\[Pi]}]],{i,0,n-1}],Lighter[Gray,0.25]]},FilterRules[{opts},Options[Graphics]]]]
Module[{F,pfn,rfn,n},
F[x_,i_]:=Sign[x]Abs[x]^(1/(1+i));
F[0,i_]:=0;
F[x_,0]:=x;
pfn[i_][\[Phi]_]:=(0.75+i){ F[Cos[\[Phi]],i],F[Sin[\[Phi]],i]};
rfn[i_][\[Phi]_]:=(1.0+i){F[Cos[\[Phi]],i],F[Sin[\[Phi]],i]};
n=3;
RingFunctionGraphics[pfn,rfn,n]
]//ShowExample

RingOffsetAngle::usage = "RingOffsetAngle is an option to MakeRingTessellation that specifies the rotational offset angle from 0\[Degree].";
Options[MakeRingTessellation]={
RingOffsetAngle->0\[Degree]
};
MakeRingTessellation[m_,n_,\[Alpha]_,pfn_,rfn_,opts___]:=Module[{\[Phi]0,mm,rma,rmma,rmpa,rm2a,vi,verts,p,q,r,s,dp,dq,dr,ds,fails,edges,types,tobj,verts2d},
\[Phi]0=RingOffsetAngle/.{opts}/.Options[MakeRingTessellation];
mm[j_]:=Mod[j,m];
rma=RotationMatrix2D[\[Alpha]];
rmma=RotationMatrix2D[-\[Alpha]];
rmpa=RotationMatrix2D[\[Pi]-\[Alpha]];
rm2a=RotationMatrix2D[2\[Alpha]];
(* points in crease pattern. vi[p,i,j] returns the index into verts of p[i,j], similarly for q, r, s. *)
verts={};
Do[
p[0,j]=q[0,j]=pfn[0][\[Phi]0 +2 Pi j / m];AppendTo[verts,p[0,j]];vi[p,0,j]=vi[q,0,j]=Length[verts]
,{j,0,m-1}];
Do[
ds[0,j]=rmma . NormalizeReal[p[0,mm[j+1]]-q[0,j]];
dr[0,j]=rmpa . NormalizeReal[q[0,mm[j-1]]-p[0,j]]
,{j,0,m-1}];
Do[
Do[r[i-1,j]=PolarInt2D[rfn[i-1],p[i-1,j],dr[i-1,j]];AppendTo[verts,r[i-1,j]];vi[r,i-1,j]=Length[verts],{j,0,m-1}];
Do[s[i-1,j]=LineInt2D[r[i-1,mm[j+1]],rma . dr[i-1,mm[j+1]],q[i-1,j],ds[i-1,j]];AppendTo[verts,s[i-1,j]];vi[s,i-1,j]=Length[verts],{j,0,m-1}];
Do[dp[i,j]=rma . NormalizeReal[r[i-1,j]-s[i-1,j]],{j,0,m-1}];
Do[dq[i,j]=dp[i,j],{j,0,m-1}];
Do[p[i,j]=PolarInt2D[pfn[i],r[i-1,j],dp[i,j]];AppendTo[verts,p[i,j]];vi[p,i,j]=Length[verts],{j,0,m-1}];
Do[q[i,j]=LineInt2D[s[i-1,j],dq[i,j],p[i,j],rmma . (r[i-1,j]-p[i,j])];AppendTo[verts,q[i,j]];vi[q,i,j]=Length[verts],{j,0,m-1}];
Do[dr[i,j]=rmpa . NormalizeReal[q[i,mm[j-1]]-p[i,j]],{j,0,m-1}];
Do[ds[i,j]=rmma . NormalizeReal[p[i,mm[j+1]]-q[i,j]],{j,0,m-1}];
,{i,n}];
(* check each vertex using std crease assignment *)
(* TBD, use a generic function, see LFF functions *)
fails={};
Do[With[{cv=CheckVertexAgainstAssignment[p[0,j],s[0,j],q[0,mm[j+1]],q[0,mm[j-1]],r[0,j]]},If[!First[cv],AppendTo[fails,{{"pq"},{0,0},cv}]]],{j,0,m-1}];
Do[With[{cv=CheckVertexAgainstAssignment[p[i,j],q[i,j],r[i-1,j],q[i,mm[j-1]],r[i,j]]},If[!First[cv],AppendTo[fails,{{"p"},{i,j},cv}]]],{j,0,m-1},{i,n-1}];
Do[With[{cv=CheckVertexAgainstAssignment[q[i,j],p[i,mm[j+1]],s[i-1,j],p[i,j],s[i,j]]},If[!First[cv],AppendTo[fails,{{"q"},{i,j},cv}]]],{j,0,m-1},{i,n-1}];
Do[With[{cv=CheckVertexAgainstAssignment[r[i,j],s[i,mm[j-1]],p[i+1,j],s[i,j],p[i,j]]},If[!First[cv],AppendTo[fails,{{"r"},{i,j},cv}]]],{j,0,m-1},{i,0,n-1}];Do[With[{cv=CheckVertexAgainstAssignment[s[i,j],r[i,j],q[i+1,j],r[i,mm[j+1]],q[i,j]]},If[!First[cv],AppendTo[fails,{{"s"},{i,j},cv}]]],{j,0,m-1},{i,0,n-1}];
(* report any errors *)
If[Length[fails]>0,Print["Error: fails=\n",fails]];
(* edges and types *)
edges=types={};
(* radial mountain folds *)
JoinTo[edges,Flatten[Table[{{vi[p,i,j],vi[r,i,j]},{vi[r,i,j],vi[p,i+1,j]}},{i,0,n-1},{j,0,m-1}],2]];
JoinTo[types,Table[M,{2n m}]];
(* radial valley folds *)
JoinTo[edges,Flatten[Table[{{vi[q,i,j],vi[s,i,j]},{vi[s,i,j],vi[q,i+1,j]}},{i,0,n-1},{j,0,m-1}],2]];
JoinTo[types,Table[V,{2n m}]];
(* axial mountains, innermost loop, which is special *)
JoinTo[edges,Table[{vi[p,0,j],vi[p,0,mm[j+1]]},{j,0,m-1}]];
JoinTo[types,Table[M,{m}]];
(* axial folds, remaining loops *)
JoinTo[edges,Flatten[Table[{
Table[{{vi[r,i,j],vi[s,i,j]},{vi[s,i,j],vi[r,i,mm[j+1]]}},{j,0,m-1}],
Table[{{vi[p,i+1,j],vi[q,i+1,j]},{vi[q,i+1,j],vi[p,i+1,mm[j+1]]}},{j,0,m-1}]
},{i,0,n-1}],3]];
JoinTo[types,
Flatten[Table[If[i==n&&k==2,B,If[EvenQ[j+k+If[j>2m,1,0]],M,V]],{i,n},{k,2},{j,2m}]]];
(* folded form vertices *)
verts2d=verts;
Do[
verts2d[[vi[r,i,j]]]=verts2d[[vi[p,i,j]]]+rm2a . (r[i,j]-p[i,j]);
verts2d[[vi[s,i,j]]]=verts2d[[vi[q,i,j]]]+rm2a . (s[i,j]-q[i,j]);
verts2d[[vi[p,i+1,j]]]=verts2d[[vi[r,i,j]]]+(p[i+1,j]-r[i,j]);
verts2d[[vi[q,i+1,j]]]=verts2d[[vi[s,i,j]]]+(q[i+1,j]-s[i,j]);
,{j,0,m-1},{i,0,n-1}];
(* output *)
MakeTPlaneGraphAssigned[verts,edges,{},types]//AddTGraph2D[verts2d]]
Module[{F,pfn,rfn,m,n,\[Alpha],\[Phi]0,efg,tobj,cp,ff},
F[x_,i_]:=Sign[x]Abs[x]^(1/(1+i));
F[0,i_]:=0;
F[x_,0]:=x;
pfn[i_][\[Phi]_]:=(0.75+i){ F[Cos[\[Phi]],i],F[Sin[\[Phi]],i]};
rfn[i_][\[Phi]_]:=(1.0+i){F[Cos[\[Phi]],i],F[Sin[\[Phi]],i]};
m=20;
n=3;
\[Alpha]=45.\[Degree];
\[Phi]0=6.\[Degree];
efg=RingFunctionGraphics[pfn,rfn,n];
tobj=MakeRingTessellation[m,n,\[Alpha],pfn,rfn,RingOffsetAngle->\[Phi]0];
cp=CreasePatternGraphics[tobj];
ff=GenericFoldedFormGraphics[tobj];
GraphicsRow[{efg,cp,ff}/.OrigamiStyle[]]
]//ShowExample
TestPleat[{qa_, qb_},\[Alpha]_]:=Module[{dir,dab,len,pa,pb},
dir=RotationMatrix2D[-\[Alpha]] . NormalizeReal[qa-qb];
dab=(qa-qb) . dir/2;
len=1.8 Mag[qa-qb];
pa=qa+(len-dab)dir;
pb=qb+(len+dab)dir;
{Style[Polygon[{pa,pb,qb,qa}],Opacity[0.1]],
Style[Line[{qa,qb}],Black],
Style[Line[{qa,pa}],Red],
Style[Line[{qb,pb}],Blue]}]
Module[{},
Graphics[TestPleat[{{0,0},{1,0.1}},45\[Degree]]]
]//ShowExample
TwoCycleCriticalTwistAngleCCW[{q1a_,q1b_},{q2a_,q2b_}]:=Module[{a1,a2},
a1=ArcTan[(q2b-q1b) . (RotationMatrix2D[-(\[Pi]/2)] . (q1a-q1b))/(q2b-q1b) . (q1a-q1b)];
a2=ArcTan[(q1b-q2b) . (RotationMatrix2D[-(\[Pi]/2)] . (q2a-q2b))/(q1b-q2b) . (q2a-q2b)];
Max[a1,a2]
]
Module[{pts,\[Alpha]},
pts={{0,0},{1,-.5},{1.8,0.2},{1,.5}};
\[Alpha]=TwoCycleCriticalTwistAngleCCW[{pts[[2]],pts[[3]]},{pts[[4]],pts[[1]]}];
Print["\[Alpha]/\[Degree] = ",\[Alpha]/\[Degree]];
Graphics[TestPleat[#,\[Alpha]]&/@Transpose[{pts,RotateLeft[pts]}],Frame->True]
]//ShowExample
TwoCycleCriticalTwistAngleCW[{q1a_,q1b_},{q2a_,q2b_}]:=\[Pi]+TwoCycleCriticalTwistAngleCCW[{q1b,q1a},{q2b,q2a}]
Module[{pts,\[Alpha]},
pts={{0,0},{1,-.5},{1.8,0.2},{1,.5}};
\[Alpha]=TwoCycleCriticalTwistAngleCW[{pts[[1]],pts[[2]]},{pts[[3]],pts[[4]]}];
Print["\[Alpha]/\[Degree] = ",\[Alpha]/\[Degree]];
Graphics[TestPleat[#,\[Alpha]]&/@Transpose[{pts,RotateLeft[pts]}],Frame->True]
]//ShowExample
TwoCycleCriticalTwistAngles[{q1a_,q1b_},{q2a_,q2b_}]:={TwoCycleCriticalTwistAngleCCW[{q1a,q1b},{q2a,q2b}],TwoCycleCriticalTwistAngleCW[{q1a,q1b},{q2a,q2b}]}
TwoCycleCriticalTwistAngles[plist_List]:=Module[{n,ipairs,apairs},
n=Length[plist];
ipairs=Flatten[Table[{i,j},{i,n-2},{j,i+2,Min[n,n+i-2]}],1];
apairs=TwoCycleCriticalTwistAngles[{plist[[#[[1]]]],plist[[#[[1]]+1]]},{plist[[#[[2]]]],plist[[Mod[#[[2]]+1,n,1]]]}]&/@ipairs;
{Min[#[[1]]],Max[#[[2]]]}&[Transpose[apairs]]]
Module[{pts,angles,\[Alpha]},
pts={{0,0},{1,-.5},{1.8,-0.2},{1,.5}};
angles=TwoCycleCriticalTwistAngles[pts];
Print["angles/\[Degree] = ",angles/\[Degree]];
\[Alpha]=First[angles];
GraphicsRow[{Graphics[TestPleat[#,First[angles]]&/@Transpose[{pts,RotateLeft[pts]}]],Graphics[TestPleat[#,Last[angles]]&/@Transpose[{pts,RotateLeft[pts]}]]}]
]//ShowExample
SameHalfPlaneQ[r1_,r2_,r3_]:=Module[{r},
Mag2[r1]==0||Mag2[r2]==0||Mag2[r3]==0||(r=RotationMatrix2D[\[Pi]/2] . r1;Sign[r . r2]==Sign[r . r3])]
SameHalfPlaneQ[{1,0},{0,1},{-.5,.5}]//ShowExample
SameHalfPlaneQ[{1,0},{0,1},{-.5,-.5}]//ShowExample
ThreeCycleCriticalTwistAngleCCW[{q1a_,q1b_},{q2a_,q2b_},{q3a_,q3b_}]:=Module[{s1,s2,s3,ii,rpm,rt,p12,p23,t12,t23,u2},
s1=q1b-q1a;
s2=q2b-q2a;
s3=q3b-q3a;
If[SameHalfPlaneQ[s1,s2,s3],\[Pi]/2,
rpm=RotationMatrix2D[(-\[Pi])/2];
ii=IdentityMatrix[2];
rt={{rpm,-ii},{ii,rpm}};
p12=q2b-q1b;
p23=q3b-q2b;
t12=LineInt2D[q1b,(s2 . (p12 . rt)) . s1,q2b,(s1 . (p12 . rt)) . s2];t23=LineInt2D[q2b,(s3 . (p23 . rt)) . s2,q3b,(s2 . (p23 . rt)) . s3];
u2=rpm . (t12-t23);(* direction vector of line from q2b to intersection pt *)
ArcTan[u2 . (rpm . s2)/u2 . s2]]]
Module[{pts,n,\[Alpha]},
pts={{0,0},{1,-.5},{1.8,-0.2},{1.5,0.5},{0.6,.5}};
n=Length[pts];
\[Alpha]=ThreeCycleCriticalTwistAngleCCW[{pts[[1]],pts[[2]]},{pts[[2]],pts[[3]]},{pts[[4]],pts[[5]]}];
Print["\[Alpha]/\[Degree] = ",\[Alpha]/\[Degree]];
Graphics[{TestPleat[#,\[Alpha]]&/@Transpose[{pts,RotateLeft[pts]}]},Frame->True]
]//ShowExample
ThreeCycleCriticalTwistAngleCW[{q1a_,q1b_},{q2a_,q2b_},{q3a_,q3b_}]:=\[Pi]+ThreeCycleCriticalTwistAngleCCW[{q1b,q1a},{q2b,q2a},{q3b,q3a}]
Module[{pts,n,\[Alpha]},
pts={{0,0},{1,-.5},{1.8,-0.2},{1.5,0.5},{0.6,.5}};
n=Length[pts];
\[Alpha]=ThreeCycleCriticalTwistAngleCW[{pts[[1]],pts[[2]]},{pts[[2]],pts[[3]]},{pts[[4]],pts[[5]]}];
Print["\[Alpha]/\[Degree] = ",\[Alpha]/\[Degree]];
Graphics[TestPleat[#,\[Alpha]]&/@Transpose[{pts,RotateLeft[pts]}],Frame->True]
]//ShowExample
ThreeCycleCriticalTwistAngles[{q1a_,q1b_},{q2a_,q2b_},{q3a_,q3b_}]:={ThreeCycleCriticalTwistAngleCCW[{q1a,q1b},{q2a,q2b},{q3a,q3b}],ThreeCycleCriticalTwistAngleCW[{q1a,q1b},{q2a,q2b},{q3a,q3b}]}
ThreeCycleCriticalTwistAngles[plist_List]:=Module[{n,itrios,apairs},
n=Length[plist];
itrios=Flatten[Table[{i,j,k},{i,n-2},{j,i+1,Min[n,n+i-2]},{k,j+1,Min[n,n+i-1]}],2];
apairs=ThreeCycleCriticalTwistAngles[
{plist[[#[[1]]]],plist[[#[[1]]+1]]},
{plist[[#[[2]]]],plist[[#[[2]]+1]]},
{plist[[#[[3]]]],plist[[Mod[#[[3]]+1,n,1]]]}]&/@itrios;
apairs=Select[apairs,#[[1]]>0&&#[[2]]<\[Pi]&];
{Min[#[[1]]],Max[#[[2]]]}&[Transpose[apairs]]]
Module[{pts,n,angles,\[Alpha]},
pts={{0,0},{1,-.5},{1.8,-0.2},{1.5,0.5},{0.5,.7}};
n=Length[pts];
angles=ThreeCycleCriticalTwistAngles[pts];
Print["angles/\[Degree] = ",angles/\[Degree]];
\[Alpha]=First[angles];
GraphicsRow[{Graphics[TestPleat[#,First[angles]]&/@Transpose[{pts,RotateLeft[pts]}]],Graphics[TestPleat[#,Last[angles]]&/@Transpose[{pts,RotateLeft[pts]}]]}]
]//ShowExample
TriangleCriticalTwistAngles[p1_,p2_,p3_]:=ThreeCycleCriticalTwistAngles[{p1,p2},{p2,p3},{p3,p1}]
Simplify[TriangleCriticalTwistAngles@@UnitTriangleVertices[{\[Theta]1,\[Theta]2,\[Theta]3}]]//ShowExample
FullSimplify[(Sin[\[Theta]1]Sin[\[Theta]2]Sin[\[Theta]3])/(1+Cos[\[Theta]1]Cos[\[Theta]2]Cos[\[Theta]3])/(4 Sin[\[Theta]1] Sin[\[Theta]2] Sin[\[Theta]3])/(3-Cos[2 \[Theta]1]-Cos[2 \[Theta]2]-Cos[2(\[Pi]-\[Theta]3)])/.\[Theta]3->\[Pi]-(\[Theta]1+\[Theta]2)]//ShowExample
TriangleCriticalTwistAngles[angles_List]:=Module[{A,B,C,\[Alpha]},
{A,B,C}=angles;
\[Alpha]=ArcTan[(Sin[A]Sin[B]Sin[C])/(1+Cos[A]Cos[B]Cos[C])];
{\[Alpha],\[Pi]-\[Alpha]}]
N[TriangleCriticalTwistAngles[{40\[Degree],60\[Degree],80\[Degree]}]/\[Degree]]//ShowExample
N[TriangleCriticalTwistAngles[{30\[Degree],120\[Degree],30\[Degree]}]/\[Degree]]//ShowExample
N[TriangleCriticalTwistAngles[{45\[Degree],90\[Degree],45\[Degree]}]/\[Degree]]//ShowExample
AnyThreeInASemiNecklaceQ[types_List, m_]:=Count[types,m]<3||
Module[{n=Length[types],
pos=Flatten[Position[types,m]],np,tpls,gaps},np=Length[pos];tpls=Flatten[Table[pos[[{i,j,k}]],{i,np-2},{j,i+1,np-1},{k,j+1,np}],2];gaps=Select[Mod[RotateLeft[#]-#,n],Function[x,x<=n/2]]&/@tpls;And@@(#<n/2&/@Flatten[RotateLeft[#]+#&/@gaps])]
AnyThreeInASemiNecklaceQ[types_List]:=AnyThreeInASemiNecklaceQ[types,M]&&AnyThreeInASemiNecklaceQ[types,V]
OppositeTypesDifferentQ[types_List]:=With[{n=Length[types]},Mod[n,2]==1||!Or@@MapThread[SameQ,{types,RotateLeft[types,n/2]}]]
RegularPolygonTwistValidQ[n_,\[Alpha]_,types_List]:=Module[{ty,\[Alpha]\[Alpha],mm,mv},
ty=Union[Thread[Times[types,RotateLeft[types]]]/.{M->1,V->-1}];
\[Alpha]\[Alpha]=Min[\[Alpha],\[Pi]-\[Alpha]];
mm=MemberQ[ty,1];
mv=MemberQ[ty,-1];(n>=3)&&((n==4||n==5)&&\[Alpha]\[Alpha]>\[Pi]/2-\[Pi]/n\[Implies]AnyThreeInASemiNecklaceQ[types]&&OppositeTypesDifferentQ[types])&&((mm&&!mv)\[Implies]\[Alpha]\[Alpha]<=\[Pi]/2-\[Pi]/n)&&((mv&&!mm)\[Implies]\[Alpha]\[Alpha]<=(2\[Pi])/n)&&((mm&&mv)\[Implies](n<=4\[Implies]\[Alpha]\[Alpha]<=\[Pi]-(2\[Pi])/n)&&(n>=4\[Implies]\[Alpha]\[Alpha]<=(2\[Pi])/n))]
{RegularPolygonTwistValidQ[3,29.999\[Degree],{M,M,M}],
RegularPolygonTwistValidQ[3,30.001\[Degree],{M,M,M}],
RegularPolygonTwistValidQ[3,59.999\[Degree],{V,M,M}],
RegularPolygonTwistValidQ[3,60.001\[Degree],{V,M,M}]}//ShowExample
{RegularPolygonTwistValidQ[4,44.999\[Degree],{M,M,M,M}],
RegularPolygonTwistValidQ[4,45.001\[Degree],{M,M,M,M}],
RegularPolygonTwistValidQ[4,89.999\[Degree],{M,V,M,V}]}//ShowExample
{RegularPolygonTwistValidQ[5,53.999\[Degree],{M,M,M,M,M}],
RegularPolygonTwistValidQ[5,54.001\[Degree],{M,M,M,M,M}],
RegularPolygonTwistValidQ[5,71.999\[Degree],{V,M,M,M,M}],
RegularPolygonTwistValidQ[5,72.001\[Degree],{V,M,M,M,M}]}//ShowExample
AllCyclicTwistTypes[n_]:=AllCyclicTwistTypes[n]=Union[Nest[Function[x,Flatten[{Prepend[#,M],Prepend[#,V]}&/@x,1]],{{M},{V}},n-1],SameTest->CyclicSameQ]
AllCyclicTwistTypes[5]//ShowExample
AllValidTwistTypes[n_,\[Alpha]_]:=Select[AllCyclicTwistTypes[n],RegularPolygonTwistValidQ[n,\[Alpha],#]&]
AllValidTwistTypes[5,60\[Degree]]//ShowExample
TTwistGraph::usage="TTwistGraph is a TObj class that represents a crease pattern or folded form composed of simple flat twists.";
RegisterTClass[TTwistGraph,{TGraph,TAssigned}];
TwistFaces::usage="TwistFaces is a TObj property that specifies the twisted faces in a plane graph.";
AddTTwistGraphTo[tobj_TObj,twistfaces_List:{}]:=Module[{},
AssertClasses[tobj,{TGraph,TAssigned}];
AddClassTo[tobj,TTwistGraph,{TwistFaces->twistfaces}]]
AddTTwistGraph[twistfaces_List:{}]:=AddTTwistGraphTo[#,twistfaces]&
Options[CircularPolygonTwistGraph2D]={
StationaryFace->Automatic
};
CircularPolygonTwistGraph2D::badtypes="List `1` of fold types is not of length `2`.";
CircularPolygonTwistGraph2D[verts_List,\[Alpha]_,r_,types_List:{}, opts___]:=Module[{sf,newverts,nv,ctr,edges,newedges,oldtypes,newtypes,ccw,f,pe,rr,newfaces,tobj,foldangles,fverts},
sf=StationaryFace/.{opts}/.Options[CircularPolygonTwistGraph2D];
newverts=N[verts];
nv=Length[verts];
ctr=Plus@@verts/nv;
newedges=edges=Transpose[{#,RotateLeft[#]}]&[Range[nv]];
If[Length[types]!=0&&Length[types]!=nv,Message[CircularPolygonTwistGraph2D::badtypes,types,nv];Abort[]];
oldtypes=If[ListEmptyQ[types],Table[U,{nv}],types];
newtypes=oldtypes;
ccw=(Abs[\[Alpha]]<\[Pi]/2);
f=Function[{edge,type},
pe=verts[[edge]];
rr= RotationMatrix2D[\[Alpha]] . NormalizeReal[Subtract@@pe];
AppendTo[newverts,RayCircleInt2D[pe[[1]],rr,ctr,r]];
AppendTo[newedges,{edge[[1]],Length[newverts]}];
AppendTo[newverts,RayCircleInt2D[pe[[2]],rr,ctr,r]];
AppendTo[newedges,{edge[[2]],Length[newverts]}];
newtypes=Join[newtypes,If[ccw,{type,InvertFoldType[type]},{InvertFoldType[type],type}]]];
MapThread[f,{edges,oldtypes}];
newfaces={Range[nv]};
(* pleat polygons *)
Do[CircularlyCompletePoly[newverts,newedges,newfaces,{nv+2i,Mod[i+1,nv,1],i,nv+2i-1},ctr,r,opts],{i,nv}];
(* wedge polygons *)
Do[CircularlyCompletePoly[newverts,newedges,newfaces,{nv+2i-1,i,nv+2Mod[i-1,nv,1]},ctr,r,opts],{i,nv}];
JoinTo[newtypes,Table[B,{Length[newedges]-Length[newtypes]}]];
tobj=MakeTPlaneGraphAssigned[newverts,newedges,newfaces,newtypes]//AddTTwistGraph[{1}];
(* create clipped folded form *)
foldangles=newtypes/.{M->-\[Pi],V->\[Pi],U->\[Pi],B->0};
If[sf===Automatic,sf=Length[newfaces]];
tobj=FoldGraph2D[tobj,foldangles,StationaryFace->sf];
fverts=tobj[Vertices2D];
fverts=CircularlyExtendEdges[fverts,newedges,tobj[BoundaryVertices],Plus@@Take[fverts,nv]/nv,r];
tobj//ReplaceProperty[Vertices2D->fverts]]
Module[{verts,types,tobj},
verts={{0,0},{1,0},{.5,.4}};
types={M,M,V};
tobj=CircularPolygonTwistGraph2D[verts,30.\[Degree],2,types,CircleDivisions->16];
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Module[{verts,types,tobj},
verts={{0,0},{1,0},{.5,.4}};
tobj=CircularPolygonTwistGraph2D[verts,30.\[Degree],2,CircleDivisions->16];
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Module[{verts,types,tobj},
verts=UnitRegularPolygonVertices[5];
types={M,M,V,V,M};
tobj=CircularPolygonTwistGraph2D[verts,30.\[Degree],2,CircleDivisions->16];
GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]
]//ShowExample
Module[{vertscp,vertscp1,vertsff,vertsff1,edges,types,faces,twistfaces},
vertscp={{0,0},{1,0},{1,1},{0,1},{-.4,-1},{-.8,-1},{2,-.4},{2,-.8},{1.4,2},{1.8,2},{-1,1.4},{-1,1.8},{-1,-1},{2,-1},{2,2},{-1,2}};
vertscp1={-1,1}#&/@vertscp;
vertsff={{0,0},{1,0},{1,1},{0,1},{.4,-1},{.8,-1},{2,.4},{2,.8},{.6,2},{.2,2},{-1,.6},{-1,.2},{-1,-1},{2,-1},{2,2},{-1,2}};
vertsff1={-1,1}#&/@vertsff;
edges={{1,2},{2,3},{4,3},{1,4},{1,5},{4,6},{7,2},{8,1},{3,9},{2,10},{4,11},{3,12}};
types={V,M,M,V,V,M,V,M,M,V,M,V};
faces={{1,2,3,4},(* twist poly *)
{1,4,6,5},{2,1,8,7},{3,2,10,9},{4,3,12,11},(* pleats *)
{1,5,14,8},{2,7,15,10},{3,9,16,12},{4,11,13,6}(* wedges *)
};
twistfaces={1};
(* define TObjs in global scope *)
twistobj = MakeTGraphAssigned[vertscp,edges,faces,types]//AddTGraph2D[vertsff]//AddTTwistGraph[twistfaces];
twistobj1 = MakeTGraphAssigned[vertscp1,edges,faces,types]//AddTGraph2D[vertsff1]//AddTTwistGraph[twistfaces];
]//ShowExample;
TwistCreasePatternLines[tobj_TObj]:=Module[{verts,edges,types},
{verts,edges,types}=GetValues[tobj,{Vertices,Edges,EdgeTypes}];
MapThread[Style,{Line[verts[[#]]]&/@edges,types/.TypeToCreasePatternStyleRules}]]
GraphicsRow[{
Graphics[TwistCreasePatternLines[twistobj]],
Graphics[TwistCreasePatternLines[twistobj1]]}]/.OrigamiStyle[]//ShowExample
TwistCreasePatternLabeledLines[tobj_TObj]:=Module[{verts,edges,types},
{verts,edges,types}=GetValues[tobj,{Vertices,Edges,EdgeTypes}];
{MapThread[Style,{Line[verts[[#]]]&/@edges,types/.TypeToCreasePatternStyleRules}],
Style[#,Darker[Red]]&/@StdVertexLabels[verts],
Style[#,Darker[Blue]]&/@StdEdgeLabels[verts,edges]}]
GraphicsRow[{
Graphics[TwistCreasePatternLabeledLines[twistobj]],Graphics[TwistCreasePatternLabeledLines[twistobj1]]}]/.OrigamiStyle[]//ShowExample
TwistCreasePatternPolys[tobj_TObj]:=Module[{verts,faces},
{verts,faces}=GetValues[tobj,{Vertices,Faces}];
Style[Polygon[verts[[#]]],PaperWhiteSideFill]&/@faces]
GraphicsRow[{
Graphics[TwistCreasePatternPolys[twistobj]],
Graphics[{
TwistCreasePatternPolys[twistobj],
TwistCreasePatternLines[twistobj]
}]}]/.OrigamiStyle[]//ShowExample
TwistCreasePatternGraphics[tobj_TObj,opts___]:=Module[{},
AssertClasses[tobj,{TGraph,TAssigned},TwistCreasePatternGraphics];
Graphics[{TwistCreasePatternPolys[tobj],TwistCreasePatternLines[tobj]},FilterRules[{opts},Options[Graphics]]]]
GraphicsRow[{
TwistCreasePatternGraphics[twistobj],
TwistCreasePatternGraphics[twistobj1]}]/.OrigamiStyle[]//ShowExample
CCWTwistQ::badangles="Error: CCWTwistQ couldn't find the pleat for this twist. Pleat angles (\[Degree]) were `1` (\[Degree]), twist network is printed.";
CCWTwistQ[verts_List,edges_List,face_]:=Module[{pe,tedges,eas,ma},
pe=Take[face,2];(* the edge we're checking *)
tedges=Select[edges,Length[Intersection[pe,#]]==1&&Length[Intersection[face,#]]==1&];(* test edges *)
eas=Mod[#-ArcTan@@-Subtract@@verts[[pe]],2\[Pi]]&/@(ArcTan@@-Subtract@@verts[[If[MemberQ[pe,First[#]],#,Reverse[#]]]]&/@tedges);(* angles of test edges relative to pleats *)
ma=DeleteCases[Flatten[Table[If[eas[[i]]==eas[[j]],eas[[i]]],{i,3},{j,i+1,4}]],Null];(* angles w/ multiplicity *)
If[ListEmptyQ[ma],(* oh-oh, error, we found no duplicate angles, this isn't a twist! *)
Message[CCWTwistQ::badangles,eas/\[Degree]];Print[GraphGraphics[MakeTGraph[verts,edges,{face}]]];Abort[]
];
ma[[1]]<\[Pi]/2]
Module[{verts,verts1,edges,faces},
{verts,edges,faces}=GetValues[twistobj,{Vertices,Edges,Faces}];
{verts1,edges,faces}=GetValues[twistobj1,{Vertices,Edges,Faces}];
{CCWTwistQ[verts,edges,faces[[1]]],CCWTwistQ[verts1,edges,faces[[1]]]}
]//ShowExample
Module[{verts,edges,face},
{verts,edges,face}={{{2.73197294819329`,0.`},{2.73197294819329`,-3.1923152333355134`},{2.398639614859957`,0.`},{-0.365986474096645`,2.3659579755872575`},{2.3986396148599574`,3.962115592255014`},{-0.19931980742997846`,2.077282840992445`},{-0.865986474096645`,-1.4999325718028185`},{-3.6306125630532478`,0.09622504486493827`},{-0.6993198074299785`,-1.2112574372080058`},{0.`,0.`},{1.`,0.`},{0.5`,0.8660254037844386`}},{{1,2},{2,5},{5,3},{4,5},{5,8},{8,6},{7,8},{8,2},{2,9}},{2,5,8}};
CCWTwistQ[verts,edges,face]
]//ShowErrorExample
MakePartialFoldedLine[{q1_,q2_,t0_,t1_}]:=Flatten[If[t0>=t1||t0>=1||t1<=0,Style[Line[{q1,q2}],HiddenFoldedLine],{If[t0>0,Style[Line[{q1,q1+t0(q2-q1)}],HiddenFoldedLine],{}],Style[Line[{q1+Max[t0,0](q2-q1),q1+Min[t1,1](q2-q1)}],FoldedLine],If[t1<1,Style[Line[{q1+t1(q2-q1),q2}],HiddenFoldedLine],{}]}]]
MakePartialFoldedLine[{{0,0},{1,0},-.3,.6}]//ShowExample
CoverPartialLine[{a1_,b1_,tmin1_,tmax1_},a2_,b2_,c2_,mi_]:=Module[{det=Det[{b1-a1,b2-a2}],t1,t2,r2,sc2},
If[det==0,Return[{a1,b1,tmin1,tmax1}]];
t1=-Det[{a1-a2,b2-a2}]/det;
t2=Det[{a2-a1,b1-a1}]/det;
r2=Rotate90[b2-a2];
sc2=Sign[(c2-a2) . r2];
If[t1<0||t1>1||t2<0||t2>1,If[!mi&&(sc2==Sign[(a1-a2) . r2]||sc2==Sign[(b1-a2) . r2]),Return[{a1,b1,0,0}],Return[{a1,b1,tmin1,tmax1}]]];If[sc2==Sign[(2b1-a1-a2) . r2],Return[{a1,b1,tmin1,Min[tmax1,t1]}],Return[{a1,b1,Max[tmin1,t1],tmax1}]]]
Module[{a1={0,0},b1={1,.6},a2={.4,.3},b2={1,.3},c2={.7,.1},cl},
cl=CoverPartialLine[{a1,b1,0,1},a2,b2,c2,True];
Print["CoverPartialLine = ",cl];Graphics[{PointSize[.02],Point/@{a1,b1,a2,b2,c2},RGBColor[1,0.5,0],Line[{a2,b2}],MakePartialFoldedLine[cl]/.OrigamiStyle[]}]
]//ShowExample
TwistFoldedFormLines[tobj_TObj]:=Module[{verts,edges,types,faces,twistfaces,ia,alledges,tfaceinfo,plwedges,vedges,medges,pgwedges={},pgedges={},pledges={},alllines},
{verts,edges,types,faces,twistfaces}=GetValues[tobj,{Vertices2D,Edges,EdgeTypes,Faces,TwistFaces}];
twistfaces = faces[[#]]&/@twistfaces;(* convert from face index to lists of vertex indices *)
ia=ArcTan@@-Subtract@@verts[[#]]&;(* converts index pair to angle *)
alledges=Transpose[{edges,types}];
(* create pleat wedges of the form {i1,i2,i3,ccw} *)
tfaceinfo=Transpose[{twistfaces,CCWTwistQ[verts,edges,#]&/@twistfaces}];
plwedges=Flatten[Table[{#[[1,i]],#[[1]],#[[2]]},{i,Length[#[[1]]]}]&/@tfaceinfo,1];
plwedges=Function[x,Module[{el},el=If[#[[1,1]]==x[[1]],#,ReplacePart[#,Reverse[#[[1]]],1]]&/@Select[alledges,MemberQ[#[[1]],x[[1]]]&&Length[Intersection[#[[1]],x[[2]]]]==1&];
el=If[Xor[Mod[Subtract@@(ia[#[[1]]]&/@el),2\[Pi]]>\[Pi],Last[x]],el,Reverse[el]];{el[[1,1,1]],el[[1,1,2]],el[[2,1,2]],Last[x],el[[1,2]]}]]/@plwedges;
plwedges=Drop[#,-1]&/@Select[plwedges,Last[#]===M&];
(* mountain and valley edges *)
vedges=First/@Select[alledges,Last[#]===V&];
medges=First/@Select[alledges,Last[#]===M&];
(* separate mtn edges into polygon and pleat edges *)
Function[x,Module[{me=x,mp1,mp2},mp1=Flatten[Select[twistfaces,MemberQ[#,me[[1]]]&]];mp2=Flatten[Select[twistfaces,MemberQ[#,me[[2]]]&]];If[mp1==mp2&&NotListEmptyQ[mp1],
(* create a polygon wedge of the form {{i1,i2},face,ctr} *)
AppendTo[pgwedges,{me,mp1,Plus@@verts[[mp1]]/Length[mp1]}];
(* create a polygon edge of the form {{i1,i2},face1,{p1,p2,t0,t1}} *)
AppendTo[pgedges,{me,mp1,Join[verts[[me]],{0,1}]}],
(* create a pleat edge of the form {{i1,i2},{face1,face2},{p1,p2,t0,t1}}*)
AppendTo[pledges,{me,{mp1,mp2},Join[verts[[me]],{0,1}]}]]]]/@medges;
(* compute coverings *)
(* covering of polygon edges by pleat wedges*)
pgedges=Fold[Function[{pge,plw},If[MemberQ[pge[[2]],plw[[1]]],ReplacePart[pge,CoverPartialLine@@Join[Take[pge,-1],verts[[Take[plw,3]]],{False}],-1]]],#,plwedges]&/@pgedges;
(* covering of pleat edges by pleat wedges *)
pledges=Fold[Function[{ple,plw},If[MemberQ[Flatten[ple[[2]]],plw[[1]]]&&Xor[Mod[ia[ple[[1]]]-ia[Take[plw,2]],2\[Pi]]<\[Pi],MemberQ[ple[[2,1]],plw[[1]]],Last[plw]],ReplacePart[ple,CoverPartialLine@@Join[Take[ple,-1],verts[[Take[plw,3]]],{False}],-1],ple]],#,plwedges]&/@pledges;
(* covering of pleat edges by polygon wedges *)
pledges=Fold[Function[{ple,pgw},If[IntersectingQ[ple[[1]],pgw[[2]]]&&!IntersectingQ[ple[[1]],pgw[[1]]]&&!MemberQ[Join[#,Reverse/@#]&[Take[#,2]&/@Select[plwedges,MemberQ[Flatten[ple[[2]]],#[[1]]]&]],ple[[1]]],ReplacePart[ple,CoverPartialLine@@Join[Take[ple,-1],verts[[pgw[[1]]]],{pgw[[3]],True}],-1],ple]],#,pgwedges]&/@pledges;
(* output *)
alllines=Flatten[MakePartialFoldedLine/@Join[Join[verts[[#]],{0,0}]&/@vedges,Last/@Join[pgedges,pledges]]];
Join[Cases[alllines,Style[_,HiddenFoldedLine]],Cases[alllines,Style[_,FoldedLine]]]]
GraphicsRow[{Graphics[TwistCreasePatternLabeledLines[twistobj]],Graphics[TwistFoldedFormLines[twistobj]]}]/.OrigamiStyle[]//ShowExample
GraphicsRow[{Graphics[TwistCreasePatternLabeledLines[twistobj1]],Graphics[TwistFoldedFormLines[twistobj1]]}]/.OrigamiStyle[]//ShowExample
TwistFoldedFormLabeledLines[tobj_TObj]:=Module[{verts,edges},
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
{TwistFoldedFormLines[tobj],
Style[#,Darker[Red]]&/@StdVertexLabels[verts],
Style[#,Darker[Blue]]&/@StdEdgeLabels[verts,edges]}]
GraphicsRow[{
Graphics[TwistFoldedFormLabeledLines[twistobj]],Graphics[TwistFoldedFormLabeledLines[twistobj1]]}]/.OrigamiStyle[]//ShowExample
TwistFoldedFormPolys[tobj_TObj]:=Module[{verts,faces},
{verts,faces}=GetValues[tobj,{Vertices2D,Faces}];
Style[Polygon[verts[[#]]],PaperWhiteSideFill]&/@faces]
GraphicsRow[{
Graphics[TwistFoldedFormPolys[twistobj]],
Graphics[{TwistFoldedFormPolys[twistobj],TwistFoldedFormLines[twistobj]}]}]/.OrigamiStyle[]//ShowExample
TwistFoldedFormGraphics[tobj_TObj,opts___]:=Module[{},
AssertClasses[tobj,{TAssigned,TTwistGraph},TwistFoldedFormGraphics];
Graphics[{TwistFoldedFormPolys[tobj],TwistFoldedFormLines[tobj]},FilterRules[{opts},Options[Graphics]]]]
GraphicsRow[{
TwistFoldedFormGraphics[twistobj],
TwistFoldedFormGraphics[twistobj]}]/.OrigamiStyle[]//ShowExample
CircularPolygonTwistCreasePatternGraphics[verts_List,\[Alpha]_,r_,types_List:{},opts___]:=Module[{tobj},
tobj=CircularPolygonTwistGraph2D[verts,\[Alpha],r,types,opts];
TwistCreasePatternGraphics[tobj]/.BorderLine->NoLine]
Module[{verts,types,cp},
verts={{0,0},{1,0},{.5,.4}};
types={M,M,V};
cp=CircularPolygonTwistCreasePatternGraphics[verts,30.\[Degree],2,types];
cp/.OrigamiStyle[]]//ShowExample
CircularPolygonTwistFoldedFormGraphics[verts_List,\[Alpha]_,r_,types_List:{},opts___]:=Module[{tobj},
tobj=CircularPolygonTwistGraph2D[verts,\[Alpha],r,types,opts];
TwistFoldedFormGraphics[tobj]/.BorderLine->NoLine]
Module[{verts,types,args,cp,ff},
verts={{0,0},{1,0},{.5,.4}};
types={M,M,V};
args={verts,30.\[Degree],2,types};
cp=CircularPolygonTwistCreasePatternGraphics@@args;
ff=CircularPolygonTwistFoldedFormGraphics@@args;
GraphicsRow[{cp,ff}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,types,args,cp,ff},
verts=UnitRegularPolygonVertices[5];
types={M,M,V,V,M};
args={verts,30.\[Degree],2,types};
cp=CircularPolygonTwistCreasePatternGraphics@@args;
ff=CircularPolygonTwistFoldedFormGraphics@@args;
GraphicsRow[{cp,ff}]/.OrigamiStyle[]
]//ShowExample
CircularRegularPolygonTwistCreasePatternGraphics[n_,\[Alpha]_,m_,types_,opts___]:=Module[{verts,r},
verts=N[UnitRegularPolygonVertices[n]];
r =N[ m UnitRegularPolygonCircumradius[n]];
CircularPolygonTwistCreasePatternGraphics[verts,N[\[Alpha]],r, types, opts]]
Graphics[CircularRegularPolygonTwistCreasePatternGraphics[6,30\[Degree],3,{M,V,M,V,M,V}]]/.OrigamiStyle[]//ShowExample
CircularRegularPolygonTwistFoldedFormGraphics[n_,\[Alpha]_,m_,types_,opts___]:=Module[{verts,r},
verts=N[UnitRegularPolygonVertices[n]];
r =N[ m UnitRegularPolygonCircumradius[n]];
CircularPolygonTwistFoldedFormGraphics[verts,N[\[Alpha]],r, types, opts]]
Module[{args},
args={5,30\[Degree],3,{M,V,M,V,M}};
GraphicsRow[{
CircularRegularPolygonTwistCreasePatternGraphics@@args,
CircularRegularPolygonTwistFoldedFormGraphics@@args}]/.OrigamiStyle[]
]//ShowExample
CircularRegularPolygonTwistPairGraphics[n_,\[Alpha]_,m_,types_,opts___]:=Graphics[PlaceInRowGraphics[{
CircularRegularPolygonTwistCreasePatternGraphics[n,\[Alpha],m,types,opts],CircularRegularPolygonTwistFoldedFormGraphics[n,\[Alpha],m,types,opts]},Sequence@@FilterRules[{opts},Options[PlaceInRowGraphics]]],FilterRules[{opts},Options[Graphics]]]
CircularRegularPolygonTwistPairGraphics[4,30\[Degree],3.,{M,M,V,V},Spacing->0.3]/.OrigamiStyle[]//ShowExample
CircularTriangleTwistCreasePatternGraphics[angles_List,\[Alpha]_,r_,types_List:{},opts___]:=Module[{verts},
verts=UnitTriangleVertices[angles];
verts=#-Centroid[verts]&/@verts;
CircularPolygonTwistCreasePatternGraphics[verts,\[Alpha],r,types,opts]
]
Module[{angles},
angles={40.\[Degree],60.\[Degree],80.\[Degree]};
CircularTriangleTwistCreasePatternGraphics[angles,20\[Degree],1.5,{M,M,M}]/.OrigamiStyle[]
]//ShowExample
CircularTriangleTwistFoldedFormGraphics[angles_List,\[Alpha]_,r_,types_List:{},opts___]:=CircularPolygonTwistFoldedFormGraphics[UnitTriangleVertices[angles],\[Alpha],r,types,opts]
Module[{angles},
angles={40.\[Degree],60.\[Degree],80.\[Degree]};
CircularTriangleTwistFoldedFormGraphics[angles,20\[Degree],1.5,{M,M,M}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,types,tobj},
verts=UnitRegularPolygonVertices[5];
types={V,M,V,M,V};
tobj=CircularPolygonTwistGraph2D[verts,45.\[Degree],2,types];
GraphicsRow[{
KillBorder[VisibleFoldedFormGraphics[tobj,PlotLabel->"VisibleFoldedFormGraphics"]]/.BorderLine->NoLine,
TwistFoldedFormGraphics[tobj,PlotLabel->"TwistFoldedFormGraphics"]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,types,tobj},
verts=UnitRegularPolygonVertices[6];
types={V,M,V,M,V,M};
tobj=CircularPolygonTwistGraph2D[verts,45.\[Degree],3,types];
GraphicsRow[{
KillBorder[VisibleFoldedFormGraphics[tobj,PlotLabel->"VisibleFoldedFormGraphics"]]/.BorderLine->NoLine,
TwistFoldedFormGraphics[tobj,PlotLabel->"TwistFoldedFormGraphics"]}]/.OrigamiStyle[]
]//ShowExample
TilingText::usage="TilingText is a symbolic style for showing text in tessellation tilings.";
TilingLine::usage="TilingLine is a symbolic style for showing tiling lines in tessellation tilings.";
TilingNoFill::usage="TilingNoFill is a symbolic style for no fill in polygons.";
TilingLightFill::usage="TilingLightFill is a symbolic style for light fill in polygons.";
TilingMedFill::usage="TilingMedFill is a symbolic style for medium fill in polygons.";
TilingDarkFill::usage="TilingDarkFill is a symbolic style for dark fill in polygons.";
TilingTextColor::usage="TilingTextColor is an option to TilingStyle that specifies the color for tiling text.";
TilingLineColor::usage="TilingLineColor is an option to TilingStyle that specifies the color for tiling lines.";
TilingFillColor::usage="TilingFillColor is an option to TilingStyle that specifies the color for tiling polygon fills.";
Options[TilingStyle]={
TilingTextColor->Darker[Brown,0.8],
TilingLineColor->Orange,
TilingFillColor->Lighter[Brown]
};
TilingStyle[opts___]:=Module[{x,ttc,tlc,tfc},
ttc=TilingTextColor/.{opts}/.Options[TilingStyle];
tlc=TilingLineColor/.{opts}/.Options[TilingStyle];
tfc=TilingFillColor/.{opts}/.Options[TilingStyle];
{Style[x_,TilingText]->Style[x,ttc],
Style[x_,TilingLine]->Style[x,tlc,AbsoluteThickness[1.0],AbsoluteDashing[{}],CapForm["Round"],JoinForm["Round"]],
Style[x_,TilingNoFill]->{},
Style[x_,TilingLightFill]->Style[x,EdgeForm[],FaceForm[Lighter[tfc,0.70]]],
Style[x_,TilingMedFill]->Style[x,EdgeForm[],FaceForm[Lighter[tfc,0.50]]],
Style[x_,TilingDarkFill]->Style[x,EdgeForm[],FaceForm[tfc]]
}]
Module[{test},
test={
Style[Polygon[{{0,0},{1,0},{1,1}}],TilingNoFill],
Style[Polygon[{{1,0},{2,0},{2,1}}],TilingLightFill],
Style[Polygon[{{2,0},{3,0},{3,1}}],TilingMedFill],
Style[Polygon[{{3,0},{4,0},{4,1}}],TilingDarkFill],
Style[Line[{{0,0},{0,1},{4,1}}],TilingLine],
Style[Text["A",{.5,.5}],TilingText]
};
Graphics[test/.TilingStyle[]]
]//ShowExample

TileVertices::usage="TileVertices is a type of tile decoration that returns a list of vertices of the tiling polygon.";
Tiling::usage = "Tiling is a type of tile decoration that renders the underlying tiling.";
RenderTile::nodef="There is no applicable definition for `1`.";
RenderTile[tiletype_,decoration_,opts___]:=Module[{args},
args=StringJoin[Riffle[ToString/@InputForm/@{tiletype,decoration,opts},", "]];
Message[RenderTile::nodef,"RenderTile["<>args<>"]"];Abort[]]
RenderTile[{"foo"},TileVertices,TileIndex->True,Numeric->True]//ShowErrorExample
RenderTile[tiletype_,decorations_List,opts___]:=RenderTile[tiletype,#,opts]&/@decorations
TestTile::usage="TestTile is a type of tile that renders a regular polygon.";
RenderTile[{TestTile,n_},TileVertices,opts___]:=UnitRegularPolygonVertices[n]
RenderTile[{TestTile,n_},Tiling,opts___]:=Module[{ti,verts,ctr},
ti=TileIndex/.{opts}/.{TileIndex->None};
verts=UnitRegularPolygonVertices[n];
ctr=UnitRegularPolygonCenter[n];
{If[ti===None,{},Style[Text[ToString[ti],ctr],Black]],
Style[Table[Text[ToString[j],0.8 verts[[j]]+0.2ctr],{j,n}],TilingText],
Style[Line[AppendFirst[verts]],TilingLine]}]
RenderTile[{TestTile,3},TileVertices]//ShowExample
Graphics[RenderTile[{TestTile,3},Tiling,TileIndex->1]]/.TilingStyle[]//ShowExample
Clear[RenderTileCache];
RenderTileCache[tiletype_List,decoration_,opts___]:=RenderTileCache[tiletype,decoration,opts]=RenderTile[tiletype,decoration,opts]
Numeric::usage="Numeric is an option to EmbedTile that applies N[] to tile coordinates.";
Options[EmbedTile]={
Numeric->False
};
EmbedTile[{tiletype_List,offset_:{0,0},rotation_:0,scale_:1},decoration_,opts___]:=Module[{nm,dtile},
nm=Numeric/.{opts}/.Options[EmbedTile];
dtile=RenderTileCache[tiletype,decoration,opts];
FunctionTransform[dtile,If[nm,N[offset+RotationMatrix2D[rotation] . (scale*#)]&,(offset+RotationMatrix2D[rotation] . (scale*#))&]]]
EmbedTile[{tiletype_List,offset_:{0,0},rotation_:0,scale_:1},TileVertices,opts___]:=Module[{nm,dtile},
dtile=RenderTileCache[tiletype,TileVertices,opts];
nm=Numeric/.{opts}/.Options[EmbedTile];
If[nm,N[offset+RotationMatrix2D[rotation] . (scale*#)]&,(offset+RotationMatrix2D[rotation] . (scale*#))&]/@dtile]
EmbedTile[{{TestTile,4}},Tiling]//ShowExample
EmbedTile[{{TestTile,4},{1,1},0\[Degree],1},TileVertices]//ShowExample
EmbedTile[{{TestTile,4},{0,0},0\[Degree],1},TileVertices,Numeric->True]//ShowExample
TileIndices::usage="TileIndices is an option to EmbedTiling that specifies whether to pass a unique index to each tile when embedding.";
TileIndex::usage="TileIndex is an option that EmbedTiling passes down the chain to RenderTile if TileIndices is set to True.";
Options[EmbedTiling]={
TileIndices->False,
TileIndex->None
};
EmbedTiling[tiling_List,decoration_,opts___]:=Module[{ti},
ti=TileIndices/.{opts}/.Options[EmbedTiling];
If[ti,
MapIndexed[EmbedTile[#1,decoration,opts,TileIndex->#2[[1]]]&,tiling],
EmbedTile[#,decoration,opts]&/@tiling]]
Module[{tiling},
tiling={
{{TestTile,4}},
{{TestTile,4},{1,0}}
};
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True]]/.TilingStyle[]
]
EmbedTiling[tiling_List,decorations_List,opts___]:=EmbedTiling[tiling,#,opts]&/@decorations
Options[JoinTiling]={
Simplification->Automatic,
Numeric->False
};
JoinTiling::badoffset="The offset `1` in tilespec `2` is improperly formatted for JoinTiling.";
JoinTiling[{}]:={};
JoinTiling[tilespecs_List,opts___]:=Module[{si,nm,sfn,out,tverts,tilespec,tiletype,offset,rotation,scale,verts,i,j,k,aoffset},
si=Simplification/.{opts}/.Options[JoinTiling];
nm=Numeric/.{opts}/.Options[JoinTiling];
sfn=If[si===Automatic,If[nm,N,#&],Simplify];
out={tilespecs[[1]]};
tverts={EmbedTile[tilespecs[[1]],TileVertices,opts]};
Do[
tilespec=tilespecs[[n]];
tiletype=tilespec[[1]];
offset=If[Length[tilespec]>=2,tilespec[[2]],{0,0}];
rotation=If[Length[tilespec]>=3,tilespec[[3]],0];
scale=If[Length[tilespec]>=4,tilespec[[4]],1];
verts=EmbedTile[{tiletype,{0,0},rotation,scale},TileVertices,opts];
aoffset={0,0};
Switch[Length[tilespec[[2]]],
3,{i,j,k}=tilespec[[2]],
4,{i,j,k,aoffset}=tilespec[[2]],
_,Message[JoinTiling::badoffset,tilespec[[2]],tilespec];Abort[]];
If[k<0,
offset=sfn[tverts[[i,j]]-verts[[Abs[k]]]]+aoffset,
(* k>0 *)
{scale,rotation,offset}=ScaleRotationOffset[{verts[[k]],verts[[Mod[k-1,Length[verts],1]]]},{tverts[[i,j]],tverts[[i,Mod[j+1,Length[tverts[[i]]],1]]]}];
offset+=aoffset];
AppendTo[out,{tiletype,sfn[offset],sfn[rotation],sfn[scale]}];
AppendTo[tverts,sfn[EmbedTile[out[[-1]],TileVertices,opts]]]
,{n,2,Length[tilespecs]}];
out]
Module[{tilespecs,tilespecs1},
tilespecs={
{{TestTile,4},{0,0}},
{{TestTile,5},{1,3,-5}}};
tilespecs1=JoinTiling[tilespecs,Numeric->True];
PrintThis[tilespecs1];
Graphics[EmbedTiling[tilespecs1,Tiling,TileIndices->True]]/.TilingStyle[]
]//ShowExample
Module[{tilespecs,tilespecs1},
tilespecs={
{{TestTile,4},{0,0}},
{{TestTile,5},{1,2,1}}};
tilespecs1=JoinTiling[tilespecs,Numeric->True];
Graphics[EmbedTiling[tilespecs1,Tiling,TileIndices->True]]/.TilingStyle[]
]//ShowExample
Module[{tilespecs,tilespecs1,t1,t2},
tilespecs={
{{TestTile,4},{0,0}},
{{TestTile,5},{1,2,1,{0.1,0}}}};
t1=Timing[tilespecs1=JoinTiling[tilespecs,Numeric->False]];
t2=Timing[tilespecs1=JoinTiling[tilespecs,Numeric->True]];
Print["Timing (Numeric\[Rule]False) = ",t1[[1]]];
Print["Timing (Numeric\[Rule]True) = ",t2[[1]]];
Graphics[EmbedTiling[tilespecs1,Tiling,TileIndices->True]]/.TilingStyle[]
]//ShowExample
Module[{tilespecs,tilespecs1},
tilespecs={
{{TestTile,3},{0,0}},
{{TestTile,4},{1,2,1}},
{{TestTile,3},{2,2,1}}
};
tilespecs1=JoinTiling[tilespecs];
Graphics[EmbedTiling[tilespecs1,Tiling,TileIndices->True]]/.TilingStyle[]
]//ShowExample
TilespecInTilingQ[tilespec_,verts_]:=Module[{pts},
pts=EmbedTile[tilespec,TileVertices,Numeric->True];
Or@@Join[PtInConvexPolygonQ[#,verts]&/@pts,PtInConvexPolygonQ[#,pts]&/@verts ]]
Module[{tilespec,cliprect},
tilespec={{TestTile,4},{1.1,0},10\[Degree]};
cliprect=SquareVertices[1.];
Print[Graphics[{
EmbedTiling[{tilespec},Tiling],Style[Line[Append[cliprect,cliprect[[1]]]],
AbsoluteThickness[2],Red]}]/.TilingStyle[]];
TilespecInTilingQ[tilespec,cliprect]
]//ShowExample
Module[{tilespec,cliprect},
tilespec={{TestTile,4},{1.3,0},10\[Degree]};
cliprect=SquareVertices[1.];
Print[Graphics[{
EmbedTiling[{tilespec},Tiling],Style[Line[Append[cliprect,cliprect[[1]]]],
AbsoluteThickness[2],Red]}]/.TilingStyle[]];
TilespecInTilingQ[tilespec,cliprect]
]//ShowExample
PruneTiling[tilespecs_,verts_List]:=Select[tilespecs,TilespecInTilingQ[#,verts]&]
Module[{tilespecs,cliprect,ptilespecs},
tilespecs=Flatten[Table[{{TestTile,4},{-.1+i-1,-.1+j-1}},{i,4},{j,4}],1];
cliprect=SquareVertices[2.3];
ptilespecs=PruneTiling[tilespecs,cliprect];
GraphicsRow[{
Graphics[{
EmbedTiling[tilespecs,Tiling],
Style[Line[Append[cliprect,cliprect[[1]]]],AbsoluteThickness[2],Red]},PlotLabel->"unpruned"],
Graphics[{
EmbedTiling[ptilespecs,Tiling],
Style[Line[Append[cliprect,cliprect[[1]]]],AbsoluteThickness[2],Red]},PlotLabel->"pruned"]}/.TilingStyle[]]
]//ShowExample
PrunePoly[verts_List]:=Style[Line[Append[verts,verts[[1]]]],AbsoluteThickness[2],Red]
EmbedTile[{tiletype_List,offset_:{0,0},rotation_:0,scale_:1},TGraphAssigned,opts___]:=Module[{nm,dtile,verts},
nm=Numeric/.{opts}/.Options[EmbedTile];
dtile=RenderTileCache[tiletype,TGraphAssigned,opts];
verts=If[nm,N[offset+RotationMatrix2D[rotation] . (scale*#)]&,(offset+RotationMatrix2D[rotation] . (scale*#))&]/@dtile[Vertices];
dtile//ReplaceProperty[Vertices->verts]]
EmbedTile[{tiletype_List,offset_:{0,0},rotation_:0,scale_:1},TGraph2DAssigned,opts___]:=Module[{nm,dtile,verts,verts2d,f2d},
nm=Numeric/.{opts}/.Options[EmbedTile];
dtile=RenderTileCache[tiletype,TGraph2DAssigned,opts];
f2d=If[nm,N[offset+RotationMatrix2D[rotation] . (scale*#)]&,(offset+RotationMatrix2D[rotation] . (scale*#))&];
verts=f2d/@dtile[Vertices];
verts2d=f2d/@dtile[Vertices2D];
dtile//ReplaceProperties[{Vertices->verts,Vertices2D->verts2d}]]
EmbedTile[{tiletype_List,offset_:{0,0},rotation_:0,scale_:1},TGraph3DAssigned,opts___]:=Module[{nm,dtile,verts,verts3d,f2d,f3d},
nm=Numeric/.{opts}/.Options[EmbedTile];
dtile=RenderTileCache[tiletype,TGraph3DAssigned,opts];
f2d=If[nm,N[offset+RotationMatrix2D[rotation] . (scale*#)]&,(offset+RotationMatrix2D[rotation] . (scale*#))&];
f3d=If[nm,N[Append[offset,0]+RotationZMatrix3D[rotation] . (scale*#)]&,(Append[offset,0]+RotationZMatrix3D[rotation] . (scale*#))&];
verts=f2d/@dtile[Vertices];
verts3d=f2d/@dtile[Vertices3D];
dtile//ReplaceProperties[{Vertices->verts,Vertices3D->verts3d}]]
CreasePattern::usage="CreasePattern is a type of tile decoration that displays a crease pattern tile.";
FoldedForm2D::usage="FoldedForm2D is a type of tile decoration that displays a flat folded form tile.";
FoldedForm3D::usage="FoldedForm3D is a type of tile decoration that displays a 3D folded form tile.";
RenderTile[tiletype_List,CreasePattern,opts___]:=Module[{tobj},
tobj=RenderTile[tiletype,TGraphAssigned,opts];
CreasePatternGraphics[tobj][[1]]//KillBorder]
RenderTile[tiletype_List,FoldedForm2D,opts___]:=Module[{tobj},
tobj=RenderTile[tiletype,TGraph2DAssigned,opts];
VisibleFoldedFormGraphics[tobj][[1]]//KillBorder]
RenderTile[tiletype_List,FoldedForm3D,opts___]:=Module[{tobj},
tobj=RenderTile[tiletype,TGraph3DAssigned,opts];
FoldedFormGraphics3D[tobj][[1]]//KillBorder]
TileArrowDH[{p_,q_}, dir_]:=Module[{r,s,ctr,sz,w,pts},
r=q-p;
s=Rotate90[r];
ctr=(p+q)/2;
sz=0.15;
w=0.58;
pts=ctr+sz #&/@ If[dir>0,
{-.5 r,+.5 r,-.5 r+w s},
{+.5 r,-.5 r,+.5 r+w s}];
Style[Polygon[pts],TilingLine]]
Module[{pts1,pts2},
pts1={{0,0},{1,0}};
pts2={{1,0},{1,0.7}};
Graphics[{
{Line[pts1],TileArrowDH[pts1,+1]},
{Line[pts2],TileArrowDH[pts2,-1]}}]/.TilingStyle[]
]//ShowExample
TileArrowCH[{p_,q_}, dir_]:=Module[{r,s,ctr,sz,w,pts},
r=q-p;
s=Rotate90[r];
ctr=(p+q)/2;
sz=0.15;
w = 0.3;
pts=ctr+sz #&/@If[dir>0,
{{0,0},s+w r,s-w r},
{-w r,w r,s}];
Style[Polygon[pts],TilingLine]]
Module[{pts1,pts2},
pts1={{0,0},{1,0}};
pts2={{1,0},{1,0.7}};
Graphics[{
{Line[pts1],TileArrowCH[pts1,+1]},
{Line[pts2],TileArrowCH[pts2,-1]}}]/.TilingStyle[]
]//ShowExample
TileArrowDF[{p_,q_}, dir_]:=Module[{r,s,ctr,sz,w,pts},
r=q-p;
s=Rotate90[r];
ctr=(p+q)/2;
sz=0.18;
w=0.3;
pts=ctr+sz #&/@ If[dir>0,
{-.5 r-w s,+.5 r,-.5 r+w s},
{+.5 r-w s,-.5 r,+.5 r+w s}];
Style[Polygon[pts],TilingLine]]
Module[{pts1,pts2},
pts1={{0,0},{1,0}};
pts2={{1,0},{1,0.7}};
Graphics[{
{Line[pts1],TileArrowDF[pts1,+1]},
{Line[pts2],TileArrowDF[pts2,-1]}}]/.TilingStyle[]
]//ShowExample
TileArrowCF[{p_,q_}, dir_]:=Module[{r,s,ctr,sz,w,pts},
r=q-p;
s=Rotate90[r];
ctr=(p+q)/2;
sz=0.18;
w=0.3;
pts=ctr+sz #&/@If[dir>0,
{-.5s,.5s+w r,.5s-w r},
{-w r-.5s,w r-.5s,.5s}];
Style[Polygon[pts],TilingLine]]
Module[{pts1,pts2},
pts1={{0,0},{1,0}};
pts2={{1,0},{1,0.7}};
Graphics[{
{Line[pts1],TileArrowCF[pts1,+1]},
{Line[pts2],TileArrowCF[pts2,-1]}}]/.TilingStyle[]
]//ShowExample
PolygonTile::usage="PolygonTile is a tile type that specifies a polygon by its vertices.";
RenderTile[{PolygonTile,verts_List},TileVertices,opts___]:=verts
RenderTile[{PolygonTile,UnitRegularPolygonVertices[4]},TileVertices]
TilePolys::usage="TilePolys is an option to RenderTile[{PolygonTile, verts}, Tiling, opts] that specifies whether to render tile polygons with a fill color.";
TileEdges::usage="TileEdges is an option to RenderTile[{PolygonTile, verts}, Tiling, opts] that specifies whether to render the edges of time polygons.";
TileVertexIndices::usage="TileVertexIndices is an option to RenderTile[{PolygonTile, verts}, Tiling, opts] that specifies whether to label the indices of the vertices of the tile.";
TileEdgeArrowStyle::usage="TileEdgeArrowStyle is an option to RenderTile[{PolygonTile, verts}, Tiling, opts] that specifies the arrowhead style to use on the edges of the tile.";
TilePolyFill::usage="TilePolyFill is an option to RenderTile[{PolygonTile, verts}, Tiling] that specifies the symbolic fill color to use for the tile.";
TileEdgeArrowDirs::usage="TileEdgeArrowDirs is an option to RenderTile[{PolygonTile, verts}, Tiling, opts] that specifies a list of directions (\[PlusMinus]1) for each edge of the tile.";
Options[PolygonTile]={
TilePolys->False,
TileEdges->True,
TileVertexIndices->False,
TileEdgeArrowStyle->None,
TilePolyFill->None,
TileEdgeArrowDirs->None,
TileIndex->None
};
PolygonTile::badpolys="Value `1` to option TilePolys should be True or False.";
PolygonTile::badedges="Value `1` to option TileEdges should be True or False.";
PolygonTile::badvertinds="Value `1` to option TileVertexIndices should be True or False.";
PolygonTile::badpolytype="`1` is an invalid specification for TilePolyFill.";
PolygonTile::badedgetypes = "The length `1` of EdgeTypes `2` does not match the length `3` of vertices `4`.";
PolygonTile::badedgearrows="`1` is an invalid specification for TileEdgeArrowStyle.";
RenderTile[{PolygonTile,verts_List},Tiling,opts___]:=Module[{tp,te,pt,et,ea,ci,vi,n,ctr,out,fill,edges},
tp=TilePolys/.{opts}/.Options[PolygonTile];
te=TileEdges/.{opts}/.Options[PolygonTile];
vi=TileVertexIndices/.{opts}/.Options[PolygonTile];
ea=TileEdgeArrowStyle/.{opts}/.Options[PolygonTile];
pt=TilePolyFill/.{opts}/.Options[PolygonTile];
et=TileEdgeArrowDirs/.{opts}/.Options[PolygonTile];
ci=TileIndex/.{opts}/.Options[PolygonTile];
n=Length[verts];
ctr=(Plus@@verts)/n;
edges=Transpose[{verts,RotateLeft[verts]}];
out={};
(* fill *)
Switch[tp,
True,If[!(pt===None),AppendTo[out,Style[Polygon[verts],pt]]],
False,Null,
_,Message[PolygonTile::badpolys,tp];Abort[]];
(* lines *)
Switch[te,
True,AppendTo[out,Style[Line[#],TilingLine]&/@edges],
False,Null,
_,Message[PolygonTile::badedges,te];Abort[]];
(* arrowheads *)
If[!(ea===None||et===None),
If[Length[et]!=Length[verts],Message[PolygonTile::badedgetypes,Length[et],et,Length[verts],verts];Abort[]];
If[Position[{TileArrowDH,TileArrowCH,TileArrowDF,TileArrowCF},ea]=={},Message[PolygonTile::badedgearrows,ea];Abort[]];
AppendTo[out,MapThread[ea,{edges,et}]]];
(* tiling index *)
If[!(ci===None),AppendTo[out,Style[Text[ToString[ci],ctr],TilingText]]];
(* vertex indices *)
Switch[vi,
True,AppendTo[out,Style[Table[Text[ToString[j],0.8 verts[[j]]+0.2ctr],{j,n}],TilingText]],
False,Null,
_,Message[PolygonTile::badvertinds,vi];Abort[]];
out]
Module[{verts},
verts=UnitRegularPolygonVertices[4];
GraphicsRow[{
Graphics[RenderTile[{PolygonTile,verts},Tiling],PlotLabel->"none"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TilePolys->True,TilePolyFill->TilingNoFill],PlotLabel->"TilingNoFill"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TilePolys->True,TilePolyFill->TilingLightFill],PlotLabel->"TilingLightFill"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TilePolys->True,TilePolyFill->TilingMedFill],PlotLabel->"TilingMedFill"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TilePolys->True,TilePolyFill->TilingDarkFill],PlotLabel->"TilingDarkFill"]
}]/.TilingStyle[]
]//ShowExample
Module[{verts},
verts=UnitRegularPolygonVertices[4];
GraphicsRow[{
Graphics[RenderTile[{PolygonTile,verts},Tiling,TileEdgeArrowDirs->{1,1,-1,-1}],PlotLabel->"none"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TileEdgeArrowDirs->{1,1,-1,-1},TileEdgeArrowStyle->TileArrowDH],PlotLabel->"TileArrowDH"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TileEdgeArrowDirs->{1,1,-1,-1},TileEdgeArrowStyle->TileArrowCH],PlotLabel->"TileArrowCH"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TileEdgeArrowDirs->{1,1,-1,-1},TileEdgeArrowStyle->TileArrowDF],PlotLabel->"TileArrowDF"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TileEdgeArrowDirs->{1,1,-1,-1},TileEdgeArrowStyle->TileArrowCF],PlotLabel->"TileArrowCF"]
}]/.TilingStyle[]
]//ShowExample
Module[{verts},
verts=UnitRegularPolygonVertices[4];
GraphicsRow[{
Graphics[RenderTile[{PolygonTile,verts},Tiling],PlotLabel->"none"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TileIndex->"a"],PlotLabel->"TileIndex"],
Graphics[RenderTile[{PolygonTile,verts},Tiling,TileVertexIndices->True],PlotLabel->"TileVertexIndices"]
}]/.TilingStyle[]
]//ShowExample
PolygonTwistTile::usage="PolygonTwistTile is a tile type that produces a simple flat twist in a polygon.";
TileCheckTypes::badtypes="Length `1` of vertex list `2` does not match length `3` of types list `4`.";
TileCheckTypes[verts_List,types_List]:=If[Length[verts]!=Length[types],Message[TileCheckTypes::badtypes,Length[verts],verts,Length[types],types];Abort[]]
RenderTile[{PolygonTwistTile,verts_List,w_,d_,\[Tau]_,ccw_,types_List},TileVertices,opts___]:=verts
Module[{verts,w,d,\[Tau],ccw,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=0.1;
\[Tau]=70\[Degree];
ccw=True;
types={M,M,V,V};
RenderTile[{PolygonTwistTile,verts,w,d,\[Tau],ccw,types},TileVertices]
]//ShowExample
RenderTile[{PolygonTwistTile,verts_List,w_,d_,\[Tau]_,ccw_,types_List},Tiling,opts___]:=RenderTile[{PolygonTile,verts},Tiling,opts]
Module[{verts,w,d,\[Tau],ccw,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=0.1;
\[Tau]=70\[Degree];
ccw=True;
types={M,M,V,V};
Graphics[RenderTile[{PolygonTwistTile,verts,w,d,\[Tau],ccw,types},Tiling]]/.TilingStyle[]
]//ShowExample
Module[{O,A,B,C,P,Pp,Ap,Bp,\[Tau]p,soln,ex},
O={0,0};
A={(1-w)/2+d,0};
B={(1+w)/2+d,0};
P={1,0};
C=B+2 w Sin[\[Tau]] {-Sin[\[Tau]],Cos[\[Tau]]};
Pp=P+2 w Sin[\[Tau]] {-Sin[\[Tau]],Cos[\[Tau]]};
Ap=LineInt2D[O,Pp-O,A,U[\[Tau]]];
Bp=LineInt2D[O,Pp-O,C,U[\[Tau]]];
(* equivalent tilt angle for folded form *)
\[Tau]p=FullSimplify[ArcTan[U[\[Tau]-\[Pi]/2] . (Pp-O)/U[\[Tau]] . (Pp-O)]];
Print["\[Tau]' = ",\[Tau]p];
soln=FullSimplify[Solve[{(1-wp)/2+dp==(Ap-O)[[1]]/(Pp-O)[[1]],(1+wp)/2+dp==(Bp-O)[[1]]/(Pp-O)[[1]]},{wp,dp}]];
Print["w' = ",wp/.soln[[1]],", d' = ",dp/.soln[[1]]];
(* and show a plot of the geometry *)
ex={w->0.15,d->-0.08,\[Tau]->70\[Degree]};
Graphics[{
Black,Line[{O,P}],
Gray,Line[{A,A+.5U[\[Tau]]}],Line[{B,B+.5U[\[Tau]]}],Line[{C,C+.5U[\[Tau]]}],
Orange,Line[{O,Pp}],
Green,Line[{A,C,Pp}],
LightGray,Line[{B,C}],Line[{P,Pp}],Line[{C-.1U[\[Tau]],C}],
Black,
Point[O],Text["O",O,{2,0}],
Point[A],Text["A",A,{0,2}],
Point[B],Text["B",B,{0,2}],
Point[C],Text["C",C,{0,-2}],
Point[P],Text["P",P,{-2,0}],
Point[Pp],Text["P'",Pp,{-2,0}],
Point[Ap],Text["A'",Ap,{0,-2}],
Point[Bp],Text["B'",Bp,{1,-2}],
{}}]/.ex
]//ShowExample
RenderTile[{PolygonTwistTile,verts_List, w_,d_, \[Tau]_,ccw_,types_List},TGraphAssigned,opts___] := Module[{n,gverts,dirs,cverts,averts,edges,atypes,twistface,faces,pleats,wedges},
TileCheckTypes[verts,types];
n=Length[verts];
(* vertices on tile boundary *)
gverts=MapThread[{#1,((1+w)/2)#1+((1-w)/2)#2+d(#2-#1),((1-w)/2)#1+((1+w)/2)#2+d(#2-#1)}&,{verts,RotateLeft[verts]}];
dirs=RotationMatrix2D[\[Tau]] . #&/@(RotateLeft[verts]-verts);
(* central polygon vertices *)
cverts=MapThread[LineInt2D,{#[[2]]&/@gverts,dirs,#[[3]]&/@RotateRight[gverts],RotateRight[dirs]}];(* all vertices *)
averts=Flatten[MapThread[Append,{gverts,cverts}],1];
edges=Mod[Flatten[Table[{{1,2},{2,3},{3,5},{2,4},{3,8},{4,8}}+4i,{i,0,n-1}],1],4n,1];
atypes=Flatten[{B,B,B,If[ccw,#,InvertFoldType[#]],If[ccw,InvertFoldType[#],#],#}&/@types];
pleats=Mod[Table[{2,3,8,4}+4i,{i,0,n-1}],4n,1];
wedges=Mod[Table[{1,2,4,-1}+4i,{i,0,n-1}],4n,1];
twistface=Mod[Table[4i,{i,n}],4n,1];
faces=Join[{twistface},pleats,wedges];
MakeTGraph[averts,edges,faces]//AddTAssigned[atypes]//AddTTwistGraph[{1}]]
Module[{verts,w,d,\[Tau],ccw,types,tobj},
verts={{0,0},{1,0},{1/2,1}};
w=0.15;
d=0;
\[Tau]=75\[Degree];
ccw=True;
types={M,M,M};
tobj=RenderTile[{PolygonTwistTile,verts,w,d,\[Tau] ,ccw,types},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
Module[{verts,w,d,\[Tau],ccw,types,tobj},
verts={{0,0},{1,0},{1/2,1}};
w=0.16;
d=0.08;
\[Tau]=90\[Degree];
ccw=True;
types={M,M,M};
tobj=RenderTile[{PolygonTwistTile,verts,w,d,\[Tau] ,ccw,types},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
RenderTile[{PolygonTwistTile,verts_List, w_,d_, \[Tau]_,ccw_,types_List},TGraph2DAssigned,opts___] := Module[{tobjcp,tobjff},
tobjcp=RenderTile[{PolygonTwistTile,verts,w,d,\[Tau],ccw,types},TGraphAssigned,opts];
tobjff=RenderTile[{PolygonTwistTile,verts,(-w)/(1-2w), d/(1-2 w),ArcCot[Cot[\[Tau]]/(1-2w)],ccw,types},TGraphAssigned,opts];
tobjcp//AddTGraph2D[tobjff[Vertices]]]
Module[{verts,w,d,\[Tau],ccw,types,tobj},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=-0.05;
\[Tau]=70\[Degree];
ccw=True;
types={M,M,V,V};
tobj=RenderTile[{PolygonTwistTile,verts,w,d,\[Tau],ccw,types},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
PolygonTwistNumSides[tobj_TObj]:=Length[tobj[Faces][[1]]]
Module[{verts,tobj},
verts={{0,0},{1,0},{.8,.9},{-.1,.7}};
tobj=RenderTile[{PolygonTwistTile,verts,.2,.2,90\[Degree],True,{M,M,V,V}},TGraphAssigned];
Print["Num sides = ",PolygonTwistNumSides[tobj]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
PolygonTwistTwistAngles[tobj_TObj]:=Module[{n,v,p,q,r},
n=Length[tobj[Faces][[1]]];
v=tobj[Vertices];
Table[
{p,q,r}=v[[Mod[4i+{-1,4,0},Length[v],1]]];(* triples that define each twist angle *)
ArcTan[(p-q) . (r-q),(p-q) . (RotationMatrix2D[\[Pi]/2] . (r-q))],{i,n}]]
Module[{verts,tobj},
verts={{0,0},{1,0},{.8,.9},{-.1,.7}};
tobj=RenderTile[{PolygonTwistTile,verts,.2,.2,90\[Degree],True,{M,M,V,V}},TGraphAssigned];
Print["Twist angles/\[Degree] = ",PolygonTwistTwistAngles[tobj]/\[Degree]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
PolygonTwistCentralPolygonSides[tobj_TObj]:=Module[{n,v,p,q},
n=Length[tobj[Faces][[1]]];
v=tobj[Vertices];
Table[
{p,q}=v[[Mod[4i+{0,4},Length[v],1]]];
Mag[p-q],{i,n}]]
Module[{verts,tobj},
verts={{0,0},{1,0},{.8,.9},{-.1,.7}};
tobj=RenderTile[{PolygonTwistTile,verts,.2,.2,90\[Degree],True,{M,M,V,V}},TGraphAssigned];
Print["Central polygon side lengths = ",PolygonTwistCentralPolygonSides[tobj]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
PolygonTwistCentralPolygonAngles[tobj_TObj]:=Module[{n,v,p,q,r},
n=Length[tobj[Faces][[1]]];
v=tobj[Vertices];
Table[
{p,q,r}=v[[Mod[4i+{-4,0,4},Length[v],1]]];
\[Pi]-ArcTan[(r-q) . (q-p),(r-q) . (RotationMatrix2D[\[Pi]/2] . (q-p))],{i,n}]]
Module[{verts,tobj},
verts={{0,0},{1,0},{.8,.9},{-.1,.7}};
tobj=RenderTile[{PolygonTwistTile,verts,.2,.2,90\[Degree],True,{M,M,V,V}},TGraphAssigned];
Print["Central polygon corner angles/\[Degree] = ",PolygonTwistCentralPolygonAngles[tobj]/\[Degree]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
PolygonTwistCentralPolygonAnglesExcess[tobj_TObj]:=Module[{ta},
ta=PolygonTwistTwistAngles[tobj];
2(ta-RotateRight[ta])]
Module[{verts,tobj},
verts={{0,0},{1,0},{.8,.9},{-.1,.7}};
tobj=RenderTile[{PolygonTwistTile,verts,.2,.2,90\[Degree],True,{M,M,V,V}},TGraphAssigned];
Print["Central polygon corner angle excess/\[Degree] = ",PolygonTwistCentralPolygonAnglesExcess[tobj]/\[Degree]];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
CenteredTwistAngle[w_,\[Tau]_]:=Mod[ArcTan[w Tan[\[Tau]]],\[Pi]]
CenteredTwistShrinkage[w_, \[Tau]_]:=\[Sqrt](((1+w^2)+(1-w^2) Cos[2 \[Tau]])/2)
CenteredTwistRotation[w_, \[Tau]_]:=ArcTan[((1-w)Sin[2\[Tau]])/((1+w)+(1-w)Cos[2\[Tau]])]
CenteredTwistTiltAngle[w_,\[Alpha]_]:=ArcTan[Tan[\[Alpha]]/w]
PolygonCenteredTwistTile::usage="PolygonCenteredTwistTile is a tile type that produces an edge-centered simple flat twist from parameters {w, \[Tau]} in a polygon.";
RenderTile[{PolygonCenteredTwistTile,verts_List,w_,\[Tau]_,types_List},TileVertices,opts___]:=verts
Module[{verts,w,\[Tau],types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Tau]=70\[Degree];
types={M,M,V,V};
RenderTile[{PolygonCenteredTwistTile,verts,w,\[Tau],types},TileVertices]
]//ShowExample
RenderTile[{PolygonCenteredTwistTile,verts_List,w_,\[Tau]_,types_List},Tiling,opts___]:=Module[{edgedirs},
TileCheckTypes[verts,types];
edgedirs=If[#===M,+1,-1]&/@types;
RenderTile[{PolygonTile,verts},Tiling,TileEdgeArrowDirs->edgedirs,opts]]
Module[{verts,w,\[Tau],types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Tau]=70\[Degree];
types={M,M,V,V};
GraphicsRow[{Graphics[RenderTile[{PolygonCenteredTwistTile,verts,w,\[Tau],types},Tiling]],Graphics[RenderTile[{PolygonCenteredTwistTile,verts,w,\[Tau],types},Tiling,TileEdgeArrowStyle->TileArrowCF]]}]/.TilingStyle[]
]//ShowExample
RenderTile[{PolygonCenteredTwistTile,verts_List, w_, \[Tau]_,types_List},TGraphAssigned,opts___]:=RenderTile[{PolygonTwistTile,verts,w,0,\[Tau],\[Tau]<\[Pi]/2,types},TGraphAssigned,opts]
Module[{tobj},
tobj=RenderTile[{PolygonCenteredTwistTile,{{0,0},{1,0},{1/2,1}},.2,70\[Degree] ,{M,M,M}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonCenteredTwistTile,UnitRegularPolygonVertices[4],.2,70\[Degree] ,{M,M,M,V}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonCenteredTwistTile,UnitRegularPolygonVertices[5],.2,70\[Degree] ,{M,M,M,V,V}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
RenderTile[{PolygonCenteredTwistTile,verts_List, w_, \[Tau]_,types_List},TGraph2DAssigned,opts___] := RenderTile[{PolygonTwistTile,verts,w,0,\[Tau],\[Tau]<\[Pi]/2,types},TGraph2DAssigned,opts]
Module[{tobj},
tobj=RenderTile[{PolygonCenteredTwistTile,UnitRegularPolygonVertices[4],.2,70.\[Degree] ,{M,M,M,V}},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,\[Tau],types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Tau]=70\[Degree];
types={M,M,V,V};
GraphicsRow[{
Graphics[RenderTile[{PolygonCenteredTwistTile,verts,w,\[Tau],types},CreasePattern]],Graphics[RenderTile[{PolygonCenteredTwistTile,verts,w,\[Tau],types},FoldedForm2D]]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,\[Tau],types,tiling},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Tau]=70\[Degree];
types={M,M,V,V};
tiling={
{{PolygonCenteredTwistTile,verts,w,\[Tau],types}},
{{PolygonCenteredTwistTile,verts,w,\[Tau],types},{0,1}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
PolygonCenteredTwistAltTile::usage="PolygonCenteredTwistAlt is a tile type that produces an edge-centered simple flat twist from parameters {w, \[Alpha]} in a polygon.";
RenderTile[{PolygonCenteredTwistAltTile,verts_List, w_, \[Alpha]_,types_List},decoration_,opts___]:=RenderTile[{PolygonCenteredTwistTile,verts,w,CenteredTwistTiltAngle[w,\[Alpha]],types},decoration,opts]
Module[{verts,w,\[Alpha],types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Alpha]=30\[Degree];
types={M,M,V,V};
RenderTile[{PolygonCenteredTwistAltTile,verts,w,\[Alpha],types},TileVertices]
]//ShowExample
Module[{verts,w,\[Alpha],types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Alpha]=30\[Degree];
types={M,M,V,V};
GraphicsRow[{Graphics[RenderTile[{PolygonCenteredTwistAltTile,verts,w,\[Alpha],types},Tiling]],Graphics[RenderTile[{PolygonCenteredTwistAltTile,verts,w,\[Alpha],types},Tiling,TileEdgeArrowStyle->TileArrowDF]]}]/.TilingStyle[]
]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonCenteredTwistAltTile,{{0,0},{1,0},{1/2,1}},.2,30\[Degree] ,{M,M,M}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonCenteredTwistAltTile,UnitRegularPolygonVertices[4],.2,30\[Degree] ,{M,M,M,V}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonCenteredTwistAltTile,UnitRegularPolygonVertices[5],.2,30\[Degree] ,{M,M,M,V,V}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonCenteredTwistAltTile,UnitRegularPolygonVertices[4],.2,30\[Degree] ,{M,M,M,V}},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,\[Alpha],types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Alpha]=30\[Degree];
types={M,M,V,V};
GraphicsRow[{Graphics[RenderTile[{PolygonCenteredTwistAltTile,verts,w,\[Alpha],types},CreasePattern]],Graphics[RenderTile[{PolygonCenteredTwistAltTile,verts,w,\[Alpha],types},FoldedForm2D]]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,\[Alpha],types,tiling},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Alpha]=30\[Degree];
types={M,M,V,V};
tiling={
{{PolygonCenteredTwistAltTile,verts,w,\[Alpha],types}},
{{PolygonCenteredTwistAltTile,verts,w,\[Alpha],types},{0,1}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
PolygonOffsetTwistTile::usage="PolygonOffsetTwistTile is a tile type that produces an offset simple flat twist from parameters {w, d} in a polygon.";
RenderTile[{PolygonOffsetTwistTile,verts_List,w_,d_,types_List},TileVertices,opts___]:=verts
Module[{verts,w,d,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=0.1;
types={M,M,V,V};
RenderTile[{PolygonOffsetTwistTile,verts,w,d,types},TileVertices]
]//ShowExample
RenderTile[{PolygonOffsetTwistTile,verts_List,w_,d_,types_List},Tiling,opts___]:=Module[{polyfill,edgedirs},
TileCheckTypes[verts,types];
polyfill=If[Length[Union[types]]>=2,TilingMedFill,
(* cyclic *)
If[d>0&&types[[1]]===M||d<0&&types[[1]]===V,TilingDarkFill,TilingLightFill]];
edgedirs=Sign[d](If[#===M,+1,-1]&/@types);
RenderTile[{PolygonTile,verts},Tiling,TilePolyFill->polyfill,TileEdgeArrowDirs->edgedirs,opts]]
Module[{verts,w,d,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=0.1;
types={M,M,V,V};
GraphicsRow[{Graphics[RenderTile[{PolygonOffsetTwistTile,verts,w,d,types},Tiling]],Graphics[RenderTile[{PolygonOffsetTwistTile,verts,w,d,types},Tiling,TilePolys->True, TileEdgeArrowStyle->TileArrowDF]]}]/.TilingStyle[]
]//ShowExample
RenderTile[{PolygonOffsetTwistTile,verts_List, w_, d_,types_List},TGraphAssigned,opts___] := RenderTile[{PolygonTwistTile,verts,w,d,\[Pi]/2,d>0,types},TGraphAssigned,opts]
Module[{tobj},
tobj=RenderTile[{PolygonOffsetTwistTile,{{0,0},{1,0},{0.3,0.6}},.1,.05 ,{M,M,M}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonOffsetTwistTile,UnitRegularPolygonVertices[4],.2,.1 ,{M,M,M,V}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonOffsetTwistTile,UnitRegularPolygonVertices[5],.2,.1,{M,M,M,V,V}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj},
tobj=RenderTile[{PolygonOffsetTwistTile,{{0,0},{1.5,0},{1.5,1},{0,1}},.25,.1 ,{M,M,M,M}},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}
]/.OrigamiStyle[]
]//ShowExample
RenderTile[{PolygonOffsetTwistTile,verts_List, w_, d_,types_List},TGraph2DAssigned,opts___] := RenderTile[{PolygonTwistTile,verts,w,d,\[Pi]/2,d>0,types},TGraph2DAssigned,opts]
Module[{tobj},
tobj=RenderTile[{PolygonOffsetTwistTile,UnitRegularPolygonVertices[4],.1,.1 ,{M,M,M,V}},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,d,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=0.15;
types={M,M,V,V};
GraphicsRow[{Graphics[RenderTile[{PolygonOffsetTwistTile,verts,w,d,types},CreasePattern]],Graphics[RenderTile[{PolygonOffsetTwistTile,verts,w,d,types},FoldedForm2D]]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,d,types1,types2,tiling},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=0.15;
types1={V,V,V,V};
types2={V,V,V,V};
tiling={
{{PolygonOffsetTwistTile,verts,w,d,types1}},
{{PolygonOffsetTwistTile,verts,w,-d,types2},{0,1}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
QuadrilateralSplitTwistTile::usage="QuadrilateralSplitTwistTile is a tile type that produces a split twist in a quadrilateral.";
QuadrilateralSplitTwistTile::badtypes="Length `1` of vertex list `2` and length `3` of types list `4` do not match.";
RenderTile[{QuadrilateralSplitTwistTile,verts_List,w_,d_,\[Tau]_,ccw_,ip_,ctype_,types_List},TileVertices,opts___]:=Module[{},
If[Length[verts]!=Length[types],Message[QuadrilateralSplitTwistTile::badtypes,Length[verts],verts,Length[types],types];Abort[]];
verts]
Module[{verts,w,d,\[Tau],ccw,ip,ctype,types},
verts={{0,0},{1,0},{1.1,1.2},{-0.2,1.0}};
w=0.2;
d=0.1;
\[Tau]=70\[Degree];
ccw=True;
ip=1;
ctype=M;
types={M,M,V,V};
RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,\[Tau],ccw,ip,ctype,types},TileVertices]
]//ShowExample
RenderTile[{QuadrilateralSplitTwistTile,verts_List,w_,d_,\[Tau]_,ccw_,ip_,ctype_,types_List},Tiling,opts___]:=RenderTile[{PolygonTile,verts},Tiling,opts]
Module[{verts,w,d,\[Tau],ccw,ip,ctype,types},
verts={{0,0},{1,0},{1.1,1.2},{-0.2,1.0}};
w=0.2;
d=0.1;
\[Tau]=70\[Degree];
ccw=True;
ip=1;
ctype=M;
types={M,M,V,V};
Graphics[RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,\[Tau],ccw,ip,ctype,types},Tiling]]/.TilingStyle[]
]//ShowExample
QuadrilateralSplitTwistTile::badsize="Vertex list `1` is not length 4.";
QuadrilateralSplitTwistTile::badip="The specified vertex `1`'s Kawasaki excess `2` is not positive.";
RenderTile[{QuadrilateralSplitTwistTile,verts_List, w_,d_, \[Tau]_,ccw_,ip_,ctype_,types_List},TGraphAssigned,opts___] := Module[{n,tobj,tae,ta,sta,vfn,efn,v,e,f,t,\[Alpha]l,\[Alpha]r,vil,vir,vib,vb,pdir,vl,vr,en},
n=Length[verts];
If[n!=4,Message[QuadrilateralSplitTwistTile::badsize,verts];Abort[]];
tobj=RenderTile[{PolygonTwistTile,verts,w,d,\[Tau],ccw,types},TGraphAssigned];
tae=PolygonTwistCentralPolygonAnglesExcess[tobj];
If[tae[[ip]]<=0,Message[QuadrilateralSplitTwistTile::badip,ip,tae[[ip]]];Abort[]]//Hold;
ta=PolygonTwistTwistAngles[tobj];
(* gets vertex index based on rotational position i *)
vfn[i_,j_]:=Mod[4i+j,16,1];(* gets edge index based on rotational position i *)
efn[i_,j_]:=Mod[6(i-1)+j,24,1];{v,e,f,t}=GetValues[tobj,{Vertices,Edges,Faces,EdgeTypes}];
{\[Alpha]l,\[Alpha]r}=ta[[Mod[{ip-1,ip},4,1]]];(* preceding and following twist angles *)
ta[[Mod[{ip-2,ip+1},4,1]]]={\[Alpha]l,\[Alpha]r};(* new split twist angles *)
vil=vfn[ip+2,0];(* index of vertex to split, will become left vertex *)
AppendTo[v,v[[vil]]];(* the new vertex, will become right vertex *)
vir=Length[v];(* index of the right vertex *)
vib=vfn[ip,0];(* index of the base (degree-6) vertex *)
vb=v[[vib]];(* coordinates of the base (degree-6) vertex *)
(* compute location of altered vertices *)
pdir=(v[[vfn[ip+2,0]]]-v[[vfn[ip+2,-2]]]);(* direction of one altered pleat *)
vl=LineInt2D[v[[vfn[ip-1,0]]],RotationMatrix2D[-\[Alpha]l] . pdir,v[[vil]],pdir];(* first new vertex *)
pdir=(v[[vfn[ip+1,0]]]-v[[vfn[ip+1,-2]]]);(* direction of other altered pleat *)
vr=LineInt2D[v[[vfn[ip+1,0]]],RotationMatrix2D[\[Pi]-\[Alpha]r] . pdir,v[[vil]],pdir];(* second new vertex *)
(* put them into our vertex array *)
v[[vil]]=vl;
v[[vir]]=vr;
(* move some edges to new vertices *)
e[[efn[ip+1,6]]]={vfn[ip+1,0],vir};
e[[efn[ip+1,5]]]={vfn[ip+1,-1],vir};
(* add some new edges *)
en=1+Length[e];(* index where new edges start *)
AppendTo[e,{vib,vil}];(* crossing edge *)
AppendTo[e,{vib,vir}];
AppendTo[e,{vil,vir}];
(* set crease types at top of pleats. *)
Do[If[ccw\[Xor]Mod[ta[[i]],\[Pi],-\[Pi]/2]>0,t[[efn[i,2]]]=InvertFoldType[t[[efn[i,2]]]]],{i,4}];
(* set crease types for 3 new creases (left, right, connecting) *)
AppendTo[t,If[\[Alpha]l<\[Pi]/2,InvertFoldType[ctype],ctype]];
AppendTo[t,If[\[Alpha]r<\[Pi]/2,ctype,InvertFoldType[ctype]]];
AppendTo[t,ctype];
(* move some faces to new vertices *)
f[[1]]={vib,vfn[ip+1,0],vir};
f[[Mod[ip+2,4,2]]]={vfn[ip+1,-2],vfn[ip+1,-1],vir,vfn[ip+1,0]};
f[[Mod[ip+7,4,6]]]={vfn[ip+2,-3],vfn[ip+2,-2],vil,vir,vfn[ip+1,-1]};
(* add some new faces *)
AppendTo[f,{vib,vir,vil}];
AppendTo[f,{vib,vil,vfn[ip-1,0]}];
(* stuff everything back into the graph and return it. *)
tobj//ReplaceProperties[{Vertices->v,Edges->e,Faces->f,EdgeTypes->t}]]
Module[{verts,w,d,\[Tau],ccw,ip,ctype,types,tobj},
verts={{0,0},{1,0},{1.1,1.4},{-0.2,1.0}};
w=0.15;
d=0;
\[Tau]=70\[Degree];
ccw=\[Tau]<\[Pi]/2;
ip=2;
ctype=M;
types={M,M,V,V};
tobj=RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,\[Tau],ccw,ip,ctype,types},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]]
Module[{verts,w,d,\[Tau],ccw,ip,ctype,types,tobj},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.14;
d=-.12;
\[Tau]=90\[Degree];
ccw=d>0;
ip=1;
ctype=M;
types={M,M,V,V};
tobj=RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,\[Tau],ccw,ip,ctype,types},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,d,\[Tau],ccw,ip,ctype,types,tobj},
verts=UnitQuadrilateralVertices[{60\[Degree],90\[Degree],90\[Degree],120\[Degree]},.811,4];
w=0.12;
d=0;
\[Tau]=80\[Degree];
ccw=\[Tau]<90\[Degree];
ip=2;
ctype=M;
types={M,V,V,M};
tobj=RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,\[Tau],ccw,ip,ctype,types},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{O,A,B,C,P,Pp,Ap,Bp,\[Tau]p,soln,ex},
O={0,0};
A={(1-w)/2+d,0};
B={(1+w)/2+d,0};
P={1,0};
C=B+2 w Sin[\[Tau]] {-Sin[\[Tau]],Cos[\[Tau]]};
Pp=P+2 w Sin[\[Tau]] {-Sin[\[Tau]],Cos[\[Tau]]};
Ap=LineInt2D[O,Pp-O,A,U[\[Tau]]];
Bp=LineInt2D[O,Pp-O,C,U[\[Tau]]];
(* equivalent tilt angle for folded form *)
\[Tau]p=FullSimplify[ArcTan[U[\[Tau]-\[Pi]/2] . (Pp-O)/U[\[Tau]] . (Pp-O)]];
Print["\[Tau]' = ",\[Tau]p];
soln=FullSimplify[Solve[{(1-wp)/2+dp==(Ap-O)[[1]]/(Pp-O)[[1]],(1+wp)/2+dp==(Bp-O)[[1]]/(Pp-O)[[1]]},{wp,dp}]];
Print["w' = ",wp/.soln[[1]],", d' = ",dp/.soln[[1]]];
(* and show a plot of the geometry *)
ex={w->0.15,d->-0.08,\[Tau]->70\[Degree]};
Graphics[{
Black,Line[{O,P}],
Gray,Line[{A,A+.5U[\[Tau]]}],Line[{B,B+.5U[\[Tau]]}],Line[{C,C+.5U[\[Tau]]}],
Orange,Line[{O,Pp}],
Green,Line[{A,C,Pp}],
LightGray,Line[{B,C}],Line[{P,Pp}],Line[{C-.1U[\[Tau]],C}],
Black,
Point[O],Text["O",O,{2,0}],
Point[A],Text["A",A,{0,2}],
Point[B],Text["B",B,{0,2}],
Point[C],Text["C",C,{0,-2}],
Point[P],Text["P",P,{-2,0}],
Point[Pp],Text["P'",Pp,{-2,0}],
Point[Ap],Text["A'",Ap,{0,-2}],
Point[Bp],Text["B'",Bp,{1,-2}],
{}}]/.ex
]//ShowExample
RenderTile[{QuadrilateralSplitTwistTile,verts_List, w_,d_, \[Tau]_,ccw_,ip_,ctype_,types_List},TGraph2DAssigned,opts___] := Module[{tobjcp,tobjff},
tobjcp=RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,\[Tau],ccw,ip,ctype,types},TGraphAssigned,opts];
tobjff=RenderTile[{QuadrilateralSplitTwistTile,verts,(-w)/(1-2w), d/(1-2 w),ArcCot[Cot[\[Tau]]/(1-2w)],ccw,ip,ctype,types},TGraphAssigned,opts];
tobjcp//AddTGraph2D[tobjff[Vertices]]]
Module[{verts,w,d,\[Tau],ccw,ip,ctype,types,tobj},
verts={{0,0},{1,0},{1.1,1.4},{-0.2,1.0}};
w=0.15;
d=0;
\[Tau]=70\[Degree];
ccw=\[Tau]<\[Pi]/2;
ip=2;
ctype=M;
types={M,M,V,V};
tobj=RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,\[Tau],ccw,ip,ctype,types},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,d,\[Tau],ccw,ip,ctype,types,tobj},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.14;
d=.12;
\[Tau]=90\[Degree];
ccw=d>0;
ip=1;
ctype=V;
types={M,M,V,M};
tobj=RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,\[Tau],ccw,ip,ctype,types},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
QuadrilateralCenteredSplitTwistTile::usage="QuadrilateralCenteredSplitTwistTile is a tile type that produces an edge-centered split twist from parameters {w, \[Tau]} in a polygon.";
RenderTile[{QuadrilateralCenteredSplitTwistTile,verts_List,w_,\[Tau]_,ip_,ctype_,types_List},TileVertices,opts___]:=verts
Module[{verts,w,\[Tau],ip,ctype,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Tau]=70\[Degree];
ip=2;
ctype=M;
types={M,M,V,V};
RenderTile[{QuadrilateralCenteredSplitTwistTile,verts,w,\[Tau],ip,ctype,types},TileVertices]
]//ShowExample
RenderTile[{QuadrilateralCenteredSplitTwistTile,verts_List,w_,\[Tau]_,ip_,ctype_,types_List},Tiling,opts___]:=RenderTile[{PolygonCenteredTwistTile,verts,w,\[Tau],types},Tiling,opts]
Module[{verts,w,\[Tau],ip,ctype,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Tau]=70\[Degree];
ip=2;
ctype=M;
types={M,M,V,V};
Graphics[RenderTile[{QuadrilateralCenteredSplitTwistTile,verts,w,\[Tau],ip,ctype,types},Tiling,TileEdgeArrowStyle->TileArrowCF]]/.TilingStyle[]
]//ShowExample
RenderTile[{QuadrilateralCenteredSplitTwistTile,verts_List, w_, \[Tau]_,ip_,ctype_,types_List},TGraphAssigned,opts___]:=RenderTile[{QuadrilateralSplitTwistTile,verts,w,0,\[Tau],\[Tau]<\[Pi]/2,ip,ctype,types},TGraphAssigned,opts]
Module[{tobj,verts,w,\[Tau],ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
\[Tau]=75\[Degree];
ip=1;
ctype=M;
types={M,M,M,M};
tobj=RenderTile[{QuadrilateralCenteredSplitTwistTile,verts,w,\[Tau],ip,ctype,types},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
RenderTile[{QuadrilateralCenteredSplitTwistTile,verts_List, w_, \[Tau]_,ip_,ctype_,types_List},TGraph2DAssigned,opts___]:=RenderTile[{QuadrilateralSplitTwistTile,verts,w,0,\[Tau],\[Tau]<\[Pi]/2,ip,ctype,types},TGraph2DAssigned,opts]
Module[{tobj,verts,w,\[Tau],ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
\[Tau]=75\[Degree];
ip=1;
ctype=M;
types={M,M,M,M};
tobj=RenderTile[{QuadrilateralCenteredSplitTwistTile,verts,w,\[Tau],ip,ctype,types},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj,verts,w,\[Tau],ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
\[Tau]=75\[Degree];
ip=1;
ctype=M;
types={M,M,M,M};
GraphicsRow[{Graphics[RenderTile[{QuadrilateralCenteredSplitTwistTile,verts,w,\[Tau],ip,ctype,types},CreasePattern]],Graphics[RenderTile[{QuadrilateralCenteredSplitTwistTile,verts,w,\[Tau],ip,ctype,types},FoldedForm2D]]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,\[Tau],ip,ctype,types,tiling},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
\[Tau]=75\[Degree];
ip=1;
ctype=M;
types={M,M,V,V};
tiling=JoinTiling[{
{{QuadrilateralCenteredSplitTwistTile,verts,w,\[Tau],ip,ctype,types}},
{{QuadrilateralCenteredSplitTwistTile,verts,w,\[Tau],ip,ctype,types},{1,3,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
QuadrilateralCenteredSplitTwistAltTile::usage="QuadrilateralCenteredSplitTwistAltTile is a tile type that produces an edge-centered split twist from parameters {w, \[Alpha]} in a polygon.";
RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts_List,w_,\[Alpha]_,ip_,ctype_,types_List},TileVertices,opts___]:=verts
Module[{verts,w,\[Alpha],ip,ctype,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Alpha]=25\[Degree];
ip=2;
ctype=M;
types={M,M,V,V};
RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts,w,\[Alpha],ip,ctype,types},TileVertices]
]//ShowExample
RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts_List,w_,\[Alpha]_,ip_,ctype_,types_List},Tiling,opts___]:=RenderTile[{PolygonCenteredTwistAltTile,verts,w,\[Alpha],types},Tiling,opts]
Module[{verts,w,\[Alpha],ip,ctype,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
\[Alpha]=70\[Degree];
ip=2;
ctype=M;
types={M,M,V,V};
Graphics[RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts,w,\[Alpha],ip,ctype,types},Tiling,TileEdgeArrowStyle->TileArrowCF]]/.TilingStyle[]
]//ShowExample
RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts_List, w_, \[Alpha]_,ip_,ctype_,types_List},TGraphAssigned,opts___]:=RenderTile[{QuadrilateralSplitTwistTile,verts,w,0,CenteredTwistTiltAngle[w,\[Alpha]],\[Alpha]<\[Pi]/2,ip,ctype,types},TGraphAssigned,opts]
Module[{tobj,verts,w,\[Alpha],ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
\[Alpha]=30\[Degree];
ip=1;
ctype=M;
types={M,M,M,M};
tobj=RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts,w,\[Alpha],ip,ctype,types},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts_List, w_, \[Alpha]_,ip_,ctype_,types_List},TGraph2DAssigned,opts___]:=RenderTile[{QuadrilateralSplitTwistTile,verts,w,0,CenteredTwistTiltAngle[w,\[Alpha]],\[Alpha]<\[Pi]/2,ip,ctype,types},TGraph2DAssigned,opts]
Module[{tobj,verts,w,\[Alpha],ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
\[Alpha]=30\[Degree];
ip=1;
ctype=M;
types={M,M,M,M};
tobj=RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts,w,\[Alpha],ip,ctype,types},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj,verts,w,\[Alpha],ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
\[Alpha]=30\[Degree];
ip=1;
ctype=M;
types={M,M,M,M};
GraphicsRow[{Graphics[RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts,w,\[Alpha],ip,ctype,types},CreasePattern]],Graphics[RenderTile[{QuadrilateralCenteredSplitTwistAltTile,verts,w,\[Alpha],ip,ctype,types},FoldedForm2D]]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,\[Alpha],ip,ctype,types,tiling},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
\[Alpha]=30\[Degree];
ip=1;
ctype=M;
types={M,M,V,V};
tiling=JoinTiling[{
{{QuadrilateralCenteredSplitTwistAltTile,verts,w,\[Alpha],ip,ctype,types}},
{{QuadrilateralCenteredSplitTwistAltTile,verts,w,\[Alpha],ip,ctype,types},{1,3,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
QuadrilateralOffsetSplitTwistTile::usage="QuadrilateralOffsetSplitTwistTile is a tile type that produces an offset split twist from parameters {w, d} in a polygon.";
RenderTile[{QuadrilateralOffsetSplitTwistTile,verts_List,w_,d_,ip_,ctype_,types_List},TileVertices,opts___]:=verts
Module[{verts,w,d,ip,ctype,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=0.1;
ip=2;
ctype=M;
types={M,M,V,V};
RenderTile[{QuadrilateralOffsetSplitTwistTile,verts,w,d,ip,ctype,types},TileVertices]
]//ShowExample
RenderTile[{QuadrilateralOffsetSplitTwistTile,verts_List,w_,d_,ip_,ctype_,types_List},Tiling,opts___]:=RenderTile[{PolygonOffsetTwistTile,verts,w,d,types},Tiling,opts]
Module[{verts,w,d,ip,ctype,types},
verts=UnitRegularPolygonVertices[4];
w=0.2;
d=70\[Degree];
ip=2;
ctype=M;
types={M,M,V,V};
Graphics[RenderTile[{QuadrilateralOffsetSplitTwistTile,verts,w,d,ip,ctype,types},Tiling,TilePolys->True, TileEdgeArrowStyle->TileArrowDF]]/.TilingStyle[]
]//ShowExample
RenderTile[{QuadrilateralOffsetSplitTwistTile,verts_List, w_, d_,ip_,ctype_,types_List},TGraphAssigned,opts___]:=RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,90\[Degree],d>0,ip,ctype,types},TGraphAssigned,opts]
Module[{tobj,verts,w,d,ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
d=0.1;
ip=1;
ctype=M;
types={M,M,M,M};
tobj=RenderTile[{QuadrilateralOffsetSplitTwistTile,verts,w,d,ip,ctype,types},TGraphAssigned];
GraphicsRow[{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}]]/.OrigamiStyle[]//ShowExample
RenderTile[{QuadrilateralOffsetSplitTwistTile,verts_List, w_, d_,ip_,ctype_,types_List},TGraph2DAssigned,opts___]:=RenderTile[{QuadrilateralSplitTwistTile,verts,w,d,90\[Degree],d>0,ip,ctype,types},TGraph2DAssigned,opts]
Module[{tobj,verts,w,d,ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
d=0.1;
ip=1;
ctype=M;
types={M,M,M,M};
tobj=RenderTile[{QuadrilateralOffsetSplitTwistTile,verts,w,d,ip,ctype,types},TGraph2DAssigned];
GraphicsGrid[{{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]},{
Graph2DGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj,verts,w,d,ip,ctype,types},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
d=0.1;
ip=1;
ctype=M;
types={M,M,M,M};
GraphicsRow[{Graphics[RenderTile[{QuadrilateralOffsetSplitTwistTile,verts,w,d,ip,ctype,types},CreasePattern]],Graphics[RenderTile[{QuadrilateralOffsetSplitTwistTile,verts,w,d,ip,ctype,types},FoldedForm2D]]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,d,ip,ctype,types,tiling},
verts={{0,0},{1,0},{.9,.8},{.2,1}};
w=0.2;
d=0.1;
ip=1;
ctype=M;
types={M,M,M,M};
tiling=JoinTiling[{
{{QuadrilateralOffsetSplitTwistTile,verts,w,d,ip,ctype,types}},
{{QuadrilateralOffsetSplitTwistTile,verts,w,-d,ip,ctype,types},{1,3,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{verts,w,d,ip,ctype,types,tiling},
verts={{0,0},{1,0},{1,1/\[Sqrt]2},{0,1/\[Sqrt]2}};
w=0.2;
d=0.12;
ip=1;
ctype=V;
types={V,V,V,V};
tiling=JoinTiling[{
{{QuadrilateralOffsetSplitTwistTile,verts,w,d,1,ctype,types}},
{{QuadrilateralOffsetSplitTwistTile,verts,w,-d,4,ctype,types},{1,3,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
MonolithicEmbedTiling::baddec="`1` is an invalid decoration for MonolithicEmbedTiling.";
CollinearCleanup::usage="CollinearCleanup is an option to MonolithicEmbedTiling that specifies whether to remove degree-2 vertices between collinear edges.";
Options[MonolithicEmbedTiling]={
KillMergedEdges->True,
CollinearCleanup->True
};
MonolithicEmbedTiling[tiling_List,decoration_,opts___]:=(Message[MonolithicEmbedTiling::baddec,decoration];Abort[]);
MonolithicEmbedTiling[tiling_List,TGraphAssigned,opts___]:=Module[{cc,kme,tlist,tobj},
kme=KillMergedEdges/.{opts}/.Options[MonolithicEmbedTiling];
cc=CollinearCleanup/.{opts}/.Options[MonolithicEmbedTiling];
tlist=EmbedTiling[tiling,TGraphAssigned];
tobj=MergeGraphAssigneds[tlist,KillMergedEdges->kme,opts];
If[cc,tobj=CollinearCleanupGraphAssigned[tobj]];
tobj//RebuildPlaneGraph]
Module[{w,\[Alpha],name,verts,tiling,tobj,tobj1},
w=0.18;
\[Alpha]=30\[Degree];
name=PolygonCenteredTwistAltTile;
verts=UnitRegularPolygonVertices[4];
tiling=JoinTiling[{
{{name,verts,w,\[Alpha],{V,V,V,V}}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,2,1}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,3,2}},
{{name,verts,w,\[Alpha],{V,V,V,V}},{2,3,2}}
}];
tobj=MonolithicEmbedTiling[tiling,TGraphAssigned];
GraphicsGrid[{{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]]},{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
MonolithicEmbedTiling[tiling_List,TGraph2DAssigned,opts___]:=Module[{cc,kme,tlist,tobj},
kme=KillMergedEdges/.{opts}/.Options[MonolithicEmbedTiling];
cc=CollinearCleanup/.{opts}/.Options[MonolithicEmbedTiling];
tlist=EmbedTiling[tiling,TGraph2DAssigned];
tobj=MergeGraph2DAssigneds[tlist,KillMergedEdges->kme,opts];
If[cc,tobj=CollinearCleanupGraph2DAssigned[tobj]];
tobj=tobj//RebuildPlaneGraph;
FoldGraph2D[tobj,TypeToFlatFoldAngle[tobj[EdgeTypes]],opts]]
Module[{w,\[Alpha],name,verts,tiling,tobj,tobj1},
w=0.18;
\[Alpha]=30\[Degree];
name=PolygonCenteredTwistAltTile;
verts=UnitRegularPolygonVertices[4];
tiling=JoinTiling[{
{{name,verts,w,\[Alpha],{V,V,V,V}}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,2,1}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,3,2}},
{{name,verts,w,\[Alpha],{V,V,V,V}},{2,3,2}}
}];
tobj=MonolithicEmbedTiling[tiling,TGraph2DAssigned];
GraphicsGrid[{{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]],Graphics[EmbedTiling[tiling,FoldedForm2D]]},{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj]}}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
MonolithicTGraph::usage="MonolithicTGraph is a type of tile decoration that renders the full tiling as a single TGraph.";
MonolithicTGraph2D::usage="MonolithicTGraph2D is a type of tile decoration that renders the full tiling as a single TGraph2D.";
MonolithicCreasePattern::usage="MonolithicCreasePattern is a type of tile decoration that renders the full tiling as a single crease pattern.";
MonolithicFoldedForm::usage="MonolithicFoldedForm is a type of tile decoration that renders the full tiling as a single folded form.";
EmbedTiling[tiling_List,MonolithicTGraph,opts___]:=MonolithicEmbedTiling[tiling,TGraphAssigned,opts]
Module[{w,\[Alpha],name,verts,tiling,tobj},
w=0.18;
\[Alpha]=30\[Degree];
name=PolygonCenteredTwistAltTile;
verts=UnitRegularPolygonVertices[4];
tiling=JoinTiling[{
{{name,verts,w,\[Alpha],{V,V,V,V}}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,2,1}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,3,2}},
{{name,verts,w,\[Alpha],{V,V,V,V}},{2,3,2}}
}];
tobj=EmbedTiling[tiling,MonolithicTGraph];
GraphicsGrid[{{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]]},{
GraphGraphics[tobj],
CreasePatternGraphics[tobj]}}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
EmbedTiling[tiling_List,MonolithicTGraph2D,opts___]:=MonolithicEmbedTiling[tiling,TGraph2DAssigned,opts]
Module[{w,\[Alpha],name,verts,tiling,tobj},
w=0.18;
\[Alpha]=30\[Degree];
name=PolygonCenteredTwistAltTile;
verts=UnitRegularPolygonVertices[4];
tiling=JoinTiling[{
{{name,verts,w,\[Alpha],{V,V,V,V}}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,2,1}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,3,2}},
{{name,verts,w,\[Alpha],{V,V,V,V}},{2,3,2}}
}];
tobj=EmbedTiling[tiling,MonolithicTGraph2D,StationaryFace->3];
GraphicsGrid[{{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]},{
GraphGraphics[tobj],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->3]}}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
EmbedTiling[tiling_List,MonolithicCreasePattern,opts___]:=CreasePatternGraphics[EmbedTiling[tiling,MonolithicTGraph,opts]]
Module[{w,\[Alpha],name,verts,tiling,tobj},
w=0.18;
\[Alpha]=30\[Degree];
name=PolygonCenteredTwistAltTile;
verts=UnitRegularPolygonVertices[4];
tiling=JoinTiling[{
{{name,verts,w,\[Alpha],{V,V,V,V}}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,2,1}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,3,2}},
{{name,verts,w,\[Alpha],{V,V,V,V}},{2,3,2}}
}];
tobj=EmbedTiling[tiling,MonolithicTGraph];
GraphicsGrid[{{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]]},{
GraphGraphics[tobj],
Graphics[EmbedTiling[tiling,MonolithicCreasePattern]]}}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
EmbedTiling[tiling_List,MonolithicFoldedForm,opts___]:=VisibleFoldedFormGraphics[EmbedTiling[tiling,MonolithicTGraph2D,opts],opts]
Module[{w,\[Alpha],name,verts,tiling,tobj},
w=0.18;
\[Alpha]=30\[Degree];
name=PolygonCenteredTwistAltTile;
verts=UnitRegularPolygonVertices[4];
tiling=JoinTiling[{
{{name,verts,w,\[Alpha],{V,V,V,V}}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,2,1}},
{{name,verts,w,\[Alpha],{M,M,M,M}},{1,3,2}},
{{name,verts,w,\[Alpha],{V,V,V,V}},{2,3,2}}
}];
tobj=EmbedTiling[tiling,MonolithicTGraph2D,StationaryFace->3];
GraphicsGrid[{{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]},{
GraphGraphics[tobj],
Graphics[EmbedTiling[tiling,MonolithicCreasePattern]],
Graphics[EmbedTiling[tiling,MonolithicFoldedForm,StationaryFace->3,FaceupFace->3]]}}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitRegularPolygonTile::usage="UnitRegularPolygonTile is a tile type that produces a unit regular polygon.";
RenderTile[{UnitRegularPolygonTile, n_},decoration_,opts___]:=RenderTile[{PolygonTile,UnitRegularPolygonVertices[n]},decoration,opts]
Graphics[RenderTile[{UnitRegularPolygonTile,5},Tiling]]/.TilingStyle[]//ShowExample
UnitRegularPolygonCenteredTwistSelfContainedQ[n_,w_,\[Tau]_,types_List]:=RegularPolygonTwistValidQ[n,CenteredTwistAngle[w,\[Tau]],types]&&Abs[Tan[\[Tau]]]>Tan[\[Pi]/n]/(1-2w);
UnitRegularPolygonCenteredTwistSelfContainedTypes[n_,w_,\[Tau]_]:=Select[AllCyclicTwistTypes[n],UnitRegularPolygonCenteredTwistSelfContainedQ[n,w,\[Tau],#]&]
UnitRegularPolygonCenteredTwistTile::usage="UnitRegularPolygonCenteredTwistTile is a tile type that produces an edge-centered simple flat twist from parameters {w, \[Tau]} in a regular unit polygon.";
RenderTile[{UnitRegularPolygonCenteredTwistTile,n_,w_,\[Tau]_,types_List},decoration_,opts___]:=RenderTile[{PolygonCenteredTwistTile,UnitRegularPolygonVertices[n],w,\[Tau],types},decoration,opts]
Module[{n,w,\[Tau],types,tiling},
n=4;
w=0.2;
\[Tau]=70\[Degree];
types={M,M,V,V};
tiling={
{{UnitRegularPolygonCenteredTwistTile,n,w,\[Tau],types}},
{{UnitRegularPolygonCenteredTwistTile,n,w,\[Tau],types},{0,1}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitRegularPolygonCenteredTwistAltSelfContainedQ[n_,w_,\[Alpha]_,types_List]:=UnitRegularPolygonCenteredTwistSelfContainedQ[n,w,CenteredTwistTiltAngle[w,\[Alpha]],types]
UnitRegularPolygonCenteredTwistAltSelfContainedTypes[n_,w_,\[Alpha]_]:=Select[AllCyclicTwistTypes[n],UnitRegularPolygonCenteredTwistAltSelfContainedQ[n,w,\[Alpha],#]&]
UnitRegularPolygonCenteredTwistAltTile::usage="UnitRegularPolygonCenteredTwistAlt is a tile type that produces an edge-centered simple flat twist from parameters {w, \[Alpha]} in a regular unit polygon.";
RenderTile[{UnitRegularPolygonCenteredTwistAltTile,n_,w_,\[Alpha]_,types_List},decoration_,opts___]:=RenderTile[{PolygonCenteredTwistAltTile,UnitRegularPolygonVertices[n],w,\[Alpha],types},decoration,opts]
Module[{n,w,\[Alpha],types,tiling},
n=4;
w=0.2;
\[Alpha]=30\[Degree];
types={M,M,V,V};
tiling={
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types}},
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types},{0,1}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{c,v,r,s,q},
c=UnitRegularPolygonCenter[n];
v[i_]:=c-RotationMatrix2D[2\[Pi] (i-1)/n] . c;
r[i_]:=((1+w)/2-d)v[i]+((1-w)/2+d)v[i+1];
s[i_]:=((1-w)/2-d)v[i]+((1+w)/2+d)v[i+1];
q[i_]:=LineInt2D[s[i-1],U[2\[Pi] (i-2)/n+\[Pi]/2],r[i],U[2\[Pi] (i-1)/n+\[Pi]/2]];
Print["Twist angle = ",FullSimplify[ArcTan[w/(q[2]-q[1])[[2]]]]];
Print["Shrinkage = ",FullSimplify[Mag[q[2]-q[1]]]];
Print["Rotation = ",FullSimplify[ArcTan[(q[2]-q[1])[[2]]/w]]];
Graphics[{
Style[Line[{v[0],v[1],v[2],v[3]}],Black],
Style[{Line[{s[0],q[1],r[1]}],Line[{s[1],q[2],r[2]}]},Blue],
Style[Line[{q[0],q[1],q[2],q[3]}],Red]
},Frame->True]/.{n->5,w->0.2,d->0.1}
]//ShowExample
UnitRegularPolygonOffsetTwistAngle[n_,w_,d_]:=Mod[ArcTan[(w/(2d))Cot[\[Pi]/n]],\[Pi]]
UnitRegularPolygonOffsetTwistOffset[n_,w_,\[Alpha]_]:=(w/2)Cot[\[Pi]/n]Cot[\[Alpha]]
Module[{w,d,pts},
w=0.2;
d=0.2;
pts=Table[{n,UnitRegularPolygonOffsetTwistAngle[n,w,d]/\[Degree]},{n,3,12}];
ListPlot[pts,PlotRange->{{0,12},{0,90}},AxesLabel->{"n","\[Alpha]/\[Degree]"}]
]//ShowExample
UnitRegularPolygonOffsetTwistSelfContainedQ[n_,w_,d_,types_List]:=RegularPolygonTwistValidQ[n,UnitRegularPolygonOffsetTwistAngle[n,w,d],types]&&w<=(1/3)(1-2Abs[d]);
UnitRegularPolygonOffsetTwistAltSelfContainedQ[n_,w_,\[Alpha]_,types_List]:=UnitRegularPolygonOffsetTwistSelfContainedQ[n,w,UnitRegularPolygonOffsetTwistOffset[n,w,\[Alpha]],types]
UnitRegularPolygonOffsetTwistTile::usage="UnitRegularPolygonOffsetTwistTile is a tile type that produces an offset simple flat twist from parameters {w, d} in a regular unit polygon.";
RenderTile[{UnitRegularPolygonOffsetTwistTile,n_,w_,d_,types_List},decoration_,opts___]:=RenderTile[{PolygonOffsetTwistTile,UnitRegularPolygonVertices[n],w,d,types},decoration,opts]
Module[{n,w,d,types1,types2,tiling},
n=4;
w=0.2;
d=0.15;
types1={V,V,V,V};
types2={V,V,V,V};
tiling={
{{UnitRegularPolygonOffsetTwistTile,n,w,d,types1}},
{{UnitRegularPolygonOffsetTwistTile,n,w,-d,types2},{0,1}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitTriangleTile::usage="UnitRegularPolygonTile is a tile type that produces a unit triangle.";
RenderTile[{UnitTriangleTile, angles_},decoration_,opts___]:=RenderTile[{PolygonTile,UnitTriangleVertices[angles]},decoration,opts]
Graphics[RenderTile[{UnitTriangleTile,{50\[Degree],60\[Degree],70\[Degree]}},Tiling]]/.TilingStyle[]//ShowExample
UnitTriangleCenteredTwistTile::usage="UnitTriangleCenteredTwistTile is a tile type that produces an edge-centered simple flat twist from parameters {w, \[Tau]} in a unit triangle.";
RenderTile[{UnitTriangleCenteredTwistTile,angles_,w_,\[Tau]_,types_List},decoration_,opts___]:=RenderTile[{PolygonCenteredTwistTile,UnitTriangleVertices[angles],w,\[Tau],types},decoration,opts]
Module[{angles,w,\[Tau],types1,types2,tiling},
angles={50\[Degree],60\[Degree],70\[Degree]};
w=0.1;
\[Tau]=80\[Degree];
types1={M,M,M};
types2={V,V,V};
tiling=JoinTiling[{
{{UnitTriangleCenteredTwistTile,angles,w,\[Tau],types1}},
{{UnitTriangleCenteredTwistTile,angles,w,\[Tau],types2},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitTriangleCenteredTwistAltTile::usage="UnitTriangleCenteredTwistAlt is a tile type that produces an edge-centered simple flat twist from parameters {w, \[Alpha]} in a unit triangle.";
RenderTile[{UnitTriangleCenteredTwistAltTile,angles_,w_,\[Alpha]_,types_List},decoration_,opts___]:=RenderTile[{PolygonCenteredTwistAltTile,UnitTriangleVertices[angles],w,\[Alpha],types},decoration,opts]
Module[{angles,w,\[Alpha],types1,types2,tiling},
angles={50\[Degree],60\[Degree],70\[Degree]};
w=0.1;
\[Alpha]=25\[Degree];
types1={M,M,M};
types2={V,V,V};
tiling=JoinTiling[{
{{UnitTriangleCenteredTwistAltTile,angles,w,\[Alpha],types1}},
{{UnitTriangleCenteredTwistAltTile,angles,w,\[Alpha],types2},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{tverts,tobj,ex,n,verts,pverts,cverts,tas},
tverts=FullSimplify[UnitTriangleVertices[{\[Theta]1,\[Theta]2,\[Theta]3}]/.\[Theta]1+\[Theta]2->\[Pi]-\[Theta]3];
tobj=RenderTile[{PolygonOffsetTwistTile,tverts,w,d ,{M,M,M}},TGraphAssigned];
ex={\[Theta]1->50.\[Degree],\[Theta]2->60.\[Degree],\[Theta]3->70.\[Degree],w->0.1,d->0.06};
n=Length[tobj[Faces][[tobj[TwistFaces][[1]]]]];
verts=tobj[Vertices];
pverts=verts[[{1,5,9}]];(* outer polygon vertices *)
cverts=verts[[{4,8,12}]];(* central polygon vertices *)
Print[Graphics[{
Style[Line[Append[pverts,pverts[[1]]]],LightGray],
GraphGraphics[tobj][[1]]}]/.ex/.OrigamiStyle[]];
Print["critical twist angles/\[Degree] = ",TriangleCriticalTwistAngles[{\[Theta]1,\[Theta]2,\[Theta]3}]/\[Degree]/.ex];
(* directly computed twist angles *)
(* all three twist angles *)
tas=RotationAngle[verts[[#[[1]]]]-verts[[#[[2]]]],verts[[#[[3]]]]-verts[[#[[2]]]]]&/@Mod[Table[{4,8,3}+4i,{i,0,n-1}],4n,1]/.ArcTan[x_,y_]:>ArcTan[y/x];
tas=FullSimplify[tas];
Print["Twist angles = ",tas];
Print["Twist angles/\[Degree] = ",tas/\[Degree]/.ex];
(* Check our alternate formula for the twist angle *)
Print["check: ",Chop[(tas[[1]]-ArcTan[(w/(2d))((Sin[\[Theta]1]Sin[\[Theta]2]Sin[\[Theta]3])/(1+Cos[\[Theta]1]Cos[\[Theta]2]Cos[\[Theta]3]))])/.ex]];
(* Triangle angles (same) *)
Print["Corner angles/\[Degree]: outer = ",(TriangleAngles2D@@pverts)/\[Degree]/.ex," inner = ",(TriangleAngles2D@@cverts)/\[Degree] /.ex];
(* Triangle circumcenters (different) *)
Print["Circumcenters: outer = ",Circumcenter[pverts]/.ex," inner = ",Circumcenter[cverts]/.ex ];
(* Triangle incenters (different) *)
Print["Incenters: outer = ",TriangleIncenter2D@@pverts/.ex," inner = ",TriangleIncenter2D@@cverts /.ex];
(* Triangle Brocard points (different) *)
(* Triangle Brocard points *)
(* Print["Brocard points: outer = ",BrocardTriangleInfo[pverts/.ex]\[LeftDoubleBracket]2\[RightDoubleBracket]," inner = ",BrocardTriangleInfo[cverts/.ex]\[LeftDoubleBracket]2\[RightDoubleBracket] ];*)
(* Fixed point of the transformation *)
ctr=ScaleRotationOffsetFixedPoint[Take[pverts,2]/.ex,Take[cverts,2]/.ex];
Print["Fixed point of twist = ",ctr/.ex];
]//ShowExample
UnitTriangleOffsetTwistAngle[angles_,w_,d_]:=Module[{\[Theta]1,\[Theta]2,\[Theta]3},
{\[Theta]1,\[Theta]2,\[Theta]3}=angles;
ArcTan[(w/(2d))((Sin[\[Theta]1]Sin[\[Theta]2]Sin[\[Theta]3])/(1+Cos[\[Theta]1]Cos[\[Theta]2]Cos[\[Theta]3]))]]
UnitTriangleOffsetTwistAngle[{50\[Degree],60\[Degree],70\[Degree]},.09,.06]/\[Degree]
UnitTriangleOffsetTwistOffset[angles_,w_,\[Alpha]_]:=Module[{\[Theta]1,\[Theta]2,\[Theta]3},
{\[Theta]1,\[Theta]2,\[Theta]3}=angles;
(w /2 )((Sin[\[Theta]1]Sin[\[Theta]2]Sin[\[Theta]3])/(1+Cos[\[Theta]1]Cos[\[Theta]2]Cos[\[Theta]3]))Cot[\[Alpha]]]
UnitTriangleOffsetTwistOffset[{50\[Degree],60\[Degree],70\[Degree]},.09,22.8432\[Degree]]
UnitTriangleOffsetTwistShrinkage[angles_List, w_, d_]:=Module[{\[Alpha]},
\[Alpha]=UnitTriangleOffsetTwistAngle[angles,w,d];
w Csc[\[Alpha]]]
UnitTriangleOffsetTwistRotation[angles_List, w_, d_]:=Module[{\[Alpha]},
\[Alpha]=UnitTriangleOffsetTwistAngle[angles,w,d];
\[Pi]/2-\[Alpha]]
UnitTriangleOffsetTwistSelfContainedQ[angles_,w_,d_,types_List]:=RegularPolygonTwistValidQ[angles,UnitTriangleOffsetTwistAngle[angles,w,d],types]&&w<=(1/3)(1-2Abs[d]);
UnitTriangleOffsetTwistTile::usage="UnitTriangleOffsetTwistTile is a tile type that produces an offset simple flat twist from parameters {w, d} in a unit triangle.";
RenderTile[{UnitTriangleOffsetTwistTile,angles_,w_,d_,types_List},decoration_,opts___]:=RenderTile[{PolygonOffsetTwistTile,UnitTriangleVertices[angles],w,d,types},decoration,opts]
Module[{angles,w,d,types,tiling},
angles={50\[Degree],60\[Degree],70\[Degree]};
w=0.1;
d=0.05;
types={M,M,M};
tiling=JoinTiling[{
{{UnitTriangleOffsetTwistTile,angles,w,d,types}},
{{UnitTriangleOffsetTwistTile,angles,w,-d,types},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitCyclicPolygonCenteredTwistTile::usage="UnitCyclicPolygonCenteredTwistTile is a tile type that produces an edge-centered simple flat twist from parameters {w, \[Tau]} in a unit cyclic polygon.";
RenderTile[{UnitCyclicPolygonCenteredTwistTile,{angles_,side_,is_},w_,\[Tau]_,types_List},decoration_,opts___]:=RenderTile[{PolygonCenteredTwistTile,UnitCyclicPolygonVertices[angles,side,is],w,\[Tau],types},decoration,opts]
Module[{angles,side,is,w,\[Tau],types1,types2,tiling},
angles={75\[Degree],85\[Degree],95\[Degree],105\[Degree]};
side=1.2;
is=2;
w=0.1;
\[Tau]=80\[Degree];
types1={M,M,M,M};
types2={V,V,V,V};
tiling=JoinTiling[{
{{UnitCyclicPolygonCenteredTwistTile,{angles,side,is},w,\[Tau],types1}},
{{UnitCyclicPolygonCenteredTwistTile,{angles,side,is},w,\[Tau],types2},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitCyclicPolygonCenteredTwistAltTile::usage="UnitCyclicPolygonCenteredTwistAlt is a tile type that produces an edge-centered simple flat twist from parameters {w, \[Alpha]} in a unit cyclic polygon.";
RenderTile[{UnitCyclicPolygonCenteredTwistAltTile,{angles_,side_,is_},w_,\[Alpha]_,types_List},decoration_,opts___]:=RenderTile[{PolygonCenteredTwistAltTile,UnitCyclicPolygonVertices[angles,side,is],w,\[Alpha],types},decoration,opts]
Module[{angles,side,is,w,\[Alpha],types1,types2,tiling},
angles={75\[Degree],85\[Degree],95\[Degree],105\[Degree]};
side=1.2;
is=2;
w=0.1;
\[Alpha]=30\[Degree];
types1={M,M,M,M};
types2={V,V,V,V};
tiling=JoinTiling[{
{{UnitCyclicPolygonCenteredTwistAltTile,{angles,side,is},w,\[Alpha],types1}},
{{UnitCyclicPolygonCenteredTwistAltTile,{angles,side,is},w,\[Alpha],types2},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitCyclicBrocardPolygonOffsetTwistTile::usage="UnitCyclicBrocardPolygonOffsetTwistTile is a tile type that produces an offset simple flat twist from parameters {w, d} in a unit cyclic Brocard polygon.";
RenderTile[{UnitCyclicBrocardPolygonOffsetTwistTile,{n_,angle1_,angle2_,i1_,i2_},w_,d_,types_List},decoration_,opts___]:=Module[{verts,cctr,cr,\[Theta],bctr,\[Alpha]},
{verts,cctr,cr,\[Theta],bctr,\[Alpha]}=If[Sign[w]==Sign[d],
UnitCyclicBrocardPolygonInfoCCW[n, angle1, angle2, i1, i2],
UnitCyclicBrocardPolygonInfoCW[n, angle1, angle2, i1, i2]];
RenderTile[{PolygonOffsetTwistTile,verts,w,d,types},decoration,opts]]
Module[{n,\[Theta]1,\[Theta]2,i1,i2,w,d,types,tiling},
n=5;
\[Theta]1=110\[Degree];
\[Theta]2=90\[Degree];
i1=1;
i2=2;
w=0.2;
d=0.15;
types=Table[M,{n}];
tiling=JoinTiling[{
{{UnitCyclicBrocardPolygonOffsetTwistTile,{n,\[Theta]1,\[Theta]2,i1,i2},w,d,types}},
{{UnitCyclicBrocardPolygonOffsetTwistTile,{n,\[Theta]1,\[Theta]2,i1,i2},w,-d,types},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{verts,ctr,acrit,tobj,tverts,dx,dy},
{verts,ctr,acrit}=UnitBrocardTrapezoidInfo[\[Delta]];tobj=RenderTile[{PolygonOffsetTwistTile,verts,w,d,{M,M,M,M}},TGraphAssigned];
Print[GraphGraphics[tobj]/.{\[Delta]->70\[Degree],w->.2,d->.1}];
tverts=tobj[Vertices];
{dx,dy}=tverts[[8]]-tverts[[4]];
Print["Twist angle = ",FullSimplify[ArcCot[TrigExpand[dy/dx]]]];
Print["Shrinkage = ",FullSimplify[Mag[{dx,dy}]]];
Print["height of v4 = ",FullSimplify[tverts[[4,2]],{\[Delta]>0,\[Delta]<\[Pi]}]];
]//ShowExample
UnitTrapezoidOffsetTwistAngle[\[Delta]_, w_,d_]:=If[d>=0,0,\[Pi]]+ArcCot[(\[Sqrt]2 d \[Sqrt](3+Cos[2 \[Delta]]) Csc[\[Delta]])/w]
UnitTrapezoidOffsetTwistAngle[70\[Degree],.2,.1]/\[Degree]//ShowExample
UnitTrapezoidOffsetTwistAngle[70\[Degree],.2,-.1]/\[Degree]//ShowExample
UnitTrapezoidOffsetTwistAngle[70\[Degree],.2,0]/\[Degree]//ShowExample
UnitTrapezoidOffsetTwistOffset[\[Delta]_, w_, \[Alpha]_]:=(w Cot[\[Alpha]] Sin[\[Delta]])/(\[Sqrt]2 \[Sqrt](3+Cos[2 \[Delta]]))
UnitTrapezoidOffsetTwistOffset[70\[Degree],.2,42\[Degree]]//ShowExample
UnitTrapezoidOffsetTwistOffset[70\[Degree],.2,138\[Degree]]//ShowExample
UnitTrapezoidOffsetShrinkage[\[Delta]_, w_, d_]:=(\[Sqrt](w^2+2 d^2 (3+Cos[2 \[Delta]]) ))/Sin[\[Delta]]
UnitTrapezoidOffsetRotation[\[Delta]_, w_, d_]:=ArcCot[(\[Sqrt]2 d \[Sqrt](3+Cos[2 \[Delta]]) Csc[\[Delta]])/w]
UnitTrapezoidOffsetRotation[70\[Degree],.2,.1]/\[Degree]//ShowExample
UnitTrapezoidOffsetRotation[70\[Degree],.2,-.1]/\[Degree]//ShowExample
UnitSymmetricTrapezoidOffsetTwistTile::usage="UnitSymmetricTrapezoidOffsetTwistTile is a tile type that produces an offset simple flat twist from parameters {w, d} in a unit symmetric trapezoid.";
RenderTile[{UnitSymmetricTrapezoidOffsetTwistTile,\[Delta]_,w_,d_,types_List},decoration_,opts___]:=Module[{verts,ctr,acrit},{verts,ctr,acrit}=UnitBrocardTrapezoidInfo[\[Delta]];RenderTile[{PolygonOffsetTwistTile,verts,w,d,types},decoration,opts]]
Module[{\[Delta],w,d,types,tiling},
\[Delta]=80\[Degree];
w=0.2;
d=0.15;
types={M,M,M,M};
tiling=JoinTiling[{
{{UnitSymmetricTrapezoidOffsetTwistTile,\[Delta],w,d,types}},
{{UnitSymmetricTrapezoidOffsetTwistTile,\[Delta],w,-d,types},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitQuadrilateralCenteredSplitTwistTile::usage="UnitQuadrilateralCenteredSplitTwistTile is a tile type that produces a split twist from parameters {w, \[Tau]} in a unit quadrilateral.";
RenderTile[{UnitQuadrilateralCenteredSplitTwistTile,{angles_,side_,is_},w_,\[Tau]_,ip_,ctype_,types_List},decoration_,opts___]:=RenderTile[{QuadrilateralCenteredSplitTwistTile,UnitQuadrilateralVertices[angles,side,is],w,\[Tau],ip,ctype,types},decoration,opts]
Module[{angles,side,is,w,\[Tau],ip,ctype1,ctype2,types1,types2,tiling},
angles={75\[Degree],85\[Degree],95\[Degree],105\[Degree]};
side=1.2;
is=2;
w=0.1;
\[Tau]=80\[Degree];
ip=2;
ctype1=M;
ctype2=V;
types1={M,M,M,M};
types2={V,V,V,V};
tiling=JoinTiling[{
{{UnitQuadrilateralCenteredSplitTwistTile,{angles,side,is},w,\[Tau],ip,ctype1,types1}},
{{UnitQuadrilateralCenteredSplitTwistTile,{angles,side,is},w,\[Tau],ip,ctype2,types2},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitQuadrilateralCenteredSplitTwistAltTile::usage="UnitQuadrilateralCenteredSplitTwistAltTile is a tile type that produces an edge-centered split twist from parameters {w, \[Alpha]} in a unit quadrilateral.";
RenderTile[{UnitQuadrilateralCenteredSplitTwistAltTile,{angles_,side_,is_},w_,\[Alpha]_,ip_,ctype_,types_List},decoration_,opts___]:=RenderTile[{QuadrilateralCenteredSplitTwistAltTile,UnitQuadrilateralVertices[angles,side,is],w,\[Alpha],ip,ctype,types},decoration,opts]
Module[{angles,side,is,w,\[Alpha],ip,ctype1,ctype2,types1,types2,tiling},
angles={75\[Degree],85\[Degree],95\[Degree],105\[Degree]};
side=1.2;
is=2;
w=0.1;
\[Alpha]=30\[Degree];
ip=2;
ctype1=M;
ctype2=V;
types1={M,M,M,M};
types2={V,V,V,V};
tiling=JoinTiling[{
{{UnitQuadrilateralCenteredSplitTwistAltTile,{angles,side,is},w,\[Alpha],ip,ctype1,types1}},
{{UnitQuadrilateralCenteredSplitTwistAltTile,{angles,side,is},w,\[Alpha],ip,ctype2,types2},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitQuadrilateralOffsetSplitTwistTile::usage="UnitQuadrilateralOffsetSplitTwistTile is a tile type that produces an offset split twist from parameters {w, d} in a unit quadrilateral.";
RenderTile[{UnitQuadrilateralOffsetSplitTwistTile,{angles_List,side_,is_},w_,d_,ip_,ctype_,types_List},decoration_,opts___]:=RenderTile[{QuadrilateralOffsetSplitTwistTile,UnitQuadrilateralVertices[angles,side,is],w,d,ip,ctype,types},decoration,opts]
Module[{angles,is,side,w,d,ip,ctype1,ctype2,types,tiling},
angles={70\[Degree],85\[Degree],95\[Degree],110\[Degree]};
is=2;
side=1;
w=0.15;
d=0.09;
ip=2;
ctype1=M;
ctype2=M;
types={M,M,M,M};
tiling=JoinTiling[{
{{UnitQuadrilateralOffsetSplitTwistTile,{angles,side,is},w,d,ip,ctype1,types}},
{{UnitQuadrilateralOffsetSplitTwistTile,{angles,side,is},w,-d,ip,ctype2,types},{1,2,2}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowDF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitRegularStarPolygonTile::usage="UnitRegularStarPolygonTile is a tile type that produces a unit regular star polygon.";
RenderTile[{UnitRegularStarPolygonTile, n_,\[Alpha]_},decoration_,opts___]:=RenderTile[{PolygonTile,UnitRegularStarPolygonVertices[n,\[Alpha]]},decoration,opts]
Graphics[RenderTile[{UnitRegularStarPolygonTile,5,36\[Degree]},Tiling]]/.TilingStyle[]//ShowExample
Module[{n,w,\[Tau],types,tiling},
n=3;
w=0.12;
\[Tau]=70\[Degree];
types={M,M,M};
tiling={
{{UnitRegularPolygonCenteredTwistTile,n,w,\[Tau],types}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,\[Alpha],types,tiling},
n=4;
w=0.18;
\[Alpha]=30\[Degree];
types={M,M,V,V};
tiling={
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,\[Alpha],types1,types2,tiling},
n=3;
w=0.1;
\[Alpha]=25\[Degree];
types1={M,M,M};
types2={V,V,V};
tiling=JoinTiling[{
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types1}},
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types2},{1,2,1}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,\[Alpha],types1,types2,tiling},
n=4;
w=0.2;
\[Alpha]=25\[Degree];
types1={M,M,M,M};
types2={V,V,V,V};
tiling=JoinTiling[{
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types1}},
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types2},{1,2,1}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,\[Alpha],types1,types2,tiling},
n=6;
w=0.2;
\[Alpha]=25\[Degree];
types1={M,M,M,M,M,M};
types2={V,V,V,V,V,V};
tiling=JoinTiling[{
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types1}},
{{UnitRegularPolygonCenteredTwistAltTile,n,w,\[Alpha],types2},{1,3,1}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{w,\[Alpha],name,tiling,cp,tobj},
w=0.18;
\[Alpha]=30\[Degree];
name=UnitRegularPolygonCenteredTwistAltTile;
tiling=JoinTiling[{
{{name,4,w,\[Alpha],{V,V,V,V}}},
{{name,6,w,\[Alpha],{M,M,M,M,M,M}},{1,2,1}},
{{name,4,w,\[Alpha],{V,V,V,V}},{2,3,1}},
{{name,3,w,\[Alpha],{M,M,M}},{1,1,1}},
{{name,4,w,\[Alpha],{V,V,V,V}},{4,2,1}},
{{name,3,w,\[Alpha],{M,M,M}},{5,2,1}},
{{name,4,w,\[Alpha],{V,V,V,V}},{6,2,1}},
{{name,3,w,\[Alpha],{M,M,M}},{7,2,1}},
{{name,3,w,\[Alpha],{M,M,M}},{1,3,2}},
{{name,4,w,\[Alpha],{V,V,V,V}},{9,2,1}},
{{name,3,w,\[Alpha],{M,M,M}},{10,2,1}},
{{name,4,w,\[Alpha],{V,V,V,V}},{11,1,1}},
{{name,3,w,\[Alpha],{M,M,M}},{12,2,1}}
}];
Print[GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]];
tobj=EmbedTiling[tiling,MonolithicTGraph2D,StationaryFace->7];
Print[GraphGraphics[tobj]]//Hold;
GraphicsRow[{
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->-1]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,d,types,tiling},
n=3;
w=0.1;
d=0.06;
types={M,M,M};
tiling={
{{UnitRegularPolygonOffsetTwistTile,n,w,d,types}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,d,types,tiling},
n=4;
w=0.15;
d=0.10;
types={M,M,V,V};
tiling={
{{UnitRegularPolygonOffsetTwistTile,n,w,d,types}}
};
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,d,types,tiling},
n=3;
w=0.15;
d=0.10;
types={M,M,M};
tiling=JoinTiling[{
{{UnitRegularPolygonOffsetTwistTile,n,w,d,types}},
{{UnitRegularPolygonOffsetTwistTile,n,w,-d,types},{1,2,1}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,d,types,tiling},
n=4;
w=0.15;
d=0.12;
types={V,V,V,V};
tiling=JoinTiling[{
{{UnitRegularPolygonOffsetTwistTile,n,w,d,types}},
{{UnitRegularPolygonOffsetTwistTile,n,w,-d,types},{1,2,1}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,d,types,tiling},
n=6;
w=0.2;
d=0.15;
types={M,M,M,M,M,M};
tiling=JoinTiling[{
{{UnitRegularPolygonOffsetTwistTile,n,w,d,types}},
{{UnitRegularPolygonOffsetTwistTile,n,w,-d,types},{1,3,1}}
}];
GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],
Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{w,d,name,tiling,cp,tobj},
w=0.18;
d=0.15;
name=UnitRegularPolygonOffsetTwistTile;
tiling=JoinTiling[{
{{name,4,w,d,{V,V,V,V}}},
{{name,4,w,-d,{V,V,V,V}},{1,2,1}},
{{name,4,w,-d,{V,V,V,V}},{1,3,2}},
{{name,4,w,d,{V,V,V,V}},{2,3,2}}
}];
Print[GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]];
tobj=EmbedTiling[tiling,MonolithicTGraph2D,StationaryFace->7];
Print[GraphGraphics[tobj]]//Hold;
GraphicsRow[{
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->-1]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{w,d,name,angles,side,is,tiling,cp,tobj},
w=0.18;
d=0.12;
name=UnitQuadrilateralOffsetSplitTwistTile;
angles={90\[Degree],90\[Degree],90\[Degree],90\[Degree]};
side=1/\[Sqrt]2;
is=2;
tiling=JoinTiling[{
{{name,{angles,side,is},w,d,1,V,{V,V,V,V}}},
{{name,{angles,side,is},w,-d,2,V,{V,V,V,V}},{1,2,1}},
{{name,{angles,side,is},w,-d,4,V,{V,V,V,V}},{1,3,2}},
{{name,{angles,side,is},w,d,3,V,{V,V,V,V}},{2,3,2}}
}];
Print[GraphicsRow[{
Graphics[EmbedTiling[tiling,Tiling,TilePolys->True,TileEdgeArrowStyle->TileArrowCF,TileIndices->True,TileVertexIndices->True]],Graphics[EmbedTiling[tiling,CreasePattern]],
Graphics[EmbedTiling[tiling,FoldedForm2D]]
}]/.TilingStyle[]/.OrigamiStyle[]];
tobj=EmbedTiling[tiling,MonolithicTGraph2D,StationaryFace->17];
Print[GraphGraphics[tobj]]//Hold;
GraphicsRow[{
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->-1]
}]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
RegularizePatch::badlen="`1` has the wrong length to be in a tiling.";
RegularizePatch[patch_List]:=Switch[Length[#],
4,#,
3,Append[#,1],
2,Join[#,{0,1}],
1,Join[#,{{0,0},0,1}],
_,Message[RegularizePatch::badlen,#];Abort[]]&/@patch;
Module[{patch},
patch={
{{TestTile,4},{0,0}},
{{TestTile,4},{0,0},22.5\[Degree],.5}
};
RegularizePatch[patch]
]//ShowExample
PatchVector[patch_List, {i1_, j1_}, {i2_, j2_}]:=Module[{verts},
verts=EmbedTiling[patch,TileVertices];
verts[[i2,j2]]-verts[[i1,j1]]]
Module[{patch},
patch=JoinTiling[{
{{UnitRegularPolygonTile,4}},
{{UnitRegularPolygonTile,4},{1,2,1}},
{{UnitRegularPolygonTile,4},{2,3,2}},
{{UnitRegularPolygonTile,4},{3,4,3}}
}];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]];
PatchVector[patch,{1,1},{4,3}]
]//ShowExample

PatchVectors[patch_List, {i1_, j1_}, {i2_, j2_},{i3_,j3_}]:=Module[{verts},
verts=EmbedTiling[patch,TileVertices];
{verts[[i2,j2]]-verts[[i1,j1]],verts[[i3,j3]]-verts[[i1,j1]]}]
Module[{patch},
patch=JoinTiling[{
{{UnitRegularPolygonTile,4}},
{{UnitRegularPolygonTile,4},{1,2,1}},
{{UnitRegularPolygonTile,4},{2,3,2}},
{{UnitRegularPolygonTile,4},{3,4,3}}
}];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]];
PatchVectors[patch,{1,1},{2,3},{4,3}]
]//ShowExample

MakeLatticeTiling[patch_,{l1_,l2_},{j1min_,j1max_},{j2min_,j2max_}]:=Flatten[Table[ReplacePart[#,#[[2]]+j1 l1+j2 l2,2]&/@RegularizePatch[patch],{j2,j2min,j2max},{j1,j1min,j1max}],2]
Module[{patch,tiling},
patch={
{{TestTile,4},{0,0}},
{{TestTile,4},{0,0},22.5\[Degree],.5}
};
tiling=MakeLatticeTiling[patch,{{1.2,0},{0,1.2}},{0,1},{0,1}];
Print[ColumnForm[tiling]];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True]]/.TilingStyle[]
]//ShowExample
MakeArchimedeanVertexFigure[vtype_List] :=Module[{polys, rots},
polys=RenderTile[{UnitRegularPolygonTile,#},Tiling]&/@vtype;
rots=Drop[FoldList[#1+\[Pi]-(2\[Pi])/#2&,0,vtype],-1];
{MapThread[Rotate2D,{polys,rots}],Style[Point[{0,0}],AbsolutePointSize[5]]}]
Graphics[MakeArchimedeanVertexFigure[{3,3,3,4,4}]]/.TilingStyle[]//ShowExample
ArchimedeanVertexType::badnum="ArchimedeanVertexType[`1`] is not defined.";
ArchimedeanVertexType[n_]:=(Message[ArchimedeanVertexType::badnum,n];Abort[])
ArchimedeanName[n_]:=StringJoin["(",Riffle[ToString/@ArchimedeanVertexType[n],"."],")"]
ArchimedeanVertexType[1]={3,3,3,3,3,3};
ArchimedeanPatch[1]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularPolygonTile,3},{1,2,1}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[1]=PatchVectors[ArchimedeanPatch[1],{1,1},{1,2},{1,3}]//Simplify;
Module[{n,patch,lattice,tiling},
n=1;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[2]={4,4,4,4};
ArchimedeanPatch[2]=JoinTiling[{
{{UnitRegularPolygonTile,4}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[2]=PatchVectors[ArchimedeanPatch[2],{1,1},{1,2},{1,4}]//Simplify;
Module[{n,patch,lattice,tiling},
n=2;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[3]={6,6,6};
ArchimedeanPatch[3]=JoinTiling[{
{{UnitRegularPolygonTile,6}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[3]=PatchVectors[ArchimedeanPatch[3],{1,1},{1,3},{1,5}]//Simplify;
Module[{n,patch,lattice,tiling},
n=3;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[4]={3,3,3,3,6};
ArchimedeanPatch[4]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularPolygonTile,3},{1,2,1}},
{{UnitRegularPolygonTile,3},{2,1,1}},
{{UnitRegularPolygonTile,3},{3,2,1}},
{{UnitRegularPolygonTile,3},{4,2,2}},
{{UnitRegularPolygonTile,3},{5,2,1}},
{{UnitRegularPolygonTile,3},{6,2,2}},
{{UnitRegularPolygonTile,3},{7,3,2}},
{{UnitRegularPolygonTile,6},{2,2,2}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[4]=PatchVectors[ArchimedeanPatch[4],{1,1},{4,2},{9,5}]//Simplify;
Module[{n,patch,lattice,tiling},
n=4;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[5]={3,3,3,3,6};
ArchimedeanPatch[5]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularPolygonTile,3},{1,3,2}},
{{UnitRegularPolygonTile,3},{2,3,3}},
{{UnitRegularPolygonTile,3},{3,3,2}},
{{UnitRegularPolygonTile,3},{4,2,2}},
{{UnitRegularPolygonTile,3},{5,3,2}},
{{UnitRegularPolygonTile,3},{6,2,2}},
{{UnitRegularPolygonTile,3},{7,2,1}},
{{UnitRegularPolygonTile,6},{2,2,2}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[5]=With[{patch=ArchimedeanPatch[5]},{PatchVector[patch,{4,3},{1,2}],PatchVector[patch,{1,1},{9,5}]}]//Simplify;
Module[{n,patch,lattice,tiling},
n=5;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[6]={3,3,3,4,4};
ArchimedeanPatch[6]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularPolygonTile,3},{1,2,1}},
{{UnitRegularPolygonTile,4},{2,2,2}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[6]=PatchVectors[ArchimedeanPatch[6],{1,1},{1,2},{3,4}]//Simplify;
Module[{n,patch,lattice,tiling},
n=6;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[7]={3,3,4,3,4};
ArchimedeanPatch[7]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularPolygonTile,4},{1,2,1}},
{{UnitRegularPolygonTile,3},{2,3,2}},
{{UnitRegularPolygonTile,3},{3,2,1}},
{{UnitRegularPolygonTile,4},{3,3,3}},
{{UnitRegularPolygonTile,3},{5,1,3}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[7]=PatchVectors[ArchimedeanPatch[7],{1,1},{2,2},{5,4}]//Simplify;
Module[{n,patch,lattice,tiling},
n=7;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[8]={3,4,6,4};
ArchimedeanPatch[8]=JoinTiling[{
{{UnitRegularPolygonTile,4}},
{{UnitRegularPolygonTile,3},{1,1,3}},
{{UnitRegularPolygonTile,4},{2,1,1}},
{{UnitRegularPolygonTile,3},{3,2,1}},
{{UnitRegularPolygonTile,4},{4,2,1}},
{{UnitRegularPolygonTile,6},{1,2,1}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[8]=With[{patch=ArchimedeanPatch[8]},{PatchVector[patch,{1,4},{6,4}],PatchVector[patch,{4,1},{6,4}]}]//Simplify;
Module[{n,patch,lattice,tiling},
n=8;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[9]={3,6,3,6};
ArchimedeanPatch[9]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularPolygonTile,6},{1,2,1}},
{{UnitRegularPolygonTile,3},{2,3,1}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[9]=PatchVectors[ArchimedeanPatch[9],{1,1},{2,2},{2,5}]//Simplify;
Module[{n,patch,lattice,tiling},
n=9;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[10]={3,12,12};
ArchimedeanPatch[10]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularPolygonTile,12},{1,2,12}},
{{UnitRegularPolygonTile,3},{2,5,1}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[10]=PatchVectors[ArchimedeanPatch[10],{1,1},{2,3},{2,8}]//Simplify;
Module[{n,patch,lattice,tiling},
n=10;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[11]={4,6,12};
ArchimedeanPatch[11]=JoinTiling[{
{{UnitRegularPolygonTile,4}},
{{UnitRegularPolygonTile,6},{1,2,6}},
{{UnitRegularPolygonTile,4},{2,3,1}},
{{UnitRegularPolygonTile,6},{3,2,1}},
{{UnitRegularPolygonTile,4},{4,4,2}},
{{UnitRegularPolygonTile,12},{1,3,2}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[11]=PatchVectors[ArchimedeanPatch[11],{1,1},{4,2},{6,8}]//Simplify;
Module[{n,patch,lattice,tiling},
n=11;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ArchimedeanVertexType[12]={4,8,8};
ArchimedeanPatch[12]=JoinTiling[{
{{UnitRegularPolygonTile,4}},
{{UnitRegularPolygonTile,8},{1,2,8}}
}]//Simplify;
ArchimedeanPatchLatticeVectors[12]=PatchVectors[ArchimedeanPatch[12],{1,1},{2,3},{2,6}]//FullSimplify;
ArchimedeanPatch[12]=FullSimplify[ArchimedeanPatch[12]];
Module[{n,patch,lattice,tiling},
n=12;
Print["tiling = ",ArchimedeanName[n]];
patch=ArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoColorableArchimedeanPatch::badnum="TwoColorableArchimedeanPatch[`1`] is not defined.";
TwoColorableArchimedeanPatch[n_]:=(Message[TwoColorableArchimedeanPatch::badnum,n];Abort[])
TwoColorableArchimedeanPatchLatticeVectors::badnum="TwoColorableArchimedeanPatchLatticeVectors[`1`] is not defined.";
TwoColorableArchimedeanPatchLatticeVectors[n_]:=(Message[TwoColorableArchimedeanPatchLatticeVectors::badnum,n];Abort[])
TwoColorableArchimedeanPatch[1]=ArchimedeanPatch[1];
TwoColorableArchimedeanPatchParity[1]={1,-1};
TwoColorableArchimedeanPatchLatticeVectors[1]=ArchimedeanPatchLatticeVectors[1];
Module[{n,patch,lattice,tiling},
n=1;
Print["tiling = ",ArchimedeanName[n]];
patch=TwoColorableArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoColorableArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoColorableArchimedeanPatch[2]=JoinTiling[{
{{UnitRegularPolygonTile,4}},
{{UnitRegularPolygonTile,4},{1,2,1}}
}]//Simplify;
TwoColorableArchimedeanPatchParity[2]={1,-1};
TwoColorableArchimedeanPatchLatticeVectors[2]=PatchVectors[TwoColorableArchimedeanPatch[2],{1,1},{2,2},{1,3}];
Module[{n,patch,lattice,tiling},
n=2;
Print["tiling = ",ArchimedeanName[n]];
patch=TwoColorableArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoColorableArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoColorableArchimedeanPatch[8]=ArchimedeanPatch[8];
TwoColorableArchimedeanPatchParity[8]={1,-1,1,-1,1,-1};
TwoColorableArchimedeanPatchLatticeVectors[8]=ArchimedeanPatchLatticeVectors[8];
Module[{n,patch,lattice,tiling},
n=8;
Print["tiling = ",ArchimedeanName[n]];
patch=TwoColorableArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoColorableArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoColorableArchimedeanPatch[9]=ArchimedeanPatch[9];
TwoColorableArchimedeanPatchParity[9]={1,-1,1};
TwoColorableArchimedeanPatchLatticeVectors[9]=ArchimedeanPatchLatticeVectors[9];
Module[{n,patch,lattice,tiling},
n=9;
Print["tiling = ",ArchimedeanName[n]];
patch=TwoColorableArchimedeanPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoColorableArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
PatchCheckTypes::badlens="The length `1` of types `2` does not match the length `3` of patch `4`.";
PatchCheckTypes::badtypes=
"The length `1` of typelist `2` does not match the required length `3` from tilespec `4` of patch `5`.";
PatchCheckTypes[patch_List,types_List]:=Module[{},
If[Length[types]!=Length[patch],Message[PatchCheckTypes::badlens,Length[types],types,Length[patch],patch];Abort[]];
Do[
If[Length[types[[i]]]!=patch[[i,1,2]],Message[PatchCheckTypes::badtypes,Length[types[[i]]],types[[i]],patch[[i,1,2]],i,patch];Abort[]];
,{i,Length[patch]}]]
Module[{patch,types},
patch=ArchimedeanPatch[1];
types={{M,M,M},{V,V,V,V}};
PatchCheckTypes[patch,types]
]//ShowErrorExample
PatchCheckParity::badlens="The length `1` of parity `2` does not match the length `3` of patch `4`.";
PatchCheckParity[patch_List,parity_List]:=Module[{},
If[Length[parity]!=Length[patch],Message[PatchCheckParity::badlens,Length[parity],parity,Length[patch],patch];Abort[]]]
Module[{patch,parity},
patch=TwoColorableArchimedeanPatch[1];
parity={1,-1,1};
PatchCheckParity[patch,parity]
]//ShowErrorExample
UnitRegularPolygonCenteredTwistPatch[patch_List,w_,\[Tau]_,types_List]:=Module[{},
PatchCheckTypes[patch,types];
MapThread[{{UnitRegularPolygonCenteredTwistTile,#1[[1,2]],w,\[Tau],#2},#1[[2]],#1[[3]]}&,{RegularizePatch[patch],types}]]
Module[{n,tpatch,w,\[Tau],types,patch},
n=1;
tpatch=ArchimedeanPatch[n];
Print["patch = ",tpatch//ColumnForm];
w=0.2;
\[Tau]=70\[Degree];
types={{M,M,M},{V,V,V}};
patch=UnitRegularPolygonCenteredTwistPatch[tpatch,w,\[Tau],types];
Print["patch = ",patch//ColumnForm];
Graphics[EmbedTiling[patch,{CreasePattern,Tiling}]]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitRegularPolygonCenteredTwistAltPatch[patch_List,w_,\[Alpha]_,types_List]:=Module[{},
PatchCheckTypes[patch,types];
MapThread[{{UnitRegularPolygonCenteredTwistAltTile,#1[[1,2]],w,\[Alpha],#2},#1[[2]],#1[[3]]}&,{RegularizePatch[patch],types}]]
Module[{n,tpatch,w,\[Alpha],types,patch},
n=6;
tpatch=ArchimedeanPatch[n];
Print["patch = ",tpatch//ColumnForm];
w=0.2;
\[Alpha]=25\[Degree];
types={{M,M,M},{V,V,V},{M,M,M,M}};
patch=UnitRegularPolygonCenteredTwistAltPatch[tpatch,w,\[Alpha],types];
Print["patch = ",patch//ColumnForm];
Graphics[EmbedTiling[patch,{CreasePattern,Tiling},TileEdgeArrowStyle->TileArrowCF]]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
UnitRegularPolygonOffsetTwistPatch[patch_List,parity_List,w_,d_,types_List]:=Module[{},
PatchCheckTypes[patch,types];
PatchCheckParity[patch,parity];
MapThread[{{UnitRegularPolygonOffsetTwistTile,#1[[1,2]],w,#3 d,#2},#1[[2]],#1[[3]]}&,{RegularizePatch[patch],types,parity}]]
Module[{n,tpatch,parity,w,d,types,patch},
n=2;
tpatch=TwoColorableArchimedeanPatch[n];
parity=TwoColorableArchimedeanPatchParity[n];
Print["patch = ",tpatch//ColumnForm];
Print["parity = ",parity//ColumnForm];
w=0.2;
d=0.1;
types={{M,M,M,M},{M,M,M,M}};
patch=UnitRegularPolygonOffsetTwistPatch[tpatch,parity,w,d,types];
Print["patch = ",patch//ColumnForm];
Graphics[EmbedTiling[patch,{CreasePattern,Tiling},TileEdgeArrowStyle->TileArrowDF]]/.TilingStyle[]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,\[Alpha],tpatch,types,patch,lattice,tiling,cliprect,ptiling,tobj},
n=2;
w=0.2;
\[Alpha]=30.\[Degree];
tpatch=ArchimedeanPatch[n];
types={{V,V,M,M}};
patch=UnitRegularPolygonCenteredTwistAltPatch[tpatch,w,\[Alpha],types];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,3},{0,3}];
cliprect=SquareVertices[2.9];
ptiling=PruneTiling[tiling,cliprect];
(* show tiling before and after pruning *)
Print[GraphicsRow[{
Graphics[{EmbedTiling[tiling,Tiling],PrunePoly[cliprect]}],Graphics[{EmbedTiling[ptiling,Tiling],PrunePoly[cliprect]}]}]/.TilingStyle[]];
(* crease pattern and folded form tilings *)
Print[GraphicsRow[{
Graphics[EmbedTiling[ptiling,CreasePattern]],
Graphics[EmbedTiling[ptiling,FoldedForm2D]]}]/.OrigamiStyle[]];
(* monolithic versions *)
tobj=EmbedTiling[ptiling,MonolithicTGraph2D,StationaryFace->32];
Print[GraphGraphics[tobj]]//Hold;
GraphicsRow[{
Graphics[CreasePatternGraphics[tobj]],
Graphics[VisibleFoldedFormGraphics[tobj,FaceupFace->32]]}]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,\[Alpha],tpatch,types,patch,lattice,tiling,cliprect,ptiling,tobj},
n=8;
w=0.12;
\[Alpha]=29\[Degree];
tpatch=ArchimedeanPatch[n];
types={{M,M,M,M},{V,V,V},{M,M,M,M},{V,V,V},{M,M,M,M},{V,V,V,V,V,V}};
patch=UnitRegularPolygonCenteredTwistAltPatch[tpatch,w,\[Alpha],types];
lattice=ArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{-2,2},{-1,2}];
cliprect=RectVertices[{.1,.1},{3.9,3.9}];
ptiling=PruneTiling[tiling,cliprect];
(* show tiling before and after pruning *)
Print[GraphicsRow[{
Graphics[{EmbedTiling[tiling,Tiling],PrunePoly[cliprect]}],Graphics[{EmbedTiling[ptiling,Tiling],PrunePoly[cliprect]}]}]/.TilingStyle[]];
(* crease pattern and folded form tilings *)
Print[GraphicsRow[{
Graphics[EmbedTiling[ptiling,CreasePattern]],
Graphics[EmbedTiling[ptiling,FoldedForm2D]]}]/.OrigamiStyle[]];
(* monolithic versions *)
tobj=EmbedTiling[ptiling,MonolithicTGraph2D,StationaryFace->1];
Print[GraphicsRow[{GraphGraphics[tobj],Graph2DGraphics[tobj]}]]//Hold;
GraphicsRow[{
Graphics[CreasePatternGraphics[tobj]],
Graphics[VisibleFoldedFormGraphics[tobj,FaceupFace->1]]}]/.OrigamiStyle[]
]//ShowExample
Graphics[{{}, {Inset[Graphics[{{{Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0, 0}, {0.44, 0.}, {0.5112914975617392, 0.32931268658412555`}, {0., 0.44}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.44, 0.}, {0.56, 0.}, {0.6706873134158745, 0.5112914975617392}, {0.5112914975617392, 0.32931268658412555`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.56, 0.}, {1, 0}, {1.381051177665153, -0.22}, {1.818973983486618, 0.2627038188158325}, {0.6706873134158745, 0.5112914975617392}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.5112914975617392, 0.32931268658412555`}, {0.6706873134158745, 0.5112914975617392}, {0.4887085024382608, 0.6706873134158744}, {0.32931268658412555`, 0.4887085024382608}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.6706873134158745, 0.5112914975617392}, {1.818973983486618, 0.2627038188158325}, {1.6369951725090044`, 0.4220996346699676}, {0.4887085024382608, 0.6706873134158744}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.4887085024382608, 0.6706873134158744}, {1.6369951725090044`, 0.4220996346699676}, {1.2781350823353927`, 1.540838901151225}, {0.6322306656794343, 1.333650931488077}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.4887085024382608, 0.6706873134158744}, {0.6322306656794343, 1.333650931488077}, {0.47283484982529905`, 1.1516721205104634`}, {0.32931268658412555`, 0.4887085024382608}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.32931268658412555`, 0.4887085024382608}, {0.47283484982529905`, 1.1516721205104634`}, {-0.029547403589486043`, 1.607447768919518}, {-0.38105117766515284`, 1.2199999999999998`}, {0, Rational[1, 2] (-1 - 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2])}, {0., 0.56}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0., 0.56}, {0., 0.44}, {0.5112914975617392, 0.32931268658412555`}, {0.32931268658412555`, 0.4887085024382608}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.381051177665153, -0.22}, {1.4849742261192858`, -0.28}, {2.0480042147620523`, 0.3406041841458648}, {1.818973983486618, 0.2627038188158325}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.4849742261192858`, -0.28}, {1 + Rational[1, 2] 3^Rational[1, 2], Rational[-1, 2]}, {2.247076581449592, -0.28000000000000014`}, {2.0480042147620523`, 0.3406041841458648}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.818973983486618, 0.2627038188158325}, {2.0480042147620523`, 0.3406041841458648}, {2.0950556350598726`, 0.5779003653300323}, {1.9130768240822593`, 0.7372961811841674}, {1.684046592806825, 0.6593958158541351}, {1.6369951725090044`, 0.4220996346699676}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.247076581449592, -0.28000000000000014`}, {2.3509996299037246`, -0.22000000000000003`}, {2.0950556350598726`, 0.5779003653300323}, {2.0480042147620523`, 0.3406041841458648}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.3509996299037246`, -0.22000000000000003`}, {1 + 3^Rational[1, 2], 0}, {3.172050807568877, 0.}, {3.2433423051306165`, 0.32931268658412555`}, {2.0950556350598726`, 0.5779003653300323}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.0950556350598726`, 0.5779003653300323}, {3.2433423051306165`, 0.32931268658412555`}, {3.061363494153003, 0.4887085024382608}, {1.9130768240822593`, 0.7372961811841674}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.9130768240822593`, 0.7372961811841674}, {3.061363494153003, 0.4887085024382608}, {3.2048856573941764`, 1.1516721205104634`}, {2.7025034039793914`, 1.607447768919518}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.9130768240822593`, 0.7372961811841674}, {2.7025034039793914`, 1.607447768919518}, {2.473473172703957, 1.5295474035894858`}, {1.684046592806825, 0.6593958158541351}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.684046592806825, 0.6593958158541351}, {2.473473172703957, 1.5295474035894858`}, {1.971090919289172, 1.9853230519985405`}, {1.325186502633213, 1.7781350823353925`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.684046592806825, 0.6593958158541351}, {1.325186502633213, 1.7781350823353925`}, {1.2781350823353927`, 1.540838901151225}, {1.6369951725090044`, 0.4220996346699676}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.172050807568877, 0.}, {3.2920508075688772`, 0.}, {3.402738120984752, 0.5112914975617392}, {3.2433423051306165`, 0.32931268658412555`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.2920508075688772`, 0.}, {2 + 3^Rational[1, 2], 0}, {4.11310198523403, -0.22}, {4.551024791055495, 0.2627038188158325}, {3.402738120984752, 0.5112914975617392}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.2433423051306165`, 0.32931268658412555`}, {3.402738120984752, 0.5112914975617392}, {3.220759310007138, 0.6706873134158744}, {3.061363494153003, 0.4887085024382608}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.402738120984752, 0.5112914975617392}, {4.551024791055495, 0.2627038188158325}, {4.369045980077882, 0.4220996346699676}, {3.220759310007138, 0.6706873134158744}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.220759310007138, 0.6706873134158744}, {4.369045980077882, 0.4220996346699676}, {4.010185889904269, 1.540838901151225}, {3.3642814732483117`, 1.333650931488077}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.220759310007138, 0.6706873134158744}, {3.3642814732483117`, 1.333650931488077}, {3.2048856573941764`, 1.1516721205104634`}, {3.061363494153003, 0.4887085024382608}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.11310198523403, -0.22}, {4.217025033688163, -0.28}, {4.780055022330929, 0.3406041841458648}, {4.551024791055495, 0.2627038188158325}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.217025033688163, -0.28}, {2 + Rational[3, 2] 3^Rational[1, 2], Rational[-1, 2]}, {4.979127389018469, -0.28000000000000014`}, {4.780055022330929, 0.3406041841458648}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.551024791055495, 0.2627038188158325}, {4.780055022330929, 0.3406041841458648}, {4.82710644262875, 0.5779003653300323}, {4.645127631651137, 0.7372961811841674}, {4.416097400375702, 0.6593958158541351}, {4.369045980077882, 0.4220996346699676}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.979127389018469, -0.28000000000000014`}, {5.083050437472602, -0.22000000000000003`}, {4.82710644262875, 0.5779003653300323}, {4.780055022330929, 0.3406041841458648}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{5.083050437472602, -0.22000000000000003`}, {2 + 2 3^Rational[1, 2], 0}, {5.464101615137754, 0.43999999999999984`}, {4.82710644262875, 0.5779003653300323}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{5.464101615137754, 0.43999999999999984`}, {5.464101615137755, 0.5599999999999998}, {4.645127631651137, 0.7372961811841674}, {4.82710644262875, 0.5779003653300323}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{5.464101615137755, 0.5599999999999998}, {2 + 2 3^Rational[1, 2], 1}, {5.083050437472601, 1.2199999999999998`}, {4.645127631651137, 0.7372961811841674}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{5.083050437472601, 1.2199999999999998`}, {4.979127389018469, 1.2799999999999998`}, {4.416097400375702, 0.6593958158541351}, {4.645127631651137, 0.7372961811841674}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.979127389018469, 1.2799999999999998`}, {Rational[1, 2] 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2])}, {4.378076211353315, 1.8810511776651528`}, {4.05723731020209, 1.7781350823353925`}, {4.416097400375702, 0.6593958158541351}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.416097400375702, 0.6593958158541351}, {4.05723731020209, 1.7781350823353925`}, {4.010185889904269, 1.540838901151225}, {4.369045980077882, 0.4220996346699676}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{Rational[-1, 2] - 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[-1, 2] 3^Rational[1, 2] + Rational[1, 2] (3 + 3^Rational[1, 2])}, {-0.48497422611928553`, 1.2799999999999998`}, {-0.25857763486492025`, 1.5295474035894858`}, {-0.6460254037844384, 1.8810511776651528`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.48497422611928553`, 1.2799999999999998`}, {-0.38105117766515284`, 1.2199999999999998`}, {-0.029547403589486043`, 1.607447768919518}, {-0.25857763486492025`, 1.5295474035894858`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.25857763486492025`, 1.5295474035894858`}, {-0.029547403589486043`, 1.607447768919518}, {-0.10744776891951835`, 1.8364780001949523`}, {-0.33647800019495255`, 1.75857763486492}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.029547403589486043`, 1.607447768919518}, {0.47283484982529905`, 1.1516721205104634`}, {0.39493448449526675`, 1.3807023517858976`}, {-0.10744776891951835`, 1.8364780001949523`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.10744776891951835`, 1.8364780001949523`}, {0.39493448449526675`, 1.3807023517858976`}, {1.040838901151225, 1.5878903214490456`}, {0.6819788109776137, 2.706629587930303}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.10744776891951835`, 1.8364780001949523`}, {0.6819788109776137, 2.706629587930303}, {0.4529485797021794, 2.628729222600271}, {-0.33647800019495255`, 1.75857763486492}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.33647800019495255`, 1.75857763486492}, {0.4529485797021794, 2.628729222600271}, {-0.3660254037844386, 2.8060254037844383`}, {-3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[1, 2] (3 + 3^Rational[1, 2])}, {-0.5860254037844386, 1.9849742261192853`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.5860254037844386, 1.9849742261192853`}, {-0.6460254037844384, 1.8810511776651528`}, {-0.25857763486492025`, 1.5295474035894858`}, {-0.33647800019495255`, 1.75857763486492}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.47283484982529905`, 1.1516721205104634`}, {0.6322306656794343, 1.333650931488077}, {0.39493448449526675`, 1.3807023517858976`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.6322306656794343, 1.333650931488077}, {1.2781350823353927`, 1.540838901151225}, {1.040838901151225, 1.5878903214490456`}, {0.39493448449526675`, 1.3807023517858976`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.2781350823353927`, 1.540838901151225}, {1.325186502633213, 1.7781350823353925`}, {1.0878903214490456`, 1.825186502633213}, {1.040838901151225, 1.5878903214490456`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.325186502633213, 1.7781350823353925`}, {1.971090919289172, 1.9853230519985405`}, {1.7337947381050043`, 2.032374472296361}, {1.0878903214490456`, 1.825186502633213}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.0878903214490456`, 1.825186502633213}, {1.7337947381050043`, 2.032374472296361}, {1.8773169013461777`, 2.6953380903685638`}, {0.7290302312754342, 2.943925769114471}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.0878903214490456`, 1.825186502633213}, {0.7290302312754342, 2.943925769114471}, {0.6819788109776137, 2.706629587930303}, {1.040838901151225, 1.5878903214490456`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.4529485797021794, 2.628729222600271}, {0.6819788109776137, 2.706629587930303}, {0.7290302312754342, 2.943925769114471}, {0.5470514202978207, 3.1033215849686058`}, {0.3180211890223863, 3.0254212196385737`}, {0.2709697687245658, 2.788125038454406}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.7290302312754342, 2.943925769114471}, {1.8773169013461777`, 2.6953380903685638`}, {1.6953380903685642`, 2.854733906222699}, {0.5470514202978207, 3.1033215849686058`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.5470514202978207, 3.1033215849686058`}, {1.6953380903685642`, 2.854733906222699}, {1.8388602536097376`, 3.517697524294902}, {1.3364780001949526`, 3.973473172703957}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.5470514202978207, 3.1033215849686058`}, {1.3364780001949526`, 3.973473172703957}, {1.1074477689195183`, 3.8955728073739246`}, {0.3180211890223863, 3.0254212196385737`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.3180211890223863, 3.0254212196385737`}, {1.1074477689195183`, 3.8955728073739246`}, {0.6050655155047333, 4.351348455782979}, {-0.04083890115122557, 4.144160486119831}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.3180211890223863, 3.0254212196385737`}, {-0.04083890115122557, 4.144160486119831}, {-0.08789032144904585, 3.906864304935664}, {0.2709697687245658, 2.788125038454406}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.2709697687245658, 2.788125038454406}, {-0.08789032144904585, 3.906864304935664}, {-0.586025403784439, 3.7470765814495914`}, {1 + 3^Rational[1, 2] - 2 (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}, {-0.3660254037844386, 2.9260254037844384`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.3660254037844386, 2.9260254037844384`}, {-0.3660254037844386, 2.8060254037844383`}, {0.4529485797021794, 2.628729222600271}, {0.2709697687245658, 2.788125038454406}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.8773169013461777`, 2.6953380903685638`}, {1.7337947381050043`, 2.032374472296361}, {1.8931905539591396`, 2.214353283273975}, {2.036712717200313, 2.8773169013461777`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.036712717200313, 2.8773169013461777`}, {1.8931905539591396`, 2.214353283273975}, {2.3955728073739246`, 1.75857763486492}, {3.1849993872710565`, 2.628729222600271}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.8773169013461777`, 2.6953380903685638`}, {2.036712717200313, 2.8773169013461777`}, {1.8547339062226995`, 3.036712717200313}, {1.6953380903685642`, 2.854733906222699}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.036712717200313, 2.8773169013461777`}, {3.1849993872710565`, 2.628729222600271}, {3.003020576293443, 2.788125038454406}, {1.8547339062226995`, 3.036712717200313}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.8547339062226995`, 3.036712717200313}, {3.003020576293443, 2.788125038454406}, {2.644160486119831, 3.906864304935664}, {1.998256069463873, 3.6996763352725166`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.8547339062226995`, 3.036712717200313}, {1.998256069463873, 3.6996763352725166`}, {1.8388602536097376`, 3.517697524294902}, {1.6953380903685642`, 2.854733906222699}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.971090919289172, 1.9853230519985405`}, {2.473473172703957, 1.5295474035894858`}, {2.3955728073739246`, 1.75857763486492}, {1.8931905539591396`, 2.214353283273975}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.971090919289172, 1.9853230519985405`}, {1.8931905539591396`, 2.214353283273975}, {1.7337947381050043`, 2.032374472296361}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.473473172703957, 1.5295474035894858`}, {2.7025034039793914`, 1.607447768919518}, {2.624603038649359, 1.8364780001949523`}, {2.3955728073739246`, 1.75857763486492}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.7025034039793914`, 1.607447768919518}, {3.2048856573941764`, 1.1516721205104634`}, {3.126985292064144, 1.3807023517858976`}, {2.624603038649359, 1.8364780001949523`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.624603038649359, 1.8364780001949523`}, {3.126985292064144, 1.3807023517858976`}, {3.7728897087201023`, 1.5878903214490456`}, {3.4140296185464907`, 2.706629587930303}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.624603038649359, 1.8364780001949523`}, {3.4140296185464907`, 2.706629587930303}, {3.1849993872710565`, 2.628729222600271}, {2.3955728073739246`, 1.75857763486492}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.2048856573941764`, 1.1516721205104634`}, {3.3642814732483117`, 1.333650931488077}, {3.126985292064144, 1.3807023517858976`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.3642814732483117`, 1.333650931488077}, {4.010185889904269, 1.540838901151225}, {3.7728897087201023`, 1.5878903214490456`}, {3.126985292064144, 1.3807023517858976`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.010185889904269, 1.540838901151225}, {4.05723731020209, 1.7781350823353925`}, {3.8199411290179226`, 1.825186502633213}, {3.7728897087201023`, 1.5878903214490456`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.378076211353315, 1.8810511776651528`}, {4.318076211353316, 1.9849742261192853`}, {3.8199411290179226`, 1.825186502633213}, {4.05723731020209, 1.7781350823353925`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.318076211353316, 1.9849742261192853`}, {1 + 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[1, 2] (3 + 3^Rational[1, 2])}, {4.098076211353316, 2.8060254037844383`}, {3.461081038844311, 2.943925769114471}, {3.8199411290179226`, 1.825186502633213}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.8199411290179226`, 1.825186502633213}, {3.461081038844311, 2.943925769114471}, {3.4140296185464907`, 2.706629587930303}, {3.7728897087201023`, 1.5878903214490456`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.1849993872710565`, 2.628729222600271}, {3.4140296185464907`, 2.706629587930303}, {3.461081038844311, 2.943925769114471}, {3.279102227866698, 3.1033215849686058`}, {3.0500719965912637`, 3.0254212196385737`}, {3.003020576293443, 2.788125038454406}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.098076211353316, 2.8060254037844383`}, {4.098076211353316, 2.926025403784438}, {3.279102227866698, 3.1033215849686058`}, {3.461081038844311, 2.943925769114471}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.098076211353316, 2.926025403784438}, {Rational[3, 2] + Rational[3, 2] 3^Rational[1, 2], Rational[5, 2] + Rational[1, 2] 3^Rational[1, 2]}, {4.318076211353316, 3.7470765814495914`}, {4.06852880776383, 3.973473172703957}, {3.279102227866698, 3.1033215849686058`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.279102227866698, 3.1033215849686058`}, {4.06852880776383, 3.973473172703957}, {3.8394985764883955`, 3.8955728073739246`}, {3.0500719965912637`, 3.0254212196385737`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.0500719965912637`, 3.0254212196385737`}, {3.8394985764883955`, 3.8955728073739246`}, {3.3371163230736105`, 4.351348455782979}, {2.6912119064176516`, 4.144160486119831}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.0500719965912637`, 3.0254212196385737`}, {2.6912119064176516`, 4.144160486119831}, {2.644160486119831, 3.906864304935664}, {3.003020576293443, 2.788125038454406}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.08789032144904585, 3.906864304935664}, {-0.04083890115122557, 4.144160486119831}, {-0.27813508233539297`, 4.191211906417652}, {-0.3251865026332137, 3.953915725233485}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.04083890115122557, 4.144160486119831}, {0.6050655155047333, 4.351348455782979}, {0.3677693343205658, 4.3983998760808}, {-0.27813508233539297`, 4.191211906417652}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.27813508233539297`, 4.191211906417652}, {0.3677693343205658, 4.3983998760808}, {0.44, 4.732050807568877}, {0, 3 + 3^Rational[1, 2]}, {-0.38105117766515306`, 4.512050807568877}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.38105117766515306`, 4.512050807568877}, {-0.48497422611928576`, 4.4520508075688765`}, {-0.3251865026332137, 3.953915725233485}, {-0.27813508233539297`, 4.191211906417652}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.48497422611928576`, 4.4520508075688765`}, {Rational[1, 2] + 3^Rational[1, 2] - 2 (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + Rational[3, 2] 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}, {-0.6460254037844386, 3.8509996299037246`}, {-0.3251865026332137, 3.953915725233485}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.6460254037844386, 3.8509996299037246`}, {-0.586025403784439, 3.7470765814495914`}, {-0.08789032144904585, 3.906864304935664}, {-0.3251865026332137, 3.953915725233485}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.6050655155047333, 4.351348455782979}, {1.1074477689195183`, 3.8955728073739246`}, {1.029547403589486, 4.124603038649359}, {0.527165150174701, 4.580378687058413}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.527165150174701, 4.580378687058413}, {1.029547403589486, 4.124603038649359}, {1.381051177665153, 4.512050807568877}, {1, 3 + 3^Rational[1, 2]}, {0.56, 4.732050807568878}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.6050655155047333, 4.351348455782979}, {0.527165150174701, 4.580378687058413}, {0.3677693343205658, 4.3983998760808}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.56, 4.732050807568878}, {0.44, 4.732050807568877}, {0.3677693343205658, 4.3983998760808}, {0.527165150174701, 4.580378687058413}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.1074477689195183`, 3.8955728073739246`}, {1.3364780001949526`, 3.973473172703957}, {1.2585776348649202`, 4.202503403979391}, {1.029547403589486, 4.124603038649359}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.3364780001949526`, 3.973473172703957}, {1.8388602536097376`, 3.517697524294902}, {1.7609598882797053`, 3.746727755570336}, {1.2585776348649202`, 4.202503403979391}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.2585776348649202`, 4.202503403979391}, {1.7609598882797053`, 3.746727755570336}, {2.4068643049356635`, 3.953915725233485}, {2.2470765814495914`, 4.4520508075688765`}, {Rational[-1, 2] + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + Rational[3, 2] 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}, {1.4849742261192858`, 4.452050807568877}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.4849742261192858`, 4.452050807568877}, {1.381051177665153, 4.512050807568877}, {1.029547403589486, 4.124603038649359}, {1.2585776348649202`, 4.202503403979391}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.8388602536097376`, 3.517697524294902}, {1.998256069463873, 3.6996763352725166`}, {1.7609598882797053`, 3.746727755570336}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.998256069463873, 3.6996763352725166`}, {2.644160486119831, 3.906864304935664}, {2.4068643049356635`, 3.953915725233485}, {1.7609598882797053`, 3.746727755570336}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.644160486119831, 3.906864304935664}, {2.6912119064176516`, 4.144160486119831}, {2.4539157252334842`, 4.191211906417652}, {2.4068643049356635`, 3.953915725233485}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.6912119064176516`, 4.144160486119831}, {3.3371163230736105`, 4.351348455782979}, {3.099820141889443, 4.3983998760808}, {2.4539157252334842`, 4.191211906417652}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.4539157252334842`, 4.191211906417652}, {3.099820141889443, 4.3983998760808}, {3.172050807568877, 4.732050807568877}, {1 + 3^Rational[1, 2], 3 + 3^Rational[1, 2]}, {2.350999629903724, 4.512050807568877}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.350999629903724, 4.512050807568877}, {2.2470765814495914`, 4.4520508075688765`}, {2.4068643049356635`, 3.953915725233485}, {2.4539157252334842`, 4.191211906417652}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.3371163230736105`, 4.351348455782979}, {3.8394985764883955`, 3.8955728073739246`}, {3.7615982111583635`, 4.124603038649359}, {3.259215957743578, 4.580378687058413}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.259215957743578, 4.580378687058413}, {3.7615982111583635`, 4.124603038649359}, {4.11310198523403, 4.512050807568877}, {2 + 3^Rational[1, 2], 3 + 3^Rational[1, 2]}, {3.2920508075688772`, 4.732050807568878}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.3371163230736105`, 4.351348455782979}, {3.259215957743578, 4.580378687058413}, {3.099820141889443, 4.3983998760808}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.2920508075688772`, 4.732050807568878}, {3.172050807568877, 4.732050807568877}, {3.099820141889443, 4.3983998760808}, {3.259215957743578, 4.580378687058413}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.8394985764883955`, 3.8955728073739246`}, {4.06852880776383, 3.973473172703957}, {3.9906284424337977`, 4.202503403979391}, {3.7615982111583635`, 4.124603038649359}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.318076211353316, 3.7470765814495914`}, {4.378076211353315, 3.8509996299037246`}, {3.9906284424337977`, 4.202503403979391}, {4.06852880776383, 3.973473172703957}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.378076211353315, 3.8509996299037246`}, {2 + Rational[3, 2] 3^Rational[1, 2], Rational[5, 2] + 3^Rational[1, 2]}, {4.217025033688163, 4.452050807568877}, {3.9906284424337977`, 4.202503403979391}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.217025033688163, 4.452050807568877}, {4.11310198523403, 4.512050807568877}, {3.7615982111583635`, 4.124603038649359}, {3.9906284424337977`, 4.202503403979391}}]}}, {{GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0, 0}, {0.44, 0.}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.44, 0.}, {0.56, 0.}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.56, 0.}, {1, 0}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.44, 0.}, {0.5112914975617392, 0.32931268658412555`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.56, 0.}, {0.6706873134158745, 0.5112914975617392}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.5112914975617392, 0.32931268658412555`}, {0.6706873134158745, 0.5112914975617392}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.6706873134158745, 0.5112914975617392}, {1.818973983486618, 0.2627038188158325}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.4887085024382608, 0.6706873134158744}, {1.6369951725090044`, 0.4220996346699676}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.6706873134158745, 0.5112914975617392}, {0.4887085024382608, 0.6706873134158744}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.4887085024382608, 0.6706873134158744}, {0.6322306656794343, 1.333650931488077}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.32931268658412555`, 0.4887085024382608}, {0.47283484982529905`, 1.1516721205104634`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.4887085024382608, 0.6706873134158744}, {0.32931268658412555`, 0.4887085024382608}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0, Rational[1, 2] (-1 - 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2])}, {0., 0.56}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0., 0.56}, {0., 0.44}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0., 0.44}, {0, 0}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0., 0.56}, {0.32931268658412555`, 0.4887085024382608}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0., 0.44}, {0.5112914975617392, 0.32931268658412555`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.32931268658412555`, 0.4887085024382608}, {0.5112914975617392, 0.32931268658412555`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1, 0}, {1.381051177665153, -0.22}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.381051177665153, -0.22}, {1.4849742261192858`, -0.28}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4849742261192858`, -0.28}, {1 + Rational[1, 2] 3^Rational[1, 2], Rational[-1, 2]}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.381051177665153, -0.22}, {1.818973983486618, 0.2627038188158325}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4849742261192858`, -0.28}, {2.0480042147620523`, 0.3406041841458648}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.818973983486618, 0.2627038188158325}, {2.0480042147620523`, 0.3406041841458648}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1 + Rational[1, 2] 3^Rational[1, 2], Rational[-1, 2]}, {2.247076581449592, -0.28000000000000014`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.247076581449592, -0.28000000000000014`}, {2.3509996299037246`, -0.22000000000000003`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.3509996299037246`, -0.22000000000000003`}, {1 + 3^Rational[1, 2], 0}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.247076581449592, -0.28000000000000014`}, {2.0480042147620523`, 0.3406041841458648}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.3509996299037246`, -0.22000000000000003`}, {2.0950556350598726`, 0.5779003653300323}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.0480042147620523`, 0.3406041841458648}, {2.0950556350598726`, 0.5779003653300323}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.0950556350598726`, 0.5779003653300323}, {3.2433423051306165`, 0.32931268658412555`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.9130768240822593`, 0.7372961811841674}, {3.061363494153003, 0.4887085024382608}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.0950556350598726`, 0.5779003653300323}, {1.9130768240822593`, 0.7372961811841674}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.9130768240822593`, 0.7372961811841674}, {2.7025034039793914`, 1.607447768919518}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.684046592806825, 0.6593958158541351}, {2.473473172703957, 1.5295474035894858`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.9130768240822593`, 0.7372961811841674}, {1.684046592806825, 0.6593958158541351}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.684046592806825, 0.6593958158541351}, {1.325186502633213, 1.7781350823353925`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.6369951725090044`, 0.4220996346699676}, {1.2781350823353927`, 1.540838901151225}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.684046592806825, 0.6593958158541351}, {1.6369951725090044`, 0.4220996346699676}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.6369951725090044`, 0.4220996346699676}, {1.818973983486618, 0.2627038188158325}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1 + 3^Rational[1, 2], 0}, {3.172050807568877, 0.}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.172050807568877, 0.}, {3.2920508075688772`, 0.}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.2920508075688772`, 0.}, {2 + 3^Rational[1, 2], 0}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.172050807568877, 0.}, {3.2433423051306165`, 0.32931268658412555`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.2920508075688772`, 0.}, {3.402738120984752, 0.5112914975617392}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.2433423051306165`, 0.32931268658412555`}, {3.402738120984752, 0.5112914975617392}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.402738120984752, 0.5112914975617392}, {4.551024791055495, 0.2627038188158325}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.220759310007138, 0.6706873134158744}, {4.369045980077882, 0.4220996346699676}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.402738120984752, 0.5112914975617392}, {3.220759310007138, 0.6706873134158744}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.220759310007138, 0.6706873134158744}, {3.3642814732483117`, 1.333650931488077}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.061363494153003, 0.4887085024382608}, {3.2048856573941764`, 1.1516721205104634`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.220759310007138, 0.6706873134158744}, {3.061363494153003, 0.4887085024382608}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.061363494153003, 0.4887085024382608}, {3.2433423051306165`, 0.32931268658412555`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2 + 3^Rational[1, 2], 0}, {4.11310198523403, -0.22}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.11310198523403, -0.22}, {4.217025033688163, -0.28}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.217025033688163, -0.28}, {2 + Rational[3, 2] 3^Rational[1, 2], Rational[-1, 2]}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.11310198523403, -0.22}, {4.551024791055495, 0.2627038188158325}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.217025033688163, -0.28}, {4.780055022330929, 0.3406041841458648}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.551024791055495, 0.2627038188158325}, {4.780055022330929, 0.3406041841458648}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2 + Rational[3, 2] 3^Rational[1, 2], Rational[-1, 2]}, {4.979127389018469, -0.28000000000000014`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.979127389018469, -0.28000000000000014`}, {5.083050437472602, -0.22000000000000003`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{5.083050437472602, -0.22000000000000003`}, {2 + 2 3^Rational[1, 2], 0}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.979127389018469, -0.28000000000000014`}, {4.780055022330929, 0.3406041841458648}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{5.083050437472602, -0.22000000000000003`}, {4.82710644262875, 0.5779003653300323}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.780055022330929, 0.3406041841458648}, {4.82710644262875, 0.5779003653300323}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2 + 2 3^Rational[1, 2], 0}, {5.464101615137754, 0.43999999999999984`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{5.464101615137754, 0.43999999999999984`}, {5.464101615137755, 0.5599999999999998}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{5.464101615137755, 0.5599999999999998}, {2 + 2 3^Rational[1, 2], 1}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{5.464101615137754, 0.43999999999999984`}, {4.82710644262875, 0.5779003653300323}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{5.464101615137755, 0.5599999999999998}, {4.645127631651137, 0.7372961811841674}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.82710644262875, 0.5779003653300323}, {4.645127631651137, 0.7372961811841674}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2 + 2 3^Rational[1, 2], 1}, {5.083050437472601, 1.2199999999999998`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{5.083050437472601, 1.2199999999999998`}, {4.979127389018469, 1.2799999999999998`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.979127389018469, 1.2799999999999998`}, {Rational[1, 2] 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2])}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{5.083050437472601, 1.2199999999999998`}, {4.645127631651137, 0.7372961811841674}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.979127389018469, 1.2799999999999998`}, {4.416097400375702, 0.6593958158541351}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.645127631651137, 0.7372961811841674}, {4.416097400375702, 0.6593958158541351}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.416097400375702, 0.6593958158541351}, {4.05723731020209, 1.7781350823353925`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.369045980077882, 0.4220996346699676}, {4.010185889904269, 1.540838901151225}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.416097400375702, 0.6593958158541351}, {4.369045980077882, 0.4220996346699676}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.369045980077882, 0.4220996346699676}, {4.551024791055495, 0.2627038188158325}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{Rational[-1, 2] - 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[-1, 2] 3^Rational[1, 2] + Rational[1, 2] (3 + 3^Rational[1, 2])}, {-0.48497422611928553`, 1.2799999999999998`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.48497422611928553`, 1.2799999999999998`}, {-0.38105117766515284`, 1.2199999999999998`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.38105117766515284`, 1.2199999999999998`}, {0, Rational[1, 2] (-1 - 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2])}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.48497422611928553`, 1.2799999999999998`}, {-0.25857763486492025`, 1.5295474035894858`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{-0.38105117766515284`, 1.2199999999999998`}, {-0.029547403589486043`, 1.607447768919518}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.25857763486492025`, 1.5295474035894858`}, {-0.029547403589486043`, 1.607447768919518}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.029547403589486043`, 1.607447768919518}, {0.47283484982529905`, 1.1516721205104634`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{-0.10744776891951835`, 1.8364780001949523`}, {0.39493448449526675`, 1.3807023517858976`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.029547403589486043`, 1.607447768919518}, {-0.10744776891951835`, 1.8364780001949523`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.10744776891951835`, 1.8364780001949523`}, {0.6819788109776137, 2.706629587930303}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{-0.33647800019495255`, 1.75857763486492}, {0.4529485797021794, 2.628729222600271}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.10744776891951835`, 1.8364780001949523`}, {-0.33647800019495255`, 1.75857763486492}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[1, 2] (3 + 3^Rational[1, 2])}, {-0.5860254037844386, 1.9849742261192853`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.5860254037844386, 1.9849742261192853`}, {-0.6460254037844384, 1.8810511776651528`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6460254037844384, 1.8810511776651528`}, {Rational[-1, 2] - 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[-1, 2] 3^Rational[1, 2] + Rational[1, 2] (3 + 3^Rational[1, 2])}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.5860254037844386, 1.9849742261192853`}, {-0.33647800019495255`, 1.75857763486492}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6460254037844384, 1.8810511776651528`}, {-0.25857763486492025`, 1.5295474035894858`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.33647800019495255`, 1.75857763486492}, {-0.25857763486492025`, 1.5295474035894858`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.47283484982529905`, 1.1516721205104634`}, {0.6322306656794343, 1.333650931488077}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.6322306656794343, 1.333650931488077}, {1.2781350823353927`, 1.540838901151225}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.39493448449526675`, 1.3807023517858976`}, {1.040838901151225, 1.5878903214490456`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.6322306656794343, 1.333650931488077}, {0.39493448449526675`, 1.3807023517858976`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.39493448449526675`, 1.3807023517858976`}, {0.47283484982529905`, 1.1516721205104634`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.2781350823353927`, 1.540838901151225}, {1.325186502633213, 1.7781350823353925`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.325186502633213, 1.7781350823353925`}, {1.971090919289172, 1.9853230519985405`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.0878903214490456`, 1.825186502633213}, {1.7337947381050043`, 2.032374472296361}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.325186502633213, 1.7781350823353925`}, {1.0878903214490456`, 1.825186502633213}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.0878903214490456`, 1.825186502633213}, {0.7290302312754342, 2.943925769114471}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.040838901151225, 1.5878903214490456`}, {0.6819788109776137, 2.706629587930303}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.0878903214490456`, 1.825186502633213}, {1.040838901151225, 1.5878903214490456`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.040838901151225, 1.5878903214490456`}, {1.2781350823353927`, 1.540838901151225}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.4529485797021794, 2.628729222600271}, {0.6819788109776137, 2.706629587930303}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.6819788109776137, 2.706629587930303}, {0.7290302312754342, 2.943925769114471}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.7290302312754342, 2.943925769114471}, {1.8773169013461777`, 2.6953380903685638`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.5470514202978207, 3.1033215849686058`}, {1.6953380903685642`, 2.854733906222699}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.7290302312754342, 2.943925769114471}, {0.5470514202978207, 3.1033215849686058`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.5470514202978207, 3.1033215849686058`}, {1.3364780001949526`, 3.973473172703957}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.3180211890223863, 3.0254212196385737`}, {1.1074477689195183`, 3.8955728073739246`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.5470514202978207, 3.1033215849686058`}, {0.3180211890223863, 3.0254212196385737`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.3180211890223863, 3.0254212196385737`}, {-0.04083890115122557, 4.144160486119831}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.2709697687245658, 2.788125038454406}, {-0.08789032144904585, 3.906864304935664}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.3180211890223863, 3.0254212196385737`}, {0.2709697687245658, 2.788125038454406}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1 + 3^Rational[1, 2] - 2 (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}, {-0.3660254037844386, 2.9260254037844384`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3660254037844386, 2.9260254037844384`}, {-0.3660254037844386, 2.8060254037844383`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3660254037844386, 2.8060254037844383`}, {-3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[1, 2] (3 + 3^Rational[1, 2])}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3660254037844386, 2.9260254037844384`}, {0.2709697687245658, 2.788125038454406}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3660254037844386, 2.8060254037844383`}, {0.4529485797021794, 2.628729222600271}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.2709697687245658, 2.788125038454406}, {0.4529485797021794, 2.628729222600271}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.8773169013461777`, 2.6953380903685638`}, {1.7337947381050043`, 2.032374472296361}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.036712717200313, 2.8773169013461777`}, {1.8931905539591396`, 2.214353283273975}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.8773169013461777`, 2.6953380903685638`}, {2.036712717200313, 2.8773169013461777`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.036712717200313, 2.8773169013461777`}, {3.1849993872710565`, 2.628729222600271}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.8547339062226995`, 3.036712717200313}, {3.003020576293443, 2.788125038454406}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.036712717200313, 2.8773169013461777`}, {1.8547339062226995`, 3.036712717200313}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.8547339062226995`, 3.036712717200313}, {1.998256069463873, 3.6996763352725166`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.6953380903685642`, 2.854733906222699}, {1.8388602536097376`, 3.517697524294902}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.8547339062226995`, 3.036712717200313}, {1.6953380903685642`, 2.854733906222699}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.6953380903685642`, 2.854733906222699}, {1.8773169013461777`, 2.6953380903685638`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.971090919289172, 1.9853230519985405`}, {2.473473172703957, 1.5295474035894858`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.8931905539591396`, 2.214353283273975}, {2.3955728073739246`, 1.75857763486492}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.971090919289172, 1.9853230519985405`}, {1.8931905539591396`, 2.214353283273975}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.8931905539591396`, 2.214353283273975}, {1.7337947381050043`, 2.032374472296361}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.7337947381050043`, 2.032374472296361}, {1.971090919289172, 1.9853230519985405`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.473473172703957, 1.5295474035894858`}, {2.7025034039793914`, 1.607447768919518}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.7025034039793914`, 1.607447768919518}, {3.2048856573941764`, 1.1516721205104634`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.624603038649359, 1.8364780001949523`}, {3.126985292064144, 1.3807023517858976`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.7025034039793914`, 1.607447768919518}, {2.624603038649359, 1.8364780001949523`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.624603038649359, 1.8364780001949523`}, {3.4140296185464907`, 2.706629587930303}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.3955728073739246`, 1.75857763486492}, {3.1849993872710565`, 2.628729222600271}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.624603038649359, 1.8364780001949523`}, {2.3955728073739246`, 1.75857763486492}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.3955728073739246`, 1.75857763486492}, {2.473473172703957, 1.5295474035894858`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.2048856573941764`, 1.1516721205104634`}, {3.3642814732483117`, 1.333650931488077}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.3642814732483117`, 1.333650931488077}, {4.010185889904269, 1.540838901151225}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.126985292064144, 1.3807023517858976`}, {3.7728897087201023`, 1.5878903214490456`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.3642814732483117`, 1.333650931488077}, {3.126985292064144, 1.3807023517858976`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.126985292064144, 1.3807023517858976`}, {3.2048856573941764`, 1.1516721205104634`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.010185889904269, 1.540838901151225}, {4.05723731020209, 1.7781350823353925`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{Rational[1, 2] 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2])}, {4.378076211353315, 1.8810511776651528`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.378076211353315, 1.8810511776651528`}, {4.318076211353316, 1.9849742261192853`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.318076211353316, 1.9849742261192853`}, {1 + 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[1, 2] (3 + 3^Rational[1, 2])}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.378076211353315, 1.8810511776651528`}, {4.05723731020209, 1.7781350823353925`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.318076211353316, 1.9849742261192853`}, {3.8199411290179226`, 1.825186502633213}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.05723731020209, 1.7781350823353925`}, {3.8199411290179226`, 1.825186502633213}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.8199411290179226`, 1.825186502633213}, {3.461081038844311, 2.943925769114471}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.7728897087201023`, 1.5878903214490456`}, {3.4140296185464907`, 2.706629587930303}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.8199411290179226`, 1.825186502633213}, {3.7728897087201023`, 1.5878903214490456`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.7728897087201023`, 1.5878903214490456`}, {4.010185889904269, 1.540838901151225}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.1849993872710565`, 2.628729222600271}, {3.4140296185464907`, 2.706629587930303}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.4140296185464907`, 2.706629587930303}, {3.461081038844311, 2.943925769114471}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1 + 3^Rational[1, 2] + Rational[1, 2] (1 + 3^Rational[1, 2]), Rational[1, 2] (3 + 3^Rational[1, 2])}, {4.098076211353316, 2.8060254037844383`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.098076211353316, 2.8060254037844383`}, {4.098076211353316, 2.926025403784438}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.098076211353316, 2.926025403784438}, {Rational[3, 2] + Rational[3, 2] 3^Rational[1, 2], Rational[5, 2] + Rational[1, 2] 3^Rational[1, 2]}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.098076211353316, 2.8060254037844383`}, {3.461081038844311, 2.943925769114471}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.098076211353316, 2.926025403784438}, {3.279102227866698, 3.1033215849686058`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.461081038844311, 2.943925769114471}, {3.279102227866698, 3.1033215849686058`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.279102227866698, 3.1033215849686058`}, {4.06852880776383, 3.973473172703957}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.0500719965912637`, 3.0254212196385737`}, {3.8394985764883955`, 3.8955728073739246`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.279102227866698, 3.1033215849686058`}, {3.0500719965912637`, 3.0254212196385737`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.0500719965912637`, 3.0254212196385737`}, {2.6912119064176516`, 4.144160486119831}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.003020576293443, 2.788125038454406}, {2.644160486119831, 3.906864304935664}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.0500719965912637`, 3.0254212196385737`}, {3.003020576293443, 2.788125038454406}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.003020576293443, 2.788125038454406}, {3.1849993872710565`, 2.628729222600271}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.08789032144904585, 3.906864304935664}, {-0.04083890115122557, 4.144160486119831}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.04083890115122557, 4.144160486119831}, {0.6050655155047333, 4.351348455782979}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{-0.27813508233539297`, 4.191211906417652}, {0.3677693343205658, 4.3983998760808}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.04083890115122557, 4.144160486119831}, {-0.27813508233539297`, 4.191211906417652}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0, 3 + 3^Rational[1, 2]}, {-0.38105117766515306`, 4.512050807568877}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.38105117766515306`, 4.512050807568877}, {-0.48497422611928576`, 4.4520508075688765`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.48497422611928576`, 4.4520508075688765`}, {Rational[1, 2] + 3^Rational[1, 2] - 2 (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + Rational[3, 2] 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.38105117766515306`, 4.512050807568877}, {-0.27813508233539297`, 4.191211906417652}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{-0.48497422611928576`, 4.4520508075688765`}, {-0.3251865026332137, 3.953915725233485}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.27813508233539297`, 4.191211906417652}, {-0.3251865026332137, 3.953915725233485}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{Rational[1, 2] + 3^Rational[1, 2] - 2 (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + Rational[3, 2] 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}, {-0.6460254037844386, 3.8509996299037246`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6460254037844386, 3.8509996299037246`}, {-0.586025403784439, 3.7470765814495914`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.586025403784439, 3.7470765814495914`}, {1 + 3^Rational[1, 2] - 2 (1 + 3^Rational[1, 2]) + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6460254037844386, 3.8509996299037246`}, {-0.3251865026332137, 3.953915725233485}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{-0.586025403784439, 3.7470765814495914`}, {-0.08789032144904585, 3.906864304935664}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3251865026332137, 3.953915725233485}, {-0.08789032144904585, 3.906864304935664}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.6050655155047333, 4.351348455782979}, {1.1074477689195183`, 3.8955728073739246`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.527165150174701, 4.580378687058413}, {1.029547403589486, 4.124603038649359}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.6050655155047333, 4.351348455782979}, {0.527165150174701, 4.580378687058413}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1, 3 + 3^Rational[1, 2]}, {0.56, 4.732050807568878}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.56, 4.732050807568878}, {0.44, 4.732050807568877}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.44, 4.732050807568877}, {0, 3 + 3^Rational[1, 2]}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.56, 4.732050807568878}, {0.527165150174701, 4.580378687058413}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.44, 4.732050807568877}, {0.3677693343205658, 4.3983998760808}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.527165150174701, 4.580378687058413}, {0.3677693343205658, 4.3983998760808}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{0.3677693343205658, 4.3983998760808}, {0.6050655155047333, 4.351348455782979}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.1074477689195183`, 3.8955728073739246`}, {1.3364780001949526`, 3.973473172703957}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.3364780001949526`, 3.973473172703957}, {1.8388602536097376`, 3.517697524294902}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.2585776348649202`, 4.202503403979391}, {1.7609598882797053`, 3.746727755570336}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.3364780001949526`, 3.973473172703957}, {1.2585776348649202`, 4.202503403979391}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{Rational[-1, 2] + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + Rational[3, 2] 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}, {1.4849742261192858`, 4.452050807568877}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4849742261192858`, 4.452050807568877}, {1.381051177665153, 4.512050807568877}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.381051177665153, 4.512050807568877}, {1, 3 + 3^Rational[1, 2]}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4849742261192858`, 4.452050807568877}, {1.2585776348649202`, 4.202503403979391}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.381051177665153, 4.512050807568877}, {1.029547403589486, 4.124603038649359}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.2585776348649202`, 4.202503403979391}, {1.029547403589486, 4.124603038649359}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.029547403589486, 4.124603038649359}, {1.1074477689195183`, 3.8955728073739246`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.8388602536097376`, 3.517697524294902}, {1.998256069463873, 3.6996763352725166`}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.998256069463873, 3.6996763352725166`}, {2.644160486119831, 3.906864304935664}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.7609598882797053`, 3.746727755570336}, {2.4068643049356635`, 3.953915725233485}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.998256069463873, 3.6996763352725166`}, {1.7609598882797053`, 3.746727755570336}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{1.7609598882797053`, 3.746727755570336}, {1.8388602536097376`, 3.517697524294902}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.644160486119831, 3.906864304935664}, {2.6912119064176516`, 4.144160486119831}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.6912119064176516`, 4.144160486119831}, {3.3371163230736105`, 4.351348455782979}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.4539157252334842`, 4.191211906417652}, {3.099820141889443, 4.3983998760808}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.6912119064176516`, 4.144160486119831}, {2.4539157252334842`, 4.191211906417652}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1 + 3^Rational[1, 2], 3 + 3^Rational[1, 2]}, {2.350999629903724, 4.512050807568877}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.350999629903724, 4.512050807568877}, {2.2470765814495914`, 4.4520508075688765`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.2470765814495914`, 4.4520508075688765`}, {Rational[-1, 2] + Rational[1, 2] (3 + 3^Rational[1, 2]), 3 + Rational[3, 2] 3^Rational[1, 2] + Rational[1, 2] (-1 - 3^Rational[1, 2])}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.350999629903724, 4.512050807568877}, {2.4539157252334842`, 4.191211906417652}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{2.2470765814495914`, 4.4520508075688765`}, {2.4068643049356635`, 3.953915725233485}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.4539157252334842`, 4.191211906417652}, {2.4068643049356635`, 3.953915725233485}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.4068643049356635`, 3.953915725233485}, {2.644160486119831, 3.906864304935664}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.3371163230736105`, 4.351348455782979}, {3.8394985764883955`, 3.8955728073739246`}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.259215957743578, 4.580378687058413}, {3.7615982111583635`, 4.124603038649359}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.3371163230736105`, 4.351348455782979}, {3.259215957743578, 4.580378687058413}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2 + 3^Rational[1, 2], 3 + 3^Rational[1, 2]}, {3.2920508075688772`, 4.732050807568878}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.2920508075688772`, 4.732050807568878}, {3.172050807568877, 4.732050807568877}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.172050807568877, 4.732050807568877}, {1 + 3^Rational[1, 2], 3 + 3^Rational[1, 2]}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.2920508075688772`, 4.732050807568878}, {3.259215957743578, 4.580378687058413}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.172050807568877, 4.732050807568877}, {3.099820141889443, 4.3983998760808}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.259215957743578, 4.580378687058413}, {3.099820141889443, 4.3983998760808}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{3.099820141889443, 4.3983998760808}, {3.3371163230736105`, 4.351348455782979}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.8394985764883955`, 3.8955728073739246`}, {4.06852880776383, 3.973473172703957}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{Rational[3, 2] + Rational[3, 2] 3^Rational[1, 2], Rational[5, 2] + Rational[1, 2] 3^Rational[1, 2]}, {4.318076211353316, 3.7470765814495914`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.318076211353316, 3.7470765814495914`}, {4.378076211353315, 3.8509996299037246`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.378076211353315, 3.8509996299037246`}, {2 + Rational[3, 2] 3^Rational[1, 2], Rational[5, 2] + 3^Rational[1, 2]}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.318076211353316, 3.7470765814495914`}, {4.06852880776383, 3.973473172703957}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.378076211353315, 3.8509996299037246`}, {3.9906284424337977`, 4.202503403979391}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.06852880776383, 3.973473172703957}, {3.9906284424337977`, 4.202503403979391}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2 + Rational[3, 2] 3^Rational[1, 2], Rational[5, 2] + 3^Rational[1, 2]}, {4.217025033688163, 4.452050807568877}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.217025033688163, 4.452050807568877}, {4.11310198523403, 4.512050807568877}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.11310198523403, 4.512050807568877}, {2 + 3^Rational[1, 2], 3 + 3^Rational[1, 2]}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.217025033688163, 4.452050807568877}, {3.9906284424337977`, 4.202503403979391}}]}, {RGBColor[1, 0, 1], AbsoluteThickness[0.8], AbsoluteDashing[{3, 3}], CapForm["Round"], JoinForm["Round"], Line[{{4.11310198523403, 4.512050807568877}, {3.7615982111583635`, 4.124603038649359}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.9906284424337977`, 4.202503403979391}, {3.7615982111583635`, 4.124603038649359}}]}, {RGBColor[0, 0, Rational[4, 9]], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.7615982111583635`, 4.124603038649359}, {3.8394985764883955`, 3.8955728073739246`}}]}}}], {192., -154.71050117156958`}, ImageScaled[{0.5, 0.5}], {360., 294.68666889822777`}], Inset[Graphics[{{{Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0, 0}, {0.44, 0.}, {0.5112914975617392, 0.32931268658412555`}, {2.694222958124177*^-17, 0.44}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.44, 0.}, {0.33074431341476407`, 0.049630584812076446`}, {0.4414316268306383, 0.5609220823738156}, {0.5112914975617392, 0.32931268658412555`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.33074431341476407`, 0.049630584812076446`}, {0.7707443134147639, 0.04963058481207657}, {1.1517954910799169`, -0.17036941518792328`}, {1.5897182969013817`, 0.31233440362790943`}, {0.4414316268306383, 0.5609220823738156}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.5112914975617392, 0.32931268658412555`}, {0.4414316268306383, 0.5609220823738156}, {0.20982223104094821`, 0.4910622116427148}, {0.2796821017720491, 0.25945281585302465`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.4414316268306383, 0.5609220823738156}, {1.5897182969013817`, 0.31233440362790943`}, {1.3581089011116916`, 0.242474532896809}, {0.20982223104094821`, 0.4910622116427148}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.20982223104094821`, 0.4910622116427148}, {1.3581089011116916`, 0.242474532896809}, {0.9992488109380793, 1.3612137993780657`}, {0.35334439428212117`, 1.1540258297149173`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.20982223104094821`, 0.4910622116427148}, {0.35334439428212117`, 1.1540258297149173`}, {0.4232042650132223, 0.9224164339252274}, {0.2796821017720491, 0.25945281585302465`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.2796821017720491, 0.25945281585302465`}, {0.4232042650132223, 0.9224164339252274}, {-0.07917798840156332, 1.3781920823342815`}, {-0.4306817624772293, 0.9907443134147638}, {-0.04963058481207653, 0.7707443134147638}, {-0.04963058481207645, 0.3307443134147641}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.04963058481207645, 0.3307443134147641}, {2.694222958124177*^-17, 0.44}, {0.5112914975617392, 0.32931268658412555`}, {0.2796821017720491, 0.25945281585302465`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.1517954910799169`, -0.17036941518792328`}, {1.08199258339523, -0.07276022464336904}, {1.6450225720379967`, 0.5478439595024959}, {1.5897182969013817`, 0.31233440362790943`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.08199258339523, -0.07276022464336904}, {1.4630437610603828`, -0.29276022464336887`}, {1.844094938725536, -0.07276022464336906}, {1.6450225720379967`, 0.5478439595024959}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.5897182969013817`, 0.31233440362790943`}, {1.6450225720379967`, 0.5478439595024959}, {1.4687174513849217`, 0.713493644645982}, {1.2371080555952312`, 0.6436337739148814}, {1.1818037804586163`, 0.40812421804029475`}, {1.3581089011116916`, 0.242474532896809}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.844094938725536, -0.07276022464336906}, {1.7246614462287728`, -0.08440672068405058}, {1.4687174513849217`, 0.713493644645982}, {1.6450225720379967`, 0.5478439595024959}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.7246614462287728`, -0.08440672068405058}, {2.1057126238939254`, 0.1355932793159488}, {2.5457126238939254`, 0.13559327931594795`}, {2.6170041214556647`, 0.4649059659000735}, {1.4687174513849217`, 0.713493644645982}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.4687174513849217`, 0.713493644645982}, {2.6170041214556647`, 0.4649059659000735}, {2.385394725665974, 0.3950460951689728}, {1.2371080555952312`, 0.6436337739148814}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.2371080555952312`, 0.6436337739148814}, {2.385394725665974, 0.3950460951689728}, {2.528916888907149, 1.058009713241175}, {2.026534635492365, 1.5137853616502306`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.2371080555952312`, 0.6436337739148814}, {2.026534635492365, 1.5137853616502306`}, {1.9712303603557482`, 1.2782758057756451`}, {1.1818037804586163`, 0.40812421804029475`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.1818037804586163`, 0.40812421804029475`}, {1.9712303603557482`, 1.2782758057756451`}, {1.468848106940963, 1.7340514541846999`}, {0.8229436902850044, 1.5268634845215519`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.1818037804586163`, 0.40812421804029475`}, {0.8229436902850044, 1.5268634845215519`}, {0.9992488109380793, 1.3612137993780657`}, {1.3581089011116916`, 0.242474532896809}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.5457126238939254`, 0.13559327931594795`}, {2.4364569373086895`, 0.18522386412802455`}, {2.547144250724564, 0.6965153616897637}, {2.6170041214556647`, 0.4649059659000735}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.4364569373086895`, 0.18522386412802455`}, {2.8764569373086895`, 0.1852238641280243}, {3.257508114973843, -0.03477613587197709}, {3.6954309207953067`, 0.44792768294385654`}, {2.547144250724564, 0.6965153616897637}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.6170041214556647`, 0.4649059659000735}, {2.547144250724564, 0.6965153616897637}, {2.3155348549348744`, 0.6266554909586628}, {2.385394725665974, 0.3950460951689728}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.547144250724564, 0.6965153616897637}, {3.6954309207953067`, 0.44792768294385654`}, {3.4638215250056175`, 0.37806781221275376`}, {2.3155348549348744`, 0.6266554909586628}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.3155348549348744`, 0.6266554909586628}, {3.4638215250056175`, 0.37806781221275376`}, {3.104961434832007, 1.4968070786940113`}, {2.4590570181760496`, 1.2896191090308649`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.3155348549348744`, 0.6266554909586628}, {2.4590570181760496`, 1.2896191090308649`}, {2.528916888907149, 1.058009713241175}, {2.385394725665974, 0.3950460951689728}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.257508114973843, -0.03477613587197709}, {3.187705207289156, 0.06283305467257747}, {3.750735195931921, 0.6834372388184431}, {3.6954309207953067`, 0.44792768294385654`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.187705207289156, 0.06283305467257747}, {3.5687563849543094`, -0.15716694532742184`}, {3.949807562619462, 0.06283305467257849}, {3.750735195931921, 0.6834372388184431}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.6954309207953067`, 0.44792768294385654`}, {3.750735195931921, 0.6834372388184431}, {3.574430075278845, 0.8490869239619281}, {3.342820679489159, 0.779227053230827}, {3.2875164043525427`, 0.54371749735624}, {3.4638215250056175`, 0.37806781221275376`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.949807562619462, 0.06283305467257849}, {3.8303740701226983`, 0.05118655863189633}, {3.574430075278845, 0.8490869239619281}, {3.750735195931921, 0.6834372388184431}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.8303740701226983`, 0.05118655863189633}, {4.21142524778785, 0.27118655863189683`}, {4.211425247787849, 0.711186558631897}, {3.574430075278845, 0.8490869239619281}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.211425247787849, 0.711186558631897}, {4.161794662975776, 0.6019308720466546}, {3.342820679489159, 0.779227053230827}, {3.574430075278845, 0.8490869239619281}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{4.161794662975776, 0.6019308720466546}, {4.161794662975778, 1.0419308720466536`}, {3.780743485310626, 1.261930872046656}, {3.342820679489159, 0.779227053230827}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.780743485310626, 1.261930872046656}, {3.8505463929953123`, 1.1643216815021018`}, {3.2875164043525427`, 0.54371749735624}, {3.342820679489159, 0.779227053230827}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.8505463929953123`, 1.1643216815021018`}, {3.4694952153301597`, 1.384321681502103}, {3.2494952153301617`, 1.7653728591672573`}, {2.9286563141789363`, 1.6624567638374985`}, {3.2875164043525427`, 0.54371749735624}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.2875164043525427`, 0.54371749735624}, {2.9286563141789363`, 1.6624567638374985`}, {3.104961434832007, 1.4968070786940113`}, {3.4638215250056175`, 0.37806781221275376`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.7419300324576955, 1.1131351228702093`}, {-0.36087885479254256`, 0.8931351228702095}, {-0.1344822635381778, 1.142682526459695}, {-0.5219300324576972, 1.4941863005353606`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.36087885479254256`, 0.8931351228702095}, {-0.4306817624772293, 0.9907443134147638}, {-0.07917798840156332, 1.3781920823342815`}, {-0.1344822635381778, 1.142682526459695}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.1344822635381778, 1.142682526459695}, {-0.07917798840156332, 1.3781920823342815`}, {-0.31468754427615014`, 1.4334963574708959`}, {-0.3699918194127645, 1.1979868015963093`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.07917798840156332, 1.3781920823342815`}, {0.4232042650132223, 0.9224164339252274}, {0.18769470913863565`, 0.9777207090618419}, {-0.31468754427615014`, 1.4334963574708959`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.31468754427615014`, 1.4334963574708959`}, {0.18769470913863565`, 0.9777207090618419}, {0.8335991257945938, 1.1849086787249905`}, {0.47473903562098047`, 2.303647945206248}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.31468754427615014`, 1.4334963574708959`}, {0.47473903562098047`, 2.303647945206248}, {0.41943476048436557`, 2.0681383893316623`}, {-0.3699918194127645, 1.1979868015963093`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.3699918194127645, 1.1979868015963093`}, {0.41943476048436557`, 2.0681383893316623`}, {-0.39953922300225353`, 2.2454345705158247`}, {-0.3995392230022522, 1.8054345705158275`}, {-0.6195392230022512, 1.4243833928506737`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.6195392230022512, 1.4243833928506737`}, {-0.5219300324576972, 1.4941863005353606`}, {-0.1344822635381778, 1.142682526459695}, {-0.3699918194127645, 1.1979868015963093`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.4232042650132223, 0.9224164339252274}, {0.35334439428212117`, 1.1540258297149173`}, {0.18769470913863565`, 0.9777207090618419}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.35334439428212117`, 1.1540258297149173`}, {0.9992488109380793, 1.3612137993780657`}, {0.8335991257945938, 1.1849086787249905`}, {0.18769470913863565`, 0.9777207090618419}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.9992488109380793, 1.3612137993780657`}, {0.8229436902850044, 1.5268634845215519`}, {0.6572940051415186, 1.3505583638684762`}, {0.8335991257945938, 1.1849086787249905`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.8229436902850044, 1.5268634845215519`}, {1.468848106940963, 1.7340514541846999`}, {1.303198421797477, 1.5577463335316255`}, {0.6572940051415186, 1.3505583638684762`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.6572940051415186, 1.3505583638684762`}, {1.303198421797477, 1.5577463335316255`}, {1.4467205850386489`, 2.220709951603829}, {0.298433914967905, 2.4692976303497343`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.6572940051415186, 1.3505583638684762`}, {0.298433914967905, 2.4692976303497343`}, {0.47473903562098047`, 2.303647945206248}, {0.8335991257945938, 1.1849086787249905`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.41943476048436557`, 2.0681383893316623`}, {0.47473903562098047`, 2.303647945206248}, {0.298433914967905, 2.4692976303497343`}, {0.06682451917821522, 2.3994377596186336`}, {0.011520244041599792`, 2.163928203744046}, {0.18782536469467606`, 1.9982785186005605`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.298433914967905, 2.4692976303497343`}, {1.4467205850386489`, 2.220709951603829}, {1.215111189248959, 2.1508500808727278`}, {0.06682451917821522, 2.3994377596186336`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.06682451917821522, 2.3994377596186336`}, {1.215111189248959, 2.1508500808727278`}, {1.358633352490132, 2.8138136989449305`}, {0.8562510990753464, 3.2695893473539863`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.06682451917821522, 2.3994377596186336`}, {0.8562510990753464, 3.2695893473539863`}, {0.8009468239387302, 3.0340797914793987`}, {0.011520244041599792`, 2.163928203744046}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.011520244041599792`, 2.163928203744046}, {0.8009468239387302, 3.0340797914793987`}, {0.2985645705239441, 3.489855439888452}, {-0.34733984613201435`, 3.2826674702253023`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.011520244041599792`, 2.163928203744046}, {-0.34733984613201435`, 3.2826674702253023`}, {-0.1710347254789424, 3.117017785081816}, {0.18782536469467606`, 1.9982785186005605`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.18782536469467606`, 1.9982785186005605`}, {-0.1710347254789424, 3.117017785081816}, {-0.6691698078143345, 2.9572300615957405`}, {-0.4491698078143325, 2.5761788839305884`}, {-0.44916980781432936`, 2.1361788839305884`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.44916980781432936`, 2.1361788839305884`}, {-0.39953922300225353`, 2.2454345705158247`}, {0.41943476048436557`, 2.0681383893316623`}, {0.18782536469467606`, 1.9982785186005605`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.4467205850386489`, 2.220709951603829}, {1.303198421797477, 1.5577463335316255`}, {1.2333385510663764`, 1.7893557293213145`}, {1.376860714307549, 2.4523193473935168`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.376860714307549, 2.4523193473935168`}, {1.2333385510663764`, 1.7893557293213145`}, {1.7357208044811616`, 1.3335800809122595`}, {2.5251473843782923`, 2.203731668647611}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.4467205850386489`, 2.220709951603829}, {1.376860714307549, 2.4523193473935168`}, {1.1452513185178592`, 2.3824594766624156`}, {1.215111189248959, 2.1508500808727278`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.376860714307549, 2.4523193473935168`}, {2.5251473843782923`, 2.203731668647611}, {2.2935379885886027`, 2.13387179791651}, {1.1452513185178592`, 2.3824594766624156`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.1452513185178592`, 2.3824594766624156`}, {2.2935379885886027`, 2.13387179791651}, {1.9346778984149884`, 3.252611064397767}, {1.2887734817590313`, 3.045423094734619}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.1452513185178592`, 2.3824594766624156`}, {1.2887734817590313`, 3.045423094734619}, {1.358633352490132, 2.8138136989449305`}, {1.215111189248959, 2.1508500808727278`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.468848106940963, 1.7340514541846999`}, {1.9712303603557482`, 1.2782758057756451`}, {1.7357208044811616`, 1.3335800809122595`}, {1.2333385510663764`, 1.7893557293213145`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.468848106940963, 1.7340514541846999`}, {1.2333385510663764`, 1.7893557293213145`}, {1.303198421797477, 1.5577463335316255`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.9712303603557482`, 1.2782758057756451`}, {2.026534635492365, 1.5137853616502306`}, {1.7910250796177782`, 1.569089636786846}, {1.7357208044811616`, 1.3335800809122595`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.026534635492365, 1.5137853616502306`}, {2.528916888907149, 1.058009713241175}, {2.2934073330325626`, 1.1133139883777896`}, {1.7910250796177782`, 1.569089636786846}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.7910250796177782`, 1.569089636786846}, {2.2934073330325626`, 1.1133139883777896`}, {2.939311749688521, 1.3205019580409374`}, {2.580451659514911, 2.4392412245221955`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.7910250796177782`, 1.569089636786846}, {2.580451659514911, 2.4392412245221955`}, {2.5251473843782923`, 2.203731668647611}, {1.7357208044811616`, 1.3335800809122595`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.528916888907149, 1.058009713241175}, {2.4590570181760496`, 1.2896191090308649`}, {2.2934073330325626`, 1.1133139883777896`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.4590570181760496`, 1.2896191090308649`}, {3.104961434832007, 1.4968070786940113`}, {2.939311749688521, 1.3205019580409374`}, {2.2934073330325626`, 1.1133139883777896`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.104961434832007, 1.4968070786940113`}, {2.9286563141789363`, 1.6624567638374985`}, {2.7630066290354454`, 1.4861516431844226`}, {2.939311749688521, 1.3205019580409374`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.2494952153301617`, 1.7653728591672573`}, {3.261141711370838, 1.6459393666704967`}, {2.7630066290354454`, 1.4861516431844226`}, {2.9286563141789363`, 1.6624567638374985`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.261141711370838, 1.6459393666704967`}, {3.04114171137084, 2.0269905443356486`}, {3.041141711370841, 2.4669905443356486`}, {2.4041465388618364`, 2.604890909665682}, {2.7630066290354454`, 1.4861516431844226`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.7630066290354454`, 1.4861516431844226`}, {2.4041465388618364`, 2.604890909665682}, {2.580451659514911, 2.4392412245221955`}, {2.939311749688521, 1.3205019580409374`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.5251473843782923`, 2.203731668647611}, {2.580451659514911, 2.4392412245221955`}, {2.4041465388618364`, 2.604890909665682}, {2.1725371430721467`, 2.535031038934582}, {2.117232867935527, 2.2995214830599955`}, {2.2935379885886027`, 2.13387179791651}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.041141711370841, 2.4669905443356486`}, {2.9915111265587644`, 2.357734857750413}, {2.1725371430721467`, 2.535031038934582}, {2.4041465388618364`, 2.604890909665682}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.9915111265587644`, 2.357734857750413}, {2.991511126558765, 2.7977348577504135`}, {3.2115111265587646`, 3.178786035415567}, {2.961963722969279, 3.4051826266699328`}, {2.1725371430721467`, 2.535031038934582}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.1725371430721467`, 2.535031038934582}, {2.961963722969279, 3.4051826266699328`}, {2.906659447832658, 3.169673070795347}, {2.117232867935527, 2.2995214830599955`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.117232867935527, 2.2995214830599955`}, {2.906659447832658, 3.169673070795347}, {2.4042771944178725`, 3.625448719204401}, {1.758372777761914, 3.4182607495412523`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.117232867935527, 2.2995214830599955`}, {1.758372777761914, 3.4182607495412523`}, {1.9346778984149884`, 3.252611064397767}, {2.2935379885886027`, 2.13387179791651}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.1710347254789424, 3.117017785081816}, {-0.34733984613201435`, 3.2826674702253023`}, {-0.5129895312754995, 3.106362349572226}, {-0.33668441062242827`, 2.9407126644287405`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.34733984613201435`, 3.2826674702253023`}, {0.2985645705239441, 3.489855439888452}, {0.1329148853804587, 3.3135503192353757`}, {-0.5129895312754995, 3.106362349572226}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.5129895312754995, 3.106362349572226}, {0.1329148853804587, 3.3135503192353757`}, {0.20514555105989152`, 3.6472012507234526`}, {-0.2348544489401077, 3.6472012507234517`}, {-0.6159056266052603, 3.4272012507234506`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.6159056266052603, 3.4272012507234506`}, {-0.49647213410850094`, 3.438847746764132}, {-0.33668441062242827`, 2.9407126644287405`}, {-0.5129895312754995, 3.106362349572226}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.49647213410850094`, 3.438847746764132}, {-0.8775233117736534, 3.218847746764129}, {-0.6575233117736515, 2.8377965690989773`}, {-0.33668441062242827`, 2.9407126644287405`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{-0.6575233117736515, 2.8377965690989773`}, {-0.6691698078143345, 2.9572300615957405`}, {-0.1710347254789424, 3.117017785081816}, {-0.33668441062242827`, 2.9407126644287405`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.2985645705239441, 3.489855439888452}, {0.8009468239387302, 3.0340797914793987`}, {0.5654372680641437, 3.0893840666160135`}, {0.06305501464935748, 3.545159715025066}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.06305501464935748, 3.545159715025066}, {0.5654372680641437, 3.0893840666160135`}, {0.9169410421398096, 3.4768318355355325`}, {0.5358898644746559, 3.696831835535532}, {0.09588986447465622, 3.6968318355355305`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.2985645705239441, 3.489855439888452}, {0.06305501464935748, 3.545159715025066}, {0.1329148853804587, 3.3135503192353757`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.09588986447465622, 3.6968318355355305`}, {0.20514555105989152`, 3.6472012507234526`}, {0.1329148853804587, 3.3135503192353757`}, {0.06305501464935748, 3.545159715025066}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.8009468239387302, 3.0340797914793987`}, {0.8562510990753464, 3.2695893473539863`}, {0.6207415432007599, 3.324893622490601}, {0.5654372680641437, 3.0893840666160135`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.8562510990753464, 3.2695893473539863`}, {1.358633352490132, 2.8138136989449305`}, {1.1231237966155456`, 2.8691179740815467`}, {0.6207415432007599, 3.324893622490601}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.6207415432007599, 3.324893622490601}, {1.1231237966155456`, 2.8691179740815467`}, {1.7690282132715027`, 3.0763059437446914`}, {1.6092404897854298`, 3.5744410260800823`}, {1.2281893121202783`, 3.354441026080088}, {0.8471381344551252, 3.5744410260800876`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{0.8471381344551252, 3.5744410260800876`}, {0.9169410421398096, 3.4768318355355325`}, {0.5654372680641437, 3.0893840666160135`}, {0.6207415432007599, 3.324893622490601}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.358633352490132, 2.8138136989449305`}, {1.2887734817590313`, 3.045423094734619}, {1.1231237966155456`, 2.8691179740815467`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.2887734817590313`, 3.045423094734619}, {1.9346778984149884`, 3.252611064397767}, {1.7690282132715027`, 3.0763059437446914`}, {1.1231237966155456`, 2.8691179740815467`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.9346778984149884`, 3.252611064397767}, {1.758372777761914, 3.4182607495412523`}, {1.5927230926184288`, 3.2419556288881766`}, {1.7690282132715027`, 3.0763059437446914`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.758372777761914, 3.4182607495412523`}, {2.4042771944178725`, 3.625448719204401}, {2.2386275092743873`, 3.4491435985513252`}, {1.5927230926184288`, 3.2419556288881766`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.5927230926184288`, 3.2419556288881766`}, {2.2386275092743873`, 3.4491435985513252`}, {2.31085817495382, 3.7827945300394017`}, {1.8708581749538211`, 3.7827945300394017`}, {1.4898069972886685`, 3.562794530039401}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{1.4898069972886685`, 3.562794530039401}, {1.6092404897854298`, 3.5744410260800823`}, {1.7690282132715027`, 3.0763059437446914`}, {1.5927230926184288`, 3.2419556288881766`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.4042771944178725`, 3.625448719204401}, {2.906659447832658, 3.169673070795347}, {2.6711498919580716`, 3.224977345931962}, {2.168767638543286, 3.6807529943410158`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.168767638543286, 3.6807529943410158`}, {2.6711498919580716`, 3.224977345931962}, {3.022653666033738, 3.6124251148514803`}, {2.6416024883685854`, 3.8324251148514805`}, {2.2016024883685854`, 3.83242511485148}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.4042771944178725`, 3.625448719204401}, {2.168767638543286, 3.6807529943410158`}, {2.2386275092743873`, 3.4491435985513252`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.2016024883685854`, 3.83242511485148}, {2.31085817495382, 3.7827945300394017`}, {2.2386275092743873`, 3.4491435985513252`}, {2.168767638543286, 3.6807529943410158`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.906659447832658, 3.169673070795347}, {2.961963722969279, 3.4051826266699328`}, {2.7264541670946927`, 3.460486901806548}, {2.6711498919580716`, 3.224977345931962}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.2115111265587646`, 3.178786035415567}, {3.1139019360142095`, 3.108983127730881}, {2.7264541670946927`, 3.460486901806548}, {2.961963722969279, 3.4051826266699328`}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{3.1139019360142095`, 3.108983127730881}, {3.3339019360142106`, 3.490034305396033}, {2.9528507583490584`, 3.7100343053960336`}, {2.7264541670946927`, 3.460486901806548}}]}, {Opacity[0.5], EdgeForm[None], FaceForm[RGBColor[0.92, 0.85, 1]], Polygon[{{2.9528507583490584`, 3.7100343053960336`}, {3.022653666033738, 3.6124251148514803`}, {2.6711498919580716`, 3.224977345931962}, {2.7264541670946927`, 3.460486901806548}}]}}, {{GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0., 0}, {0.44, 0}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0, 0.}, {0., 0.31999999999999984`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0., 0.31999999999999984`}, {0, 0.44}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.44, 0.}, {0.33074431341476407`, 0.049630584812076446`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.44, 0.}, {0.5112914975617392, 0.32931268658412555`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.4507443134147641, 0.04963058481207648}, {0.7707443134147639, 0.04963058481207657}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.33074431341476407`, 0.049630584812076446`}, {0.4507443134147641, 0.04963058481207648}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.33074431341476407`, 0.049630584812076446`}, {0.4414316268306383, 0.5609220823738156}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.5112914975617392, 0.32931268658412555`}, {0.4414316268306383, 0.5609220823738156}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.5112914975617392, 0.32931268658412555`}, {0., 0.44}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.5112914975617392, 0.32931268658412555`}, {0.2796821017720491, 0.25945281585302465`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.7707443134147639, 0.04963058481207657}, {1.1517954910799169`, -0.17036941518792328`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.4414316268306383, 0.5609220823738156}, {0.20982223104094821`, 0.4910622116427148}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.4414316268306383, 0.5609220823738156}, {1.4573574645381433`, 0.3409886351292003}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.4573574645381433`, 0.3409886351292003}, {1.5897182969013817`, 0.31233440362790943`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.20982223104094821`, 0.4910622116427148}, {0.2796821017720491, 0.25945281585302465`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.20982223104094821`, 0.4910622116427148}, {1.3581089011116916`, 0.242474532896809}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.20982223104094821`, 0.4910622116427148}, {0.32469016278083035`, 1.021664997351679}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.32469016278083035`, 1.021664997351679}, {0.35334439428212117`, 1.1540258297149173`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.04963058481207653, 0.7707443134147638}, {-0.04963058481207645, 0.3307443134147641}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.04963058481207653, 0.7707443134147638}, {-0.3267587140230967, 0.9307443134147637}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3267587140230967, 0.9307443134147637}, {-0.4306817624772293, 0.9907443134147638}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.04963058481207645, 0.3307443134147641}, {0., 0.44}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.04963058481207645, 0.3307443134147641}, {0.2796821017720491, 0.25945281585302465`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.2796821017720491, 0.25945281585302465`}, {0.4232042650132223, 0.9224164339252274}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.1517954910799169`, -0.17036941518792328`}, {1.08199258339523, -0.07276022464336904}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.1517954910799169`, -0.17036941518792328`}, {1.1859156318493627`, -0.13276022464336903`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.1859156318493627`, -0.13276022464336903`}, {1.5897182969013817`, 0.31233440362790943`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.08199258339523, -0.07276022464336904}, {1.4630437610603828`, -0.29276022464336887`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.08199258339523, -0.07276022464336904}, {1.5540268634503396`, 0.4475432319605237}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.5540268634503396`, 0.4475432319605237}, {1.6450225720379967`, 0.5478439595024959}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.5897182969013817`, 0.31233440362790943`}, {1.6450225720379967`, 0.5478439595024959}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.5897182969013817`, 0.31233440362790943`}, {1.3581089011116916`, 0.242474532896809}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4630437610603828`, -0.29276022464336887`}, {1.844094938725536, -0.07276022464336906}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.844094938725536, -0.07276022464336906}, {1.7246614462287728`, -0.08440672068405058}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.844094938725536, -0.07276022464336906}, {1.8285844946829055`, -0.024406720684050635`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.8285844946829055`, -0.024406720684050635`}, {1.6450225720379967`, 0.5478439595024959}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.7246614462287728`, -0.08440672068405058}, {2.1057126238939254`, 0.1355932793159488}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.7246614462287728`, -0.08440672068405058}, {1.5100825751605027`, 0.5845386856027184}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.5100825751605027`, 0.5845386856027184}, {1.4687174513849217`, 0.713493644645982}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.6450225720379967`, 0.5478439595024959}, {1.4687174513849217`, 0.713493644645982}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.1057126238939254`, 0.1355932793159488}, {2.5457126238939254`, 0.13559327931594795`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.4687174513849217`, 0.713493644645982}, {1.2371080555952312`, 0.6436337739148814}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.4687174513849217`, 0.713493644645982}, {2.6170041214556647`, 0.4649059659000735}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2371080555952312`, 0.6436337739148814}, {1.1818037804586163`, 0.40812421804029475`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.3694688879584695`, 0.6149795424135903}, {2.385394725665974, 0.3950460951689728}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2371080555952312`, 0.6436337739148814}, {1.3694688879584695`, 0.6149795424135903}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2371080555952312`, 0.6436337739148814}, {2.026534635492365, 1.5137853616502306`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.1818037804586163`, 0.40812421804029475`}, {1.3581089011116916`, 0.242474532896809}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.1818037804586163`, 0.40812421804029475`}, {0.8229436902850044, 1.5268634845215519`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.2727994890462735`, 0.5084249455822671}, {1.9712303603557482`, 1.2782758057756451`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.1818037804586163`, 0.40812421804029475`}, {1.2727994890462735`, 0.5084249455822671}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.3167437773361104`, 0.3714294919400721}, {0.9992488109380793, 1.3612137993780657`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.3581089011116916`, 0.242474532896809}, {1.3167437773361104`, 0.3714294919400721}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.5457126238939254`, 0.13559327931594795`}, {2.4364569373086895`, 0.18522386412802455`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.5457126238939254`, 0.13559327931594795`}, {2.6170041214556647`, 0.4649059659000735}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.5564569373086896`, 0.1852238641280245}, {2.8764569373086895`, 0.1852238641280243}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.4364569373086895`, 0.18522386412802455`}, {2.5564569373086896`, 0.1852238641280245}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.4364569373086895`, 0.18522386412802455`}, {2.547144250724564, 0.6965153616897637}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.6170041214556647`, 0.4649059659000735}, {2.547144250724564, 0.6965153616897637}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.6170041214556647`, 0.4649059659000735}, {2.385394725665974, 0.3950460951689728}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.8764569373086895`, 0.1852238641280243}, {3.257508114973843, -0.03477613587197709}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.547144250724564, 0.6965153616897637}, {2.3155348549348744`, 0.6266554909586628}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.547144250724564, 0.6965153616897637}, {3.563070088432068, 0.47658191444514747`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.563070088432068, 0.47658191444514747`}, {3.6954309207953067`, 0.44792768294385654`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.3155348549348744`, 0.6266554909586628}, {2.385394725665974, 0.3950460951689728}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.3155348549348744`, 0.6266554909586628}, {3.4638215250056175`, 0.37806781221275376`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.3155348549348744`, 0.6266554909586628}, {2.430402786674758, 1.1572582766676267`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.430402786674758, 1.1572582766676267`}, {2.4590570181760496`, 1.2896191090308649`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.385394725665974, 0.3950460951689728}, {2.528916888907149, 1.058009713241175}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.257508114973843, -0.03477613587197709}, {3.187705207289156, 0.06283305467257747}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.257508114973843, -0.03477613587197709}, {3.291628255743289, 0.0028330546725774675`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.291628255743289, 0.0028330546725774675`}, {3.6954309207953067`, 0.44792768294385654`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.187705207289156, 0.06283305467257747}, {3.5687563849543094`, -0.15716694532742184`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.187705207289156, 0.06283305467257747}, {3.6597394873442637`, 0.5831365112764698}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.6597394873442637`, 0.5831365112764698}, {3.750735195931921, 0.6834372388184431}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.6954309207953067`, 0.44792768294385654`}, {3.750735195931921, 0.6834372388184431}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.6954309207953067`, 0.44792768294385654`}, {3.4638215250056175`, 0.37806781221275376`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.5687563849543094`, -0.15716694532742184`}, {3.949807562619462, 0.06283305467257849}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.949807562619462, 0.06283305467257849}, {3.8303740701226983`, 0.05118655863189633}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.949807562619462, 0.06283305467257849}, {3.9342971185768314`, 0.1111865586318969}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.9342971185768314`, 0.1111865586318969}, {3.750735195931921, 0.6834372388184431}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.8303740701226983`, 0.05118655863189633}, {4.21142524778785, 0.27118655863189683`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.8303740701226983`, 0.05118655863189633}, {3.6157951990544266`, 0.7201319649186635}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.6157951990544266`, 0.7201319649186635}, {3.574430075278845, 0.8490869239619281}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.750735195931921, 0.6834372388184431}, {3.574430075278845, 0.8490869239619281}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.21142524778785, 0.27118655863189683`}, {4.211425247787849, 0.711186558631897}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.211425247787849, 0.711186558631897}, {4.161794662975776, 0.6019308720466546}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.211425247787849, 0.711186558631897}, {4.161794662975776, 0.7219308720466602}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{4.161794662975776, 0.7219308720466602}, {3.574430075278845, 0.8490869239619281}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.161794662975776, 0.6019308720466546}, {4.161794662975778, 1.0419308720466536`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.161794662975776, 0.6019308720466546}, {3.4751815118523974`, 0.7505728217295352}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.4751815118523974`, 0.7505728217295352}, {3.342820679489159, 0.779227053230827}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.574430075278845, 0.8490869239619281}, {3.342820679489159, 0.779227053230827}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{4.161794662975778, 1.0419308720466536`}, {3.780743485310626, 1.261930872046656}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.780743485310626, 1.261930872046656}, {3.8505463929953123`, 1.1643216815021018`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.780743485310626, 1.261930872046656}, {3.7466233445411805`, 1.224321681502102}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.7466233445411805`, 1.224321681502102}, {3.342820679489159, 0.779227053230827}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.8505463929953123`, 1.1643216815021018`}, {3.4694952153301597`, 1.384321681502103}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.8505463929953123`, 1.1643216815021018`}, {3.3785121129402, 0.6440182248982116}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.3785121129402, 0.6440182248982116}, {3.2875164043525427`, 0.54371749735624}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.342820679489159, 0.779227053230827}, {3.2875164043525427`, 0.54371749735624}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.4694952153301597`, 1.384321681502103}, {3.2494952153301617`, 1.7653728591672573`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.2875164043525427`, 0.54371749735624}, {3.4638215250056175`, 0.37806781221275376`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.2875164043525427`, 0.54371749735624}, {2.9286563141789363`, 1.6624567638374985`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.422456401230036, 0.5070227712560194}, {3.104961434832007, 1.4968070786940113`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.4638215250056175`, 0.37806781221275376`}, {3.422456401230036, 0.5070227712560194}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.7419300324576955, 1.1131351228702093`}, {-0.36087885479254256`, 0.8931351228702095}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.7419300324576955, 1.1131351228702093`}, {-0.5819300324576969, 1.3902632520812281`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.5819300324576969, 1.3902632520812281`}, {-0.5219300324576972, 1.4941863005353606`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.36087885479254256`, 0.8931351228702095}, {-0.4306817624772293, 0.9907443134147638}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.36087885479254256`, 0.8931351228702095}, {-0.1344822635381778, 1.142682526459695}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.4306817624772293, 0.9907443134147638}, {-0.07917798840156332, 1.3781920823342815`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.1344822635381778, 1.142682526459695}, {-0.07917798840156332, 1.3781920823342815`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.1344822635381778, 1.142682526459695}, {-0.5219300324576972, 1.4941863005353606`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.1344822635381778, 1.142682526459695}, {-0.3699918194127645, 1.1979868015963093`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.07917798840156332, 1.3781920823342815`}, {-0.31468754427615014`, 1.4334963574708959`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.07917798840156332, 1.3781920823342815`}, {0.3229035374712495, 1.0134121425128848`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.3229035374712495, 1.0134121425128848`}, {0.4232042650132223, 0.9224164339252274}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.31468754427615014`, 1.4334963574708959`}, {-0.3699918194127645, 1.1979868015963093`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.31468754427615014`, 1.4334963574708959`}, {0.18769470913863565`, 0.9777207090618419}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.31468754427615014`, 1.4334963574708959`}, {0.38374332703332314`, 2.2033472176642754`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.38374332703332314`, 2.2033472176642754`}, {0.47473903562098047`, 2.303647945206248}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3995392230022522, 1.8054345705158275`}, {-0.6195392230022512, 1.4243833928506737`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3995392230022522, 1.8054345705158275`}, {-0.39953922300225353`, 2.2454345705158247`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6195392230022512, 1.4243833928506737`}, {-0.5219300324576972, 1.4941863005353606`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6195392230022512, 1.4243833928506737`}, {-0.3699918194127645, 1.1979868015963093`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.3699918194127645, 1.1979868015963093`}, {0.41943476048436557`, 2.0681383893316623`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.4232042650132223, 0.9224164339252274}, {0.35334439428212117`, 1.1540258297149173`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.4232042650132223, 0.9224164339252274}, {0.18769470913863565`, 0.9777207090618419}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.35334439428212117`, 1.1540258297149173`}, {0.18769470913863565`, 0.9777207090618419}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.35334439428212117`, 1.1540258297149173`}, {0.9992488109380793, 1.3612137993780657`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.3166496681818991, 1.019085832837423}, {0.8335991257945938, 1.1849086787249905`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.18769470913863565`, 0.9777207090618419}, {0.3166496681818991, 1.019085832837423}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.9992488109380793, 1.3612137993780657`}, {0.8229436902850044, 1.5268634845215519`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.9992488109380793, 1.3612137993780657`}, {0.8335991257945938, 1.1849086787249905`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.8229436902850044, 1.5268634845215519`}, {0.6572940051415186, 1.3505583638684762`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.8229436902850044, 1.5268634845215519`}, {1.3398931478976992`, 1.6926863304091189`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.3398931478976992`, 1.6926863304091189`}, {1.468848106940963, 1.7340514541846999`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.6572940051415186, 1.3505583638684762`}, {0.8335991257945938, 1.1849086787249905`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.6572940051415186, 1.3505583638684762`}, {0.3397990387434861, 2.340342671306471}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.3397990387434861, 2.340342671306471}, {0.298433914967905, 2.4692976303497343`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.6572940051415186, 1.3505583638684762`}, {1.303198421797477, 1.5577463335316255`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.8335991257945938, 1.1849086787249905`}, {0.47473903562098047`, 2.303647945206248}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.41943476048436557`, 2.0681383893316623`}, {0.47473903562098047`, 2.303647945206248}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.2870739281211276, 2.0967926208329524`}, {-0.39953922300225353`, 2.2454345705158247`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.41943476048436557`, 2.0681383893316623`}, {0.2870739281211276, 2.0967926208329524`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.41943476048436557`, 2.0681383893316623`}, {0.18782536469467606`, 1.9982785186005605`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.47473903562098047`, 2.303647945206248}, {0.298433914967905, 2.4692976303497343`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.298433914967905, 2.4692976303497343`}, {0.06682451917821522, 2.3994377596186336`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.298433914967905, 2.4692976303497343`}, {1.4467205850386489`, 2.220709951603829}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.06682451917821522, 2.3994377596186336`}, {0.011520244041599792`, 2.163928203744046}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.19918535154145348`, 2.370783528117343}, {1.215111189248959, 2.1508500808727278`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.06682451917821522, 2.3994377596186336`}, {0.19918535154145348`, 2.370783528117343}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.06682451917821522, 2.3994377596186336`}, {0.8562510990753464, 3.2695893473539863`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.011520244041599792`, 2.163928203744046}, {0.18782536469467606`, 1.9982785186005605`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.011520244041599792`, 2.163928203744046}, {-0.34733984613201435`, 3.2826674702253023`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.10251595262925672`, 2.264228931286018}, {0.8009468239387302, 3.0340797914793987`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.011520244041599792`, 2.163928203744046}, {0.10251595262925672`, 2.264228931286018}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.4491698078143325, 2.5761788839305884`}, {-0.44916980781432936`, 2.1361788839305884`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.4491698078143325, 2.5761788839305884`}, {-0.6091698078143339, 2.853307013141608}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6091698078143339, 2.853307013141608}, {-0.6691698078143345, 2.9572300615957405`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.44916980781432936`, 2.1361788839305884`}, {-0.39953922300225353`, 2.2454345705158247`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.44916980781432936`, 2.1361788839305884`}, {-0.39953922300225314`, 2.1254345705158246`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.39953922300225314`, 2.1254345705158246`}, {0.18782536469467606`, 1.9982785186005605`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.14646024091909443`, 2.1272334776438235`}, {-0.1710347254789424, 3.117017785081816}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.18782536469467606`, 1.9982785186005605`}, {0.14646024091909443`, 2.1272334776438235`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4467205850386489`, 2.220709951603829}, {1.376860714307549, 2.4523193473935168`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4467205850386489`, 2.220709951603829}, {1.215111189248959, 2.1508500808727278`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4467205850386489`, 2.220709951603829}, {1.3318526532987676`, 1.690107165894863}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.3318526532987676`, 1.690107165894863}, {1.303198421797477, 1.5577463335316255`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.376860714307549, 2.4523193473935168`}, {1.1452513185178592`, 2.3824594766624156`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.376860714307549, 2.4523193473935168`}, {1.2333385510663764`, 1.7893557293213145`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.376860714307549, 2.4523193473935168`}, {2.392786552015058, 2.232385900148901}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.392786552015058, 2.232385900148901}, {2.5251473843782923`, 2.203731668647611}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.1452513185178592`, 2.3824594766624156`}, {1.215111189248959, 2.1508500808727278`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.1452513185178592`, 2.3824594766624156`}, {2.2935379885886027`, 2.13387179791651}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.1452513185178592`, 2.3824594766624156`}, {1.2601192502577412`, 2.9130622623713833`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2601192502577412`, 2.9130622623713833`}, {1.2887734817590313`, 3.045423094734619}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.215111189248959, 2.1508500808727278`}, {1.358633352490132, 2.8138136989449305`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.468848106940963, 1.7340514541846999`}, {1.2333385510663764`, 1.7893557293213145`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.468848106940963, 1.7340514541846999`}, {1.303198421797477, 1.5577463335316255`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.468848106940963, 1.7340514541846999`}, {1.9712303603557482`, 1.2782758057756451`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2333385510663764`, 1.7893557293213145`}, {1.303198421797477, 1.5577463335316255`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.3336392786083482`, 1.6983600207336573`}, {1.7357208044811616`, 1.3335800809122595`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2333385510663764`, 1.7893557293213145`}, {1.3336392786083482`, 1.6983600207336573`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.9712303603557482`, 1.2782758057756451`}, {2.026534635492365, 1.5137853616502306`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.9712303603557482`, 1.2782758057756451`}, {1.7357208044811616`, 1.3335800809122595`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.026534635492365, 1.5137853616502306`}, {1.7910250796177782`, 1.569089636786846}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.026534635492365, 1.5137853616502306`}, {2.428616161365177, 1.149005421828832}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.428616161365177, 1.149005421828832}, {2.528916888907149, 1.058009713241175}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.7910250796177782`, 1.569089636786846}, {1.7357208044811616`, 1.3335800809122595`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.7910250796177782`, 1.569089636786846}, {2.2934073330325626`, 1.1133139883777896`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.7910250796177782`, 1.569089636786846}, {2.489455950927254, 2.3389404969802228`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.489455950927254, 2.3389404969802228`}, {2.580451659514911, 2.4392412245221955`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.7357208044811616`, 1.3335800809122595`}, {2.5251473843782923`, 2.203731668647611}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.528916888907149, 1.058009713241175}, {2.4590570181760496`, 1.2896191090308649`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.528916888907149, 1.058009713241175}, {2.2934073330325626`, 1.1133139883777896`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.4590570181760496`, 1.2896191090308649`}, {2.2934073330325626`, 1.1133139883777896`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.4590570181760496`, 1.2896191090308649`}, {3.104961434832007, 1.4968070786940113`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.4223622920758263`, 1.1546791121533706`}, {2.939311749688521, 1.3205019580409374`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.2934073330325626`, 1.1133139883777896`}, {2.4223622920758263`, 1.1546791121533706`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.104961434832007, 1.4968070786940113`}, {2.9286563141789363`, 1.6624567638374985`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.104961434832007, 1.4968070786940113`}, {2.939311749688521, 1.3205019580409374`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.2494952153301617`, 1.7653728591672573`}, {3.261141711370838, 1.6459393666704967`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.2494952153301617`, 1.7653728591672573`}, {2.9286563141789363`, 1.6624567638374985`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.2011417113708407`, 1.749862415124626}, {3.04114171137084, 2.0269905443356486`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.261141711370838, 1.6459393666704967`}, {3.2011417113708407`, 1.749862415124626}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.261141711370838, 1.6459393666704967`}, {2.7630066290354454`, 1.4861516431844226`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.9286563141789363`, 1.6624567638374985`}, {2.7630066290354454`, 1.4861516431844226`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.04114171137084, 2.0269905443356486`}, {3.041141711370841, 2.4669905443356486`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.7630066290354454`, 1.4861516431844226`}, {2.939311749688521, 1.3205019580409374`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.7630066290354454`, 1.4861516431844226`}, {2.445511662637417, 2.475935950622419}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.445511662637417, 2.475935950622419}, {2.4041465388618364`, 2.604890909665682}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.939311749688521, 1.3205019580409374`}, {2.580451659514911, 2.4392412245221955`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.5251473843782923`, 2.203731668647611}, {2.580451659514911, 2.4392412245221955`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.5251473843782923`, 2.203731668647611}, {2.2935379885886027`, 2.13387179791651}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.580451659514911, 2.4392412245221955`}, {2.4041465388618364`, 2.604890909665682}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.041141711370841, 2.4669905443356486`}, {2.9915111265587644`, 2.357734857750413}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.041141711370841, 2.4669905443356486`}, {2.9915111265587644`, 2.477734857750413}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.9915111265587644`, 2.477734857750413}, {2.4041465388618364`, 2.604890909665682}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.9915111265587644`, 2.357734857750413}, {2.991511126558765, 2.7977348577504135`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.9915111265587644`, 2.357734857750413}, {2.3048979754353804`, 2.5063768074332917`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.3048979754353804`, 2.5063768074332917`}, {2.1725371430721467`, 2.535031038934582}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.4041465388618364`, 2.604890909665682}, {2.1725371430721467`, 2.535031038934582}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.991511126558765, 2.7977348577504135`}, {3.2115111265587646`, 3.178786035415567}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.1725371430721467`, 2.535031038934582}, {2.117232867935527, 2.2995214830599955`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.1725371430721467`, 2.535031038934582}, {2.961963722969279, 3.4051826266699328`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.117232867935527, 2.2995214830599955`}, {2.2935379885886027`, 2.13387179791651}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.117232867935527, 2.2995214830599955`}, {1.758372777761914, 3.4182607495412523`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.2082285765231844`, 2.399822210601968}, {2.906659447832658, 3.169673070795347}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.117232867935527, 2.2995214830599955`}, {2.2082285765231844`, 2.399822210601968}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.2521728648130215`, 2.2628267569597735`}, {1.9346778984149884`, 3.252611064397767}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.2935379885886027`, 2.13387179791651}, {2.2521728648130215`, 2.2628267569597735`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.1710347254789424, 3.117017785081816}, {-0.34733984613201435`, 3.2826674702253023`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.1710347254789424, 3.117017785081816}, {-0.6691698078143345, 2.9572300615957405`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.1710347254789424, 3.117017785081816}, {-0.33668441062242827`, 2.9407126644287405`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.34733984613201435`, 3.2826674702253023`}, {-0.5129895312754995, 3.106362349572226}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.34733984613201435`, 3.2826674702253023`}, {0.16960961148068116`, 3.4484903161128706`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.16960961148068116`, 3.4484903161128706`}, {0.2985645705239441, 3.489855439888452}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.2348544489401077, 3.6472012507234517`}, {-0.6159056266052603, 3.4272012507234506`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.2348544489401077, 3.6472012507234517`}, {0.20514555105989152`, 3.6472012507234526`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6159056266052603, 3.4272012507234506`}, {-0.49647213410850094`, 3.438847746764132}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6159056266052603, 3.4272012507234506`}, {-0.5129895312754995, 3.106362349572226}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6003951825626299, 3.378847746764133}, {-0.8775233117736534, 3.218847746764129}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.49647213410850094`, 3.438847746764132}, {-0.6003951825626299, 3.378847746764133}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.49647213410850094`, 3.438847746764132}, {-0.33668441062242827`, 2.9407126644287405`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.5129895312754995, 3.106362349572226}, {-0.33668441062242827`, 2.9407126644287405`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.5129895312754995, 3.106362349572226}, {0.1329148853804587, 3.3135503192353757`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.8775233117736534, 3.218847746764129}, {-0.6575233117736515, 2.8377965690989773`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6575233117736515, 2.8377965690989773`}, {-0.6691698078143345, 2.9572300615957405`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{-0.6575233117736515, 2.8377965690989773`}, {-0.33668441062242827`, 2.9407126644287405`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.2985645705239441, 3.489855439888452}, {0.06305501464935748, 3.545159715025066}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.2985645705239441, 3.489855439888452}, {0.1329148853804587, 3.3135503192353757`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.2985645705239441, 3.489855439888452}, {0.8009468239387302, 3.0340797914793987`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.5358898644746559, 3.696831835535532}, {0.09588986447465622, 3.6968318355355305`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.5358898644746559, 3.696831835535532}, {0.8130179936856778, 3.5368318355355317`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.8130179936856778, 3.5368318355355317`}, {0.9169410421398096, 3.4768318355355325`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.09588986447465622, 3.6968318355355305`}, {0.20514555105989152`, 3.6472012507234526`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.09588986447465622, 3.6968318355355305`}, {0.08514555105989186, 3.6472012507234526`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.08514555105989186, 3.6472012507234526`}, {0.06305501464935748, 3.545159715025066}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.20514555105989152`, 3.6472012507234526`}, {0.1615691168817492, 3.4459111515986147`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.1615691168817492, 3.4459111515986147`}, {0.1329148853804587, 3.3135503192353757`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.06305501464935748, 3.545159715025066}, {0.1329148853804587, 3.3135503192353757`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.16335574219133014`, 3.4541640064374093`}, {0.5654372680641437, 3.0893840666160135`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.06305501464935748, 3.545159715025066}, {0.16335574219133014`, 3.4541640064374093`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.8009468239387302, 3.0340797914793987`}, {0.8562510990753464, 3.2695893473539863`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.8009468239387302, 3.0340797914793987`}, {0.5654372680641437, 3.0893840666160135`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.8562510990753464, 3.2695893473539863`}, {0.6207415432007599, 3.324893622490601}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.8562510990753464, 3.2695893473539863`}, {1.2583326249481601`, 2.9048094075325874`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2583326249481601`, 2.9048094075325874`}, {1.358633352490132, 2.8138136989449305`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.2281893121202783`, 3.354441026080088}, {0.8471381344551252, 3.5744410260800876`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.2281893121202783`, 3.354441026080088}, {1.5053174413312984`, 3.5144410260800845`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.5053174413312984`, 3.5144410260800845`}, {1.6092404897854298`, 3.5744410260800823`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.8471381344551252, 3.5744410260800876`}, {0.9169410421398096, 3.4768318355355325`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.8471381344551252, 3.5744410260800876`}, {0.6207415432007599, 3.324893622490601}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.9169410421398096, 3.4768318355355325`}, {0.5654372680641437, 3.0893840666160135`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{0.6207415432007599, 3.324893622490601}, {0.5654372680641437, 3.0893840666160135`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{0.6207415432007599, 3.324893622490601}, {1.1231237966155456`, 2.8691179740815467`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.358633352490132, 2.8138136989449305`}, {1.2887734817590313`, 3.045423094734619}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.358633352490132, 2.8138136989449305`}, {1.1231237966155456`, 2.8691179740815467`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2887734817590313`, 3.045423094734619}, {1.1231237966155456`, 2.8691179740815467`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.2887734817590313`, 3.045423094734619}, {1.9346778984149884`, 3.252611064397767}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.2520787556588084`, 2.9104830978571266`}, {1.7690282132715027`, 3.0763059437446914`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.1231237966155456`, 2.8691179740815467`}, {1.2520787556588084`, 2.9104830978571266`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.9346778984149884`, 3.252611064397767}, {1.758372777761914, 3.4182607495412523`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.9346778984149884`, 3.252611064397767}, {1.7690282132715027`, 3.0763059437446914`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.758372777761914, 3.4182607495412523`}, {1.5927230926184288`, 3.2419556288881766`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.758372777761914, 3.4182607495412523`}, {2.2753222353746096`, 3.5840835954288197`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.2753222353746096`, 3.5840835954288197`}, {2.4042771944178725`, 3.625448719204401}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.8708581749538211`, 3.7827945300394017`}, {1.4898069972886685`, 3.562794530039401}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.8708581749538211`, 3.7827945300394017`}, {2.31085817495382, 3.7827945300394017`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.4898069972886685`, 3.562794530039401}, {1.6092404897854298`, 3.5744410260800823`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.4898069972886685`, 3.562794530039401}, {1.5927230926184288`, 3.2419556288881766`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.6092404897854298`, 3.5744410260800823`}, {1.7690282132715027`, 3.0763059437446914`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{1.5927230926184288`, 3.2419556288881766`}, {1.7690282132715027`, 3.0763059437446914`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{1.5927230926184288`, 3.2419556288881766`}, {2.2386275092743873`, 3.4491435985513252`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.4042771944178725`, 3.625448719204401}, {2.168767638543286, 3.6807529943410158`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.4042771944178725`, 3.625448719204401}, {2.2386275092743873`, 3.4491435985513252`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.4042771944178725`, 3.625448719204401}, {2.906659447832658, 3.169673070795347}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.6416024883685854`, 3.8324251148514805`}, {2.2016024883685854`, 3.83242511485148}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.6416024883685854`, 3.8324251148514805`}, {2.9187306175796106`, 3.6724251148514773`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.9187306175796106`, 3.6724251148514773`}, {3.022653666033738, 3.6124251148514803`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.2016024883685854`, 3.83242511485148}, {2.31085817495382, 3.7827945300394017`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.2016024883685854`, 3.83242511485148}, {2.1908581749538207`, 3.7827945300394017`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.1908581749538207`, 3.7827945300394017`}, {2.168767638543286, 3.6807529943410158`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.31085817495382, 3.7827945300394017`}, {2.267281740775678, 3.581504430914564}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.267281740775678, 3.581504430914564}, {2.2386275092743873`, 3.4491435985513252`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.168767638543286, 3.6807529943410158`}, {2.2386275092743873`, 3.4491435985513252`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.269068366085259, 3.589757285753359}, {2.6711498919580716`, 3.224977345931962}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.168767638543286, 3.6807529943410158`}, {2.269068366085259, 3.589757285753359}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.906659447832658, 3.169673070795347}, {2.961963722969279, 3.4051826266699328`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.906659447832658, 3.169673070795347}, {2.6711498919580716`, 3.224977345931962}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.2115111265587646`, 3.178786035415567}, {3.1139019360142095`, 3.108983127730881}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.2115111265587646`, 3.178786035415567}, {2.961963722969279, 3.4051826266699328`}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.17390193601421, 3.2129061761850135`}, {3.3339019360142106`, 3.490034305396033}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.1139019360142095`, 3.108983127730881}, {3.17390193601421, 3.2129061761850135`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.1139019360142095`, 3.108983127730881}, {2.7264541670946927`, 3.460486901806548}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.961963722969279, 3.4051826266699328`}, {2.7264541670946927`, 3.460486901806548}}]}, {GrayLevel[0], AbsoluteThickness[1], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{3.3339019360142106`, 3.490034305396033}, {2.9528507583490584`, 3.7100343053960336`}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{2.9528507583490584`, 3.7100343053960336`}, {3.022653666033738, 3.6124251148514803`}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.9528507583490584`, 3.7100343053960336`}, {2.7264541670946927`, 3.460486901806548}}]}, {RGBColor[Rational[1, 3], Rational[1, 3], Rational[1, 3]], AbsoluteThickness[0.8], AbsoluteDashing[{0, 3.1}], CapForm["Round"], JoinForm["Round"], Line[{{3.022653666033738, 3.6124251148514803`}, {2.6711498919580716`, 3.224977345931962}}]}, {GrayLevel[0], AbsoluteThickness[0.8], Dashing[{}], CapForm["Round"], JoinForm["Round"], Line[{{2.7264541670946927`, 3.460486901806548}, {2.6711498919580716`, 3.224977345931962}}]}}}], {575.5790389990619, -154.7105011715701}, ImageScaled[{0.5, 0.5}], {360., 294.68666889822777`}]}, {}}, ContentSelectable -> True, ImagePadding -> {{83.959677, 84.959677}, {1., 0.}}, PlotRange -> {{186., 582.}, {-314.42100234313915`, 5.}}, PlotRangePadding -> Automatic]
Module[{n,w,\[Alpha],tpatch,types,patch,lattice,tiling,cliprect,ptiling},
n=2;
w=0.2;
\[Alpha]=30.\[Degree];
tpatch=TwoColorableArchimedeanPatch[n];
types={{M,M,M,M},{V,V,V,V}};
patch=UnitRegularPolygonCenteredTwistAltPatch[tpatch,w,\[Alpha],types];
lattice=TwoColorableArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{-2,2},{0,3}];
cliprect=RectVertices[{.1,.1},{3.9,3.9}];
ptiling=PruneTiling[tiling,cliprect];
(* show tiling before and after pruning *)
Print[GraphicsRow[{
Graphics[{EmbedTiling[tiling,Tiling],PrunePoly[cliprect]}],Graphics[{EmbedTiling[ptiling,Tiling],PrunePoly[cliprect]}]}]/.TilingStyle[]];
(* crease pattern and folded form tilings *)
GraphicsRow[{
Graphics[EmbedTiling[ptiling,CreasePattern]],
Graphics[EmbedTiling[ptiling,FoldedForm2D]]}]/.OrigamiStyle[]
]//ShowExample
Module[{n,w,d,tpatch,parity,types,patch,lattice,tiling,cliprect,ptiling},
n=2;
w=0.2;
d=0.1001;
tpatch=TwoColorableArchimedeanPatch[n];
parity=TwoColorableArchimedeanPatchParity[n];
types={{M,M,M,M},{M,M,M,M}};
patch=UnitRegularPolygonOffsetTwistPatch[tpatch,parity,w,d,types];
lattice=TwoColorableArchimedeanPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{-2,2},{0,3}];
cliprect=RectVertices[{.1,.1},{3.9,3.9}];
ptiling=PruneTiling[tiling,cliprect];
(* show tiling before and after pruning *)
Print[GraphicsRow[{
Graphics[{EmbedTiling[tiling,Tiling],PrunePoly[cliprect]}],Graphics[{EmbedTiling[ptiling,Tiling],PrunePoly[cliprect]}]}]/.TilingStyle[]];
(* crease pattern and folded form tilings *)
GraphicsRow[{
Graphics[EmbedTiling[ptiling,CreasePattern]],
Graphics[EmbedTiling[ptiling,FoldedForm2D]]}]/.OrigamiStyle[]
]//ShowExample
TwoUniformVertexTypes::badnum="TwoUniformVertexTypes[`1`] is not defined.";
TwoUniformVertexTypes[n_]:=(Message[TwoUniformVertexTypes::badnum,n];Abort[])
TwoUniformName[n_]:=Module[{vnames},
vnames=StringJoin[Riffle[ToString/@#,"."]]&/@TwoUniformVertexTypes[n];
StringJoin["(",Riffle[ToString/@vnames,"; "],")"]]
TwoUniformPatch::badnum="TwoUniformPatch[`1`] is not defined.";
TwoUniformPatch[n_]:=(Message[TwoUniformPatch::badnum,n];Abort[])
TwoUniversityPatchLatticeVectors::badnum="TwoUniversityPatchLatticeVectors[`1`] is not defined.";
TwoUniversityPatchLatticeVectors[n_]:=(Message[TwoUniversityPatchLatticeVectors::badnum,n];Abort[])
TwoUniformVertexTypes[1]={{3,3,3,3,3,3},{3,3,3,3,6}};
TwoUniformPatch[1]=JoinTiling[{
{{UnitRegularPolygonTile,6}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,1,1}},(*4*)
{{UnitRegularPolygonTile,3},{4,2,1}},(*5*)
{{UnitRegularPolygonTile,3},{1,3,1}},(*6*)
{{UnitRegularPolygonTile,3},{6,1,1}},(*7*)
{{UnitRegularPolygonTile,3},{7,2,1}},(*8*)
{{UnitRegularPolygonTile,3},{8,1,1}},(*9*)
{{UnitRegularPolygonTile,3},{1,4,2}},(*10*)
{{UnitRegularPolygonTile,3},{10,2,1}},(*11*)
{{UnitRegularPolygonTile,3},{6,2,2}},(*12*)
{{UnitRegularPolygonTile,3},{12,2,1}},(*13*)
{{UnitRegularPolygonTile,3},{8,2,2}},(*14*)
{{UnitRegularPolygonTile,3},{14,2,1}},(*15*)
{{UnitRegularPolygonTile,3},{11,2,2}},(*16*)
{{UnitRegularPolygonTile,3},{16,2,1}},(*17*)
{{UnitRegularPolygonTile,3},{17,1,1}},(*18*)
{{UnitRegularPolygonTile,3},{18,2,1}},(*19*)
{{UnitRegularPolygonTile,3},{19,1,1}},(*20*)
{{UnitRegularPolygonTile,3},{20,2,1}}(*21*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[1]=PatchVectors[TwoUniformPatch[1],{1,1},{5,2},{16,3}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=1;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[2]={{3,3,3,3,3,3},{3,3,3,3,6}};
TwoUniformPatch[2]=JoinTiling[{
{{UnitRegularPolygonTile,6}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,1,1}},(*4*)
{{UnitRegularPolygonTile,3},{1,3,1}},(*5*)
{{UnitRegularPolygonTile,3},{5,1,1}},(*6*)
{{UnitRegularPolygonTile,3},{6,2,1}},(*7*)
{{UnitRegularPolygonTile,3},{1,4,2}},(*8*)
{{UnitRegularPolygonTile,3},{8,2,1}},(*9*)
{{UnitRegularPolygonTile,3},{9,1,1}},(*10*)
{{UnitRegularPolygonTile,3},{10,2,1}},(*11*)
{{UnitRegularPolygonTile,3},{11,1,1}},(*12*)
{{UnitRegularPolygonTile,3},{12,2,1}}(*13*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[2]=PatchVectors[TwoUniformPatch[2],{1,1},{4,2},{9,2}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=2;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[3]={{3,3,3,3,3,3},{3,3,3,4,4}};
TwoUniformPatch[3]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,1,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,2,1}},(*4*)
{{UnitRegularPolygonTile,3},{4,2,2}}(*5*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[3]=PatchVectors[TwoUniformPatch[3],{1,1},{4,2},{1,4}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=3;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[4]={{3,3,3,3,3,3},{3,3,3,4,4}};
TwoUniformPatch[4]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,2}},(*3*)
{{UnitRegularPolygonTile,3},{3,2,1}},(*4*)
{{UnitRegularPolygonTile,3},{4,1,1}},(*5*)
{{UnitRegularPolygonTile,3},{5,2,1}},(*6*)
{{UnitRegularPolygonTile,3},{6,2,2}}(*7*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[4]=PatchVectors[TwoUniformPatch[4],{1,1},{6,2},{1,4}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=4;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[5]={{3,3,3,3,3,3},{3,3,4,12}};
TwoUniformPatch[5]=JoinTiling[{
{{UnitRegularPolygonTile,12}},(*1*)
{{UnitRegularPolygonTile,3},{1,3,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,1,1}},(*4*)
{{UnitRegularPolygonTile,4},{3,2,2}},(*5*)
{{UnitRegularPolygonTile,3},{5,3,2}},(*6*)
{{UnitRegularPolygonTile,3},{1,5,1}},(*7*)
{{UnitRegularPolygonTile,3},{7,2,2}},(*8*)
{{UnitRegularPolygonTile,4},{1,6,2}},(*9*)
{{UnitRegularPolygonTile,3},{9,4,2}},(*10*)
{{UnitRegularPolygonTile,3},{1,7,2}},(*11*)
{{UnitRegularPolygonTile,3},{11,3,2}},(*12*)
{{UnitRegularPolygonTile,4},{1,8,2}},(*13*)
{{UnitRegularPolygonTile,3},{13,4,3}},(*14*)
{{UnitRegularPolygonTile,3},{1,9,2}},(*15*)
{{UnitRegularPolygonTile,3},{14,3,2}}(*16*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[5]={PatchVector[TwoUniformPatch[5],{16,3},{9,3}],PatchVector[TwoUniformPatch[5],{1,1},{16,3}]}//FullSimplify;
Module[{n,patch,lattice,tiling},
n=5;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[6]={{3,3,3,3,3,3},{3,3,4,3,4}};
TwoUniformPatch[6]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,4},{2,2,2}},(*3*)
{{UnitRegularPolygonTile,3},{3,2,1}},(*4*)
{{UnitRegularPolygonTile,3},{4,2,1}},(*5*)
{{UnitRegularPolygonTile,3},{5,1,1}},(*6*)
{{UnitRegularPolygonTile,4},{6,2,1}},(*7*)
{{UnitRegularPolygonTile,3},{7,1,1}},(*8*)
{{UnitRegularPolygonTile,3},{3,4,2}},(*9*)
{{UnitRegularPolygonTile,3},{1,3,2}},(*10*)
{{UnitRegularPolygonTile,3},{10,3,2}},(*11*)
{{UnitRegularPolygonTile,3},{3,3,2}},(*12*)
{{UnitRegularPolygonTile,4},{5,2,2}},(*13*)
{{UnitRegularPolygonTile,3},{7,3,2}},(*14*)
{{UnitRegularPolygonTile,3},{11,2,2}},(*15*)
{{UnitRegularPolygonTile,3},{15,2,1}},(*16*)
{{UnitRegularPolygonTile,3},{9,2,2}},(*17*)
{{UnitRegularPolygonTile,4},{12,3,2}},(*18*)
{{UnitRegularPolygonTile,3},{18,2,1}},(*19*)
{{UnitRegularPolygonTile,3},{13,3,2}},(*20*)
{{UnitRegularPolygonTile,3},{20,2,1}},(*21*)
{{UnitRegularPolygonTile,4},{14,2,2}}(*22*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[6]=PatchVectors[TwoUniformPatch[6],{1,1},{8,2},{15,3}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=6;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[7]={{3,3,3,3,3,3},{3,3,6,6}};
TwoUniformPatch[7]=JoinTiling[{
{{UnitRegularPolygonTile,3}},(*1*)
{{UnitRegularPolygonTile,6},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,2,1}},(*4*)
{{UnitRegularPolygonTile,3},{2,4,2}},(*5*)
{{UnitRegularPolygonTile,3},{5,2,1}},(*6*)
{{UnitRegularPolygonTile,6},{2,3,1}},(*7*)
{{UnitRegularPolygonTile,3},{7,3,1}}(*8*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[7]=PatchVectors[TwoUniformPatch[7],{1,1},{3,2},{5,3}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=7;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[8]={{3,3,3,3,6},{3,3,6,6}};
TwoUniformPatch[8]=JoinTiling[{
{{UnitRegularPolygonTile,6}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,2,2}},(*4*)
{{UnitRegularPolygonTile,3},{4,3,2}}(*5*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[8]=PatchVectors[TwoUniformPatch[8],{1,1},{3,2},{1,5}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=8;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[9]={{3,3,3,4,4},{3,3,4,3,4}};
TwoUniformPatch[9]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,1,1}},(*3*)
{{UnitRegularPolygonTile,4},{3,2,1}},(*4*)
{{UnitRegularPolygonTile,4},{4,2,1}},(*5*)
{{UnitRegularPolygonTile,3},{5,2,1}},(*6*)
{{UnitRegularPolygonTile,3},{1,4,3}},(*7*)
{{UnitRegularPolygonTile,4},{7,3,2}},(*8*)
{{UnitRegularPolygonTile,3},{8,2,1}},(*9*)
{{UnitRegularPolygonTile,3},{1,3,2}},(*10*)
{{UnitRegularPolygonTile,3},{10,2,1}},(*11*)
{{UnitRegularPolygonTile,4},{2,2,2}},(*12*)
{{UnitRegularPolygonTile,3},{12,2,1}},(*13*)
{{UnitRegularPolygonTile,3},{13,2,1}},(*14*)
{{UnitRegularPolygonTile,3},{5,3,2}},(*15*)
{{UnitRegularPolygonTile,3},{8,3,2}},(*16*)
{{UnitRegularPolygonTile,3},{16,2,2}},(*17*)
{{UnitRegularPolygonTile,4},{9,2,2}},(*18*)
{{UnitRegularPolygonTile,4},{18,2,1}},(*19*)
{{UnitRegularPolygonTile,3},{19,2,1}},(*20*)
{{UnitRegularPolygonTile,3},{12,3,2}},(*21*)
{{UnitRegularPolygonTile,4},{14,2,2}},(*22*)
{{UnitRegularPolygonTile,3},{17,3,2}},(*23*)
{{UnitRegularPolygonTile,4},{23,2,2}},(*24*)
{{UnitRegularPolygonTile,3},{18,3,2}},(*25*)
{{UnitRegularPolygonTile,3},{25,2,1}},(*26*)
{{UnitRegularPolygonTile,3},{19,3,2}},(*27*)
{{UnitRegularPolygonTile,4},{27,2,1}},(*28*)
{{UnitRegularPolygonTile,3},{20,2,2}},(*29*)
{{UnitRegularPolygonTile,4},{22,3,2}},(*30*)
{{UnitRegularPolygonTile,3},{24,3,2}},(*31*)
{{UnitRegularPolygonTile,4},{26,2,2}},(*32*)
{{UnitRegularPolygonTile,3},{32,2,1}},(*33*)
{{UnitRegularPolygonTile,3},{28,2,1}},(*34*)
{{UnitRegularPolygonTile,3},{30,3,2}},(*35*)
{{UnitRegularPolygonTile,3},{35,2,1}}(*36*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[9]=PatchVectors[TwoUniformPatch[9],{1,1},{6,2},{31,3}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=9;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[10]={{3,3,3,4,4},{3,3,4,3,4}};
TwoUniformPatch[10]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,4},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,1,1}},(*4*)
{{UnitRegularPolygonTile,3},{4,2,1}},(*5*)
{{UnitRegularPolygonTile,3},{5,1,1}},(*6*)
{{UnitRegularPolygonTile,3},{1,3,2}},(*7*)
{{UnitRegularPolygonTile,3},{7,2,1}},(*8*)
{{UnitRegularPolygonTile,3},{2,3,2}},(*9*)
{{UnitRegularPolygonTile,3},{9,2,1}},(*10*)
{{UnitRegularPolygonTile,4},{3,2,2}},(*11*)
{{UnitRegularPolygonTile,4},{5,2,2}}(*12*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[10]=PatchVectors[TwoUniformPatch[10],{1,1},{6,2},{7,3}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=10;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[11]={{3,3,4,3,4},{3,4,6,4}};
TwoUniformPatch[11]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,3},{1,4,3}},(*2*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*3*)
{{UnitRegularPolygonTile,4},{2,3,2}},(*4*)
{{UnitRegularPolygonTile,6},{1,3,2}},(*5*)
{{UnitRegularPolygonTile,4},{3,2,2}},(*6*)
{{UnitRegularPolygonTile,3},{6,2,1}},(*7*)
{{UnitRegularPolygonTile,3},{4,3,2}},(*8*)
{{UnitRegularPolygonTile,3},{6,3,2}},(*9*)
{{UnitRegularPolygonTile,4},{8,2,2}},(*10*)
{{UnitRegularPolygonTile,4},{5,3,1}},(*11*)
{{UnitRegularPolygonTile,3},{11,2,1}},(*12*)
{{UnitRegularPolygonTile,3},{10,3,2}},(*13*)
{{UnitRegularPolygonTile,4},{5,4,2}},(*14*)
{{UnitRegularPolygonTile,3},{11,3,2}}(*15*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[11]=PatchVectors[TwoUniformPatch[11],{2,1},{7,2},{14,3}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=11;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[12]={{3,3,3,4,4},{3,4,6,4}};
TwoUniformPatch[12]=JoinTiling[{
{{UnitRegularPolygonTile,6}},(*1*)
{{UnitRegularPolygonTile,4},{1,3,1}},(*2*)
{{UnitRegularPolygonTile,4},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,4},{1,4,2}},(*4*)
{{UnitRegularPolygonTile,3},{2,3,2}},(*5*)
{{UnitRegularPolygonTile,3},{5,2,2}},(*6*)
{{UnitRegularPolygonTile,3},{3,3,2}},(*7*)
{{UnitRegularPolygonTile,4},{4,3,2}},(*8*)
{{UnitRegularPolygonTile,3},{8,2,1}},(*9*)
{{UnitRegularPolygonTile,4},{9,2,2}},(*10*)
{{UnitRegularPolygonTile,4},{7,2,2}},(*11*)
{{UnitRegularPolygonTile,3},{10,3,2}},(*12*)
{{UnitRegularPolygonTile,3},{12,2,1}},(*13*)
{{UnitRegularPolygonTile,3},{11,3,2}},(*14*)
{{UnitRegularPolygonTile,3},{13,2,2}}(*15*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[12]=PatchVectors[TwoUniformPatch[12],{1,1},{3,2},{8,4}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=12;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[13]={{3,3,4,4},{4,4,4,4}};
TwoUniformPatch[13]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,4},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,2,2}}(*4*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[13]=PatchVectors[TwoUniformPatch[13],{1,1},{3,2},{1,4}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=13;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[14]={{3,3,4,4},{4,4,4,4}};
TwoUniformPatch[14]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,4},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,4},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,2,1}},(*4*)
{{UnitRegularPolygonTile,3},{4,2,2}}(*5*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[14]=PatchVectors[TwoUniformPatch[14],{1,1},{4,2},{1,4}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=14;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[15]={{3,3,4,4},{6,3,4,6,4}};
TwoUniformPatch[15]=JoinTiling[{
{{UnitRegularPolygonTile,6}},(*1*)
{{UnitRegularPolygonTile,4},{1,4,2}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,4},{1,3,1}},(*4*)
{{UnitRegularPolygonTile,4},{4,2,1}},(*5*)
{{UnitRegularPolygonTile,4},{5,2,1}},(*6*)
{{UnitRegularPolygonTile,4},{2,3,2}},(*7*)
{{UnitRegularPolygonTile,6},{3,2,1}},(*8*)
{{UnitRegularPolygonTile,3},{8,2,1}},(*9*)
{{UnitRegularPolygonTile,4},{7,3,2}},(*10*)
{{UnitRegularPolygonTile,3},{10,2,1}},(*11*)
{{UnitRegularPolygonTile,4},{11,2,2}},(*12*)
{{UnitRegularPolygonTile,4},{8,3,2}},(*13*)
{{UnitRegularPolygonTile,4},{9,2,2}},(*14*)
{{UnitRegularPolygonTile,3},{12,3,2}},(*15*)
{{UnitRegularPolygonTile,6},{13,3,2}},(*16*)
{{UnitRegularPolygonTile,3},{14,3,2}},(*17*)
{{UnitRegularPolygonTile,3},{16,4,2}}(*18*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[15]=PatchVectors[TwoUniformPatch[15],{1,1},{6,2},{10,4}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=15;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[16]={{3,3,6,6},{3,6,3,6}};
TwoUniformPatch[16]=JoinTiling[{
{{UnitRegularPolygonTile,6}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{1,3,2}}(*3*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[16]=PatchVectors[TwoUniformPatch[16],{1,1},{2,2},{1,5}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=16;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[17]={{3,4,3,12},{3,12,12}};
TwoUniformPatch[17]=JoinTiling[{
{{UnitRegularPolygonTile,12}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,4},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,3},{3,2,1}},(*4*)
{{UnitRegularPolygonTile,3},{1,3,1}},(*5*)
{{UnitRegularPolygonTile,3},{1,5,1}}(*6*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[17]=PatchVectors[TwoUniformPatch[17],{1,1},{4,2},{1,8}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=17;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[18]={{3,4,4,6},{3,6,3,6}};
TwoUniformPatch[18]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,6},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,4},{1,3,2}},(*3*)
{{UnitRegularPolygonTile,3},{2,5,2}},(*4*)
{{UnitRegularPolygonTile,3},{2,4,2}}(*5*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[18]=PatchVectors[TwoUniformPatch[18],{1,1},{2,3},{3,4}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=18;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[19]={{3,4,4,6},{3,6,3,6}};
TwoUniformPatch[19]=JoinTiling[{
{{UnitRegularPolygonTile,4}},(*1*)
{{UnitRegularPolygonTile,6},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,4},{1,3,2}},(*3*)
{{UnitRegularPolygonTile,3},{2,5,2}},(*4*)
{{UnitRegularPolygonTile,3},{2,4,2}},(*5*)
{{UnitRegularPolygonTile,4},{2,3,1}},(*6*)
{{UnitRegularPolygonTile,3},{6,2,1}},(*7*)
{{UnitRegularPolygonTile,4},{6,3,2}},(*8*)
{{UnitRegularPolygonTile,6},{7,2,2}},(*9*)
{{UnitRegularPolygonTile,3},{9,2,1}}(*10*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[19]=PatchVectors[TwoUniformPatch[19],{1,1},{10,2},{3,4}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=19;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
TwoUniformVertexTypes[20]={{3,4,6,4},{4,6,12}};
TwoUniformPatch[20]=JoinTiling[{
{{UnitRegularPolygonTile,12}},(*1*)
{{UnitRegularPolygonTile,4},{1,4,1}},(*2*)
{{UnitRegularPolygonTile,3},{2,2,1}},(*3*)
{{UnitRegularPolygonTile,4},{3,2,2}},(*4*)
{{UnitRegularPolygonTile,6},{1,5,1}},(*5*)
{{UnitRegularPolygonTile,6},{1,7,2}},(*6*)
{{UnitRegularPolygonTile,4},{1,6,2}},(*7*)
{{UnitRegularPolygonTile,3},{7,3,2}},(*8*)
{{UnitRegularPolygonTile,4},{5,4,2}},(*9*)
{{UnitRegularPolygonTile,4},{8,3,2}},(*10*)
{{UnitRegularPolygonTile,6},{9,3,2}},(*11*)
{{UnitRegularPolygonTile,4},{11,3,1}}(*12*)
}]//FullSimplify;
TwoUniformPatchLatticeVectors[20]=PatchVectors[TwoUniformPatch[20],{1,1},{4,3},{6,5}]//FullSimplify;
Module[{n,patch,lattice,tiling},
n=20;
Print["tiling = ",TwoUniformName[n]];
patch=TwoUniformPatch[n];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=TwoUniformPatchLatticeVectors[n];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
Module[{list},
list=Table[{n,TwoUniformVertexTypes[n]},{n,20}];
Select[list,And@@(EvenQ[Length[#]]&/@#[[2]])&]//ColumnForm
]
CairoPentagonAngles[\[Delta]1_]:=CairoPentagonAngles[\[Delta]1]=Module[{angles,\[Delta]2,\[Delta]3},
angles=CompletePolygonAngles[{\[Delta]1,\[Delta]2,\[Delta]3,\[Pi]-\[Delta]1}];
angles/.FindRoot[{1+Cos[\[Delta]1]-Cos[\[Delta]1-\[Delta]3]+Cos[\[Delta]1-\[Delta]2-\[Delta]3]-Cos[\[Delta]2+\[Delta]3],-Sin[\[Delta]1]+Sin[\[Delta]1-\[Delta]3]-Sin[\[Delta]1-\[Delta]2-\[Delta]3]-Sin[\[Delta]2+\[Delta]3]},{\[Delta]2,90\[Degree]},{\[Delta]3,90\[Degree]}]]
Module[{angles},
angles=CairoPentagonAngles[90.\[Degree]];
angles/\[Degree]
]//ShowExample
CairoSymmetricPentagonBaseAngle=Module[{angles,\[Delta]1,\[Delta]2,\[Delta]3},
angles=CompletePolygonAngles[{\[Delta]1,\[Delta]2,\[Delta]3,\[Pi]-\[Delta]1}];
\[Delta]1/.FindRoot[{\[Delta]2-\[Delta]1,1+Cos[\[Delta]1]-Cos[\[Delta]1-\[Delta]3]+Cos[\[Delta]1-\[Delta]2-\[Delta]3]-Cos[\[Delta]2+\[Delta]3],-Sin[\[Delta]1]+Sin[\[Delta]1-\[Delta]3]-Sin[\[Delta]1-\[Delta]2-\[Delta]3]-Sin[\[Delta]2+\[Delta]3]},{\[Delta]1,90\[Degree]},{\[Delta]2,90\[Degree]},{\[Delta]3,90\[Degree]}]];
CairoSymmetricPentagonBaseAngle/\[Degree]//ShowExample
UnitCairoPentagonTile::usage="UnitCairoPentagonTile is a tile type that produces a unit equilateral pentagon that supports a Cairo tiling.";
CairoSymmetricPentagonBaseAngle/\[Degree]//ShowExample
RenderTile[{UnitCairoPentagonTile,\[Delta]_},decoration_,opts___]:=Module[{angles,verts},
angles=CairoPentagonAngles[\[Delta]];
verts=UnitEquilateralPolygonVertices[angles];
RenderTile[{PolygonTile,verts},decoration,opts]]
Module[{\[Delta]},
\[Delta]=CairoSymmetricPentagonBaseAngle;
Graphics[RenderTile[{UnitCairoPentagonTile,\[Delta]},Tiling]]/.TilingStyle[]
]//ShowExample
CairoPatch[\[Delta]_]:=JoinTiling[{
{{UnitCairoPentagonTile, \[Delta]}},
{{UnitCairoPentagonTile, \[Pi]-\[Delta]},{1,4,4}},
{{UnitCairoPentagonTile, \[Delta]},{2,1,1}},
{{UnitCairoPentagonTile, \[Pi]-\[Delta]},{3,4,4}}
}]//Chop;
Graphics[EmbedTiling[CairoPatch[CairoSymmetricPentagonBaseAngle],Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]//ShowExample
CairoPatch[90.\[Degree]]//ShowExample
Graphics[EmbedTiling[CairoPatch[90.\[Degree]],Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]//ShowExample
CairoLatticeVectors[\[Delta]_]:=PatchVectors[CairoPatch[\[Delta]],{4,5},{1,3},{3,2}]
Module[{\[Delta],patch,l1,l2,tiling},
\[Delta]=CairoSymmetricPentagonBaseAngle;
patch=CairoPatch[\[Delta]];
{l1,l2}=CairoLatticeVectors[\[Delta]];
tiling=MakeLatticeTiling[patch,{l1,l2},{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]
]//ShowExample

Module[{\[Delta],patch,l1,l2,tiling},
\[Delta]=90.\[Degree];
patch=CairoPatch[\[Delta]];
{l1,l2}=CairoLatticeVectors[\[Delta]];
tiling=MakeLatticeTiling[patch,{l1,l2},{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]
]//ShowExample

Module[{\[Delta],patch,l1,l2,tiling},
\[Delta]=105.\[Degree];
patch=CairoPatch[\[Delta]];
{l1,l2}=CairoLatticeVectors[\[Delta]];
tiling=MakeLatticeTiling[patch,{l1,l2},{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]
]//ShowExample

DoubleCairoPatch[\[Delta]_]:=JoinTiling[{
{{UnitCairoPentagonTile, \[Delta]}},
{{UnitCairoPentagonTile, \[Pi]-\[Delta]},{1,4,4}},
{{UnitCairoPentagonTile, \[Delta]},{2,1,1}},
{{UnitCairoPentagonTile, \[Pi]-\[Delta]},{3,4,4}},
{{UnitCairoPentagonTile,\[Pi]- \[Delta]},{2,5,2}},
{{UnitCairoPentagonTile, \[Delta]},{5,4,4}},
{{UnitCairoPentagonTile,  \[Pi]-\[Delta]},{6,1,1}},
{{UnitCairoPentagonTile,\[Delta]},{3,1,1}}
}]//Chop;
DoubleCairoPatch[90.\[Degree]]
Graphics[EmbedTiling[DoubleCairoPatch[95.\[Degree]],Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]//ShowExample
DoubleCairoLatticeVectors[\[Delta]_]:={PatchVector[DoubleCairoPatch[\[Delta]],{3,2},{1,3}],PatchVector[DoubleCairoPatch[\[Delta]],{4,5},{5,3}]}
Module[{\[Delta],patch,l1,l2,tiling},
\[Delta]=105.\[Degree];
patch=DoubleCairoPatch[\[Delta]];
{l1,l2}=DoubleCairoLatticeVectors[\[Delta]];
tiling=MakeLatticeTiling[patch,{l1,l2},{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]
]//ShowExample

ClearAll[ReschStarName,ReschStarPatch,ReschStarPatchLatticeVectors]
ReschStarName::usage="ReschStarName[n] returns a string giving the name (vertex figure) of the nth ReschStar tiling with tip angle \[Alpha].";
ReschStarName[1]="(\!\(\*SuperscriptBox[SubscriptBox[\(3.3\), \(\[Alpha]\)], \(*\)]\).3\!\(\*SuperscriptBox[SubscriptBox[\(.3\), \(\[Alpha]\)], \(**\)]\))";
ReschStarPatch[1,\[Alpha]_]:=ReschStarPatch[1,\[Alpha]]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularStarPolygonTile,3,\[Alpha]},{1,2,1}},
{{UnitRegularPolygonTile,3},{2,3,1}}
}]//Simplify;
ReschStarPatchLatticeVectors[1,\[Alpha]_]:=ReschStarPatchLatticeVectors[1,\[Alpha]]=PatchVectors[ReschStarPatch[1,\[Alpha]],{1,1},{2,2},{2,5}]//Simplify;
Module[{n,\[Alpha],patch,lattice,tiling},
n=1;
\[Alpha]=40.\[Degree];
Print["tiling = ",ReschStarName[n]];
patch=ReschStarPatch[n,\[Alpha]];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ReschStarPatchLatticeVectors[n,\[Alpha]];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ReschStarName[2]="(3.3\!\(\*SuperscriptBox[SubscriptBox[\(.3\), \(\[Alpha]\)], \(*\)]\)\!\(\*SuperscriptBox[SubscriptBox[\(.3\), \(\[Alpha]\)], \(**\)]\); \!\(\*SuperscriptBox[SubscriptBox[\(3.3\), \(\[Alpha]\)], \(*\)]\).3\!\(\*SuperscriptBox[SubscriptBox[\(.3\), \(\[Alpha]\)], \(**\)]\))";
ReschStarPatch[2,\[Alpha]_]:=ReschStarPatch[2,\[Alpha]]=JoinTiling[{
{{UnitRegularStarPolygonTile,3,\[Alpha]}},(*1*)
{{UnitRegularPolygonTile,3},{1,2,1}},(*2*)
{{UnitRegularPolygonTile,3},{1,3,2}},(*3*)
{{UnitRegularStarPolygonTile,3,\[Alpha]},{1,4,1}},(*4*)
{{UnitRegularPolygonTile,3},{4,1,1}},(*5*)
{{UnitRegularPolygonTile,3},{4,2,2}}(*6*)
}]//Simplify;
ReschStarPatchLatticeVectors[2,\[Alpha]_]:=ReschStarPatchLatticeVectors[2,\[Alpha]]=PatchVectors[ReschStarPatch[2,\[Alpha]],{1,1},{2,2},{4,4}]//Simplify;
Module[{n,\[Alpha],patch,lattice,tiling},
n=2;
\[Alpha]=40.\[Degree];
Print["tiling = ",ReschStarName[n]];
patch=ReschStarPatch[n,\[Alpha]];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ReschStarPatchLatticeVectors[n,\[Alpha]];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ReschStarName[3]="(\!\(\*SuperscriptBox[SubscriptBox[\(6.3\), \(\[Alpha]\)], \(*\)]\)\!\(\*SuperscriptBox[SubscriptBox[\(.3\), \(\[Alpha]\)], \(**\)]\))";
ReschStarPatch[3,\[Alpha]_]:=ReschStarPatch[3,\[Alpha]]=JoinTiling[{
{{UnitRegularPolygonTile,6}},
{{UnitRegularStarPolygonTile,3,\[Alpha]},{1,2,6}},
{{UnitRegularStarPolygonTile,3,\[Alpha]},{1,3,6}}
}]//Simplify;
ReschStarPatchLatticeVectors[3,\[Alpha]_]:=ReschStarPatchLatticeVectors[3,\[Alpha]]=PatchVectors[ReschStarPatch[3,\[Alpha]],{1,1},{2,3},{3,4}]//Simplify;
Module[{n,\[Alpha],patch,lattice,tiling},
n=3;
\[Alpha]=40.\[Degree];
Print["tiling = ",ReschStarName[n]];
patch=ReschStarPatch[n,\[Alpha]];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ReschStarPatchLatticeVectors[n,\[Alpha]];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ReschStarName[4]="(\!\(\*SuperscriptBox[SubscriptBox[\(4.4\), \(\[Alpha]\)], \(*\)]\)\!\(\*SuperscriptBox[SubscriptBox[\(.4\), \(\[Alpha]\)], \(**\)]\))";
ReschStarPatch[4,\[Alpha]_]:=ReschStarPatch[4,\[Alpha]]=JoinTiling[{
{{UnitRegularPolygonTile,4}},
{{UnitRegularStarPolygonTile,4,\[Alpha]},{1,2,8}}
}]//Simplify;
ReschStarPatchLatticeVectors[4,\[Alpha]_]:=ReschStarPatchLatticeVectors[4,\[Alpha]]=PatchVectors[ReschStarPatch[4,\[Alpha]],{1,1},{2,3},{2,6}]//Simplify;
Module[{n,\[Alpha],patch,lattice,tiling},
n=4;
\[Alpha]=40.\[Degree];
Print["tiling = ",ReschStarName[n]];
patch=ReschStarPatch[n,\[Alpha]];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ReschStarPatchLatticeVectors[n,\[Alpha]];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
ReschStarName[5]="(\!\(\*SuperscriptBox[SubscriptBox[\(3.6\), \(\[Alpha]\)], \(*\)]\)\!\(\*SuperscriptBox[SubscriptBox[\(.6\), \(\[Alpha]\)], \(**\)]\))";
ReschStarPatch[5,\[Alpha]_]:=ReschStarPatch[5,\[Alpha]]=JoinTiling[{
{{UnitRegularPolygonTile,3}},
{{UnitRegularStarPolygonTile,6,\[Alpha]},{1,2,12}},
{{UnitRegularPolygonTile,3},{2,5,1}}
}]//Simplify;
ReschStarPatchLatticeVectors[5,\[Alpha]_]:=ReschStarPatchLatticeVectors[5,\[Alpha]]=PatchVectors[ReschStarPatch[5,\[Alpha]],{1,1},{2,3},{2,8}]//Simplify;
Module[{n,\[Alpha],patch,lattice,tiling},
n=5;
\[Alpha]=40.\[Degree];
Print["tiling = ",ReschStarName[n]];
patch=ReschStarPatch[n,\[Alpha]];
Print[Graphics[EmbedTiling[patch,Tiling,TileVertexIndices->True,TileIndices->True],PlotLabel->"patch"]/.TilingStyle[]];
lattice=ReschStarPatchLatticeVectors[n,\[Alpha]];
tiling=MakeLatticeTiling[patch,lattice,{0,1},{0,1}];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True],PlotLabel->"tiling"]/.TilingStyle[]
]//ShowExample
JoinTilingPatches[patchinfolist_List,opts___]:=Module[{si,nm,sfn,np,patchlist,patchinfo,patch,h,i,j,k,l,sverts,tverts,ps,pr,po,nt,tilespec,tiletype,to,tr,ts,verts,pos},
si=Simplification/.{opts}/.Options[JoinTiling];
nm=Numeric/.{opts}/.Options[JoinTiling];
sfn=If[si===Automatic,If[nm,N,#&],Simplify];
np=Length[patchinfolist];
patchlist=First/@patchinfolist;(* just the patches *)
Do[(* for each patch *)
patchinfo=patchinfolist[[ip]];
patch=patchinfo[[1]];
{{h,i,j},{k,l}}=patchinfo[[2]];
sverts=EmbedTile[patchlist[[h,i]],TileVertices];(* source tile vertices *)
tverts=EmbedTile[patch[[k]],TileVertices];(* target tile vertices within in this patch *)
(* scale, rotation, offset to be applied to each tile in the patch *)
{ps,pr,po}=ScaleRotationOffset[{tverts[[l]],tverts[[Mod[l-1,Length[tverts],1]]]},{sverts[[j]],sverts[[Mod[j+1,Length[sverts],1]]]}];
nt=Length[patch];
Do[ (* for each tile in patch, compose scale/rotation/offset *)
tilespec=patch[[it]];
tiletype=tilespec[[1]];
to=If[Length[tilespec]>=2,tilespec[[2]],{0,0}];(* offset *)
tr=If[Length[tilespec]>=3,tilespec[[3]],0];(* rotation *)
ts=If[Length[tilespec]>=4,tilespec[[4]],1];(* scale *)
patchlist[[ip,it]]={tiletype,sfn[po+ps RotationMatrix2D[pr] . to],sfn[pr+tr],sfn[ps*ts]}
,{it,nt}]
,{ip,2,np}];
Flatten[patchlist,1]]
Module[{patch1,patch2,patchinfolist,tiling},
patch1={{{UnitRegularPolygonTile,4}}};
patch2=JoinTiling[{
{{UnitRegularPolygonTile,4}},
{{UnitRegularPolygonTile,4},{1,2,1}},
{{UnitRegularPolygonTile,4},{2,3,1}}}];
Print[GraphicsRow[{
Graphics[EmbedTiling[patch1,Tiling,TileVertexIndices->True,TileIndices->True]],
Graphics[EmbedTiling[patch2,Tiling,TileVertexIndices->True,TileIndices->True]]}]/.TilingStyle[]];
patchinfolist={
{patch1,Null},
{patch2,{{1,1,2},{1,1}}},
{patch2,{{1,1,3},{1,1}}},
{patch2,{{1,1,4},{1,1}}},
{patch2,{{1,1,1},{1,1}}}
};
tiling=JoinTilingPatches[patchinfolist];
Graphics[EmbedTiling[tiling,Tiling,TileVertexIndices->True,TileIndices->True]]/.TilingStyle[]
]//ShowExample
GoldbergPatch[m_,n_]:=Module[{\[Phi]},
\[Phi]=\[Pi]/m;
Flatten[Table[{{{UnitTriangleTile,{2\[Phi],\[Pi]/2-\[Phi],\[Pi]/2-\[Phi]}},(i-1)U[0]+2Sin[\[Phi]](j-1)U[\[Pi]/2+\[Phi]],0,1},If[i!=j,{{UnitTriangleTile,{\[Pi]/2-\[Phi],2\[Phi],\[Pi]/2-\[Phi]}},(i-1)U[0]+2Sin[\[Phi]](j-1)U[\[Pi]/2+\[Phi]],2\[Phi],1},Null]},{i,n},{j,i}],2]/.Null->Sequence[]]
Module[{patch},
patch=GoldbergPatch[7,2];
Print["patch = ",ColumnForm[patch]];
Graphics[EmbedTiling[patch,Tiling,TileIndices->True,TileVertexIndices->True]]/.TilingStyle[]
]//ShowExample
GoldbergTiling[m_,n_,opts___]:=Module[{patch},
patch=GoldbergPatch[m,n];
JoinTilingPatches[Table[{patch,{{i-1,1,3},{1,2}}},{i,m}],opts]]
Module[{tiling},
tiling=GoldbergTiling[7,2,Numeric->True];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True,TileVertexIndices->True,Numeric->True]]/.TilingStyle[]
]//ShowExample
GoldbergOffsetTiling[m_, n_, o_, opts___]:=Module[{patch,top,bottom},
patch=GoldbergPatch[m,n];
top=JoinTilingPatches[Table[{patch,{{i-1,1,3},{1,2}}},{i,m/2}],opts];
bottom=top/.{{UnitTriangleTile,angles_},off_,rot_,s_}:>{{UnitTriangleTile,angles},RotationMatrix2D[\[Pi]] . off+{o,0},Mod[rot+\[Pi],2\[Pi],-\[Pi]],s};
Join[top,bottom]]
Module[{tiling},
tiling=GoldbergOffsetTiling[8,2,1,Numeric->True];
Graphics[EmbedTiling[tiling,Tiling,TileIndices->True,TileVertexIndices->True,Numeric->True]]/.TilingStyle[]
]//ShowExample
Options[ShrinkAndTwistParms]={
TwistDirection->CCW
};
ShrinkAndTwistParms[\[Gamma]_,\[Alpha]_,opts___]:=Module[{dir,\[Beta],\[Rho]},
dir=TwistDirection/.{opts}/.Options[ShrinkAndTwistParms];
\[Rho]=\[Gamma]/(\[Sqrt](1+\[Gamma]^2+2 \[Gamma] Sin[\[Alpha]]));
\[Beta]=If[SameQ[dir,CCW],1,-1]ArcCos[(\[Gamma]+Sin[\[Alpha]])/(\[Sqrt](1+\[Gamma]^2+2 \[Gamma] Sin[\[Alpha]]))];
{\[Rho],\[Beta]}]
ShrinkAndTwistParms[0.5,15\[Degree],TwistDirection->CCW]//ShowExample
ShrinkAndTwistParms[0.5,-15\[Degree],TwistDirection->CCW]//ShowExample
ShrinkAndTwistParms[0.5,15\[Degree],TwistDirection->CW]//ShowExample
ShrinkAndTwistParms[0.5,-15\[Degree],TwistDirection->CW]//ShowExample
FoldedFormScaleRotation[\[Gamma]_, \[Alpha]_]:=Module[{rcp,bcp,rff,bff},
{rcp,bcp}=ShrinkAndTwistParms[\[Gamma],\[Alpha]];
{rff,bff}=ShrinkAndTwistParms[\[Gamma],-\[Alpha]];
{rcp/rff,bcp-bff}
]
FoldedFormScale[\[Gamma]_, \[Alpha]_]:=FoldedFormScaleRotation[[1]]
FoldedFormRotation[\[Gamma]_, \[Alpha]_]:=FoldedFormScaleRotation[[2]]
DualShrinkAndTwistParms[\[Rho]_,\[Beta]_]:={\[Sqrt](1+\[Rho]^2-2 \[Rho] Cos[\[Beta]]),-Sign[\[Beta]]ArcCos[(1-\[Rho] Cos[\[Beta]])/(\[Sqrt](1+\[Rho]^2-2 \[Rho] Cos[\[Beta]]))]}
PrimalDualUnsafeTwistAngleRange[pverts_,pfaces_,dverts_,dfaces_,bverts_]:=Module[{ptriples,dtriples,pangles,dangles,allangles},
ptriples=Take[#[[1]],3]&/@(Select[Transpose[{pverts[[#]],RotateLeft[pverts[[#]]],RotateLeft[pverts[[#]],2],#}],!MemberQ[bverts,#[[4]]]&]&/@pfaces);dtriples=First[Transpose[{dverts[[#]],RotateLeft[dverts[[#]]],RotateLeft[dverts[[#]],2]}]&/@dfaces];
pangles=RotationAngle[#[[2]]-#[[1]],#[[3]]-#[[2]]]&/@ptriples;
dangles=RotationAngle[#[[2]]-#[[1]],#[[3]]-#[[2]]]&/@dtriples;
allangles=Join[pangles,dangles,\[Pi]-pangles,\[Pi]-dangles];
{Min[allangles],Max[allangles]}
]
Module[{verts,edges,pverts,pedges,pfaces,dverts,dedges,dfaces,iverts,bverts,iedges,bedges,bfaces},
verts={{0,0},{1,0},{2,.5},{0,1},{1,1},{.5,2},{2,2}};
edges={{1,4},{1,2},{4,5},{2,5},{2,3},{3,7},{5,7},{4,6},{6,7}};
{pverts,pedges,pfaces,dverts,dedges,dfaces,iverts,bverts,iedges,bedges,bfaces}=AddTPrimalDualGraphTo[verts,edges];
dverts[[1]]={dverts[[2,1]],dverts[[3,2]]};
Print[PrimalDualGraphics[pverts,pedges,dverts,dedges]];
PrimalDualUnsafeTwistAngleRange[pverts,pfaces,dverts,dfaces,bverts]/N[\[Degree]]
]//ShowExample//Hold;
ScaleAndTwistPoint[pt_,ctr_,\[Rho]_,\[Beta]_]:=ctr+\[Rho] RotationMatrix2D[\[Beta]] . (pt-ctr)
ScaleAndTwistPoint[{1,0},{-1,0},\[Rho],\[Beta]]//ShowExample
MakePrimalDualTwistTessellationBoundaryEdge[bedge_,bface_,pverts_,dverts_,\[Rho]_,\[Beta]_]:=Module[{p1,p2,d1,d2,p1d1,p1d2,p2d1,p2d2,p1b,p2b,s1,s2},
{p1,p2}=pverts[[bedge]];
d1=dverts[[bface]];
p1d1=ScaleAndTwistPoint[p1,d1,\[Rho],\[Beta]];
p2d1=ScaleAndTwistPoint[p2,d1,\[Rho],\[Beta]];
{{p1d1,p2d1},B}]
Module[{\[Gamma],\[Alpha],dir,\[Rho],\[Beta],pverts,pedges, pfaces,dverts,pefis,dfaces,iverts,bverts,bedge,bface,edgepair,edgetype},
\[Gamma]=2.0;
\[Alpha]=20.\[Degree];
dir=CCW;
{\[Rho],\[Beta]}=ShrinkAndTwistParms[\[Gamma],\[Alpha],TwistDirection->dir];
Print["\[Rho]=",\[Rho],", \[Beta]=",\[Beta]/\[Degree],"\[Degree]"];
pverts={{0,0},{2,0},{4,0},{0,2},{2,2},{4,2},{0,4},{2,4},{4,4}};
pedges={{2,5},{4,5},{5,6},{5,8},{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};
pfaces={{1,2,5,4},{2,3,6,5},{4,5,8,7},{5,6,9,8}};
dverts={{1,1},{3,1},{1,3},{3,3}};
pefis={{1,2},{1,3},{2,4},{3,4},{1},{2},{2},{4},{4},{3},{3},{1}};
dfaces={{1,2,4,3}};
iverts={5};
bverts={1,2,3,6,9,8,7,4};
bedge=5;
bface=1;
{edgepair,edgetype}=MakePrimalDualTwistTessellationBoundaryEdge[pedges[[bedge]],bface,pverts,dverts,\[Rho],\[Beta]];
Show[GraphGraphics[MakeTGraph[pverts,pedges,pfaces]],Graphics[Style[Line[edgepair],edgetype]/.TypeToCreasePatternStyleRules]]/.OrigamiStyle[]
]//ShowExample
MakePrimalDualTwistTessellationInteriorEdges[pedge_,dedge_,pverts_,dverts_,bverts_,\[Rho]_,\[Beta]_]:=Module[{p1,p2,d1,d2,p1d1,p1d2,p2d1,p2d2,p1b,p2b,ob,edgepairs,edgetypes},
{p1,p2}=pverts[[pedge]];
{d1,d2}=dverts[[dedge]];
p1d1=ScaleAndTwistPoint[p1,d1,\[Rho],\[Beta]];
p2d1=ScaleAndTwistPoint[p2,d1,\[Rho],\[Beta]];
p1d2=ScaleAndTwistPoint[p1,d2,\[Rho],\[Beta]];
p2d2=ScaleAndTwistPoint[p2,d2,\[Rho],\[Beta]];
p1b=MemberQ[bverts,pedge[[1]]];
p2b=MemberQ[bverts,pedge[[2]]];
ob=(p2d1-p1d1) . (p1d2-p1d1)<0;(* p1d1 is obtuse *)
edgepairs={{p2d1,p1d1},{p1d1,p1d2},{p1d2,p2d2},{p2d1,p2d2}};
edgetypes={M,If[p1b,B,If[ob,M,V]],V,If[p2b,B,If[ob,V,M]]};
{edgepairs,edgetypes}]
Module[{\[Gamma],\[Alpha],dir,\[Rho],\[Beta],pverts,pedges, pfaces,dverts,dedges,dfaces,iverts,bverts,iedge,edgepairs,edgetypes},
\[Gamma]=2.0;
\[Alpha]=20.\[Degree];
dir=CCW;
{\[Rho],\[Beta]}=ShrinkAndTwistParms[\[Gamma],\[Alpha],TwistDirection->dir];
Print["\[Rho]=",\[Rho],", \[Beta]=",\[Beta]/\[Degree],"\[Degree]"];
pverts={{0,0},{2,0},{4,0},{0,2},{2,2},{4,2},{0,4},{2,4},{4,4}};
pedges={{2,5},{4,5},{5,6},{5,8},{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};
pfaces={{1,2,5,4},{2,3,6,5},{4,5,8,7},{5,6,9,8}};
dverts={{1,1},{3,1},{1,3},{3,3}};
dedges={{1,2},{1,3},{2,4},{3,4}};
dfaces={{1,2,4,3}};
iverts={5};
bverts={1,2,3,6,9,8,7,4};
iedge=1;
{edgepairs,edgetypes}=MakePrimalDualTwistTessellationInteriorEdges[pedges[[iedge]],dedges[[iedge]],pverts,dverts,bverts,\[Rho],\[Beta]];
Show[GraphGraphics[MakeTGraph[pverts,pedges,pfaces]],Graphics[{Style[DirectedEdgeLines[dverts,dedges],Blue],MapThread[Style[Line[#1],#2]&,{edgepairs,edgetypes}]/.TypeToCreasePatternStyleRules}]]/.OrigamiStyle[]
]//ShowExample
PostRotation::usage="PostRotation is an option to makePrimalDualTwistTessellationEdges that specifies whether and how to rotate the resulting plane graph.";
PrimalRotation::usage="PrimalRotation is an option value for PostRotation that specifies to rotate the result so that the primal polygons are in their original orientation.";
DualRotation::usage="DualRotation is an option value for PostRotation that specifies to rotate the result so that the dual polygons are in their original orientation.";
Options[MakePrimalDualTwistTessellationEdges]={
PostRotation->None,
TwistDirection->CCW
};
MakePrimalDualTwistTessellationEdges[tobj_TObj,\[Gamma]_,\[Alpha]_,opts___]:=Module[{pverts,pedges,dverts,dedges,iverts,bverts,iedges,bedges,bfaces,pr,edgepairs,edgetypes,ep,ty,\[Rho],\[Beta],\[Rho]\[Rho],\[Beta]\[Beta],newverts,newedges},
{pverts,pedges,dverts,dedges,iverts,bverts,iedges,bedges,bfaces}=GetValues[tobj,{Vertices,Edges,DualVertices,DualEdges,InteriorVertices,BoundaryVertices,InteriorEdges,BoundaryEdges,BoundaryFaces}];
pr=PostRotation/.{opts}/.Options[MakePrimalDualTwistTessellationEdges];
{\[Rho],\[Beta]}=ShrinkAndTwistParms[\[Gamma],\[Alpha],opts];
{\[Rho]\[Rho],\[Beta]\[Beta]}=DualShrinkAndTwistParms[\[Rho],\[Beta]];
edgepairs=edgetypes={};
MapThread[({ep,ty}=MakePrimalDualTwistTessellationInteriorEdges[#1,#2,pverts,dverts,bverts,\[Rho],\[Beta]];JoinTo[edgepairs,ep];JoinTo[edgetypes,ty])&,{iedges,dedges}];
MapThread[({ep,ty}=MakePrimalDualTwistTessellationBoundaryEdge[#1,#2,pverts,dverts,\[Rho],\[Beta]];AppendTo[edgepairs,ep];AppendTo[edgetypes,ty])&,{pedges[[#]]&/@bedges,bfaces}];
Switch[pr,
PrimalRotation,edgepairs=Map[RotationMatrix2D[-\[Beta]] . #&,edgepairs,{2}],
DualRotation,edgepairs=Map[RotationMatrix2D[-\[Beta]\[Beta]] . #&,edgepairs,{2}]];
{newverts,newedges}=Indexify[edgepairs,2];
MakeTGraph[newverts,newedges]//AddTAssignedTo[#,edgetypes]&]
Module[{\[Gamma],\[Alpha],dir,\[Rho],\[Beta],pverts,pedges,tobj,tobjpdpg,tobjpdtte},
\[Gamma]=2.0;
\[Alpha]=20.\[Degree];
dir=CCW;
{\[Rho],\[Beta]}=ShrinkAndTwistParms[\[Gamma],\[Alpha],TwistDirection->dir];
Print["\[Rho]=",\[Rho],", \[Beta]=",\[Beta]/\[Degree],"\[Degree]"];
pverts={{0,0},{2,0},{4,0},{0,2},{2,2},{4,2},{0,4},{2,4},{4,4}};
pedges={{2,5},{4,5},{5,6},{5,8},{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};
tobj=MakeTGraph[pverts,pedges]//AddTPlaneGraph;
tobjpdpg=AddTPrimalDualGraphTo[tobj];
tobjpdtte=MakePrimalDualTwistTessellationEdges[tobjpdpg,\[Gamma],\[Alpha],PostRotation->PrimalRotation];
GraphicsRow[{
GraphGraphics[tobj],
PrimalDualGraphics[tobjpdpg,DualDirectedEdges->True],
CreasePatternGraphics[tobjpdtte]/.OrigamiStyle[]
}]
]//ShowExample
Options[MakePrimalDualTwistTessellation]={
PostRotation->None,
TwistDirection->CCW
};
MakePrimalDualTwistTessellation[tobj_TObj,\[Gamma]_,\[Alpha]_,opts___]:=Module[{tobj1,vertsff},
AssertClass[tobj,TPrimalDualGraph,MakePrimalDualTwistTessellation];
tobj1=MakePrimalDualTwistTessellationEdges[tobj,\[Gamma],\[Alpha],opts]//AddTPlaneGraphTo;
vertsff=GetValue[MakePrimalDualTwistTessellationEdges[tobj,\[Gamma],-\[Alpha],opts],Vertices];
tobj1//AddTGraph2D[vertsff]]
Module[{\[Gamma],\[Alpha],dir,\[Rho],\[Beta],pverts,pedges, tobjpd,tobjtt},
\[Gamma]=2.0;
\[Alpha]=20.\[Degree];
dir=CCW;
{\[Rho],\[Beta]}=ShrinkAndTwistParms[\[Gamma],\[Alpha],TwistDirection->dir];
Print["CP: \[Rho]=",\[Rho],", \[Beta]=",\[Beta]/\[Degree],"\[Degree]"];
{\[Rho],\[Beta]}=ShrinkAndTwistParms[\[Gamma],-\[Alpha],TwistDirection->dir];
Print["FF: \[Rho]=",\[Rho],", \[Beta]=",\[Beta]/\[Degree],"\[Degree]"];
pverts={{0,0},{2,0},{4,0},{0,2},{2,2},{4,2},{0,4},{2,4},{4,4}};
pedges={{2,5},{4,5},{5,6},{5,8},{1,2},{2,3},{3,6},{6,9},{9,8},{8,7},{7,4},{4,1}};
tobjpd=MakeTGraph[pverts,pedges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo;
tobjtt=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha],TwistDirection->dir,PostRotation->PrimalRotation];
GraphicsRow[{
PrimalDualGraphics[tobjpd,DualDirectedEdges->True],
GraphGraphics[tobjtt],
CreasePatternGraphics[tobjtt],
VisibleFoldedFormGraphics[tobjtt,FaceupFace->3]}]/.OrigamiStyle[]
]//ShowExample
Module[{p1,p2,p3,p4,p5,p6,p7,p8,p9,p19,p10,p11,p12,p13,p14,p15,p16,p17,p18,verts,edges,tobjpd,\[Gamma],\[Alpha],dir,tobjtt},
p1={0,0};p2={1,0};p3=p2+U[60\[Degree]];p4=p3+U[120\[Degree]];p5=p4+U[180\[Degree]];p6=p5+U[240\[Degree]];
p7=p1+U[210\[Degree]];p8=p1+U[270\[Degree]];
p9=p2+U[270\[Degree]];p10=p2+U[330\[Degree]];
p11=p3+U[-30\[Degree]];p12=p3+U[30\[Degree]];
p13=p4+U[30\[Degree]];p14=p4+U[90\[Degree]];
p15=p5+U[90\[Degree]];p16=p5+U[150\[Degree]];
p17=p6+U[150\[Degree]];p18=p6+U[210\[Degree]];
verts={p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,1},{1,7},{1,8},{2,9},{2,10},{3,11},{3,12},{4,13},{4,14},{5,15},{5,16},{6,17},{6,18},{7,8},{8,9},{9,10},{10,11},{11,12},{12,13},{13,14},{14,15},{15,16},{16,17},{17,18},{18,7}
};
tobjpd=MakeTGraph[verts,edges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo;
tobjpd=OrientEdgePairs[tobjpd,RadialAxialOrderingFn[(p1+p4/2),RadialMajor->True]];
\[Gamma]=2.0;
\[Alpha]=30.\[Degree];
dir=CCW;
tobjtt=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha],TwistDirection->dir,PostRotation->PrimalRotation];
PartitionedGraphicsGrid[{
PrimalDualGraphics[tobjpd,DualDirectedEdges->True],
GraphGraphics[tobjtt],
CreasePatternGraphics[tobjtt],
VisibleFoldedFormGraphics[tobjtt,FaceupFace->1]},2]/.OrigamiStyle[]
]//ShowExample
Module[{n,\[Gamma],\[Alpha],dir,\[Rho],\[Beta],pverts,pedges, tobjpd,ctr,tobjtt},
n=3;
pverts=Flatten[Table[N[{i-1,j-1}],{j,n+1},{i,n+1}],1];
pedges=Join[Flatten[Table[{i+(n+1)(j-1),i+1+(n+1)(j-1)},{j,n+1},{i,n}],1],Flatten[Table[{i+(n+1)(j-1),i+(n+1)(j)},{j,n},{i,n+1}],1]];
tobjpd=MakeTGraph[pverts,pedges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo;
ctr=With[{dverts=GetValue[tobjpd,DualVertices]},Plus@@dverts/Length[dverts]];
tobjpd=OrientEdgePairs[tobjpd,RadialAxialOrderingFn[ctr]];
\[Gamma]=2.0;
\[Alpha]=30.\[Degree];
dir=CCW;
tobjtt=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha],TwistDirection->dir,PostRotation->PrimalRotation];
PartitionedGraphicsGrid[{
PrimalDualGraphics[tobjpd,DualDirectedEdges->True],
GraphGraphics[tobjtt],
CreasePatternGraphics[tobjtt],
VisibleFoldedFormGraphics[tobjtt,FaceupFace->1]},2]/.OrigamiStyle[]
]//ShowExample
GoldbergPoint[m_,n_,k_,l_]:=Module[{\[Phi]},
\[Phi]=\[Pi]/m;
RotationMatrix2D[2k \[Phi]] . ({n,0}+2l Sin[\[Phi]] U[\[Pi]/2+\[Phi]])]
Module[{m},
m=9;
Graphics[{
Style[Table[Point[GoldbergPoint[m,in,0,0]],{in,0,3}],Red,AbsolutePointSize[12]],
Style[Table[Point[GoldbergPoint[m,1,ik,0]],{ik,0,3}],Green,AbsolutePointSize[8]],
Style[Table[Point[GoldbergPoint[m,1,0,il]],{il,0,3}],Blue,AbsolutePointSize[4]]}]
]//ShowExample
MakeGoldbergTiling[m_,n_]:=
Flatten[{
Table[{GoldbergPoint[m,in,ik,il],GoldbergPoint[m,in+1,ik,il]},{ik,0,m-1},{il,0,n},{in,il,n-1}],
Table[{GoldbergPoint[m,in,ik,il],GoldbergPoint[m,in,ik,il+1]},{ik,0,m-1},{il,0,n},{in,il+1,n}],
Table[{GoldbergPoint[m,in,ik,il],GoldbergPoint[m,in+1,ik,il+1]},{ik,0,m-1},{il,0,n},{in,il+1,n-1}]
},3]
Module[{m,n,elist},
m=8;
n=2;
elist=MakeGoldbergTiling[m,n];
Graphics[Style[{Line[#],Point/@#}&/@elist,AbsolutePointSize[5],Orange],Frame->True]
]//ShowExample
MakeGoldbergTilingGraph[m_,n_]:=Module[{elist,verts,edges},
elist=MakeGoldbergTiling[m,n]//N;
{verts,edges}=Indexify[elist,2];
MakeTGraph[verts,edges]]
Module[{m,n,tobj},
m=9;
n=2;
tobj=MakeGoldbergTilingGraph[m,n];
GraphGraphics[tobj]
]//ShowExample
MakeGoldbergTilingPrimalDualGraph[m_,n_]:=Module[{tobj},
MakeGoldbergTilingGraph[m,n]//AddTPlaneGraphTo//AddTPrimalDualGraphTo//MakeTriangleGraphReciprocalDiagram]
Module[{m,n,tobj},
m=9;
n=2;
tobj=MakeGoldbergTilingPrimalDualGraph[m,n];
PrimalDualGraphics[tobj]
]//ShowExample
Module[{m,n,tobjpd,\[Gamma],\[Alpha],dir,tobj},
m=7;
n=2;
tobjpd=MakeGoldbergTilingPrimalDualGraph[m,n];
tobjpd=OrientEdgePairs[tobjpd,RadialAxialOrderingFn[{0,0}]];
\[Gamma]=1.15;
\[Alpha]=25.71\[Degree];
dir=CW;
tobj=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha],TwistDirection->dir,PostRotation->PrimalRotation];
GraphicsRow[{
PrimalDualGraphics[tobjpd,DualDirectedEdges->True],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->1]}]/.OrigamiStyle[]
]//ShowExample
MakeOffsetGoldbergTiling::badrot="The rotational order `1` must be even.";
MakeOffsetGoldbergTiling::badoff="The offset `1` must be positive.";
MakeOffsetGoldbergTiling[m_,n_,o_:1]:=Module[{elist,etop,ebot},
If[Mod[m,2]!=0,Message[MakeOffsetGoldbergTiling::badrot,m];Abort[]];
If[o<0,Message[MakeOffsetGoldbergTiling::badoff,o];Abort[]];
elist=MakeGoldbergTiling[m,n];
{etop,ebot}=GatherBy[elist,N[#[[1,2]]]<-10^-6||N[#[[2,2]]]<-10^-6&];
Join[Map[{-o/2,0}+#&,etop,{2}],Map[{o/2,0}+#&,ebot,{2}],Table[{{n+io-o/2,0},{n+io+1-o/2,0}},{io,0,o-1}]]]
Module[{m,n,elist},
m=8;
n=2;
elist=MakeOffsetGoldbergTiling[m,n,1];
Graphics[Style[{Line[#],Point/@#}&/@elist,AbsolutePointSize[5],Orange],Frame->True]
]//ShowExample
MakeOffsetGoldbergTilingGraph[m_,n_,o_:1]:=Module[{elist,verts,edges},
elist=MakeOffsetGoldbergTiling[m,n,o]//N;
{verts,edges}=Indexify[elist,2];
MakeTGraph[verts,edges]]
Module[{m,n,tobj},
m=8;
n=2;
tobj=MakeOffsetGoldbergTilingGraph[m,n,1];
GraphGraphics[tobj]
]//ShowExample
MakeOffsetGoldbergTilingPrimalDualGraph[m_,n_,o_:1]:=Module[{tobj},
tobj=MakeOffsetGoldbergTilingGraph[m,n]//AddTPlaneGraphTo//AddTPrimalDualGraphTo//MakeTriangleGraphReciprocalDiagram]
Module[{m,n,tobj},
m=8;
n=1;
tobj=MakeOffsetGoldbergTilingPrimalDualGraph[m,n,1];
PrimalDualGraphics[tobj]
]//ShowExample
Module[{
m,n,o,tobjpd,\[Gamma],\[Alpha],tobj},
m=8;
n=2;
o=1;
tobjpd=MakeOffsetGoldbergTilingPrimalDualGraph[m,n,o];
tobjpd=OrientEdgePairs[tobjpd,RadialAxialOrderingFn[{0,0},RadialMajor->False]];
\[Gamma]=1.0;
\[Alpha]=22.0\[Degree];
tobj=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha]];
GraphicsRow[{
PrimalDualGraphics[tobjpd,DualDirectedEdges->True],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->-1]
}]/.OrigamiStyle[]
]//ShowExample
MakeDelaunayTriangulationPrimalDualGraph[pverts_]:=Module[{delval,pedges,tobj,pfaces,dverts,dedges,dfaces,iverts,bverts,iedges,bedges,bfaces},
delval=DelaunayTriangulation[pverts];
pedges=Union[Flatten[Transpose[{Table[#[[1]],{Length[#[[2]]]}],#[[2]]}]&/@delval,1],SameTest->SameEdgeQ];
MakeTGraph[pverts,pedges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo//MakeTriangleGraphReciprocalDiagram]
Module[{pverts,tobjpd,\[Gamma],\[Alpha],dir,tobj},
SeedRandom[0];
pverts=Table[0.1+0.8 {Random[],Random[]},{8}]; 
tobjpd=MakeDelaunayTriangulationPrimalDualGraph[pverts];
\[Gamma]=1.0;
\[Alpha]=15.\[Degree];
dir=CCW;
tobj=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha],Direction->dir];
GraphicsRow[{
Graphics[PrimalDualGraphics[tobjpd,DualDirectedEdges->True][[1]],Frame->True],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->-1]
}]/.OrigamiStyle[]
]//ShowExample
MakeBoundedVoronoiDiagramPrimalDualGraph::notuniq="MakeBoundedVoronoiDiagramPrimalDualGraph failed because BoundedDiagram failed (see preceding message for details).";
MakeBoundedVoronoiDiagramPrimalDualGraph[bounds_,points_]:=Module[{delval,bd,vorverts,vadj,pverts,pfaces1,pedges,dverts1,pfaces,dverts,tobj},
(* construct the Delaunay triangulation and the Voronoi diagram of the points *)
delval=DelaunayTriangulation[points];
bd=BoundedDiagram[bounds,points,delval];
If[SameQ[Head[bd],BoundedDiagram],Message[MakeBoundedVoronoiDiagramPrimalDualGraph::notuniq];Abort[]];
{vorverts,vadj}=bd;
(* construct verts and edges; also note the faces and dual vertices for later use *)
pverts=vorverts;
pfaces1=Last/@vadj;
pedges=Union[Flatten[Transpose[{#,RotateLeft[#]}]&/@pfaces1,1],SameTest->SameEdgeQ];
dverts1=points;
(* build all the plane graph data. Note that pfaces will in general be a different order than pfaces1. *)
tobj=MakeTGraph[pverts,pedges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo;
(* now we replace the (approximate) dual vertices with the real ones, using the permutation derived from  face lists. *)
{pfaces,dverts}=GetValues[tobj,{Faces,DualVertices}];
Do[If[SameFaceQ[pfaces[[i]],pfaces1[[j]]],dverts[[i]]=dverts1[[j]]],{i,Length[pfaces]},{j,Length[pfaces]}];
ReplacePropertyIn[tobj,DualVertices->dverts]]
Module[{bounds,points,tobjpd,\[Gamma],\[Alpha],dir,tobj},
bounds={{0,0},{1,0},{1,1},{0,1}};
SeedRandom[0];
points=Table[0.1+0.8 {Random[],Random[]},{8}]; (* Use 7 pts to test the error, use 8 for complete function *)
tobjpd=MakeBoundedVoronoiDiagramPrimalDualGraph[bounds,points];
\[Gamma]=1.0;
\[Alpha]=15.\[Degree];
dir=CCW;
tobj=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha],Direction->dir];
GraphicsRow[{
PrimalDualGraphics[tobjpd],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->-1]
}]/.OrigamiStyle[]
]//ShowExample
PenroseBorderTriangles::usage="PenroseBorderTriangles is an option to MakePenroseRhombTilingPrimalDualGraph that specifies whether to include half-rhombs on the border of the pattern.";
Options[MakePenroseRhombTilingPrimalDualGraph]={
PenroseBorderTriangles->True
};
MakePenroseRhombTilingPrimalDualGraph[n_,opts___]:=Module[{bt,sd,\[Phi],a1,a2,o1,o2,deflate,tl,tdv,dv,cmp,pairs,solos,lut,pverts,pedges,tobj,pfaces,dverts},
bt=PenroseBorderTriangles/.{opts}/.Options[MakePenroseRhombTilingPrimalDualGraph];
(* infrastructure for building Penrose tilings *)
\[Phi]=GoldenRatio//N;
sd=Switch[Mod[n,2],
1,Module[{i},Flatten[Table[{a1[{Cos[72 i \[Degree]],Sin[72 i  \[Degree]]},{0,0},{Cos[(36+72 i)  \[Degree]],Sin[(36+72 i)  \[Degree]]}],a1[{Cos[72 i  \[Degree]],Sin[72 i  \[Degree]]},{0,0},{Cos[(-36+72 i)  \[Degree]],Sin[(-36+72 i)  \[Degree]]}]},{i,0,4}]]],
0,Module[{i},Flatten[Table[{o1[{0,0},{Cos[72 i  \[Degree]],Sin[72 i  \[Degree]]},\[Phi] {Cos[(36+72 i)  \[Degree]],Sin[(36+72 i)  \[Degree]]}],o1[{0,0},{Cos[72 i  \[Degree]],Sin[72 i  \[Degree]]},\[Phi] {Cos[(-36+72 i)  \[Degree]],Sin[(-36+72 i)  \[Degree]]}]},{i,0,4}]]],
_,Message[MakePenroseRhombTilingPrimalDualGraph::badopt,sd];Abort[]]//N;
(* deflation rules *)
deflate[a1[x_,y_,z_]]:=With[{d=((\[Phi]-1) x+(2-\[Phi]) y)},{a2[d,z,x],o2[z,d,y]}];
deflate[o1[x_,y_,z_]]:={o2[x,y,z]};
deflate[a2[x_,y_,z_]]:={a1[x,y,z]};
deflate[o2[x_,y_,z_]]:=With[{d=(2-\[Phi]) x+(\[Phi]-1) z},{o1[z,d,y],a1[y,x,d]}];
deflate[x_List]:=Join@@(deflate/@x);
deflate[x_List,0]:=x;
deflate[x_List,nn_]:=Nest[deflate,x,nn];
(* the desired raw tiling in triangle form *)
tl=deflate[sd,2\[LeftFloor]n/2\[RightFloor]+1];
(* record the dual vertex coordinates for each triangle *)
tdv=tl/.{a2[x_,y_,z_]:>x+(1/2-\[Phi]/2)(z-x),o2[x_,y_,z_]:>z+(1-\[Phi]/2)(x-z)};
(* indexify all vertex coordinates *)
{pverts,tl}=Indexify[tl,2];
(* group triangles into pairs and isolated triangles (which are on the border) *)
cmp[a2[x1_,y1_,z1_], a2[x2_,y2_,z2_]]:=(x1==x2)&&(z1==z2);
cmp[o2[x1_,y1_,z1_], o2[x2_,y2_,z2_]]:=(x1==x2)&&(z1==z2);
pairs={};
solos={};
Do[If[cmp[tl[[i]],tl[[j]]],AppendTo[pairs,tl[[i]]];AppendTo[pairs,tl[[j]]]],{i,2,Length[tl]},{j,i-1}];
Do[If[!IntersectingQ[{tl[[i]]},pairs],AppendTo[solos,tl[[i]]]],{i,Length[tl]}];
(* build edges of rhombs and border triangles *)
pedges=Flatten[pairs/.{a2[x_,y_,z_]|o2[x_,y_,z_]:>{{x,y},{y,z}}},1]~Join~Flatten[solos/.{a2[x_,y_,z_]|o2[x_,y_,z_]:>{{x,y},{y,z},{z,x}}},1];
pedges=Union[Sort/@pedges];
(* build the full set of plane graph data, using centroids for the dual vertices *)
tobj=MakeTGraph[pverts,pedges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo;
pfaces=GetValue[tobj,Faces];
(* but substitute the dual vertices we already computed *)
{dv,tdv}=Indexify[tdv];
(* lut is a lookup table that maps a trio of pvert indices to an index into dv *)
lut=Transpose[{List@@#&/@tl,tdv}];
dverts=dv[[Table[Select[lut,IntersectingQ[pfaces[[i]],{#[[1,1]]}]&&IntersectingQ[pfaces[[i]],{#[[1,2]]}]&&IntersectingQ[pfaces[[i]],{#[[1,3]]}]&][[1,2]],{i,Length[pfaces]}]]];
ReplacePropertyIn[tobj,DualVertices->dverts]]
Module[{tobjpd,\[Gamma],\[Alpha],dir,tobj},
tobjpd=MakePenroseRhombTilingPrimalDualGraph[3];
\[Gamma]=1;
\[Alpha]=15.\[Degree];
dir=CCW;
tobj=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha],Direction->dir];
GraphicsRow[{
PrimalDualGraphics[tobjpd],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->-1]
}]/.OrigamiStyle[]
]//ShowExample
Options[MakeRotationalTrapezoidPrimalDualGraph]={
IncludeCenter->False
};
MakeRotationalTrapezoidPrimalDualGraph[m_, rvals_, opts___]:=Module[{ic,vfn,tobj,verts,faces,dverts},
ic=IncludeCenter/.{opts}/.Options[MakeRotationalTrapezoidPrimalDualGraph];
vfn[i_,j_]:=If[i==0,{0,0},rvals[[i]]U[2\[Pi] (j-1)/m]];
Off[N::meprec];(* to prevent annoying and unimportant warning *)
tobj=MakeRotationalMesh[Length[rvals],m,vfn,IncludeCenter->ic]//AddTPlaneGraph//AddTPrimalDualGraph;
(* tweak dual vertices to be the circumcenters of their respective faces *)
{verts,faces}=GetValues[tobj,{Vertices,Faces}];
dverts=Circumcenter/@N[verts[[#]]&/@faces];
On[N::meprec];
tobj//ReplaceProperty[DualVertices->dverts]
]
Module[{m,rvals,tobjpd,fn,\[Gamma],\[Alpha],dir,tobj},
m=11;
rvals={1,2,4};
tobjpd=MakeRotationalTrapezoidPrimalDualGraph[m,rvals,IncludeCenter->False];
fn=RadialAxialOrderingFn[{0,0},RadialMajor->True];
tobjpd=OrientEdgePairs[tobjpd,fn];
\[Gamma]=2;
\[Alpha]=20.\[Degree];
dir=CW;
tobj=MakePrimalDualTwistTessellation[tobjpd,\[Gamma],\[Alpha],Direction->dir];
GraphicsRow[{
PrimalDualGraphics[tobjpd,DualDirectedEdges->True],
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj,FaceupFace->1]
}]/.OrigamiStyle[]
]//ShowExample
GroupFaces::usage="GroupFaces is an option to MakePrimalDualFlagstoneTessellation that specifies whether to group faces on the same level of folding.";
Options[MakePrimalDualFlagstoneTessellation]={
GroupFaces->False
};
MakePrimalDualFlagstoneTessellation[tobj_TObj, \[Rho]_,opts___]:=
Module[{gf,edges,edgetypes,clines,csave,pverts,pedges,pfaces,vva,boundary,bedges,vfi,dverts,dedges,iverts,iedges,bedgepairs,nb,nv,vpo,vpi,iv,vd,fp,fn,cpl,ctr,cpv,cpvi,t,pcl,vertscp,vertsff,gfaces,faces,tobjcp,tobjff},
AssertClass[tobj,TPrimalDualGraph];
gf=GroupFaces/.{opts}/.Options[MakePrimalDualFlagstoneTessellation];
edges={};(* edges of the new graph *)
edgetypes={};(* edge types of the new graph *)
gfaces=Table[{},{7}];
clines={};(* accumulation of colored lines, useful for debugging *)
csave[color_]:=AppendTo[clines,Style[Line[edges[[-1]]],color]];(* save the last edge we created with a color *)

{pverts,pedges,pfaces,vva,vfi,boundary,bedges,dverts,dedges,iverts,iedges}=GetValues[tobj,{Vertices,Edges,Faces,VertexVertexAdjacency,VertexFaceIncidence,BoundaryVertices,BoundaryEdges,DualVertices,DualEdges,InteriorVertices,InteriorEdges}];

(* build neighborhood of each vertex *)
(* nb\[LeftDoubleBracket]iv\[RightDoubleBracket] is a set of triples {fp, vd, fn} for each edge surrounding vertex iv, where fp is preceding face, vd is vertex at other end of the edge, and fn is following face, cycling CCW *)
nb=Transpose/@Transpose[{RotateRight[#]&/@vfi,vva,vfi}];
(* nv\[LeftDoubleBracket]iv\[RightDoubleBracket] is the vertex degree of vertex iv *)
nv=Length/@vva;

(* vpo[iv,if] is the outer pleat vertex closest to vertex iv and face if *)
Do[(* for each face *)
Do[(* for each vertex of the face *)
iv=pfaces[[if,j]];
vpo[iv,if]=(1-\[Rho])dverts[[if]]+(\[Rho])pverts[[iv]]
,{j,Length[pfaces[[if]]]}]
,{if,Length[pfaces]}];

(* vpi[iv,vd,if] is an inner pleat vertex closest to vertex iv, face if, that runs toward vertex vd *)
Do[(* for each vertex *)
Do[(* for each edge at the vertex *)
{fp,vd,fn}=nb[[iv,j]];(* preceding face, distal vertex, next face *)
If[fp!=0&&fn!=0,
vpi[iv,vd,fp]=(3/4)vpo[iv,fp] + (1/4)vpo[iv,fn];
vpi[iv,vd,fn]=(1/4)vpo[iv,fp] + (3/4)vpo[iv,fn];
];
,{j,nv[[iv]]}]
,{iv,Length[pverts]}];

(** BUILD EDGES OF CREASE PATTERN **)

(* Build folds around boundary vertices *)
Do[ (* for each boundary vertex *)
iv=boundary[[i]];(* boundary vertex we're working with *)
Do[ (* for each edge at this boundary vertex *)
{fp,vd,fn}=nb[[iv,j]];(* preceding face, distal vertex, next face *)
If[fp==0||fn==0,Continue[]];(* do nothing on edges that are on the boundary *)
(* accumulate pleat-crossing border lines *)
AppendTo[edges,{vpo[iv,fp],vpi[iv,vd,fp]}];AppendTo[edgetypes,B];csave[Black];
AppendTo[edges,{vpi[iv,vd,fp],vpi[iv,vd,fn]}];AppendTo[edgetypes,B];csave[Black];
AppendTo[edges,{vpi[iv,vd,fn],vpo[iv,fn]}];AppendTo[edgetypes,B];csave[Black];
,{j,nv[[iv]]}];
,{i,Length[boundary]}];

(* Build folds around interior vertices *)
Do[ (* for each interior vertex *)
iv=iverts[[i]];
cpl={};(* lines of central polygon *)
ctr=Plus@@(vpo[iv,#]&/@First/@nb[[iv]])/nv[[iv]];(* desired alignment point in central polygon *)
Do[ (* for each edge at this boundary vertex *)
{fp,vd,fn}=nb[[iv,j]];(* preceding face, distal vertex, next face *)
AppendTo[cpl,RotateSegment90[{ctr,vpo[iv,fp]}]];
,{j,nv[[iv]]}];
(* cpv[iv] is a list of the vertices of the central polygon in same order as elements of nb *)
cpv[iv]=LineInt2D1[#[[1,1]],#[[1,2]],#[[2,1]],#[[2,2]]]&/@Transpose[{cpl,RotateLeft[cpl]}];
(* build other vertices around the central polygon *)
Do[ (* for each edge at this interior vertex *)
{fp,vd,fn}=nb[[iv,j]];(* preceding face, distal vertex, next face *)
t=cpv[iv][[j]]+(vpo[iv,fp]-ctr);(* translate *)
t=Reflect2D[t,{vpo[iv,fp],vpo[vd,fp]}];(* reflect once in outer pleat *)
t=Reflect2D[t,{vpi[iv,vd,fp],vpi[vd,iv,fp]}];(* reflect again in inner pleat *)
pcl=RotateSegment90[{cpv[iv][[j]],t}];(* rotate segment to get pleat-crossing line *)
vpi[iv,vd,fp]=LineInt2D1[vpi[iv,vd,fp],vpi[vd,iv,fp],pcl[[1]],pcl[[2]]];(* inner pleat vertex *)
vpi[iv,vd,fn]=LineInt2D1[vpi[iv,vd,fn],vpi[vd,iv,fn],pcl[[1]],pcl[[2]]]; (* ditto *)
(* accumulate central polygon folds *)
AppendTo[edges,{cpv[iv][[j]],cpv[iv][[Mod[j+1,nv[[iv]],1]]]}];AppendTo[edgetypes,V];csave[Darker[Green]];
(* accumulate next ring folds *)
AppendTo[edges,{vpo[iv,fp],cpv[iv][[j]]}];AppendTo[edgetypes,M];csave[Magenta];
AppendTo[edges,{cpv[iv][[j]],vpo[iv,fn]}];AppendTo[edgetypes,M];csave[Magenta];
(* accumulate star-like folds *)
AppendTo[edges,{vpo[iv,fp],vpi[iv,vd,fp]}];AppendTo[edgetypes,V];csave[Cyan];
AppendTo[edges,{vpi[iv,vd,fp],cpv[iv][[j]]}];AppendTo[edgetypes,V];csave[Cyan];
AppendTo[edges,{cpv[iv][[j]],vpi[iv,vd,fn]}];AppendTo[edgetypes,V];csave[Cyan];
AppendTo[edges,{vpi[iv,vd,fn],vpo[iv,fn]}];AppendTo[edgetypes,V];csave[Cyan];
(* accumulate cross-pleat folds *)
AppendTo[edges,{vpi[iv,vd,fp],vpi[iv,vd,fn]}];AppendTo[edgetypes,M];csave[Orange];
,{j,nv[[iv]]}]
,{i,Length[iverts]}];

(* Build inner and outer pleats for each face, both interior and boundary pleats *)
bedgepairs=pedges[[#]]&/@bedges;
Do[(* for each face *)
Do[(* for each vertex in the face *)
iv=pfaces[[if,j]];
vd=pfaces[[if,Mod[j+1,Length[pfaces[[if]]],1]]];
If[IntersectingQ[bedgepairs,{{iv,vd}}]||IntersectingQ[bedgepairs,{{vd,iv}}],
(* it's a border edge *)
AppendTo[edges,{vpo[iv,if],vpo[vd,if]}];AppendTo[edgetypes,B];csave[Brown],
(* not a border edge *)
AppendTo[edges,{vpo[iv,if],vpo[vd,if]}];AppendTo[edgetypes,M];csave[Red];
AppendTo[edges,{vpi[iv,vd,if],vpi[vd,iv,if]}];AppendTo[edgetypes,V];csave[Blue];
];
,{j,Length[pfaces[[if]]]}];
,{if,Length[pfaces]}];

(** BUILD FACES OF CREASE PATTERN **)

Do[(* for each face *)
AppendTo[gfaces[[1]],MakeCCW[vpo[#,if]&/@pfaces[[if]]]]
,{if,Length[pfaces]}];

Do[(* for each interior edge *)
iv=iedges[[ie,1]];vd=iedges[[ie,2]];fp=dedges[[ie,1]];fn=dedges[[ie,2]];
AppendTo[gfaces[[2]],MakeCCW[{vpo[vd,fp],vpo[iv,fp],vpi[iv,vd,fp],vpi[vd,iv,fp]}]];
AppendTo[gfaces[[2]],MakeCCW[{vpo[vd,fn],vpo[iv,fn],vpi[iv,vd,fn],vpi[vd,iv,fn]}]];
AppendTo[gfaces[[3]],MakeCCW[{vpi[iv,vd,fn],vpi[vd,iv,fn],vpi[vd,iv,fp],vpi[iv,vd,fp]}]];
,{ie,Length[iedges]}];

Do[(* for each interior vertex *)
iv=iverts[[i]];
Do[(* for each edge at this interior vertex *)
{fp,vd,fn}=nb[[iv,j]];(* preceding face, distal vertex, next face *)
AppendTo[gfaces[[4]],MakeCCW[{vpi[iv,vd,fp],vpi[iv,vd,fn],cpv[iv][[j]]}]];
AppendTo[gfaces[[5]],MakeCCW[{vpi[iv,vd,fp],vpo[iv,fp],cpv[iv][[j]]}]];
AppendTo[gfaces[[5]],MakeCCW[{vpi[iv,vd,fn],vpo[iv,fn],cpv[iv][[j]]}]];
AppendTo[gfaces[[6]],MakeCCW[{vpo[iv,fp],cpv[iv][[Mod[j-1,nv[[iv]],1]]],cpv[iv][[j]]}]];
,{j,nv[[iv]]}];
AppendTo[gfaces[[7]],MakeCCW[cpv[iv]]];
,{i,Length[iverts]}];

(* handy debugging graphs *)
Print[PrimalDualGraphics[tobj]]//Hold;
Print[Graphics[clines]]//Hold;

(* compute the CP and FF *)
{vertscp,edges} = Indexify[edges,2];
tobjcp=MakeTGraph[vertscp,edges]//AddTPlaneGraph//AddTAssigned[edgetypes];FoldGraph2D[tobjcp,Switch[#,B,0,M,\[Pi],V,-\[Pi]]&/@edgetypes]//Hold;(* There's an occasional bug in this, use old version *)
tobjff=FoldGraph2DAll[tobjcp];
tobjff]
Module[{verts,edges,tobjpd,tobj},
verts={{-1,-1},{0,-1},{1,-1},{-1,0},{0,0},{1,0},{-.5,1},{.5,1}};
edges={{1,2},{2,3},{1,4},{2,5},{3,6},{4,5},{5,6},{4,7},{5,7},{5,8},{6,8},{7,8}};
tobjpd=MakeTGraph[verts,edges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo//MakeReciprocalDiagram;
tobj=MakePrimalDualFlagstoneTessellation[tobjpd,0.5];
GraphicsGrid[{{
PrimalDualGraphics[tobjpd],
GraphGraphics[tobj]},{
CreasePatternGraphics[tobj],
VisibleFoldedFormGraphics[tobj]//KillHidden
}}]/.OrigamiStyle[]
]//ShowExample
Module[{p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,verts,edges,tobjpd,tobj},
p1={0,0};p2={1,0};p3=p2+U[60\[Degree]];p4=p3+U[120\[Degree]];p5=p4+U[180\[Degree]];p6=p5+U[240\[Degree]];
p7=p1+U[210\[Degree]];p8=p1+U[270\[Degree]];
p9=p2+U[270\[Degree]];p10=p2+U[330\[Degree]];
p11=p3+U[-30\[Degree]];p12=p3+U[30\[Degree]];
p13=p4+U[30\[Degree]];p14=p4+U[90\[Degree]];
p15=p5+U[90\[Degree]];p16=p5+U[150\[Degree]];
p17=p6+U[150\[Degree]];p18=p6+U[210\[Degree]];
verts={p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,1},{1,7},{1,8},{2,9},{2,10},{3,11},{3,12},{4,13},{4,14},{5,15},{5,16},{6,17},{6,18},{7,8},{8,9},{9,10},{10,11},{11,12},{12,13},{13,14},{14,15},{15,16},{16,17},{17,18},{18,7}};
tobjpd=MakeTGraph[verts,edges]//AddTPlaneGraphTo//AddTPrimalDualGraphTo//MakeReciprocalDiagram;
tobj=MakePrimalDualFlagstoneTessellation[tobjpd,0.6];
GraphicsRow[{
PrimalDualGraphics[tobjpd],
CreasePatternGraphics[tobj],
GenericFoldedFormGraphics[tobj]
(*VisibleFoldedFormGraphics[tobj]*)
}]/.OrigamiStyle[]
]//ShowExample//Hold; (* As of Ma12, FindMinimum fails; need to debug *)
Module[{tobjpd,tobj},
tobjpd=MakePenroseRhombTilingPrimalDualGraph[3];
tobj=MakePrimalDualFlagstoneTessellation[tobjpd,0.75];
GraphicsRow[{
PrimalDualGraphics[tobjpd],
CreasePatternGraphics[tobj],
GenericFoldedFormGraphics[tobj]
}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,gpoly,dverts,tobjtri,tobjpd,tobjpd1,tobjpd2,fv,ev,av,tobjft},
(* set up a polygon *)
verts={{0,0},{1.1,-0.3},{1,.6},{1.5,1},{1.7,1.8},{.9,1.4},{0.5,1.8},{-.4,1.3},{.2,0.9}};
edges={{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,1}};
gpoly=GenericGraphGraphics[verts,edges];
dverts=verts;
(* manually create an acute triangulation. *)
edges = Join[edges,{{1,3},{9,3},{6,3},{6,4},{9,6},{9,7}}];
tobjtri=MakeTGraph[verts,edges]//AddTPlaneGraphTo;
(* Construct new primal/dual graph that includes dual vertices and midpoints of boundary edges *)
(* face vertices *)
fv=FaceCircumcenters[tobjtri];
(* edge vertices *)
ev = (verts + RotateLeft[verts])/2;
(* all vertices *)
av=Join[verts,ev,fv];
tobjpd=MakeTGraph[av,
{{1,10},{10,2},{2,11},{11,3},{3,12},{12,4},{4,13},{13,5},{5,14},{14,6},{6,15},{15,7},{7,16},{16,8},{8,17},{17,9},{9,18},{18,1},
{10,19},{19,24},{24,18},
{19,11},
{24,25},{25,20},{20,12},
{25,22},{22,23},{23,17},
{23,16},
{22,15},
{20,21},{21,13},
{21,14}}]//AddTPlaneGraphTo;
(* Construct dual graph and reciprocal diagram (not necessarily orthogonal) *)
tobjpd1 = tobjpd //AddTPrimalDualGraph//MakeReciprocalDiagram;
(* set dual vertices to original vertices, which will establish orthogonality *)
tobjpd2=tobjpd1//ReplaceProperty[DualVertices->dverts];
(* And make the flagstone tessellation *)
tobjft=MakePrimalDualFlagstoneTessellation[tobjpd2,0.85];
GraphicsGrid[{
{gpoly,GraphGraphics[tobjtri]},
{GraphGraphics[tobjpd],PrimalDualGraphics[tobjpd1],PrimalDualGraphics[tobjpd2]},
{CreasePatternGraphics[tobjft],GenericFoldedFormGraphics[tobjft]
}}]/.OrigamiStyle[]
]//ShowExample
MakeChordStarLines::distzero="The distances in the list `1` cannot contain zero values.";
MakeChordStarLines::distmag="The distances in the list `1` must have magnitude less than 1.";
MakeChordStarLines[specs_List,m_]:=Module[{dists,lines,alllines,bverts},
dists=Last/@specs;
If[Or@@(#==0&/@dists),Message[MakeChordStarLines::distzero,specs];Abort[]];
If[Or@@(Abs[#]>=1&/@dists),Message[MakeChordStarLines::distmag,specs];Abort[]];
lines={U[#[[1]]+ArcCos[#[[2]]]],U[#[[1]]-ArcCos[#[[2]]]]}&/@specs;
alllines=Flatten[Table[Map[RotationMatrix2D[2\[Pi] i/m] . #&,lines,{2}],{i,0,m-1}],1];
bverts=Sort[Union[Flatten[alllines,1]],ArcTan@@#1<ArcTan@@#2&];
Join[alllines,Transpose[{bverts,RotateLeft[bverts]}]]]
Graphics[Style[Line/@MakeChordStarLines[{{0\[Degree],0.15}},7],Blue]]//ShowExample
Graphics[Style[Line/@MakeChordStarLines[{{30\[Degree],0.4},{0\[Degree],0.3}},6],Blue]]//ShowExample
MakeChordStarLines[specs_List,m_,boundary_List]:=Module[{bmax,fspecs,lines,alllines,bverts},
bmax=Max[Mag/@boundary](* get circumradius of the boundary *);
fspecs=Select[specs,Mag[#[[2]]]<bmax&];(* filter specs to drop any that lie outside the circumcircle of boundary *)
lines=bmax{U[#[[1]]+ArcCos[#[[2]]/bmax]],U[#[[1]]-ArcCos[#[[2]]/bmax]]}&/@fspecs;
alllines=Flatten[Table[Map[RotationMatrix2D[2\[Pi] i/m] . #&,lines,{2}],{i,0,m-1}],1];
bverts=Flatten[Table[Map[RotationMatrix2D[2\[Pi] i/m] . #&,boundary],{i,0,m-1}],1];
bverts=Sort[bverts,ArcTan@@#1<ArcTan@@#2&];
alllines=ClipSegmentToConvexPolygon[#,bverts]&/@alllines;
alllines=Select[alllines,Mag[Subtract@@#]>0&];(* filter lines to drop zero-length ones *)
Join[alllines,Transpose[{bverts,RotateLeft[bverts]}]]]
Graphics[Style[Line/@MakeChordStarLines[{{0\[Degree],0.15}},7,{2.U[0\[Degree]],2. U[10\[Degree]]}],Blue]]//ShowExample
MakeChordStarGraph[specs_List,m_,opts___]:=Module[{emedges,verts,edges,tobj},
emedges=MakeChordStarLines[specs,m];
{verts,edges}=Indexify[emedges,2,opts];
tobj=MakeTGraph[verts,edges];
Intersectify[tobj,opts]]
GraphGraphics[MakeChordStarGraph[{{0\[Degree],0.15}},7]]//ShowExample
MakeChordStarGraph[specs_List,m_,boundary_List, opts___]:=Module[{emedges,verts,edges,tobj},
emedges=MakeChordStarLines[specs,m,boundary];
{verts,edges}=Indexify[emedges,2,opts];
tobj=MakeTGraph[verts,edges];
Intersectify[tobj,opts]]
GraphGraphics[MakeChordStarGraph[{{0\[Degree],0.15}},7,{1.2U[0\[Degree]],1.2 U[10\[Degree]]}]]//ShowExample
MaxTries::usage="MaxTries is an option to MakeCourteousAnarchyLines that specifies the maximum number of attempts to find courteous lines.";
RandSeed::usage="RandSeed is an option to MakeCourteousAnarchyLines that specifies a seed for the random number generator.";
Options[MakeCourteousAnarchyLines]={
MaxTries->20000,
RandSeed->0
};
MakeCourteousAnarchyLines[ngoal_,mindist_,boundary_List,opts___]:=Module[{mt,rs,box,ctr,rad,lines,ints,randline,fails,addone},
mt=MaxTries/.{opts}/.Options[MakeCourteousAnarchyLines];
rs=RandSeed/.{opts}/.Options[MakeCourteousAnarchyLines];
box={{Min[#[[1]]],Min[#[[2]]]},{Max[#[[1]]],Max[#[[2]]]}}&@Transpose[boundary];
ctr=Plus@@box/2;
rad=Mag[Subtract@@box];
lines=Transpose[{boundary,RotateLeft[boundary]}];(* accumulated lines, start w/ boundary *)
ints=boundary;(* accumulated intersection points, start w/ boundary *)
randline[]:=Module[{rctr,dir},
(* this function returns a random line whose center point lies within the polygon and with a random direction *)
rctr=Null;
While[rctr==Null||!PtInConvexPolygonQ[rctr,boundary],rctr=ctr+rad Random[]U[2\[Pi] Random[]]];
dir=rad U[2\[Pi] Random[]];
ClipSegmentToConvexPolygon[{rctr- dir, rctr+dir},boundary]];
fails=0; (* tracks numbers of attempts *)
addone[]:=Module[{newline,newints},
(* This function attempts to add a new line to the collection *)
If[Catch[
newline=randline[];
newints=LineInt2D1[newline[[1]],newline[[2]],#[[1]],#[[2]]]&/@lines;(* get all intersection pts with existing lines *)
newints=Select[newints,PtInConvexPolygonQ[#,boundary]&];(* keep only the ones withn the boundary *)
If[Length[newints]<=2&&Length[lines]!=Length[boundary],Throw[-1]];(* we want all new lines to intersect at least one other interior line *)
(* check intersections along this line *)
Do[If[Mag[newints[[i]]-newints[[j]]]<mindist,fails++;Throw[-1]],{i,Length[newints]},{j,i+1,Length[newints]}];
(* check intersections with other vertices *)
Do[If[Mag[newints[[i]]-#]<mindist,fails++;Throw[-1]]&/@ints,{i,Length[newints]}];
]==-1,Return[]];
(* still here? then it's a valid line. Add it, and its intersections. *)
AppendTo[lines,newline];
ints=Join[ints,newints];
];
SeedRandom[rs];
While[fails<mt&&Length[lines]<ngoal+Length[boundary],addone[]];
lines]
Module[{boundary,lines},
boundary=SquareVertices[1];
lines=MakeCourteousAnarchyLines[6,0.1,boundary,RandSeed->0];
Print["Found ",Length[lines]-Length[boundary]," lines"];
Graphics[Style[Line/@lines,Blue],Frame->True]
]
MakeCourteousAnarchyGraph[ngoal_,mindist_,boundary_List,opts___]:=Module[{lines,verts,edges,tobj},
lines=MakeCourteousAnarchyLines[ngoal,mindist,boundary,opts];
{verts,edges}=Indexify[lines,2,opts];
tobj=MakeTGraph[verts,edges];
Intersectify[tobj]]
Module[{boundary,tobj},
boundary=SquareVertices[1];
tobj=MakeCourteousAnarchyGraph[6,0.1,boundary,RandSeed->0];
GraphGraphics[tobj]
]//ShowExample
InsetSeparationFn[verts_List,edges_List]:=Module[{tobj,faces,h,iverts,idists},
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph;
faces=GetValue[tobj,Faces];
iverts=Flatten[InsetPoly[verts[[#]],h]&/@faces,1];
idists=Flatten[Table[Mag[iverts[[i]]-iverts[[j]]],{i,Length[iverts]},{j,i+1,Length[iverts]}],1];
Function[Evaluate[Min[idists]/.h->#]]]
Module[{isfn},
isfn=InsetSeparationFn[{{0,0},{1,0},{1,1},{0,1}},{{1,2},{2,3},{3,4},{4,1}}];
Print[isfn];
isfn[0.4]
]//ShowExample
InsetSeparationPlot[tobj_TObj,{min_,max_},opts___]:=Module[{isfn,verts,edges},
AssertClass[tobj,TGraph,InsetSeparationPlot];
{verts,edges}=GetValues[tobj,{Vertices,Edges}];
isfn=InsetSeparationFn[verts,edges];
Plot[isfn[x],{x,min,max}]
]
Module[{verts,edges,tobj},
verts={{0,0},{1,0},{1,1},{0,1}};
edges={{1,2},{2,3},{3,4},{4,1}};
tobj=MakeTGraph[verts,edges];
GraphicsRow[{GenericGraphGraphics[verts,edges],
InsetSeparationPlot[tobj,{0,1.5}]}]
]//ShowExample
MinimumPleatSize::usage="MinimumPleatSize is an option to MakeSimpleWovenTessellation that specifies the minimum pleat width relative to the inset distance.";
MinimumBorderPleatSize::usage="MinimumBorderPleatSize is an option to MakeSimpleWovenTessellation that specifies the minimum width of border pleats for diverging pleats.";
WovenParity::usage="WovenParity is an option to MakeSimpleWovenTessellation that specifies the direction of the overlaps beteen the woven strips.";
WovenPeriodicity::usage="WovenPeriodicity is an option to MakeSimpleWovenTessellation that specifies whether and how the pattern should be periodic.";
BorderInset::usage="BorderInset is an option to MakeSimpleWovenTessellation tha specifies whether the border should be inset.";
Options[MakeSimpleWovenTessellation]={
MinimumPleatSize->1,
MinimumBorderPleatSize->0.01,
BorderInset->Automatic,
WovenParity->1,
WovenPeriodicity->None,
StationaryFace->1,
ShowProgress->False
};
MakeSimpleWovenTessellation::badbi="Option BorderInset \[Rule] `1` must be either Automatic or None.";
MakeSimpleWovenTessellation::badper="Option WovenPeriodicity \[Rule] `1` must be either None or a list of index pairs.";
MakeSimpleWovenTessellation::badins="Inset list `1` must have the same length as edge list `2`.";
MakeSimpleWovenTessellation::optfail="MakeSimpleWovenTessellation failed because it was unable to find a minimum in the optimization step.";
MakeSimpleWovenTessellation::nokawa="MakeSimpleWovenTessellation failed because the best solution found has a Kawasaki condition mismatch greater than \!\(\*SuperscriptBox[\(10\), \(-4\)]\). Values were: `1`";
MakeSimpleWovenTessellation[tobj_TObj,inset_,opts___]:=Module[{mps,mbps,bi,wpar,wper,sface,sp,isper,tobjdef,verts,edges,faces,bverts,bedges,iedges,dedges,fei,vei,edgepairs,twocoloring,tcfv,h,insetverts,fvdata,beqv,beqe,di,db,makeverts,ndi,ndb,newverts,newfverts,newbverts,ocnmap,nwper,hdruleff,newedges,newtypes,nfvpos,prevnewvert,newvert,nextnewvert,altnewvert,prevvalvert,nextvalvert,addpleat,hdrulecp,tobjout,nedges,nbedges,niedges,vva,kawaconds,perconds,kawavals,merit,eqns,ineqns,vars,time,soln,newvertsff},
AssertClass[tobj,TGraph,MakeSimpleWovenTessellation];
mps=MinimumPleatSize/.{opts}/.Options[MakeSimpleWovenTessellation];
mbps=MinimumBorderPleatSize/.{opts}/.Options[MakeSimpleWovenTessellation];
bi=BorderInset/.{opts}/.Options[MakeSimpleWovenTessellation];
wpar=WovenParity/.{opts}/.Options[MakeSimpleWovenTessellation];
wper=WovenPeriodicity/.{opts}/.Options[MakeSimpleWovenTessellation];
sface=StationaryFace/.{opts}/.Options[MakeSimpleWovenTessellation];
sp=ShowProgress/.{opts}/.Options[MakeSimpleWovenTessellation];
If[!(bi===None||bi===Automatic),Message[MakeSimpleWovenTessellation::badbi,bi];Abort[]];
isper=!(wper===None);
If[isper&&!Head[wper]===List,Message[MakeSimpleWovenTessellation::badper,wper];Abort[]];

(* build the full primal-dual graph that we use to define the woven pattern *)
tobjdef=tobj//RebuildPlaneGraph//AddTPrimalDualGraph;
{verts,edges,faces,bverts,bedges,iedges,dedges,fei,vei}=GetValues[tobjdef,{Vertices,Edges,Faces,BoundaryVertices,BoundaryEdges,InteriorEdges,DualEdges,FaceEdgeIncidence,VertexEdgeIncidence}];
If[sp,Print["original pattern = ",GraphGraphics[tobjdef]]];
(* edgepairs *)
 edgepairs=OrientedInteriorEdgePairs[tobjdef];
If[sp,Print["edge pairs = ",edgepairs]];
(* two-coloring *)
twocoloring=TwoColorGraph[tobjdef,StartFace->wpar];
If[sp,Print["two-coloring = ",twocoloring,GenericGraphGraphics[verts,edges,faces,FaceColoring->twocoloring]]];
tcfv=MapThread[Table[#1,{Length[#2]}]&,{twocoloring,faces}];
If[sp,Print["two-coloring by vertex = ",tcfv]];

(* inset vertices *)
h=If[Head[inset]===List,
If[Length[inset]!=Length[edges],Message[MakeSimpleWovenTessellation::badins,inset,edges];Abort[]];inset,
Table[inset,{Length[edges]}]];
(* if we're specifying periodicity, set all boundary inset values to zero *)
If[isper||bi===None,(h[[#]]=0)&/@bedges];
insetverts=MapThread[InsetPoly[verts[[#1]],h[[#2]]]&,{faces,fei}];
If[sp,Print["inset polygons = ",Graphics[{
{Black,Point/@verts},
{Red,Line[verts[[#]]&/@#]&/@edges},
{Green,Line[AppendFirst[#]]&/@insetverts}}]]];
(* Construct data describing the neighborhood of each vertex around each face: a list of data for each vertex, grouped by faces. *)
fvdata=Transpose/@Transpose[{
RotateRight/@faces(* prev vertex index *),
faces(* this vertex index *),
RotateLeft/@faces(* next vertex index *),
insetverts(* inset vertex coords *),
tcfv(* rotation direction *),
N/@NormalizeReal/@(verts[[#]]-verts[[RotateRight[#]]])&/@faces(* prev edge vector *),
N/@NormalizeReal/@(verts[[RotateLeft[#]]]-verts[[#]])&/@faces(* next edge vector *),
RotateRight/@fei(* prev edge index *),
fei(* next edge index *)}];
If[sp,Print["face/vertex data = ",fvdata]];

beqv[iseq___]:=And@@(MemberQ[bverts,#]&/@{iseq})(* tests if vertices are on boundary *);
beqe[ie_]:=MemberQ[bedges,ie](* tests if edge is on boundary *);
newverts={};
(* makeverts creates new vertices and returns list of new vertices associated with old ones. 
di[i] is the inset distance for an interior vertex.
db[i] is the inset distance for a border vertex. *)
makeverts[ip_,iv_,in_,ivert_,rot_,ep_,en_,iep_,ien_]:=Module[{csc,addi},
csc=1/Abs[en . Rotate90[ep]];
addi[]:=Length[AppendTo[newverts,ivert]];
Join[{iv},Which[
beqe[iep]&&beqe[ien],{addi[],0},
rot==1,Which[ 
beqe[iep],{Length[AppendTo[newverts,ivert+csc db[++ndb]ep h[[ien]]]],addi[]},
beqe[ien],{Length[AppendTo[newverts,ivert-csc db[++ndb] en h[[iep]]]],addi[]},
True,{Length[AppendTo[newverts,ivert-csc di[++ndi] en  h[[iep]]]],0}],
rot==-1,Which[
beqe[iep],{Length[AppendTo[newverts,ivert+csc db[++ndb]ep h[[ien]]]],addi[]},
beqe[ien],{Length[AppendTo[newverts,ivert-csc db[++ndb] en h[[iep]]]],addi[]},
True,{Length[AppendTo[newverts,ivert+csc di[++ndi]ep h[[ien]]]],0}],
True,Abort[] (* error! *)
]]];
ndi=0;
ndb=0;
(* We simultaneously build the new vertices (newverts) and a list of mappings from old vertices to new vertices, grouped by original faces (newfverts). Each triple {i,j,k} links old vertex i to new vertices j and k (k=0 if there's only one new vertex). *)
newfverts=Apply[makeverts,fvdata,{2}];
If[sp, Print["newfverts = ",newfverts]];
hdruleff={di[_]->0.7 ,db[_]->0.3 };
If[sp,Print["new vertices = ",Graphics[{
{Black,Point/@verts},
{Red,Line[verts[[#]]&/@#]&/@edges},
{Green,Line[AppendFirst[#]]&/@insetverts},
{Blue,Point/@newverts},
Style[StdVertexLabels[newverts],Blue]}]/.hdruleff]];

(* new boundary vertices *)
newbverts={};
If[beqv[#[[1]]],AppendTo[newbverts,#[[2]]];If[#[[3]]!=0,AppendTo[newbverts,#[[3]]]]]&/@Flatten[newfverts,1];
If[sp, Print["newbverts = ",newbverts]];

(* new periodicity pairs, if needed *)
If[isper,
(* A list of triples {oldvert, color, newvert}, used in periodicity *)
ocnmap=MapThread[{#1[[1]],#2,#1[[2]]}&,{Flatten[newfverts,1],Flatten[tcfv,1]}];
If[sp,Print["old-color-new map = ",ocnmap]];
(* old periocity pairs and corresponding new vertex periodicity pairs *)
nwper=Flatten[Function[x,{{x,{Select[ocnmap,#[[1]]==x[[1]]&&#[[2]]==1&][[1,-1]],Select[ocnmap,#[[1]]==x[[2]]&&#[[2]]==1&][[1,-1]]}},{x,{Select[ocnmap,#[[1]]==x[[1]]&&#[[2]]==-1&][[1,-1]],Select[ocnmap,#[[1]]==x[[2]]&&#[[2]]==-1&][[1,-1]]}}}]/@wper,1];
If[sp,Print["new periodicity pairs = ",nwper]]];

(* new edges of the tessellation *)
newedges={};
newtypes={};
(AppendTo[newtypes,If[beqv[#[[1,1]],#[[2,1]]],B,M]];AppendTo[newedges,{#[[1,2]],#[[2,2]]}])&/@Transpose[{#,RotateLeft[#]}]&/@newfverts;
If[sp,Print["new edges = ",newedges]];
If[sp,Print["new types = ",newtypes]];
If[sp,Print["new edges (twist polygons) = ",Graphics[{
{Black,Point/@verts},
{Red,Line[verts[[#]]&/@#]&/@edges},
{Green,Line[AppendFirst[#]]&/@insetverts},
CreasePatternLines[MakeTGraph[newverts,newedges]//AddTAssignedTo[#,newtypes]&],
{Blue,Point/@newverts,StdVertexLabels[newverts]}
}]/.hdruleff/.OrigamiStyle[]]];
(* rest of the new edges *)
nfvpos[if_,iv_]:=Position[#[[1]]&/@newfverts[[if]],iv][[1,1]];
prevnewvert[if_,iv_]:=RotateLeft[newfverts[[if]],nfvpos[if,iv]-2][[1,2]];
newvert[if_,iv_]:=RotateLeft[newfverts[[if]],nfvpos[if,iv]-1][[1,2]];
nextnewvert[if_,iv_]:=RotateLeft[newfverts[[if]],nfvpos[if,iv]][[1,2]];
altnewvert[if_,iv_]:=RotateLeft[newfverts[[if]],nfvpos[if,iv]-1][[1,3]];
prevvalvert[if_,iv_]:=If[#[[3]]!=0,#[[3]],#[[2]]]&[RotateLeft[newfverts[[if]],nfvpos[if,iv]-2][[1]]];
nextvalvert[if_,iv_]:=If[#[[3]]!=0,#[[3]],#[[2]]]&[RotateLeft[newfverts[[if]],nfvpos[if,iv]][[1]]];
addpleat[{{e1_,e2_},{fr_,fl_}}]:=(
(* creases near e1 *)
If[!MemberQ[bverts,e1],
(* e1 not on boundary *)
If[twocoloring[[fl]]==1,
AppendTo[newedges,{nextvalvert[fr,e1],prevvalvert[fl,e1]}];AppendTo[newtypes,V];AppendTo[newedges,{newvert[fr,e1],newvert[fl,e1]}];AppendTo[newtypes,M]],
(* e1 on the boundary *)
AppendTo[newedges,{newvert[fr,e1],altnewvert[fr,e1]}];AppendTo[newtypes,B];
AppendTo[newedges,{newvert[fl,e1],altnewvert[fl,e1]}];AppendTo[newtypes,B];
AppendTo[newedges,{altnewvert[fr,e1],altnewvert[fl,e1]}];AppendTo[newtypes,B];
If[twocoloring[[fl]]==-1,
AppendTo[newedges,{nextvalvert[fl,e1],altnewvert[fl,e1]}];AppendTo[newtypes,V];
AppendTo[newedges,{prevvalvert[fr,e1],altnewvert[fr,e1]}];AppendTo[newtypes,V]]];
(* creases near e2 *)
If[!MemberQ[bverts,e2],
(* e2 not on boundary *)
If[twocoloring[[fl]]==-1,
AppendTo[newedges,{prevvalvert[fr,e2],nextvalvert[fl,e2]}];AppendTo[newtypes,V];AppendTo[newedges,{newvert[fr,e2],newvert[fl,e2]}];AppendTo[newtypes,M]],
(* e2 on the boundary *)
AppendTo[newedges,{newvert[fr,e2],altnewvert[fr,e2]}];AppendTo[newtypes,B];
AppendTo[newedges,{newvert[fl,e2],altnewvert[fl,e2]}];AppendTo[newtypes,B];
AppendTo[newedges,{altnewvert[fr,e2],altnewvert[fl,e2]}];AppendTo[newtypes,B];
If[twocoloring[[fl]]==1,
AppendTo[newedges,{prevvalvert[fl,e2],altnewvert[fl,e2]}];AppendTo[newtypes,V];
AppendTo[newedges,{nextvalvert[fr,e2],altnewvert[fr,e2]}];AppendTo[newtypes,V]]];
);
addpleat/@Transpose[edgepairs];
If[sp,Print["all new edges = ",Graphics[{
{Black,Point/@verts},
{Red,Line[verts[[#]]&/@#]&/@edges},
{Green,Line[AppendFirst[#]]&/@insetverts},
CreasePatternLines[MakeTGraph[newverts,newedges]//AddTAssignedTo[#,newtypes]&],
{Blue,Point/@newverts,StdVertexLabels[newverts]}
}]/.hdruleff/.OrigamiStyle[]]];
(* That's everything; build TGraphs for crease pattern and folded form using unoptimized coordinates, then construct plane graph data so we have vertex adjacency for testing Kawasaki. *)
hdrulecp={di[_]->-0.1 ,db[_]->-0.1 };
tobjout=MakeTGraph[newverts/.hdrulecp, newedges];
If[sp,Print["topological CP (unoptimized) = ",GraphGraphics[tobjout]]];
tobjout=tobjout//AddTPlaneGraph//AddTAssigned[newtypes]//AddTGraph2D[newverts/.hdruleff];
If[sp,Print["topological FF (unoptimized) = ",Graph2DGraphics[tobjout]]];

(* if there's periodicity, get vertex indices at far end of edges in periodicity pairs *)
If[isper,
{nedges,nbedges}=GetValues[tobjout,{Edges,BoundaryEdges}];
niedges={}(* interior edges, as vertex pairs, both orders *);
Do[If[!MemberQ[nbedges,i],AppendTo[niedges,nedges[[i]]]],{i,Length[nedges]}];
niedges=Join[niedges,Reverse/@niedges];
nwper=Function[x,Append[x,{Select[niedges,x[[2,1]]==#[[1]]&][[1,2]],Select[niedges,x[[2,2]]==#[[1]]&][[1,2]]}]]/@nwper;
If[sp,Print["new periodicity data = ",nwper]];
];

(* PART 2: OPTIMIZATION *)

(* Kawasaki conditions. Note that FlatFoldabilityCondition gives the proper algebraic condition
on the FF vertices if they are given in their cyclic order of the CP. *)
kawaconds={};
vva=tobjout[VertexVertexAdjacency];
Do[If[Length[vva[[i]]]==4,AppendTo[kawaconds,FlatFoldabilityCondition[newverts[[i]],newverts[[vva[[i]]]]]]],{i,Length[vva]}];
If[sp,Print["Kawasaki conditions (unoptimized) = ",kawaconds/.hdruleff]];

(* periodicity conditions, if applicable *)
If[isper,
perconds=Flatten[With[{dr=verts[[#[[1,2]]]]-verts[[#[[1,1]]]]},{(newverts[[#[[2,2]]]]-newverts[[#[[2,1]]]]-dr) . (RotationMatrix2D[\[Pi]/2] . dr),TriangleSignedArea2D[newverts[[#[[3,1]]]]+dr,newverts[[#[[2,2]]]],newverts[[#[[3,2]]]]]}]&/@nwper]];

(* optimization *)
vars=Join[Table[{di[i],mps},{i,ndi}],Table[{db[i],mbps},{i,ndb}]];
eqns=#==0&/@kawaconds;
If[isper,JoinTo[eqns,#==0&/@Drop[perconds,-1]]];
ineqns=Join[Table[di[i]>=mps,{i,ndi}],Table[db[i]>=mbps,{i,ndb}]];
merit=Sum[(di[i]^2),{i,ndi}]+Sum[(db[i]^2),{i,ndb}];
{time,soln}=Timing[FindMinimum[{merit,Join[eqns,ineqns]},vars]];
If[sp,Print["Optimization took ",time," seconds."]];
If[Head[soln]===FindMinimum,Message[MakeSimpleWovenTessellation::optfail];Abort[]];
If[sp,PrintThis[soln]];
kawavals=kawaconds/.soln[[2]];
If[sp,Print["Kawasaki conditions (optimized) = ",Chop[kawavals]]];
(* If mismatch, don't abort, but report the mismatch *)
If[Max[Abs/@kawavals]>10^-4,Message[MakeSimpleWovenTessellation::nokawa,kawavals]];
If[sp,Print["periodic conditions (optimized) = ",Chop[perconds/.soln[[2]]]]];
newvertsff=newverts/.soln[[2]];

(* build proper embedding based on the solution *)
tobjout=tobjout//ReplaceProperty[Vertices2D->newvertsff];
tobjout=UnfoldGraph2D[tobjout,StationaryFace->sface];
If[sp,Print["topological crease pattern and folded form (optimized)"];
Print[GraphicsRow[{GraphGraphics[tobjout],Graph2DGraphics[tobjout]}]];
Print[GraphicsRow[{CreasePatternGraphics[tobjout],GenericFoldedFormGraphics[tobjout]}]/.OrigamiStyle[]]];
tobjout]
Module[{verts,edges,tobj,tobjw},
verts={{0,0},{1,0},{3,0},{4,0},{0,1},{1,1},{2,1},{4,1},{1,2},{0,3},{0,4},{1,4},{4,4}};
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8},{5,10},{6,9},{7,9},{8,13},{9,10},{10,11},{9,12},{11,12},{12,13}};
tobj=MakeTGraph[verts,edges];
Print[GraphGraphics[tobj]];
tobjw=MakeSimpleWovenTessellation[tobj,0.20,WovenParity->1,StationaryFace->6,BorderInset->None,ShowProgress->False];
GraphicsRow[{
CreasePatternGraphics[tobjw],
VisibleFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{sgverts,sgedges,tobjcsg,tobj,tobjw},
(* Make a graph *)
sgverts={
{0,0},{1,0},{1.5,0},{2,0},
{0,0.5},{2,0.5},
{0,0.9},{2,0.9},
{0,1.5},{1,1.5},{1.5,1.5},{2,1.5}};
sgedges={{1,4},{5,6},{7,8},{9,12},{1,9},{2,10},{3,11},{4,12}};
tobjcsg=MakeTGraph[sgverts,sgedges];
(* Intersectify to break it into individual line segments *)
tobj=Intersectify[tobjcsg];
Print[GraphicsRow[{GraphGraphics[tobjcsg],GraphGraphics[tobj]}]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobj,{0.,0.3}]];
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellation[tobj,0.1,WovenParity->-1,BorderInset->None];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
GraphicsRow[{
CreasePatternGraphics[tobjw],
VisibleFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{sgverts,sgedges,tobjcsg,tobj,hlist,tobjw},
(* Make a graph *)
sgverts={
{0,0},{1,0},{1.5,0},{2,0},
{0,0.5},{2,0.5},
{0,0.9},{2,0.9},
{0,1.5},{1,1.5},{1.5,1.5},{2,1.5}};
sgedges={{1,4},{5,6},{7,8},{9,12},{1,9},{2,10},{3,11},{4,12}};
tobjcsg=MakeTGraph[sgverts,sgedges];
(* Intersectify to break it into individual line segments *)
tobj=Intersectify[tobjcsg];
Print[GraphicsRow[{GraphGraphics[tobjcsg],GraphGraphics[tobj]}]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobj,{0.,0.3}]]//Hold;
(* create a list of varying inset distances *)
hlist={0,0,0,.2,.2,.2,.1,.1,.1,0,0,0,0,0,0,.2,.2,.2,.1,.1,.1,0,0,0};
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellation[tobj,hlist,WovenParity->-1,BorderInset->None];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
GraphicsRow[{
CreasePatternGraphics[tobjw],
VisibleFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{sgverts,sgedges,tobjcsg,tobj,wper,tobjw},
(* Make a graph *)
sgverts={
{0,0},{1,0},{1.5,0},{2,0},
{0,0.5},{2,0.5},
{0,0.9},{2,0.9},
{0,1.5},{1,1.5},{1.5,1.5},{2,1.5}};
sgedges={{1,4},{5,6},{7,8},{9,12},{1,9},{2,10},{3,11},{4,12}};
tobjcsg=MakeTGraph[sgverts,sgedges];
(* Intersectify to break it into individual line segments *)
tobj=Intersectify[tobjcsg];
Print[GraphicsRow[{GraphGraphics[tobjcsg],GraphGraphics[tobj]}]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobj,{0.,0.3}]]//Hold;
(* set up woven perodicity data *)
wper={{2,14},{3,15},{5,8},{9,12}};
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellation[tobj,.15,WovenParity->-1,WovenPeriodicity->wper,ShowProgress->False];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
GraphicsRow[{
CreasePatternGraphics[tobjw],
VisibleFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,tobj,wper,tobjw,tobjwf},
verts={{0,0},{1,0},{3,0},{4,0},{0,1},{1,1},{2,1},{4,1},{1,2},{0,3},{4,3},{0,4},{1,4},{3,4},{4,4}};
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8},{5,10},{6,9},{7,9},{8,11},{9,10},{9,13},{10,12},{11,14},{11,15},{12,13},{13,14},{14,15}};
tobj=MakeTGraph[verts,edges];
Print[GraphGraphics[tobj]];
wper={{5,8},{2,13},{3,14},{10,11}};
tobjw=MakeSimpleWovenTessellation[tobj,0.20,WovenParity->1,WovenPeriodicity->wper,MinimumBorderPleatSize->.01,StationaryFace->6,ShowProgress->False];
tobjwf=FlopGraph2D[tobjw];
GraphicsRow[{
CreasePatternGraphics[tobjwf],
GenericFoldedFormGraphics[tobjwf]
}]/.OrigamiStyle[]
]//ShowExample
Module[{tobjcsg,tobjw},
(* Make a chord star graph *)
tobjcsg=MakeChordStarGraph[{{0\[Degree],0.15}},7];
Print[GraphGraphics[tobjcsg]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobjcsg,{0.,0.04}]];
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellation[tobjcsg,0.03,WovenParity->-1];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
GraphicsRow[{
CreasePatternGraphics[tobjw],
GenericFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{tobjcsg,tobjw},
(* Make a chord star graph *)
tobjcsg=MakeChordStarGraph[{{30\[Degree],0.4},{0\[Degree],0.3}},6];
Print[GraphGraphics[tobjcsg]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobjcsg,{0.,0.04}]];
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellation[tobjcsg,0.024,WovenParity->1,ShowProgress->True];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
GraphicsRow[{
CreasePatternGraphics[tobjw],
GenericFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{boundary,lines,verts,edges,tobj,tobjw},
boundary=SquareVertices[1];
tobj=MakeCourteousAnarchyGraph[6,0.1,boundary,RandSeed->0];
Print[GraphGraphics[tobj]];
Print[InsetSeparationPlot[tobj,{0.,0.07}]];
tobjw=MakeSimpleWovenTessellation[tobj,0.035,WovenParity->-1];
GraphicsRow[{
CreasePatternGraphics[tobjw],
VisibleFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{tobj,tobjcsg,tobjw},
tobj=MakeTGraph@@{{{1.2423`,1.1112`},{1.2423`,353.20419999999996`},{77.6633`,1.1112`},{77.6633`,353.20419999999996`},{144.0843`,1.1112`},{144.0843`,353.20419999999996`},{210.50530000000003`,1.1112`},{210.50530000000003`,353.20419999999996`},{276.92530000000005`,1.1112`},{276.92530000000005`,353.20419999999996`},{353.34630000000004`,1.1112`},{353.34630000000004`,353.20419999999996`},{1.2424000000000335`,77.5322`},{353.34540000000004`,77.5222`},{1.2415000000000336`,143.9532`},{353.34450000000004`,143.94320000000002`},{1.2403000000000335`,210.37420000000003`},{353.34330000000006`,210.36420000000004`},{1.2394000000000336`,276.7952`},{353.34240000000005`,276.78520000000003`},{39.001500000000036`,353.21520000000004`},{353.34650000000005`,32.00220000000007`}},{{1,2},{3,4},{5,6},{7,8},{9,10},{11,12},{1,11},{13,14},{15,16},{17,18},{19,20},{2,12},{21,22}}};
Print[GraphGraphics[tobj]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobj,{0.,10.,0.5}]];
(* make our woven tessellation *)
tobjcsg=Intersectify[tobj,IntersectionTolerance->2,SamePtTolerance->2]//AddTPlaneGraph;
Print[GraphGraphics[tobjcsg]];
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellation[tobjcsg,8.,WovenParity->1,ShowProgress->True];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
(CreasePatternGraphics[tobjw]//InvertFoldType)/.OrigamiStyle[]
]//ShowExample
Options[MakeSimpleWovenTessellationOld]={
MinimumPleatSize->1,
MinimumBorderPleatSize->0.01,
WovenParity->1,
StationaryFace->1,
ShowProgress->False
};
MakeSimpleWovenTessellationOld::optfail="MakeSimpleWovenTessellationOld failed because it was unable to find a minimum in the optimization step.";
MakeSimpleWovenTessellationOld::nokawa="MakeSimpleWovenTessellationOld failed because the best solution found has a Kawasaki condition mismatch greater than \!\(\*SuperscriptBox[\(10\), \(-4\)]\). Values were: `1`";
MakeSimpleWovenTessellationOld[tobj_TObj,inset_,opts___]:=Module[{mps,mbps,wpar,sface,sp,tobjdef,verts,edges,faces,boundary,iedges,dedges,edgepairs,twocoloring,h,insetverts,facedata,beq,d,dd,makenewvert,nd,ndd,newverts,newfaceverts,newboundaryverts,hdruleff,newedges,newtypes,prevnewvert,newvert,nextnewvert,altnewvert,prevvalvert,nextvalvert,addpleat,hdrulecp,tobjout,vva,kawaconds,kawavals,merit,eqns,ineqns,vars,time,soln,newvertsff},
AssertClass[tobj,TGraph,MakeSimpleWovenTessellationOld];
mps=MinimumPleatSize/.{opts}/.Options[MakeSimpleWovenTessellationOld];
mbps=MinimumBorderPleatSize/.{opts}/.Options[MakeSimpleWovenTessellationOld];
wpar=WovenParity/.{opts}/.Options[MakeSimpleWovenTessellationOld];
sface=StationaryFace/.{opts}/.Options[MakeSimpleWovenTessellationOld];
sp=ShowProgress/.{opts}/.Options[MakeSimpleWovenTessellationOld];
(* build the full primal-dual graph that we use to define the woven pattern *)
tobjdef=AddTPlaneGraphTo[tobj]//AddTPrimalDualGraphTo;
{verts,edges,faces,boundary,iedges,dedges}=GetValues[tobjdef,{Vertices,Edges,Faces,BoundaryVertices,InteriorEdges,DualEdges}];
If[sp,Print["original pattern = ",GraphGraphics[tobjdef]]];
(* edgepairs *)
 edgepairs=OrientedInteriorEdgePairs[tobjdef];
If[sp,PrintThis[edgepairs]];
(* build the two-coloring *)
twocoloring=TwoColorGraph[tobjdef,StartFace->(wpar)(sface)];
If[sp,PrintThis[twocoloring]];
(* inset vertices *)
insetverts=InsetPoly[verts[[#]],h]&/@faces;
If[sp,Print["inset polygons = ",Graphics[{{Black,Point/@verts},{Red,Line[verts[[#]]&/@#]&/@edges},{Green,Line[AppendFirst[#]]&/@insetverts}}]/.h->inset]];
(* new vertices of the tessellation *)
facedata=Transpose/@Transpose[{
RotateRight/@faces,
faces,
RotateLeft/@faces,
insetverts,
MapThread[Table[#1,{Length[#2]}]&,{twocoloring,faces}],
N/@NormalizeReal/@(verts[[#]]-verts[[RotateRight[#]]])&/@faces,
N/@NormalizeReal/@(verts[[RotateLeft[#]]]-verts[[#]])&/@faces
}];
beq=MemberQ[boundary,#1]&&MemberQ[boundary,#2]&;
makenewvert[ip_,iv_,in_,ivert_,rot_,ep_,en_]:=Module[{csc},
csc=1/Abs[en . Rotate90[ep]];
Join[{iv},Which[
beq[ip,iv]&&beq[iv,in],{Length[AppendTo[newverts,ivert]],0},
rot==1,Which[ 
beq[ip,iv],{Length[AppendTo[newverts,ivert+csc dd[++ndd]ep]],Length[AppendTo[newverts,ivert]]},
beq[iv,in],{Length[AppendTo[newverts,ivert-csc d[++nd] en]],Length[AppendTo[newverts,ivert]]},
True,{Length[AppendTo[newverts,ivert-csc d[++nd] en]],0}],
rot==-1,Which[
beq[ip,iv],{Length[AppendTo[newverts,ivert+csc d[++nd]ep]],Length[AppendTo[newverts,ivert]]},
beq[iv,in],{Length[AppendTo[newverts,ivert-csc dd[++ndd] en]],Length[AppendTo[newverts,ivert]]},
True,{Length[AppendTo[newverts,ivert+csc d[++nd]ep]],0}],
True,Abort[] (* error! *)
]]];
nd=0;
ndd=0;
newverts={};
newfaceverts=Apply[makenewvert,facedata,{2}];
newboundaryverts={};
If[MemberQ[boundary,#[[1]]],AppendTo[newboundaryverts,#[[2]]];If[#[[3]]!=0,AppendTo[newboundaryverts,#[[3]]]]]&/@Flatten[newfaceverts,1];
hdruleff={h->inset,d[_]->0.8 inset,dd[_]->0.2 inset};
If[sp,Print["new vertices = ",Graphics[{{Black,Point/@verts},{Red,Line[verts[[#]]&/@#]&/@edges},{Green,Line[AppendFirst[#]]&/@insetverts},{Blue,Point/@newverts}}]/.hdruleff]];
(* new edges of the tessellation *)
newedges={};
newtypes={};
(AppendTo[newtypes,If[beq[#[[1,1]],#[[2,1]]],B,M]];AppendTo[newedges,{#[[1,2]],#[[2,2]]}])&/@Transpose[{#,RotateLeft[#]}]&/@newfaceverts;
If[sp,PrintThis[newedges]];
If[sp,PrintThis[newtypes]];
If[sp,Print["new edges (twist polygons) = ",Graphics[{
{Black,Point/@verts},
{Red,Line[verts[[#]]&/@#]&/@edges},
{Green,Line[AppendFirst[#]]&/@insetverts},
CreasePatternLines[MakeTGraph[newverts,newedges]//AddTAssignedTo[#,newtypes]&],
{Blue,Point/@newverts,StdVertexLabels[newverts]}
}]/.hdruleff/.OrigamiStyle[]]];
(* rest of the new edges *)
prevnewvert[if_,iv_]:=RotateLeft[newfaceverts[[if]],Position[#[[1]]&/@newfaceverts[[if]],iv][[1,1]]-2][[1,2]];
newvert[if_,iv_]:=RotateLeft[newfaceverts[[if]],Position[#[[1]]&/@newfaceverts[[if]],iv][[1,1]]-1][[1,2]];
nextnewvert[if_,iv_]:=RotateLeft[newfaceverts[[if]],Position[#[[1]]&/@newfaceverts[[if]],iv][[1,1]]][[1,2]];
altnewvert[if_,iv_]:=RotateLeft[newfaceverts[[if]],Position[#[[1]]&/@newfaceverts[[if]],iv][[1,1]]-1][[1,3]];
prevvalvert[if_,iv_]:=If[#[[3]]!=0,#[[3]],#[[2]]]&[RotateLeft[newfaceverts[[if]],Position[#[[1]]&/@newfaceverts[[if]],iv][[1,1]]-2][[1]]];
nextvalvert[if_,iv_]:=If[#[[3]]!=0,#[[3]],#[[2]]]&[RotateLeft[newfaceverts[[if]],Position[#[[1]]&/@newfaceverts[[if]],iv][[1,1]]][[1]]];
addpleat[{{e1_,e2_},{fr_,fl_}}]:=(
(* creases near e1 *)
If[!MemberQ[boundary,e1],
(* e1 not on boundary *)
If[twocoloring[[fl]]==1,
AppendTo[newedges,{nextvalvert[fr,e1],prevvalvert[fl,e1]}];AppendTo[newtypes,V];AppendTo[newedges,{newvert[fr,e1],newvert[fl,e1]}];AppendTo[newtypes,M]],
(* e1 on the boundary *)
AppendTo[newedges,{newvert[fr,e1],altnewvert[fr,e1]}];AppendTo[newtypes,B];
AppendTo[newedges,{newvert[fl,e1],altnewvert[fl,e1]}];AppendTo[newtypes,B];
AppendTo[newedges,{altnewvert[fr,e1],altnewvert[fl,e1]}];AppendTo[newtypes,B];
If[twocoloring[[fl]]==-1,
AppendTo[newedges,{nextvalvert[fl,e1],altnewvert[fl,e1]}];AppendTo[newtypes,V];
AppendTo[newedges,{prevvalvert[fr,e1],altnewvert[fr,e1]}];AppendTo[newtypes,V]]];
(* creases near e2 *)
If[!MemberQ[boundary,e2],
(* e2 not on boundary *)
If[twocoloring[[fl]]==-1,
AppendTo[newedges,{prevvalvert[fr,e2],nextvalvert[fl,e2]}];AppendTo[newtypes,V];AppendTo[newedges,{newvert[fr,e2],newvert[fl,e2]}];AppendTo[newtypes,M]],
(* e2 on the boundary *)
AppendTo[newedges,{newvert[fr,e2],altnewvert[fr,e2]}];AppendTo[newtypes,B];
AppendTo[newedges,{newvert[fl,e2],altnewvert[fl,e2]}];AppendTo[newtypes,B];
AppendTo[newedges,{altnewvert[fr,e2],altnewvert[fl,e2]}];AppendTo[newtypes,B];
If[twocoloring[[fl]]==1,
AppendTo[newedges,{prevvalvert[fl,e2],altnewvert[fl,e2]}];AppendTo[newtypes,V];
AppendTo[newedges,{nextvalvert[fr,e2],altnewvert[fr,e2]}];AppendTo[newtypes,V]]];
);
addpleat/@Transpose[edgepairs];
If[sp,Print["all new edges = ",Graphics[{
{Black,Point/@verts,StdVertexLabels[verts]},
{Red,Line[verts[[#]]&/@#]&/@edges,StdEdgeLabels[verts,edges]},
{Green,Line[AppendFirst[#]]&/@insetverts,Darker[Green],StdFaceLabels[verts,faces]},
CreasePatternLines[MakeTGraph[newverts,newedges]//AddTAssignedTo[#,newtypes]&],
{Blue,Point/@newverts,StdVertexLabels[newverts]}
}]/.hdruleff/.OrigamiStyle[]]];

(* That's everything; build TGraphs for crease pattern and folded form using unoptimized coordinates *)
hdrulecp={h->0.45 inset,d[_]->-0.45 inset,dd[_]->-0.05 inset};
tobjout=MakeTGraph[newverts/.hdrulecp, newedges]//AddTPlaneGraphTo//AddTAssignedTo[#,newtypes]&//AddTGraph2D[newverts/.hdruleff];
If[sp,Print["topological crease pattern and folded form (unoptimized)"];
Print[GraphicsRow[{GraphGraphics[tobjout],Graph2DGraphics[tobjout]}]]];

(* PART 2: OPTIMIZATION *)

(* Kawasaki conditions *)
(* Note that FlatFoldabilityCondition gives the proper algebraic condition
on the FF vertices if they are given in their cyclic order of the CP. *)
vva=tobjout[VertexVertexAdjacency];
kawaconds={};
Do[If[Length[vva[[i]]]==4,AppendTo[kawaconds,FlatFoldabilityCondition[newverts[[i]],newverts[[vva[[i]]]]]]],{i,Length[vva]}];
If[sp,Print["Kawasaki conditions (unoptimized) = ",kawaconds/.hdruleff]];

(* optimization *)
merit=Sum[(d[i]^2),{i,nd}]+Sum[(dd[i]^2),{i,ndd}];
eqns=#==0&/@kawaconds/.h->inset;
ineqns=Join[Table[d[i]>=mps h,{i,nd}],Table[dd[i]>=mbps h,{i,ndd}]]/.h->inset;
vars=Join[Table[{d[i],mps h},{i,nd}],Table[{dd[i],mbps h},{i,ndd}]]/.h->inset;
{time,soln}=Timing[FindMinimum[{merit,Join[eqns,ineqns]},vars]];
If[sp,Print["Optimization took ",time," seconds."]];
If[Head[soln]===FindMinimum,Message[MakeSimpleWovenTessellationOld::optfail];Abort[]];
If[sp,PrintThis[soln]];
kawavals=kawaconds/.h->inset/.soln[[2]];
If[sp,Print["Kawasaki conditions (optimized) = ",Chop[kawavals]]];
(* If mismatch, don't abort, but report the mismatch *)
If[Max[Abs/@kawavals]>10^-4,Message[MakeSimpleWovenTessellationOld::nokawa,kawavals]];
newvertsff=newverts/.h->inset/.soln[[2]];

(* build proper embedding based on the solution *)
tobjout=tobjout//ReplaceProperty[Vertices2D->newvertsff];
tobjout=UnfoldGraph2D[tobjout,StationaryFace->sface];
If[sp,Print["topological crease pattern and folded form (optimized)"];
Print[GraphicsRow[{GraphGraphics[tobjout],Graph2DGraphics[tobjout]}]]];
If[sp,Print[GraphicsRow[{
CreasePatternGraphics[tobjout],
GenericFoldedFormGraphics[tobjout]
}]/.OrigamiStyle[]]];
tobjout]
Module[{verts,edges,tobj,tobjw},
verts={{0,0},{1,0},{3,0},{4,0},{0,1},{1,1},{2,1},{4,1},{1,2},{0,3},{0,4},{1,4},{4,4}};
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8},{5,10},{6,9},{7,9},{8,13},{9,10},{10,11},{9,12},{11,12},{12,13}};
tobj=MakeTGraph[verts,edges];
Print[GraphGraphics[tobj]];
tobjw=MakeSimpleWovenTessellationOld[tobj,0.20,WovenParity->1,StationaryFace->6,ShowProgress->False];
GraphicsRow[{
CreasePatternGraphics[tobjw],
VisibleFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{sgverts,sgedges,tobjcsg,tobj,tobjw},
(* Make a graph *)
sgverts={
{0,0},{1,0},{1.5,0},{2,0},
{0,0.5},{2,0.5},
{0,0.9},{2,0.9},
{0,1.5},{1,1.5},{1.5,1.5},{2,1.5}};
sgedges={{1,4},{5,6},{7,8},{9,12},{1,9},{2,10},{3,11},{4,12}};
tobjcsg=MakeTGraph[sgverts,sgedges];
(* Intersectify to break it into individual line segments *)
tobj=Intersectify[tobjcsg];
Print[GraphicsRow[{GraphGraphics[tobjcsg],GraphGraphics[tobj]}]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobj,{0.,0.3}]];
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellationOld[tobj,0.1,WovenParity->-1];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
GraphicsRow[{
CreasePatternGraphics[tobjw],
VisibleFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{tobjcsg,tobjw},
(* Make a chord star graph *)
tobjcsg=MakeChordStarGraph[{{0\[Degree],0.15}},7];
Print[GraphGraphics[tobjcsg]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobjcsg,{0.,0.04}]];
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellationOld[tobjcsg,0.03,WovenParity->-1];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
GraphicsRow[{
CreasePatternGraphics[tobjw],
GenericFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{tobjcsg,tobjw},
(* Make a chord star graph *)
tobjcsg=MakeChordStarGraph[{{30\[Degree],0.4},{0\[Degree],0.3}},6];
Print[GraphGraphics[tobjcsg]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobjcsg,{0.,0.04}]];
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellationOld[tobjcsg,0.024,WovenParity->1,ShowProgress->True];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
GraphicsRow[{
CreasePatternGraphics[tobjw],
GenericFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample
Module[{boundary,lines,verts,edges,tobj,tobjw},
boundary=SquareVertices[1];
tobj=MakeCourteousAnarchyGraph[6,0.1,boundary,RandSeed->0];
Print[GraphGraphics[tobj]];
Print[InsetSeparationPlot[tobj,{0.,0.07}]];
tobjw=MakeSimpleWovenTessellationOld[tobj,0.035,WovenParity->-1];
GraphicsRow[{
CreasePatternGraphics[tobjw],
VisibleFoldedFormGraphics[FlopGraph2D[tobjw],FaceupFace->Length[GetValue[tobjw,Faces]]]
}]/.OrigamiStyle[]
]//ShowExample//Hold;(* Root-finder now fails. Used to work in Ma10, but fails il Ma11, Ma12 *)
Module[{tobj,tobjcsg,tobjw},
tobj=MakeTGraph@@{{{1.2423`,1.1112`},{1.2423`,353.20419999999996`},{77.6633`,1.1112`},{77.6633`,353.20419999999996`},{144.0843`,1.1112`},{144.0843`,353.20419999999996`},{210.50530000000003`,1.1112`},{210.50530000000003`,353.20419999999996`},{276.92530000000005`,1.1112`},{276.92530000000005`,353.20419999999996`},{353.34630000000004`,1.1112`},{353.34630000000004`,353.20419999999996`},{1.2424000000000335`,77.5322`},{353.34540000000004`,77.5222`},{1.2415000000000336`,143.9532`},{353.34450000000004`,143.94320000000002`},{1.2403000000000335`,210.37420000000003`},{353.34330000000006`,210.36420000000004`},{1.2394000000000336`,276.7952`},{353.34240000000005`,276.78520000000003`},{39.001500000000036`,353.21520000000004`},{353.34650000000005`,32.00220000000007`}},{{1,2},{3,4},{5,6},{7,8},{9,10},{11,12},{1,11},{13,14},{15,16},{17,18},{19,20},{2,12},{21,22}}};
Print[GraphGraphics[tobj]];
(* plot the inset separation to find an aesthetically pleasing strip width *)
Print[InsetSeparationPlot[tobj,{0.,10.,0.5}]];
(* make our woven tessellation *)
tobjcsg=Intersectify[tobj,IntersectionTolerance->2,SamePtTolerance->2]//AddTPlaneGraph;
Print[GraphGraphics[tobjcsg]];
(* build the new woven tessellation *)
tobjw=MakeSimpleWovenTessellationOld[tobjcsg,8.,WovenParity->1,ShowProgress->True];
(* Turn over the folded form, i.e., invert the crease assignment and flop the image. *)
temp=(CreasePatternGraphics[tobjw]//InvertFoldType)/.OrigamiStyle[]
]//ShowExample
SingleGoreData[pts_List,m_]:=Module[{\[Phi],x,z,r,w,nr,a,b,c,t3d,r3d,c3d,u2d},
\[Phi]=\[Pi]/m;
{x,z}=Transpose[pts];
r=Prepend[Accumulate[Mag/@(Drop[pts,1]-Drop[pts,-1])],0];
nr=Length[r];
w=Tan[\[Phi]]x;
(* folded form points in 3D *)
a={#[[1]],0,#[[2]]}&/@pts;
b=a+(U3D[\[Pi]/2]#&/@w);
t3d=Table[Polygon[{b[[i]],b[[i+1]],{1,-1,1}b[[i+1]],{1,-1,1}b[[i]]}],{i,nr-1}];
(* crease pattern points in 3D, radial *)
a={#,0,0}&/@r;
b=a+(U3D[\[Pi]/2]#&/@w);
r3d=Table[Polygon[{b[[i]],b[[i+1]],{1,-1,1}b[[i+1]],{1,-1,1}b[[i]]}],{i,nr-1}];
(* crease pattern points in 3D, cylindrical *)
a={Max[First/@pts],0,#+1-r[[-1]]/2}&/@r;
b=a+(U3D[\[Pi]/2]#&/@w);
c3d=Table[Polygon[{b[[i]],b[[i+1]],{1,-1,1}b[[i+1]],{1,-1,1}b[[i]]}],{i,nr-1}];
(* flat gore in 2D *)
c=#[[{3,2}]]&/@b;
c=#-c[[1]]&/@c;
u2d=Table[Line[Join[c,Reverse[{1,-1}#&/@c]]],{i,nr}];
{t3d,r3d,c3d,u2d}]
Module[{n,pts,m,t3d,r3d,c3d,u2d},
n=8;
pts=Table[{Sin[\[Phi]],1-Cos[\[Phi]]},{\[Phi],0,\[Pi],\[Pi]/n}]//N;
m=8;
{t3d,r3d,c3d,u2d}=SingleGoreData[pts,m];
GraphicsGrid[{{
Graphics3D[t3d,Axes->True],
Graphics3D[r3d,Axes->True]},{
Graphics3D[c3d,Axes->True],
Graphics[u2d,Axes->True]}}]
]//ShowExample
MultipleGoreData[pts_List,m_]:=Module[{t3d,r3d,c3d,u2d},
{t3d,r3d,c3d,u2d}=SingleGoreData[pts,m];
{Table[RotateZ3D[ t3d,2  j \[Pi]/m],{j,0,m-1}],
Table[RotateZ3D[ r3d,2  j \[Pi]/m],{j,0,m-1}],
Table[RotateZ3D[ c3d,2  j \[Pi]/m],{j,0,m-1}],
Table[Rotate2D[ u2d,2  j \[Pi]/m],{j,0,m-1}]}]
Module[{n,pts,m,t3d,r3d,c3d,u2d},
n=8;
pts=Table[{Sin[\[Phi]],1-Cos[\[Phi]]},{\[Phi],0,\[Pi],\[Pi]/n}]//N;
m=8;
{t3d,r3d,c3d,u2d}=MultipleGoreData[pts,m];
GraphicsGrid[{{Graphics3D[t3d],Graphics3D[r3d]},{Graphics3D[c3d],Graphics[u2d]}}]
]//ShowExample
SphereSingleGoreData[n_,m_]:=Module[{pts},
pts=Table[{Sin[\[Phi]],1-Cos[\[Phi]]},{\[Phi],0,\[Pi],\[Pi]/n}]//N;
SingleGoreData[pts,m]]
Module[{t3d,r3d,c3d,u2d},
{t3d,r3d,c3d,u2d}=SphereSingleGoreData[16,16];
GraphicsGrid[{{
Graphics3D[t3d,Axes->True],
Graphics3D[r3d,Axes->True]},{
Graphics3D[c3d,Axes->True],
Graphics[u2d,Axes->True]}}]
]//ShowExample
SphereMultipleGoreData[n_,m_]:=Module[{pts},
pts=Table[{Sin[\[Phi]],1-Cos[\[Phi]]},{\[Phi],0,\[Pi],\[Pi]/n}]//N;
MultipleGoreData[pts,m]]
Module[{t3d,r3d,c3d,u2d},
{t3d,r3d,c3d,u2d}=SphereMultipleGoreData[16,16];
GraphicsGrid[{{Graphics3D[t3d],Graphics3D[r3d]},{Graphics3D[c3d],Graphics[u2d]}}]
]//ShowExample
MoselyBudCrossSectionPt[r_]:=
Which[r==0,{0,0},
r==1,{0,-((2 EllipticK[-4 (4+3 \[Sqrt]2)]+Im[-(-1+\[Sqrt]2) EllipticE[17+12 \[Sqrt]2]])/(\[Sqrt]2))},
True,{(1/2) (-1+\[Sqrt](1+4 r-4 r^2)),Re[(1/((-1+r) r))(-1+\[Sqrt]2) \[Sqrt](((-1+r) r)/(-2+8 (-1+r) r)) ((1+\[Sqrt]2) r (-1+4 (-1+r) r)-(-1+r)^2 \[Sqrt]((r+4 r^2-4 r^3)/(-1+r)^3) (EllipticE[ArcSin[(-1+\[Sqrt]2) \[Sqrt](r/(-1+r))],17+12 \[Sqrt]2]+2 (1+\[Sqrt]2) EllipticF[ArcSin[(-1+\[Sqrt]2) \[Sqrt](r/(-1+r))],17+12 \[Sqrt]2]))]}]
Module[{pts},
pts=Table[MoselyBudCrossSectionPt[r],{r,0,1,1/50}];
Graphics[{
Line[pts],
Line[{-1,1}#&/@pts]},Axes->True,AspectRatio->Automatic]
]//ShowExample
PotCrossSectionGraphics[pts_, opts___]:=Module[{pts1},
pts1=#-pts[[1]]&/@pts;
Graphics[{Line[pts1],Line[{-1,1}#&/@pts1]},FilterRules[{opts},Options[Graphics]]]]
Module[{pts},
pts={{0,0},{1,1},{1,2},{1,3},{2,4}};
PotCrossSectionGraphics[pts,Axes->False]
]//ShowExample
PotWedgeJoinVertices::usage="PotWedgeJoinVertices is a property of the TObj returned from MakeRadialPotWedge that gives the indices of the along the two straight sides of the wedge.";
PotGapHalfAngle::usage="PotGapHalfAngle is an option to MakeRadialPotWedge that specifies the half-angle of the gap between the inner edges of the pot.";
PotFlatFlangeInset::usage="PotFlatFlangeInset is an option to MakeRadialPotWedge that specifies a small inset to apply to vertices in the folded form to spread the layers of the flange.";
PotBorder::usage = "PotBorder is an option to MakeRadialPotWedge that specifies what type of border to put on the polygon.";
PotPlanar::usage="PotPlanar is an option value to PotBorder that specifies to make the border of the paper planar in the folded form.";
PotPolygon::usage="PotPolygon is an option value to PotBorder that specifies to make the border of the paper a regular polygon.";
PotCircular::usage="PotCircular is an option value to PotBorder that specifies to make the border of the paper circular.";
Options[MakeRadialPotWedge]={
PotGapHalfAngle->0,
PotFlatFlangeInset->0,
PotBorder->PotPlanar
};
MakeRadialPotWedge::badpts="Point list `1` is not strictly monontonically increasing or decreasing.";
MakeRadialPotWedge::badgap="The nonzero gap of `1` and asymmetry factor `2` gave rise to some negative distances in the crease pattern: s = `3`, t = `4`.";
MakeRadialPotWedge[pts_List, m_Integer, \[Rho]_:0, opts___]:=Module[{\[Delta],\[Epsilon],pb,\[Phi],cdt,fb,x,z,r,w,s,t,v,u,n,a,b,c,d,e,f,pts1,aa,bb,cc,dd,ee,ff,soln,vv,vi,verts,verts3d,edges,types,addv,adde,arcify,tobj,foldangles},
\[Delta]=PotGapHalfAngle/.{opts}/.Options[MakeRadialPotWedge];
\[Epsilon]=PotFlatFlangeInset/.{opts}/.Options[MakeRadialPotWedge];
pb=PotBorder/.{opts}/.Options[MakeRadialPotWedge];
\[Phi]=\[Pi]/m;
pts1=#-pts[[1]]&/@pts;
{x,z}=Transpose[pts1];
cdt=FoldAngleToType[z[[-1]]];(* fold angle of c and d folds *)
fb=(z[[1]]==z[[2]]);(* True = flat-bottom condition *)
(* test for strict monotonicity *)
Module[{zinc = Drop[RotateLeft[z]-z,-1]},
If[zinc[[1]]==0,zinc=Drop[zinc,1]];
If[Length[Union[Sign/@zinc]]>1,Message[MakeRadialPotWedge::badpts,pts];Abort[]]];
(* r is distance along ctr of gore *)
r=Prepend[Accumulate[Mag/@(Drop[pts,1]-Drop[pts,-1])],0];
n=Length[r];
(* w is gore half-width, accounting for gap \[Delta] *)
w=Tan[\[Phi]-\[Delta]]x;
(* crease pattern points, lettered starting from x-axis *)
a={#,0}&/@r;
b=a+(U[\[Pi]/2]#&/@w);
c=b+Table[s[i]U[\[Pi]/2],{i,n}];
f=U[2\[Phi]]#&/@r;
e=f+(U[2\[Phi]-\[Pi]/2]#&/@w);
d=e+Table[t[i]U[2\[Phi]-\[Pi]/2],{i,n}];
(* folded form points *)
aa={#[[1]],0,#[[2]]}&/@pts1;
bb=aa+(U3D[\[Pi]/2]#&/@w);
cc=bb+Table[s[i]U3D[2(\[Phi]-\[Delta])-\[Pi]/2],{i,n}];
ff=U3D[2\[Phi]]#&/@x+({0,0,#}&/@z);
ee=ff+(U3D[2\[Phi]-\[Pi]/2]#&/@w);
dd=ee+Table[t[i]U3D[\[Pi]/2+2\[Delta]],{i,n}];
(* Solve for u[i] for all i *)
s[1]=t[1]=u[1]=0;
v=x Sec[\[Phi]-\[Delta]]Sin[\[Delta]]Sec[\[Phi]-2\[Delta]];
Do[
s[i]=(r[[i]]Tan[\[Phi]]-w[[i]])u[i]((1-\[Rho])/2)-v[[i]];
t[i]=(r[[i]]Tan[\[Phi]]-w[[i]])u[i]( (1+\[Rho])/2)-v[[i]];
(* Solve for u[i]. Some special cases are known. *)
Which[
\[Delta]==0 ,(* no gap, solution is simple *)
u[i]=1,
True,(* but with gap, need to solve numerically *)
soln=Solve[{Mag2[d[[i]]-c[[i]]]==Mag2[dd[[i]]-cc[[i]]]},u[i]];
Print["i = ",i,", soln = ",soln]//Hold;
(* desired solution is smallest positive solution *)
u[i]=Min[Select[u[i]/.soln,#>=0&]]
],{i,2,n}];
(* Tweak folded form points if necessary *)
If[\[Rho]==-1,bb={1-\[Epsilon],1-\[Epsilon],1}#&/@bb];
If[\[Rho]==1,ee={1-\[Epsilon],1-\[Epsilon],1}#&/@ee];
(* Check for negative values *)
Do[If[s[i]<0||t[i]<0,Message[MakeRadialPotWedge::badgap,\[Delta],\[Rho],Table[s[j],{j,n}],Table[t[j],{j,n}]];Abort[]],{i,n}];
(* Debugging, print overlaid slices *)
Print[Graphics[Line[Take[#,2]&/@#]&/@Transpose[{aa,bb,cc,dd,ee,ff}],Axes->True]]//Hold;

(* construct list of distinct vertices, using lookup function vi *)
verts=verts3d={};
(* vv["p"] returns the list p for all of our vector point lists, both 2D and 3D *)
vv["a"]:=a;vv["b"]:=b;vv["c"]:=c;vv["d"]:=d;vv["e"]:=e;vv["f"]:=f;
vv["aa"]:=aa;vv["bb"]:=bb;vv["cc"]:=cc;vv["dd"]:=dd;vv["ee"]:=ee;vv["ff"]:=ff;
vv["verts"]:=verts;vv["verts3d"]==verts3d;
(* addv["p","q",i] creates lookup entries for vi["p",i] and vi["pp",i] to return the index in verts of p\[LeftDoubleBracket]i\[RightDoubleBracket] and pp\[LeftDoubleBracket]i\[RightDoubleBracket], and if "q" is not empty, checks for duplication against q\[LeftDoubleBracket]i\[RightDoubleBracket] and qq\[LeftDoubleBracket]i\[RightDoubleBracket]. *)
addv[p_String,q_String,i_]:=
If[q!=""&&Chop[Mag[vv[p][[i]]-vv[q][[i]]]]==0,(* found a dup *)
vi[p,i]=vi[p<>p,i]=vi[q,i],(* just register the lookup *)
AppendTo[verts,vv[p][[i]]]; (* otherwise add new vertices to lists and register *)AppendTo[verts3d,vv[p<>p][[i]]];vi[p,i]=vi[p<>p,i]=Length[verts]];
(* We can also add vertices that are not in our vector list by supply literal vertex descriptions. No dup checking is done. *)
addv["verts",vn_,vvn_]:=(
AppendTo[verts,vn];
AppendTo[verts3d,vvn];
vi["verts",Length[verts]]=vi["verts3d",Length[verts3d]]=Length[verts]);
(* Now create all vertices in radial-first order *)
Do[addv["a","",i],{i,n}];
Do[addv["b","a",i],{i,n}];
Do[addv["c","b",i],{i,n}];
Do[addv["d","c",i],{i,n}];
Do[addv["e","d",i],{i,n}];
Do[addv["f","e",i],{i,n}];
(* Debugging: print an image of all distinct points *)
Print[Graphics[Style[Point[#],PointSize[.01]]&/@verts,Axes->True]]//Hold;

(* construct lists of distinct edges *)
edges=types={};
(* adde["p",i,"q",j] adds an edge from p\[LeftDoubleBracket]i\[RightDoubleBracket] to q\[LeftDoubleBracket]j\[RightDoubleBracket] and an associated type if it doesn't already exist and isn't a self-loop *)
adde[p_String,i_,q_String,j_,type_]:=Module[{edge},
edge={vi[p,i],vi[q,j]};
If[!(edge[[1]]==edge[[2]]||MemberQ[edges,edge]||MemberQ[edges,Reverse[edge]]),
AppendTo[edges,edge];
AppendTo[types,type]]];
(* Radial folds. These fold types are known, but there are special cases: 
For \[Rho]=+1, the b and c lines are the same and should be unfolded. 
For \[Rho]=-1, the d and e lines are the same and should be unfolded. *)
Do[adde["a",i,"a",i+1,B],{i,n-1}];
Do[adde["b",i,"b",i+1,If[i==1&&fb,U,If[\[Rho]==1,U,InvertFoldType[cdt]]]],{i,n-1}];
Do[adde["c",i,"c",i+1,If[i==1&&fb,U,If[\[Rho]==1,U,cdt]]],{i,n-1}];
Do[adde["d",i,"d",i+1,If[i==1&&fb,U,If[\[Rho]==-1,U,cdt]]],{i,n-1}];
Do[adde["e",i,"e",i+1,If[i==1&&fb,U,If[\[Rho]==-1,U,InvertFoldType[cdt]]]],{i,n-1}];
Do[adde["f",i,"f",i+1,B],{i,n-1}];
(* Axial folds. All but the last are unknown, will be set later. Use N to signify. *)
Do[
adde["a",i,"b",i,N];
adde["b",i,"c",i,N];
adde["c",i,"d",i,N];
adde["d",i,"e",i,N];
adde["e",i,"f",i,N];
,{i,2,n-1}];
(* last row is special case. We have different ways of finishing boundary. *)
Which[
pb===PotCircular,
(* For each polygon along the boundary, pull the existing boundary vertices back into a circle and add more vertices to make the border circular. *)
arcify[p_,pp_,ps_,q_,qq_,qs_]:=Module[{vn,rm,offset,vvn,arc,na,prevs,prevn},
(* Pull back vertices q and qq to lie on a circle. *)
vn=RayCircleInt2D[q[[-1]],q[[-1]]-q[[-2]],{0,0},r[[-1]]];
{rm,offset}=SimilarityPair2D3D[{p[[-2]],p[[-1]],q[[-1]]},{pp[[-2]],pp[[-1]],qq[[-1]]}];
vvn=offset+rm . vn;
verts[[vi[qs,n]]]=vn;
verts3d[[vi[qs<>qs,n]]]=vvn;
arc=PolygonalEllipseArc2D[verts[[vi[ps,n]]],vn,opts];
(* If needed, add more vertices in between and add a segment (note \[Rho]=1,-1 exceptions) *)
If[!(\[Rho]==-1&&ps=="b")&&!(\[Rho]==1&&ps=="d"),
na=Length[arc];
If[na==2,(* no new segments needed, it's short enough *)
adde[ps,n,qs,n,B],
(* otherwise, we need to add points to the arc *)
prevs=ps;
prevn=n;
Do[
If[i!=na-1,
(* add a vertex, and then an edge connecting to the vertex *)
vn=arc[[i+1]];
vvn=offset+rm . vn;
addv["verts",vn,vvn];
adde[prevs,prevn,"verts",Length[verts],B],
(* just connect the last vertex added to the existing vertex at the end of the arc *)
adde[prevs,prevn,qs,n,B]];
prevs="verts";
prevn=Length[verts];
,{i,Length[arc]-1}]]]];
(* Apply arcify for each of the segments of the boundary *)
arcify[a,aa,"a",b,bb,"b"];
arcify[b,bb,"b",c,cc,"c"];
arcify[c,cc,"c",d,dd,"d"];
arcify[d,dd,"d",e,ee,"e"];
arcify[e,ee,"e",f,ff,"f"];
,
pb===PotPolygon, 
(* for \[Rho] \[NotEqual] 1 or -1, add another vertex on the boundary *)
adde["a",n,"b",n,B];
adde["b",n,"c",n,B];
If[\[Rho]==1||\[Rho]==-1,
(* business as usual *)
adde["c",n,"d",n,B],
(* otherwise add a vertex at the original corner of the m-gon *)
Module[{rm,offset,vn,vvn,in},
{rm,offset}=SimilarityPair2D3D[{c[[-2]],c[[-1]],d[[-1]]},{cc[[-2]],cc[[-1]],dd[[-1]]}];
vn=a[[-1]]+r[[-1]]Tan[\[Phi]]U[\[Pi]/2];(* new crease pattern point *)
vvn=offset+rm . vn;(* new folded form point *)
addv["verts",vn,vvn];
in=Length[verts];
adde["c",n,"verts",in,B];
adde["verts",in,"d",n,B];
]];
adde["d",n,"e",n,B];
adde["e",n,"f",n,B];
Null,
True,
(* PotPlanar, or anything else *)
adde["a",n,"b",n,B];
adde["b",n,"c",n,B];
adde["c",n,"d",n,B];
adde["d",n,"e",n,B];
adde["e",n,"f",n,B];
];

(* Build the TObj *)
tobj = MakeTGraph3DAssigned[verts,edges,{},verts3d,{},types]//AddTPlaneGraph;
(* Fix up the fold angles and types *)
foldangles=EdgeFaceAngles3D[tobj]; (* compute all fold angles *)
Do[If[types[[i]]===N,types[[i]]=FoldAngleToType[foldangles[[i]],opts]],{i,Length[edges]}];
tobj//ReplaceProperties[{FoldAngles->foldangles,EdgeTypes->types}]//AddProperty[PotWedgeJoinVertices->{Table[vi["a",i],{i,n}],Table[vi["f",i],{i,n}]}]]
Module[{pts,m,\[Rho],tobj},
pts={{0,0},{1,1},{1,2},{1,3},{2,4}}//N;
m=8;
\[Rho]=0;
tobj=MakeRadialPotWedge[pts,m,\[Rho],PotGapHalfAngle->3\[Degree],TypeMinimumAngle->10\[Degree]];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={{0,0},{1,1},{1,2},{1,3},{2,4}}//N;
m=8;
\[Rho]=0;
tobj=MakeRadialPotWedge[pts,m,\[Rho],PotGapHalfAngle->3\[Degree],TypeMinimumAngle->10\[Degree],PotBorder->PotPolygon];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={{0,0},{1,1},{1,2},{1,3},{2,4}}//N;
m=8;
\[Rho]=0;
tobj=MakeRadialPotWedge[pts,m,\[Rho],PotGapHalfAngle->3\[Degree],TypeMinimumAngle->10\[Degree],PotBorder->PotCircular];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={{0,-1},{1,-1},{1,-2},{1,-3},{2,-4}}//N;
m=8;
\[Rho]=-1;
tobj=MakeRadialPotWedge[pts,m,\[Rho],PotGapHalfAngle->0\[Degree],TypeMinimumAngle->10\[Degree]];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={{0,0},{1,1},{1,2},{2,3}}//N;
m=8;
\[Rho]=1/2;
tobj=MakeRadialPotWedge[pts,m,\[Rho],PotGapHalfAngle->4\[Degree],TypeMinimumAngle->10\[Degree]];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj,pwjv},
pts=Table[{0.5Sin[\[Theta]],Cos[\[Theta]]-1},{\[Theta],0,\[Pi],\[Pi]/4}]//N;
m=5;
\[Rho]=0;
tobj=MakeRadialPotWedge[pts,m,\[Rho],PotGapHalfAngle->4\[Degree],TypeMinimumAngle->10\[Degree]];
pwjv=tobj[PotWedgeJoinVertices];
Print["PotWedgeJoinVertices = ",pwjv];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{wi,a,b,c,d,e,f,aa,bb,cc,dd,ee,ff,si,ti,dc},
wi=xi Tan[\[Phi]];
(* cp *)
a=ri U[0];
b=a+wi U[\[Pi]/2];
c=b+si U[\[Pi]/2];
f=ri U[2\[Phi]];
e=f+wi U[2\[Phi]-\[Pi]/2];
d=e+ti U[2\[Phi]-\[Pi]/2];
(* ff *)
aa=xi U3D[0]+zi{0,0,1};
bb=aa+wi U3D[\[Pi]/2];
cc=bb+si U3D[2\[Phi]-\[Pi]/2];
ff=xi U3D[2\[Phi]]+zi {0,0,1};
ee=ff + wi U3D[2\[Phi]-\[Pi]/2];
dd=ee+ti U3D[\[Pi]/2];
(* parameters *)
si=(ri Tan[\[Phi]]-wi)ui ((1-\[Rho])/2);
ti=(ri Tan[\[Phi]]-wi)ui ((1+\[Rho])/2);
(* distance condition *)
Solve[Mag2[cc-dd]==Mag2[c-d],ui]]//ShowExample
Module[{wi,a,b,c,d,e,f,aa,bb,cc,dd,ee,ff,vi,si,ti,dc,soln},
wi=xi Tan[\[Phi]-\[Delta]];
(* cp *)
a=ri U[0];
b=a+wi U[\[Pi]/2];
c=b+si U[\[Pi]/2];
f=ri U[2\[Phi]];
e=f+wi U[2\[Phi]-\[Pi]/2];
d=e+ti U[2\[Phi]-\[Pi]/2];
(* ff *)
aa=xi U3D[0]+zi{0,0,1};
bb=aa+wi U3D[\[Pi]/2];
cc=bb+si U3D[2(\[Phi]-\[Delta])-\[Pi]/2];
ff=xi U3D[2\[Phi]]+zi {0,0,1};
ee=ff + wi U3D[2\[Phi]-\[Pi]/2];
dd=ee+ti U3D[\[Pi]/2+2\[Delta]];
(* parameters *)
vi=xi Sec[\[Phi]-\[Delta]]Sin[\[Delta]]Sec[\[Phi]-2\[Delta]];
si=(ri Tan[\[Phi]]-wi)ui ((1-\[Rho])/2)-vi;
ti=(ri Tan[\[Phi]]-wi)ui ((1+\[Rho])/2)-vi;
(* distance condition *)
soln=Solve[Mag2[cc-dd]==Mag2[c-d],ui];
LeafCount[soln]]//ShowExample
MakeRadialPot[pts_List, m_,\[Rho]_,opts___]:=Module[{tobjw,verts3d,pwjv,tbl,di,gs,tobj},
tobjw=MakeRadialPotWedge[pts,m,\[Rho],opts];
{verts3d,pwjv}=GetValues[tobjw,{Vertices3D,PotWedgeJoinVertices}];
(* we need 3 points along each edge to match up, and for best accuracy, the third point should be as far off of the line between the first two as possible. So, we make a table of all of the points along the bottom edge and sort them by distance from the line between the two corners. *)
tbl=Table[{di,PointLineDistance[verts3d[[pwjv[[1,di]]]],{verts3d[[pwjv[[1,1]]]],verts3d[[pwjv[[1,-1]]]]}]},{di,1,Length[pwjv[[1]]]}];
di=Sort[tbl,#1[[2]]<#2[[2]]&][[-1,1]];
(* Now build the list of graphspecs for joining sequentially *)
gs=Table[{tobjw,{i-1,{pwjv[[2,1]],pwjv[[2,-1]],pwjv[[2,di]]},{pwjv[[1,1]],pwjv[[1,-1]],pwjv[[1,di]]}}},{i,m}];
JoinGraph3DAssigneds[gs,opts]//AddTPlaneGraph]
Module[{pts,m,\[Rho],tobj},
pts={{0,0},{1,1},{1,2},{1,3},{2,4}}//N;
m=5;
\[Rho]=0;
tobj=MakeRadialPot[pts,m,\[Rho],PotGapHalfAngle->3\[Degree],TypeMinimumAngle->10\[Degree]];
GraphicsRow[{
CreasePatternGraphics[tobj]/.OrigamiStyle[CreaseColor->LightGray],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[ShowUnfolded->False]}]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={1,-1}#&/@Table[MoselyBudCrossSectionPt[r],{r,0,1,1/20}]//N;
m=4;
\[Rho]=0;
tobj=MakeRadialPot[pts,m,\[Rho],TypeMinimumAngle->30\[Degree]];
GraphicsRow[{
CreasePatternGraphics[tobj]/.OrigamiStyle[CreaseColor->LightGray],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[ShowUnfolded->False]}]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={1,-1}#&/@Table[MoselyBudCrossSectionPt[r],{r,0,1,1/20}]//N;
m=4;
\[Rho]=0.3333;
tobj=MakeRadialPot[pts,m,\[Rho],TypeMinimumAngle->30\[Degree]];
GraphicsRow[{
CreasePatternGraphics[tobj]/.OrigamiStyle[CreaseColor->LightGray],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[ShowUnfolded->False]}]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts=Table[{0.5Sin[\[Theta]],-(Cos[\[Theta]]-1)},{\[Theta],0,2\[Pi]/3,\[Pi]/6}]//N;
m=5;
\[Rho]=-1;
tobj=MakeRadialPot[pts,m,\[Rho],PotFlatFlangeInset->.1];
GraphicsRow[{
CreasePatternGraphics[tobj]/.OrigamiStyle[CreaseColor->LightGray],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[ShowUnfolded->False]}]
]//ShowExample
PotFlangeExcess::usage="PotFlangeExcess is an option to MakeRectangularPotWedge that specifies the extra flange width to add relative to the widest part of the gore.";
Options[MakeRectangularPotWedge]={
PotGapHalfAngle->0,
PotFlatFlangeInset->0,
PotFlangeExcess->0
};
MakeRectangularPotWedge::badpts="Point list `1` is not strictly monontonically increasing or decreasing.";
MakeRectangularPotWedge::badgap="The nonzero gap of `1` and asymmetry factor `2` gave rise to some negative distances in the crease pattern: s = `3`, t = `4`.";
MakeRectangularPotWedge[pts_List, m_Integer, \[Rho]_:0, opts___]:=Module[{\[Delta],\[Epsilon],fe,\[Phi],cdt,fb,x,z,r,w,h,s,t,v,u,n,a,b,c,d,e,f,pts1,aa,bb,cc,dd,ee,ff,soln,vv,vi,verts,verts3d,edges,types,addv,adde,arcify,tobj,foldangles},
\[Delta]=PotGapHalfAngle/.{opts}/.Options[MakeRectangularPotWedge];
\[Epsilon]=PotFlatFlangeInset/.{opts}/.Options[MakeRectangularPotWedge];
fe=PotFlangeExcess/.{opts}/.Options[MakeRectangularPotWedge];
\[Phi]=\[Pi]/m;
pts1=#-{0,pts[[1,2]]}&/@pts;
{x,z}=Transpose[pts1];
cdt=FoldAngleToType[z[[-1]]];(* fold angle of c and d folds *)
fb=(z[[1]]==z[[2]]);(* True = flat-bottom condition *)
(* test for strict monotonicity *)
Module[{zinc = Drop[RotateLeft[z]-z,-1]},
If[zinc[[1]]==0,zinc=Drop[zinc,1]];
If[Length[Union[Sign/@zinc]]>1,Message[MakeRectangularPotWedge::badpts,pts];Abort[]]];
(* r is distance along ctr of gore *)
r=Prepend[Accumulate[Mag/@(Drop[pts,1]-Drop[pts,-1])],0];
n=Length[r];
(* w is gore half-width, accounting for gap \[Delta] *)
w=Tan[\[Phi]-\[Delta]]x;
(* h is panel half-height, includes gore width plus flange excess *)
h=Max[w](1+fe);
(* crease pattern points, lettered starting from x-axis *)
a={#,0}&/@r;
b=a+(# U[\[Pi]/2]&/@w);
c=b+Table[s[i]U[\[Pi]/2],{i,n}];
f={#,2h}&/@r;
e=f-(# U[\[Pi]/2]&/@w);
d=e-Table[t[i]U[\[Pi]/2],{i,n}];
(* folded form points *)
aa={#[[1]],0,#[[2]]}&/@pts1;
bb=aa+(U3D[\[Pi]/2]#&/@w);
cc=bb+Table[s[i]U3D[2(\[Phi]-\[Delta])-\[Pi]/2],{i,n}];
ff=U3D[2\[Phi]]#&/@x+({0,0,#}&/@z);
ee=ff+(U3D[2\[Phi]-\[Pi]/2]#&/@w);
dd=ee+Table[t[i]U3D[\[Pi]/2+2\[Delta]],{i,n}];
(* Solve for u[i] for all i *)
v=x Sec[\[Phi]-\[Delta]]Sin[\[Delta]]Sec[\[Phi]-2\[Delta]];
Do[
s[i]=(h-w[[i]])u[i](1-\[Rho])/2-v[[i]];
t[i]=(h-w[[i]]) u[i](1+\[Rho])/2-v[[i]];
(* Solve for u[i]. Some special cases are known. *)
Which[
\[Delta]==0 &&(\[Rho]==1||\[Rho]==-1),(* no gap, thin-flange, solution is simple *)
u[i]=1,
\[Delta]==0&&(\[Rho]==0),(* no gap, symmetric thick flange, also simple *)
u[i]=Sec[\[Phi]/2]^2,
\[Delta]==0,(* no gap, general \[Rho], still tolerable analytic solution *)
u[i]=((-2+\[Sqrt]2 \[Sqrt](1+\[Rho]^2-(-1+\[Rho]^2) Cos[2 \[Phi]])) Csc[\[Phi]]^2)/(-1+\[Rho]^2),
True,(* but with gap, need to solve numerically *)
soln=Solve[{Mag2[d[[i]]-c[[i]]]==Mag2[dd[[i]]-cc[[i]]]},u[i]];
If[soln==={},soln={u[i]->0}];(* we've already failed, but fail gracefully *)
Print["i = ",i,", soln = ",soln]//Hold;
(* desired solution is smallest positive solution *)
u[i]=Min[Select[u[i]/.soln,#>=0&]]
],{i,n}];
(* Tweak folded form points if necessary *)
If[\[Rho]==-1,bb={1-\[Epsilon],1-\[Epsilon],1}#&/@bb];
If[\[Rho]==1,ee={1-\[Epsilon],1-\[Epsilon],1}#&/@ee];
(* Check for negative values *)
Do[If[s[i]<0||t[i]<0,Message[MakeRectangularPotWedge::badgap,\[Delta],\[Rho],Table[s[j],{j,n}],Table[t[j],{j,n}]];Abort[]],{i,n}];
(* Debugging, print overlaid slices *)
Print[Graphics[Line[Take[#,2]&/@#]&/@Transpose[{aa,bb,cc,dd,ee,ff}],Axes->True]]//Hold;

(* construct list of distinct vertices, using lookup function vi *)
verts=verts3d=edges=types={};
(* vv["p"] returns the list p for all of our vector point lists, both 2D and 3D *)
vv["a"]:=a;vv["b"]:=b;vv["c"]:=c;vv["d"]:=d;vv["e"]:=e;vv["f"]:=f;
vv["aa"]:=aa;vv["bb"]:=bb;vv["cc"]:=cc;vv["dd"]:=dd;vv["ee"]:=ee;vv["ff"]:=ff;
vv["verts"]:=verts;vv["verts3d"]==verts3d;
(* addv["p","q",i] creates lookup entries for vi["p",i] and vi["pp",i] to return the index in verts of p\[LeftDoubleBracket]i\[RightDoubleBracket] and pp\[LeftDoubleBracket]i\[RightDoubleBracket], and if "q" is not empty, checks for duplication against q\[LeftDoubleBracket]i\[RightDoubleBracket] and qq\[LeftDoubleBracket]i\[RightDoubleBracket]. *)
addv[p_String,q_String,i_]:=
If[q!=""&&Chop[Mag[vv[p][[i]]-vv[q][[i]]]]==0,(* found a dup *)
vi[p,i]=vi[p<>p,i]=vi[q,i],(* just register the lookup *)
AppendTo[verts,vv[p][[i]]]; (* otherwise add new vertices to lists and register *)AppendTo[verts3d,vv[p<>p][[i]]];vi[p,i]=vi[p<>p,i]=Length[verts]];
(* We can also add vertices that are not in our vector list by supply literal vertex descriptions. No dup checking is done. *)
addv["verts",vn_,vvn_]:=(
AppendTo[verts,vn];
AppendTo[verts3d,vvn];
vi["verts",Length[verts]]=vi["verts3d",Length[verts3d]]=Length[verts]);
(* Now create all vertices in horizontal-first order *)
Do[addv["a","",i],{i,n}];
Do[addv["b","a",i],{i,n}];
Do[addv["c","b",i],{i,n}];
Do[addv["d","c",i],{i,n}];
Do[addv["e","d",i],{i,n}];
Do[addv["f","e",i],{i,n}];
(* Debugging: print an image of all distinct points *)
Print[Graphics[Style[Point[#],PointSize[.01]]&/@verts,Axes->True]]//Hold;

(* construct lists of distinct edges *)
edges=types={};
(* adde["p",i,"q",j] adds an edge from p\[LeftDoubleBracket]i\[RightDoubleBracket] to q\[LeftDoubleBracket]j\[RightDoubleBracket] and an associated type if it doesn't already exist and isn't a self-loop *)
adde[p_String,i_,q_String,j_,type_]:=Module[{edge},
edge={vi[p,i],vi[q,j]};
If[!(edge[[1]]==edge[[2]]||MemberQ[edges,edge]||MemberQ[edges,Reverse[edge]]),
AppendTo[edges,edge];
AppendTo[types,type]]];
(* Horizontal folds. These fold types are known, but there are special cases: 
For \[Rho]=+1, the b and c lines are the same and should be unfolded. 
For \[Rho]=-1, the d and e lines are the same and should be unfolded. *)
Do[adde["a",i,"a",i+1,B],{i,n-1}];
Do[adde["b",i,"b",i+1,If[i==1&&fb,U,If[\[Rho]==1,U,InvertFoldType[cdt]]]],{i,n-1}];
Do[adde["c",i,"c",i+1,If[i==1&&fb,U,If[\[Rho]==1,U,cdt]]],{i,n-1}];
Do[adde["d",i,"d",i+1,If[i==1&&fb,U,If[\[Rho]==-1,U,cdt]]],{i,n-1}];
Do[adde["e",i,"e",i+1,If[i==1&&fb,U,If[\[Rho]==-1,U,InvertFoldType[cdt]]]],{i,n-1}];
Do[adde["f",i,"f",i+1,B],{i,n-1}];
(* Vertical folds. All but the first and last are unknown, will be set later. Use N to signify. *)
adde["a",1,"b",1,B];
adde["b",1,"c",1,B];
adde["c",1,"d",1,B];
adde["d",1,"e",1,B];
adde["e",1,"f",1,B];
Do[
adde["a",i,"b",i,N];
adde["b",i,"c",i,N];
adde["c",i,"d",i,N];
adde["d",i,"e",i,N];
adde["e",i,"f",i,N];
,{i,2,n-1}];
(* last row is special case. We have different ways of finishing boundary. *)
adde["a",n,"b",n,B];
adde["b",n,"c",n,B];
adde["c",n,"d",n,B];
adde["d",n,"e",n,B];
adde["e",n,"f",n,B];

(* Build the TObj *)
tobj = MakeTGraph3DAssigned[verts,edges,{},verts3d,{},types]//AddTPlaneGraph;
(* Fix up the fold angles and types *)
foldangles=EdgeFaceAngles3D[tobj]; (* compute all fold angles *)
Do[If[types[[i]]===N,types[[i]]=FoldAngleToType[foldangles[[i]],opts]],{i,Length[edges]}];
tobj//ReplaceProperties[{FoldAngles->foldangles,EdgeTypes->types}]//AddProperty[PotWedgeJoinVertices->{Table[vi["a",i],{i,n}],Table[vi["f",i],{i,n}]}]]
Module[{pts,m,\[Rho],tobj},
pts={{.3,0},{1,1},{1,2},{1,3},{2,4}}//N;
m=8;
\[Rho]=0;
tobj=MakeRectangularPotWedge[pts,m,\[Rho],PotGapHalfAngle->0,PotFlangeExcess->0.1,TypeMinimumAngle->10\[Degree]];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={{.3,0},{1,1},{1,2},{1,3},{2,4}}//N;
m=8;
\[Rho]=1;
tobj=MakeRectangularPotWedge[pts,m,\[Rho],PotGapHalfAngle->0,PotFlatFlangeInset->0.05,PotFlangeExcess->0.1,TypeMinimumAngle->10\[Degree]];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={{0,0},{1,1},{1,2},{1,3},{2,4}}//N;
m=8;
\[Rho]=0;
tobj=MakeRectangularPotWedge[pts,m,\[Rho],PotGapHalfAngle->3\[Degree],PotFlangeExcess->0.3,TypeMinimumAngle->10\[Degree]];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={{0,-1},{1,-1},{1,-2},{1,-3},{2,-4}}//N;
m=8;
\[Rho]=-1;
tobj=MakeRectangularPotWedge[pts,m,\[Rho],PotGapHalfAngle->0\[Degree],TypeMinimumAngle->10\[Degree]];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts={{0,0},{1,1},{1,2},{2,3}}//N;
m=8;
\[Rho]=1/2;
tobj=MakeRectangularPotWedge[pts,m,\[Rho],PotGapHalfAngle->0,TypeMinimumAngle->10\[Degree]];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,m,\[Rho],tobj,pwjv},
pts=Table[{0.5Sin[\[Theta]],Cos[\[Theta]]-1},{\[Theta],0,\[Pi],\[Pi]/4}]//N;
m=5;
\[Rho]=0;
tobj=MakeRectangularPotWedge[pts,m,\[Rho],PotGapHalfAngle->4\[Degree],PotFlangeExcess->0.5,TypeMinimumAngle->10\[Degree]];
pwjv=tobj[PotWedgeJoinVertices];
PrintThis[pwjv];
GraphicsRow[
{GraphGraphics[tobj],CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{wi,a,b,c,d,e,f,aa,bb,cc,dd,ee,ff,si,ti,dc},
wi=xi Tan[\[Phi]];
(* cp *)
a=ri U[0];
b=a+wi U[\[Pi]/2];
c=b+si U[\[Pi]/2];
f={ri,2h};
e=f-wi U[\[Pi]/2];
d=e-ti U[\[Pi]/2];
(* ff *)
aa=xi U3D[0]+zi{0,0,1};
bb=aa+wi U3D[\[Pi]/2];
cc=bb+si U3D[2\[Phi]-\[Pi]/2];
ff=xi U3D[2\[Phi]]+zi {0,0,1};
ee=ff + wi U3D[2\[Phi]-\[Pi]/2];
dd=ee+ti U3D[\[Pi]/2];
(* parameters *)
si=(h-wi)ui ((1-\[Rho])/2);
ti=(h-wi)ui ((1+\[Rho])/2);
(* distance condition *)
Solve[(Mag2[cc-dd]==Mag2[c-d])/.\[Rho]->1,ui]//FullSimplify]//ShowExample
Module[{wi,a,b,c,d,e,f,aa,bb,cc,dd,ee,ff,si,ti,dc},
wi=xi Tan[\[Phi]];
(* cp *)
a=ri U[0];
b=a+wi U[\[Pi]/2];
c=b+si U[\[Pi]/2];
f={ri,2h};
e=f-wi U[\[Pi]/2];
d=e-ti U[\[Pi]/2];
(* ff *)
aa=xi U3D[0]+zi{0,0,1};
bb=aa+wi U3D[\[Pi]/2];
cc=bb+si U3D[2\[Phi]-\[Pi]/2];
ff=xi U3D[2\[Phi]]+zi {0,0,1};
ee=ff + wi U3D[2\[Phi]-\[Pi]/2];
dd=ee+ti U3D[\[Pi]/2];
(* parameters *)
si=(h-wi)ui ((1-\[Rho])/2);
ti=(h-wi)ui ((1+\[Rho])/2);
(* distance condition *)
FullSimplify[Solve[(Mag2[cc-dd]==Mag2[c-d])/.\[Rho]->0,ui],{\[Phi]>0,\[Phi]<\[Pi]/2,h>xi Tan[\[Phi]]}]]//ShowExample
Module[{wi,a,b,c,d,e,f,aa,bb,cc,dd,ee,ff,si,ti,dc},
wi=xi Tan[\[Phi]];
(* cp *)
a=ri U[0];
b=a+wi U[\[Pi]/2];
c=b+si U[\[Pi]/2];
f={ri,2h};
e=f-wi U[\[Pi]/2];
d=e-ti U[\[Pi]/2];
(* ff *)
aa=xi U3D[0]+zi{0,0,1};
bb=aa+wi U3D[\[Pi]/2];
cc=bb+si U3D[2\[Phi]-\[Pi]/2];
ff=xi U3D[2\[Phi]]+zi {0,0,1};
ee=ff + wi U3D[2\[Phi]-\[Pi]/2];
dd=ee+ti U3D[\[Pi]/2];
(* parameters *)
si=(h-wi)ui ((1-\[Rho])/2);
ti=(h-wi)ui ((1+\[Rho])/2);
(* distance condition *)
Solve[(Mag2[cc-dd]==Mag2[c-d])/.\[Rho]->-1,ui]//FullSimplify]//ShowExample
Module[{wi,a,b,c,d,e,f,aa,bb,cc,dd,ee,ff,si,ti,dc},
wi=xi Tan[\[Phi]];
(* cp *)
a=ri U[0];
b=a+wi U[\[Pi]/2];
c=b+si U[\[Pi]/2];
f={ri,2h};
e=f-wi U[\[Pi]/2];
d=e-ti U[\[Pi]/2];
(* ff *)
aa=xi U3D[0]+zi{0,0,1};
bb=aa+wi U3D[\[Pi]/2];
cc=bb+si U3D[2\[Phi]-\[Pi]/2];
ff=xi U3D[2\[Phi]]+zi {0,0,1};
ee=ff + wi U3D[2\[Phi]-\[Pi]/2];
dd=ee+ti U3D[\[Pi]/2];
(* parameters *)
si=(h-wi)ui ((1-\[Rho])/2);
ti=(h-wi)ui ((1+\[Rho])/2);
(* distance condition *)
FullSimplify[Solve[(Mag2[cc-dd]==Mag2[c-d]),ui],{\[Phi]>0,\[Phi]<\[Pi]/2,h>xi Tan[\[Phi]]}]]//ShowExample
Module[{wi,a,b,c,d,e,f,aa,bb,cc,dd,ee,ff,v,si,ti,dc,soln},
wi=xi Tan[\[Phi]-\[Delta]];
(* cp *)
a=ri U[0];
b=a+wi U[\[Pi]/2];
c=b+si U[\[Pi]/2];
f={ri,2h};
e=f-wi U[\[Pi]/2];
d=e-ti U[\[Pi]/2];
(* ff *)
aa=xi U3D[0]+zi{0,0,1};
bb=aa+wi U3D[\[Pi]/2];
cc=bb+si U3D[2(\[Phi]-\[Delta])-\[Pi]/2];
ff=xi U3D[2\[Phi]]+zi {0,0,1};
ee=ff + wi U3D[2\[Phi]-\[Pi]/2];
dd=ee+ti U3D[\[Pi]/2+2\[Delta]];
(* parameters *)
vixi Sec[\[Phi]-\[Delta]]Sin[\[Delta]]Sec[\[Phi]-2\[Delta]];
si=(ri Tan[\[Phi]]-wi)ui ((1-\[Rho])/2)-v;
ti=(ri Tan[\[Phi]]-wi)ui ((1+\[Rho])/2)-v;
(* distance condition *)
soln=Solve[Mag2[cc-dd]==Mag2[c-d],ui];
LeafCount[soln]]//ShowExample
PotPanels::usage="PotPanels is an option to MakeRectangularPot that specifies the number of panel to use when creating a partial pot.";
Options[MakeRectangularPot]={
PotPanels->Automatic
};
MakeRectangularPot[pts_List, m_,\[Rho]_,opts___]:=Module[{m0,tobjw,verts3d,pwjv,tbl,di,gs,tobj},
m0=PotPanels/.{opts}/.Options[MakeRectangularPot];
If[m0===Automatic,m0=m];
tobjw=MakeRectangularPotWedge[pts,m,\[Rho],opts];
{verts3d,pwjv}=GetValues[tobjw,{Vertices3D,PotWedgeJoinVertices}];
(* we need 3 points along each edge to match up, and for best accuracy, the third point should be as far off of the line between the first two as possible. So, we make a table of all of the points along the bottom edge and sort them by distance from the line between the two corners. *)
tbl=Table[{di,PointLineDistance[verts3d[[pwjv[[1,di]]]],{verts3d[[pwjv[[1,1]]]],verts3d[[pwjv[[1,-1]]]]}]},{di,1,Length[pwjv[[1]]]}];
di=Sort[tbl,#1[[2]]<#2[[2]]&][[-1,1]];
(* Now build the list of graphspecs for joining sequentially *)
gs=Table[{tobjw,{i-1,{pwjv[[2,1]],pwjv[[2,-1]],pwjv[[2,di]]},{pwjv[[1,1]],pwjv[[1,-1]],pwjv[[1,di]]}}},{i,m0}];
JoinGraph3DAssigneds[gs,opts]//AddTPlaneGraph]
Module[{pts,m,\[Rho],tobj},
pts={{0,0},{1,1},{1,2},{1,3},{2,4}}//N;
m=5;
\[Rho]=0;
tobj=MakeRectangularPot[pts,m,\[Rho],PotGapHalfAngle->0,TypeMinimumAngle->10\[Degree]];
GraphicsRow[{
CreasePatternGraphics[tobj]/.OrigamiStyle[CreaseColor->LightGray],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[ShowUnfolded->False]}]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts=Table[{0.5Sin[\[Theta]],Cos[\[Theta]]-1},{\[Theta],0,\[Pi],\[Pi]/20}]//N;
m=4;
\[Rho]=0;
tobj=MakeRectangularPot[pts,m,\[Rho],PotFlangeExcess->0.5,TypeMinimumAngle->30\[Degree]];
GraphicsRow[{
CreasePatternGraphics[tobj]/.OrigamiStyle[CreaseColor->LightGray],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[ShowUnfolded->False]}]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts=Table[{0.5Sin[\[Theta]],Cos[\[Theta]]-1},{\[Theta],0,\[Pi],\[Pi]/20}]//N;
m=4;
\[Rho]=0.3333;
tobj=MakeRectangularPot[pts,m,\[Rho],PotFlangeExcess->0.5,TypeMinimumAngle->30\[Degree]];
GraphicsRow[{
CreasePatternGraphics[tobj]/.OrigamiStyle[CreaseColor->LightGray],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[ShowUnfolded->False]}]
]//ShowExample
Module[{pts,m,\[Rho],tobj},
pts=Table[{0.5Sin[\[Theta]],-(Cos[\[Theta]]-1)},{\[Theta],0,2\[Pi]/3,\[Pi]/6}]//N;
m=8;
\[Rho]=-1;
tobj=MakeRectangularPot[pts,m,\[Rho],PotFlatFlangeInset->.1,PotPanels->m-1];
GraphicsRow[{
CreasePatternGraphics[tobj]/.OrigamiStyle[CreaseColor->LightGray],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[ShowUnfolded->False]}]
]//ShowExample
PotTrimmed::usage="PotTrimmed is an option to MakeTwistedPot that specifies that the corners of the flanges should be trimmed off.";
PotFlatFlanges::usage="PotFlatFlanges is an option to MakeTwistedPot that specifies whether the flanges should be faceted or smooth.";
PotFlatFlangesFaceted::usage="PotFlatFlangesFaceted is the value of option PotFlatFlanges that specifies to try to solve for vertices on the facets that make them folded.";
PotFlatFlangesSmooth::usage="PotFlatFlangesSmooth is the value of option PotFlatFlanges that specifies to let the flanges be smooth.";
MakeTwistedPot::badrho="`1` should be \[PlusMinus]1.";
MakeTwistedPot::badtau="`1` should be \[PlusMinus]1.";
MakeTwistedPot::badbord="Option PotBorder\[Rule]`1` should be either PotPlanar or PotTrimmed.";
MakeTwistedPot::notflat="Cross section `1` does not have equal z-coordinates for the first two points.";
MakeTwistedPot::badpts="Cross section `1` is not strictly monotonic in z.";
MakeTwistedPot::noqsoln="MakeTwistedPot was unable to find a quad solution at level `1`.";
MakeTwistedPot::nofsoln="MakeTwistedPot was unable to find a flange solution at level `1`.";
Options[MakeTwistedPot]={
PotFlatFlanges->PotFlatFlangesFaceted,
PotFlatFlangeInset->0,
PotBorder->PotPlanar
};
MakeTwistedPot::nofsoln="MakeTwistedPot was unable to find a flange solution at level `1`.";
MakeTwistedPot[pts_List,m_,\[Rho]_,\[Tau]_, \[Zeta]_,opts___]:=Module[{pff,\[Epsilon],pb,pt,\[Phi],nn,pts1,x,z,w,rg,R2,R2p,R2m,R3,R3p,R3m,rfl,p,pp,q,qq,r,rr,\[Xi],v\[Xi],vp,vpp,vr,vrr,vr0,rx,ry,dv,dp,dm,dh,eqns,soln,fn,vq,vqq,vq0,vqq0,t,tx,ty,tz,eqns1 ,vars,fom,cp,ff,ifc,addifc,cc,
verts,edges,types,verts3d,foldangles,ev,addv,addet,vi,ei,tobj},
If[!(\[Rho]==1||\[Rho]==-1),Message[MakeTwistedPot::badrho,\[Rho]];Abort[]];
If[!(\[Tau]==1||\[Tau]==-1),Message[MakeTwistedPot::badtau,\[Tau]];Abort[]];
pff=(PotFlatFlanges/.{opts}/.Options[MakeTwistedPot])===PotFlatFlangesFaceted;
\[Epsilon]=PotFlatFlangeInset/.{opts}/.Options[MakeTwistedPot];
pb=PotBorder/.{opts}/.Options[MakeTwistedPot];
pt=Switch[pb,
PotTrimmed,True,
PotPlanar,False,
_,Message[MakeTwistedPot::badbord,pb];Abort[]];
\[Phi]=\[Pi]/m;
nn=Length[pts];
pts1=#-pts[[1]]&/@pts//N;
{x,z}=Transpose[pts1];
(* test for flat-bottom condition *)
If[z[[1]]!=z[[2]],Message[MakeTwistedPot::notflat,pts];Abort[]];
(* test for strict monotonicity in z. *)
Module[{zinc = Drop[RotateLeft[z]-z,-1]},
If[zinc[[1]]==0,zinc=Drop[zinc,1]];
If[Length[Union[Sign/@zinc]]>1,Message[MakeTwistedPot::badpts,pts];Abort[]]];
w=Tan[\[Phi]]x;(* gore half-width *)
(* rg is cumulative distance along ctr of gore *)
rg=Prepend[Accumulate[Mag/@(Drop[pts,1]-Drop[pts,-1])],0];
(* Assorted useful rotation stuff *)
R2[j_]:=RotationMatrix2D[2j \[Phi]]//N;
R2p=R2[1];R2m=R2[-1];
R3[j_]:=RotationZMatrix3D[2j \[Phi]]//N;
R3p=R3[1];R3m=R3[-1];
rfl=U[\[Phi]+\[Zeta]]//N;(* direction vector for straight flange fold *)
(*
Solve for the gore points (p, pp, r, rr) by forcing isometry. We choose which diagonal of the quad to force isometric based on \[Tau].
*)
p=q=r={{0,0}};(* center of cp *)
pp=qq=rr={{0,0,0}};(* center of ff *)
\[Xi]={0,0};
(* corner of base *)
(AppendTo[p,#];AppendTo[q,#];AppendTo[r,#])&@{x[[2]],w[[2]]};
(AppendTo[pp,#];AppendTo[qq,#];AppendTo[rr,#])&@{x[[2]],w[[2]],0};
(* For subsequent r- and p-points, solve isometry conditions *)
Do[
vr={rx,ry}; (* next r-point, parameterized on rx, ry *)
vp=Reflect2D[vr,{r[[2]],r[[2]]+rfl}];(* next p-point *)
vrr=vpp=RotationZMatrix3D[v\[Xi]] . {x[[i]],w[[i]],z[[i]]}; (* twisted 3D vertices coincide *)
(* isometry conditions *)
dv=Mag[vr-r[[-1]]]-Mag[vrr-rr[[-1]]];(* radial fold *)
dp=Mag[vr-R2p . p[[-1]]]-Mag[vrr-R3p . pp[[-1]]];(* uphill diagonal *)
dm=Mag[R2p . vp-r[[-1]]]-Mag[R3p . vpp-rr[[-1]]];(* downhill diagonal *)
dh=Mag[vr-R2p . vp]-Mag[vrr-R3p . vpp];(* axial fold *)
eqns={dv,If[\[Tau]==1,dm,dp] ,dh};
vr0=r[[i-1]]+0.1(rg[[i]]-rg[[i-1]])rfl;(* initial guess for next r-point *)
soln=FindRoot[eqns,{{rx,vr0[[1]]},{ry,vr0[[2]]},{v\[Xi],\[Xi][[i-1]]}}];
If[Plus@@Abs/@(eqns/.soln)>10^-6,Message[MakeTwistedPot::noqsoln,i];Abort[]];
Print["isometries at ",i,": ",Chop[{dv,dp,dm,dh}/.soln]]//Hold;
AppendTo[p,vp/.soln];
AppendTo[pp,vpp/.soln];
AppendTo[r,vr/.soln];
AppendTo[rr,vrr/.soln];
AppendTo[\[Xi],Mod[v\[Xi]/.soln,2\[Pi],-\[Pi]]];(* collect twist angle for cross sections *)
(* assign placeholders for the flange points, q and qq *)
AppendTo[q,LineInt2D[p[[2]],rfl,p[[i]],U[\[Pi]/2+\[Zeta]]]];
AppendTo[qq,pp[[i]]+Mag[q[[i]]-p[[i]]] NormalizeReal[If[\[Rho]==1,pp[[i]]-R3m . rr[[i]],rr[[i]]-R3p . pp[[i]]]]]; 
,{i,3,nn}];
(* 
Solve for the flange points (q, qq) with triangulated flange quadrilaterals and flange folds coplanar with gore cross section folds. Final flange triangle is coplanar with adjacent facet. Note that it's not always possible, in which case an error gets thrown.
*)
If[pff,Do[
vq=q[[i-1]]+t^2 rfl;
Module[{ux,uy,uz},
ux=NormalizeReal[{1,1,0}pp[[i]]];
uz={0,0,1};
uy=uz\[Cross]ux;
vqq=pp[[i]]+tx^2 ux+\[Rho] ty^2 uy];
eqns={
Mag[vq-q[[i-1]]]-Mag[vqq-qq[[i-1]]],
Mag[vq-p[[i]]]-Mag[vqq-pp[[i]]],
If[i!=nn,
Mag[vq-p[[i+1]]]-Mag[vqq-pp[[i+1]]],
If[\[Rho]==1,
TetrahedronSignedVolume[vqq,qq[[nn-1]],pp[[nn-1]],pp[[nn]]],
TetrahedronSignedVolume[vqq,qq[[nn-1]],rr[[nn-1]],rr[[nn]]]]]};
soln=FindRoot[eqns,{{t,.1},{tx,.1},{ty,.1}}];
Print[i,", ",Chop[eqns/.soln]]//Hold;
If[Plus@@Abs/@(eqns/.soln)>10^-6,Message[MakeTwistedPot::nofsoln,i];Abort[]];
q[[i]]=vq/.soln;
qq[[i]]=vqq/.soln;
,{i,3,nn}]];

(* cp and ff for debugging *)
If[False,
cp=Graphics[{
(* base *)
Style[Line[Table[R2[j] . r[[2]],{j,0,m}]],Orange],
(* radial folds *)
DupRotate2D[Style[Line[Drop[r,1]],If[\[Rho]==1,Red,Lighter[Red,.75]]],m],
DupRotate2D[Style[Line[Drop[If[pt,Drop[q,-1],q],1]],Green],m],
DupRotate2D[Style[Line[Drop[p,1]],If[\[Rho]==1,Lighter[Blue,.75],Blue]],m],
(* cross section folds, both quads and flanges *)
DupRotate2D[Table[Which[
i!=nn,Style[Line[{p[[i]],q[[i]],r[[i]],R2p . p[[i]]}],Orange],
i==nn&&!pt,Style[Line[{p[[i]],q[[i]],r[[i]],R2p . p[[i]]}],Black],
True,Style[Line[{r[[i]],R2p . p[[i]]}],Black]],{i,3,nn}],m],
(* quad diagonals *)
DupRotate2D[Table[Switch[\[Tau],
-1,Style[Line[{r[[i]],R2p . p[[i-1]]}],LightGray](* CW outward diagonal *),
+1,Style[Line[{r[[i-1]],R2p . p[[i]]}],LightGray](* CCW outward diagonal *),
_,{}],{i,3,nn}],m],
(* flange diagonals *)
DupRotate2D[Table[Which[
i==3,{},
i==nn&&pt,Style[Line[{p[[i]],q[[i-1]],r[[i]]}],Black],
True,Style[Line[{p[[i]],q[[i-1]],r[[i]]}],LightGray]
],{i,4,nn}],m],
{}}];
ff=Graphics3D[{
(* base *)
Style[Polygon[Table[R3[j] . rr[[2]],{j,0,m-1}]],Gray,Opacity[.5]],
(* gore quads *)
DupRotate3D[Table[Style[If[\[Tau]==-1,
{Polygon[{rr[[i]],R3p . pp[[i]],R3p . pp[[i-1]]}],Polygon[{rr[[i]],R3p . pp[[i-1]],rr[[i-1]]}]},
{Polygon[{rr[[i]],R3p . pp[[i]],rr[[i-1]]}],Polygon[{R3p . pp[[i]],R3p . pp[[i-1]],rr[[i-1]]}]}],LightGray,Opacity[0.75]],{i,3,nn}],m],
(* flange triangles *)
DupRotate3D[Table[
{If[!(i==nn&&pt),Style[Polygon[{qq[[i]],qq[[i-1]],pp[[i]]}],LightGray,Opacity[0.75]]],
If[i!=3,Style[Polygon[{qq[[i-1]],pp[[i-1]],pp[[i]]}],LightGray,Opacity[0.75]]]},{i,3,nn}],m],
(* base *)
Style[Line[Table[R3[ j] . rr[[2]],{j,0,m}]],Orange,Opacity[.75]],
(* radial folds *)
DupRotate3D[Style[Line[Drop[rr,1]],If[\[Rho]==1,Red,Lighter[Red,.75]]],m],
DupRotate3D[Style[Line[Drop[If[pt,Drop[qq,-1],qq],1]],Green],m],
DupRotate3D[Style[Line[Drop[pp,1]],If[\[Rho]==1,Lighter[Blue,.75],Blue]],m],
(* cross section folds, both quads and flanges *)
DupRotate3D[Table[If[i!=nn,
Style[Line[{pp[[i]],qq[[i]],rr[[i]],R3p . pp[[i]]}],Orange],
Style[If[pt,
Line[{pp[[i]],qq[[i-1]],rr[[i]],R3p . pp[[i]]}],
Line[{pp[[i]],qq[[i]],rr[[i]],R3p . pp[[i]]}]],Black]],{i,3,nn}],m],
(* quad diagonals *)
DupRotate3D[Table[Switch[\[Tau],
-1,Style[Line[{rr[[i]],R3p . pp[[i-1]]}],Gray],
+1,Style[Line[{rr[[i-1]],R3p . pp[[i]]}],Gray],
_,{}],{i,3,nn}],m],
(* flange diagonals *)
DupRotate3D[Table[Which[
i==3,{},
i==nn&&pt,Style[Line[{pp[[i]],qq[[i-1]],rr[[i]]}],Black],
True,Style[Line[{pp[[i]],qq[[i-1]],rr[[i]]}],Gray]
],{i,4,nn}],m],
{}}];
Print[GraphicsColumn[{cp,ff}]]];

(* build the TObj containing CP and FF *)
If[\[Epsilon]!=0,
If[\[Rho]==1,
Do[rr[[i]]={1-\[Epsilon],1-\[Epsilon],1}rr[[i]],{i,3,nn}],
Do[pp[[i]]={1-\[Epsilon],1-\[Epsilon],1}pp[[i]],{i,3,nn}]]];
(* vertices *)
verts=verts3d={};
ev["r",i_]:=r[[i]];ev["q",i_]:=q[[i]];ev["p",i_]:=p[[i]];
ev["rr",i_]:=rr[[i]];ev["qq",i_]:=qq[[i]];ev["pp",i_]:=pp[[i]];
(* addv[a, i, j] creates verts, verts3d, and vi entries for the specified vector quantities. *)
addv[a_String,i_,j_]:=(
AppendTo[verts,RotationMatrix2D[2j \[Phi]] . ev[a,i]];
AppendTo[verts3d,RotationZMatrix3D[2j \[Phi]] . ev[a<>a,i]];
vi[a,i,j]=vi[a,i,j-m]=vi[a,i,j+m]=Length[verts]);
Do[
addv["r",2,j];
vi["q",2,j]:=vi["r",2,j];vi["p",2,j_]:=vi["r",2,j];
vi["qq",2,j]:=vi["rr",2,j];vi["pp",2,j_]:=vi["rr",2,j];
Do[addv["p",i,j],{i,3,nn}];
Do[addv["q",i,j],{i,3,If[pt,nn-1,nn]}];
Do[addv["r",i,j],{i,3,nn}];
,{j,0,m-1}];
(* edges and types *)
ifc={};(* indices of interior flange creases *)
addifc[]:=AppendTo[ifc,Length[edges]+1];(* note the index of an interior crease *)
cc=If[z[[-1]]>z[[1]],V,M];
edges=types={};
(* adde[i,j,t] adds an edge and type given distinct vertex indices *)
addet[i_,j_,t_]:=(
AppendTo[edges,{i,j}];
AppendTo[types,t]);
Do[
(* base *)
addet[vi["r",2,j-1],vi["p",2,j],cc];
Do[
(* lower flange diagonal *)
If[i>3,addet[vi["q",i-1,j-1],vi["r",i,j-1],If[i==nn&&pt,B,addifc[];U]]];
(* prev r radial fold *)
addet[vi["r",i-1,j-1],vi["r",i,j-1],U];
(* quad diagonals *)
If[\[Tau]==-1,
addet[vi["r",i,j-1],vi["p",i-1,j],U],
addet[vi["r",i-1,j-1],vi["p",i,j],U]];
(* p radial fold *)
addet[vi["p",i-1,j],vi["p",i,j],U];
(* upper flange diagonal *)
If[i>3,addet[vi["q",i-1,j],vi["p",i,j],If[i==nn&&pt,B,addifc[];U]]];
(* q radial fold *)
If[!(i==nn&&pt),addet[vi["q",i-1,j],vi["q",i,j],cc]];
(* lower flange cross section fold *)
If[!(i==nn&&pt),addet[vi["q",i,j-1],vi["r",i,j-1],If[i==nn,B,addifc[];U]]];
(* quad cross section fold *)
addet[vi["r",i,j-1],vi["p",i,j],If[i==nn,B,U]];
(* upper flange cross section fold *)
If[!(i==nn&&pt),addet[vi["p",i,j],vi["q",i,j],If[i==nn,B,addifc[];U]]];
,{i,3,nn}];
,{j,0,m-1}];
tobj = MakeTGraph3DAssigned[verts//N,edges,{},verts3d//N,{},types]//AddTPlaneGraph;
(* Fix up the fold angles and types *)
foldangles=EdgeFaceAngles3D[tobj]; (* compute all fold angles *)
If[!pff,(foldangles[[#]]=0)&/@ifc];(* maybe wipe out interior flange creases *)
Do[If[types[[i]]===U,types[[i]]=FoldAngleToType[foldangles[[i]],opts]],{i,Length[edges]}];
tobj//ReplaceProperties[{FoldAngles->foldangles,EdgeTypes->types}]
]
Module[{pts,m,\[Rho],\[Tau],\[Zeta],tobj},
pts={{0,0},{1,0},{1,.5},{1.5,1},{1,1.5},{1,2}};
m=12;
\[Rho]=1;
\[Tau]=1;
\[Zeta]=25\[Degree];
Print[PotCrossSectionGraphics[pts,Axes->True]];
tobj=MakeTwistedPot[pts,m,\[Rho],\[Tau],\[Zeta],PotFlatFlangeInset->0.05];
GraphicsColumn[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{pts,m,\[Rho],\[Tau],\[Zeta],tobj},
pts={{0,0},{1,0},{1,.5},{1.5,1},{1,1.5},{1,2}};
m=12;
\[Rho]=1;
\[Tau]=1;
\[Zeta]=25\[Degree];
Print[PotCrossSectionGraphics[pts,Axes->True]];
tobj=MakeTwistedPot[pts,m,\[Rho],\[Tau],\[Zeta],PotFlatFlanges->PotFlatFlangesSmooth,PotFlatFlangeInset->0.05,PotBorder->PotTrimmed];
GraphicsColumn[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{pts,m,\[Rho],\[Tau],\[Zeta],tobj},
pts={{0.`,0.`},{0.201973165620801`,0.`},{0.24551521390921868`,0.04929828350861052`},{0.29103491611100674`,0.09719117040644294`},{0.3388464527060197`,0.14962845353074342`},{0.3844362844792038`,0.20295497962034656`},{0.42712836236230056`,0.2575101758008096`},{0.4701991399309364`,0.31986097513766437`},{0.5030814933671452`,0.37584120420889644`}};
m=6;
\[Rho]=1;
\[Tau]=1;
\[Zeta]=-8\[Degree];
Print[PotCrossSectionGraphics[pts,Axes->True]];
tobj=MakeTwistedPot[pts,m,\[Rho],\[Tau],\[Zeta],PotBorder->PotPlanar,PotFlatFlangeInset->0.05];
GraphicsColumn[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{verts,edges,types,tobj,cp,ff},
verts={{0,0},{1,0},{1,1},{0,1},{3/2,-1/4},{3/2,5/4}};
edges={{1,2},{2,3},{3,4},{4,1},{2,5},{5,6},{6,3}};
types={B,V,B,B,B,B,B};
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTAssigned[types]//FoldGraph2DAll;
cp=CreasePatternGraphics[tobj];
ff=VisibleFoldedFormGraphics[tobj];
GraphicsGrid[{
{GraphGraphics[tobj],Graph2DGraphics[tobj]},
{cp,ff}/.OrigamiStyle[]}]
]//ShowExample
TDisplayPair::usage="TDisplayPair is a TObj class that represents anything that possesses a crease pattern and a folded form.";
RegisterTClass[TDisplayPair];
CreasePattern::usage="CreasePattern is a TObj property that specifies a Graphics object that displays a crease pattern.";
FoldedForm2D::usage="FoldedForm2D is a TObj property that specifies a Graphics or Graphics3D object that displays the folded form.";
AddTDisplayPairTo[tobj_TObj,cp_Graphics,ff_Graphics|ff_Graphics3D]:=AddClassTo[tobj,TDisplayPair,{CreasePattern->cp,FoldedForm2D->ff}]
AddTDisplayPair[cp_Graphics,ff_Graphics|ff_Graphics3D]:=AddTDisplayPairTo[#,cp,ff]&
MakeTDisplayPair[cp_Graphics,ff_Graphics|ff_Graphics3D]:=MakeTObj[TDisplayPair,{CreasePattern->cp,FoldedForm2D->ff}]
Module[{verts,edges,types,tobjcp,tobjff,cp,ff,tobj},
verts={{0,0},{1,0},{1,1},{0,1},{3/2,-1/4},{3/2,5/4}};
edges={{1,2},{2,3},{3,4},{4,1},{2,5},{5,6},{6,3}};
types={B,V,B,B,B,B,B};
tobjcp=MakeTGraph[verts,edges]//AddTAssigned[types]//AddTPlaneGraph;
tobjff=FoldGraph2DAll[tobjcp];
cp=CreasePatternGraphics[tobjcp];
ff=VisibleFoldedFormGraphics[tobjff];
(* Build with the constructor *)
tobj=MakeTDisplayPair[cp,ff];
GraphicsRow[{tobj[CreasePattern],tobj[FoldedForm2D]}/.OrigamiStyle[]]
]//ShowExample
TRotationalPot::usage="TRotationalPot is a TObj class that describes a rotationally symmetric pot.";
RegisterTClass[TRotationalPot,{TDisplayPair}];
CrossSection::usage="CrossSection is a TObj property that specifies the cross section of the pot.";
CreasePatternWedge::usage="CreasePatternWedge is a TObj property that specifies a single wedge of the crease pattern.";
CreasePatternSplitWedge::usage="CreasePatternSplitWedge is a TObj property that specifies a single wedge of the crease pattern created by splitting each panel in half.";
FoldedFormWedge::usage="FoldedFormWedge is a TObj property that specifies a single wedge of the folded form.";
FoldedFormSplitWedge::usage="FoldedFormSplitWedge is a TObj property that specifies a single wedge of the folded form created by splitting each panel in half.";
CreasePatternBoundary::usage="CreasePatternBoundary is an option to MakeUniPot that specifies the shape of boundary to put on the crease pattern.";
FoldedFormGapSize::usage="FoldedFormGapSize is an option to MakeUniPot that specifies the size of the flange gap to use in the folded form";
Options[MakeUniPot]={
MinimumAngle->10.\[Degree],
CreasePatternBoundary->Default,
CircleDivisions->10,
FoldedFormGapSize->0.05
};
MakeUniPot[pts_,m_,opts___]:=Module[{mb,cb,cd,gs,\[Phi],sf,cf,tf,sh,ps,fb,cs,xt,\[Zeta],wt,wr,rt,vt,st,dl,an,fbfn, a2,b2,c2,d2,e2,f2,g2,cpw,cpsw,cp,a3,b3,c3,d3,e3,f3,g3,pfn,ffw,ffsw,ff},
mb=MinimumAngle/.{opts}/.Options[MakeUniPot];
cb=CreasePatternBoundary/.{opts}/.Options[MakeUniPot];
cd=CircleDivisions/.{opts}/.Options[MakeUniPot];
gs = FoldedFormGapSize/.{opts}/.Options[MakeUniPot];
(* setup *)
\[Phi]=N[\[Pi]/m];
sf=Sin[\[Phi]];cf=Cos[\[Phi]];tf=sf/cf;
ps = #-pts[[1]]&/@pts;(* shift points to origin *)
fb=(ps[[1,2]]==ps[[2,2]]);(* True if base is flat *)
{xt,\[Zeta]}=Transpose[ps];
wt=tf xt;(* half-width of each panel *)
wr=(1-gs)wt;(* reduced half-width of each panel *)
rt=FoldList[Plus,0,Drop[Mag/@(RotateLeft[ps]-ps),-1]];(* x coord of panel in CP *)
vt=tf rt;(* full half-width of wedge in CP *)
st=vt-wt;(* width of flange *)
dl=NormalizeReal/@N[Drop[RotateLeft[ps]-ps,-1]];(* directions of each panel *)
an=Join[{0},Drop[MapThread[ArcTan[#1 . #2,Cross[#1] . #2]&,{dl,RotateLeft[dl]}],-1],{0}];(* fold angle *)
fbfn=If[fb,DropFirst[#],#]&;(*drop first item of a list if bottom is flat*)
(* CROSS SECTION *)
cs=Graphics[{Line[ps],Line[{-1,1}*#&/@ps]},FilterRules[{opts},Options[Graphics]]];

(* CREASE PATTERN *)
a2=Transpose[{rt,-vt}];
b2=Transpose[{rt,-wt}];
c2={#,0}&/@rt;
d2=Transpose[{rt,+wt}];
e2=Transpose[{rt,+vt}];
f2=RotationMatrix2D[2 \[Phi]] . #&/@b2;
g2=RotationMatrix2D[2 \[Phi]] . #&/@c2;
cpw=Graphics[{
Style[Line[fbfn[a2]],ValleyLine],
Style[Line[fbfn[d2]],MountainLine],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{a2,d2,an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{d2,e2,-an}],
Style[Which[cb===Circle,Line[Table[rt[[-1]]U[2 i \[Phi]/cd],{i,-cd/2,cd/2}]],
True,Line[{a2[[-1]],e2[[-1]]}]],BorderLine]
},FilterRules[{opts},Options[Graphics]]];
cpsw=Graphics[{
Style[Line[fbfn[e2]],ValleyLine],
Style[Line[fbfn[d2]],MountainLine],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{c2,d2,an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{d2,e2,-an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{e2,g2,an}],
Style[Which[cb===Circle,Line[Table[rt[[-1]]U[2 i \[Phi]/cd],{i,0,cd}]],
True,Line[{c2[[-1]],e2[[-1]],g2[[-1]]}]],BorderLine]
},FilterRules[{opts},Options[Graphics]]];
cp=Graphics[Table[Rotate2D[cpw[[1]],2 i \[Phi]],{i,0,m-1}],FilterRules[{opts},Options[Graphics]]];

(* FOLDED FORM *)
a3=Transpose[{xt,-vt,\[Zeta]}];
b3=Transpose[{xt,-wt,\[Zeta]}];
c3={#[[1]],0,#[[2]]}&/@ps;
d3=Transpose[{xt,wr,\[Zeta]}];
e3=Transpose[{xt,wt,\[Zeta]}]+(U3D[-\[Pi]/2+2\[Phi]]*#&)/@st;
f3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@b3;
g3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@c3;
pfn=Style[Polygon/@Drop[Transpose[{#2,#1,RotateLeft[#1],RotateLeft[#2]}],-1],Paper3DFill]&;
ffw=Graphics3D[{
pfn[a3,d3],(* flange frontside + panel *)
pfn[d3,e3],(* flange backside *)
Style[Line[fbfn[a3]],FoldedLine],
Style[Line[fbfn[d3]],FoldedLine],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{a3,d3,an}],
Style[Line[{a3[[-1]],d3[[-1]],e3[[-1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics3D]]];
ffsw=Graphics3D[{
pfn[c3,d3],(* semi-panel *)
pfn[d3,e3],(* flange backside *)
pfn[e3,g3],(* flange frontside + other semi-panel *)
Style[Line[fbfn[e3]],FoldedLine],
Style[Line[fbfn[d3]],FoldedLine],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{c3,d3,an}],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{d3,e3,-an}],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{e3,g3,an}],
Style[Line[{c3[[-1]],d3[[-1]],e3[[-1]],g3[[-1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics3D]]];
ff=Graphics3D[Table[RotateZ3D[ffw[[1]],2i \[Phi]],{i,0,m-1}],FilterRules[{opts},Options[Graphics3D]]];
MakeTDisplayPair[cp,ff]//AddClass[TRotationalPot,{CrossSection->cs,CreasePatternWedge->cpw,CreasePatternSplitWedge->cpsw,FoldedFormWedge->ffw,FoldedFormSplitWedge->ffsw}]]
Module[{pts,tobj},
pts={{0,0},{1,1},{1,2},{1,3},{2,4}};
tobj=MakeUniPot[pts,8,CreasePatternBoundary->Default];
PartitionedGraphicsGrid[{
Graphics[tobj[CrossSection][[1]],Axes->True,AxesLabel->{"x","z"},PlotLabel->"CrossSection"],
Graphics[tobj[CreasePatternWedge][[1]],PlotLabel->"CreasePatternWedge"],
Graphics3D[tobj[FoldedFormWedge][[1]],PlotLabel->"FoldedFormWedge"],
Graphics[tobj[CreasePatternSplitWedge][[1]],PlotLabel->"CreasePatternSplitWedge"],
Graphics3D[tobj[FoldedFormSplitWedge][[1]],PlotLabel->"FoldedFormSplitWedge"],
Graphics[tobj[CreasePattern][[1]],PlotLabel->"CreasePattern"],
Graphics3D[tobj[FoldedForm2D][[1]],PlotLabel->"FoldedForm2D"]},5]/.OrigamiStyle[]
]//ShowExample
Options[MakeMoselyPot]={
MinimumAngle->10.\[Degree],
CreasePatternBoundary->Default,
CircleDivisions->10,
FoldedFormGapSize->0.05
};
MakeMoselyPot[pts_,m_,opts___]:=Module[{mb,cb,cd,gs,\[Phi],sf,cf,tf,sh,ps,fb,cs,xt,\[Zeta],wt,wr,rt,vt,st,dl,an,fbfn,a2,b2,c2,d2,e2,f2,g2,h2,i2,j2,k2,cpw,cpsw,cp,a3,b3,c3,d3,e3,f3,g3,h3,i3,j3,k3,pfn,ffw,ffsw,ff},mb=MinimumAngle/.{opts}/.Options[MakeMoselyPot];
cb=CreasePatternBoundary/.{opts}/.Options[MakeMoselyPot];
cd=CircleDivisions/.{opts}/.Options[MakeMoselyPot];
gs=FoldedFormGapSize/.{opts}/.Options[MakeMoselyPot];
(*setup*)
\[Phi]=N[\[Pi]/m];
sf=Sin[\[Phi]];cf=Cos[\[Phi]];tf=sf/cf;
ps=#-pts[[1]]&/@pts;(*shift points to origin*)
fb=(ps[[1,2]]==ps[[2,2]]);(*True if base is flat*)
{xt,\[Zeta]}=Transpose[ps];
wt=tf xt;(*half-width of each panel*)
wr=(1-gs) wt;(*reduced half-width of each panel*)
rt=FoldList[Plus,0,Drop[Mag/@(RotateLeft[ps]-ps),-1]];(*x coord of panel in CP*)
vt=tf rt;(*full half-width of wedge in CP*)
st=(vt-wt)/2;(*half width of space for flange*)
dl=NormalizeReal/@N[Drop[RotateLeft[ps]-ps,-1]];(*directions of each panel*)
an=Join[{0},Drop[MapThread[ArcTan[#1 . #2,Cross[#1] . #2]&,{dl,RotateLeft[dl]}],-1],{0}];(*fold angle*)
fbfn=If[fb,DropFirst[#],#]&;(*drop first item of a list if bottom is flat*)

(*CROSS SECTION*)
cs=Graphics[{Line[ps],Line[{-1,1}*#&/@ps]},FilterRules[{opts},Options[Graphics]]];

(*CREASE PATTERN*)
b2=Transpose[{rt,-vt}];
d2=Transpose[{rt,-wt}];
c2=(b2+d2)/2;
e2={#,0}&/@rt;
f2=Transpose[{rt,+wt}];
h2=Transpose[{rt,+vt}];
g2=(f2+h2)/2;
a2=RotationMatrix2D[-2 \[Phi]] . #&/@g2;
h2=RotationMatrix2D[2 \[Phi]] . #&/@b2;
i2=RotationMatrix2D[2 \[Phi]] . #&/@c2;
j2=RotationMatrix2D[2 \[Phi]] . #&/@d2;
k2=RotationMatrix2D[2 \[Phi]] . #&/@e2;
cpw=Graphics[{
Style[Line[fbfn[c2]],ValleyLine],
Style[Line[fbfn[d2]],MountainLine],
Style[Line[fbfn[f2]],MountainLine],
Style[Line[fbfn[g2]],ValleyLine],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{a2,c2,an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{c2,d2,-an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{d2,f2,an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{f2,g2,-an}],
Style[Which[
cb===Circle,Line[Table[rt[[-1]] U[2 i \[Phi]/cd],{i,-cd/2,cd/2}]],
cb===Closed,Line[{b2[[-1]],h2[[-1]]}],
True,Line[{a2[[-1]],c2[[-1]],g2[[-1]]}]],BorderLine]},FilterRules[{opts},Options[Graphics]]];
cpsw=Graphics[{
Style[Line[fbfn[f2]],MountainLine],
Style[Line[fbfn[g2]],ValleyLine],
Style[Line[fbfn[i2]],ValleyLine],
Style[Line[fbfn[j2]],MountainLine],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{e2,f2,an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{f2,g2,-an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{g2,i2,an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{i2,j2,-an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{j2,k2,an}],
Style[Which[
cb===Circle,Line[Table[rt[[-1]] U[2 i \[Phi]/cd],{i,0,cd}]],
cb===Closed,Line[{e2[[-1]],h2[[-1]],k2[[-1]]}],
True,Line[{e2[[-1]],g2[[-1]],i2[[-1]],k2[[-1]]}]],BorderLine]},FilterRules[{opts},Options[Graphics]]];
cp=Graphics[Table[Rotate2D[cpw[[1]],2 i \[Phi]],{i,0,m-1}],FilterRules[{opts},Options[Graphics]]];
(*FOLDED FORM*)
a3=Transpose[{xt,-wt,\[Zeta]}]+(U3D[-\[Pi]/2]*#&)/@st;
c3=Transpose[{xt,-wt,\[Zeta]}]+(U3D[\[Pi]/2-2 \[Phi]]*#&)/@st;
d3=Transpose[{xt,-wr,\[Zeta]}];
e3={#[[1]],0,#[[2]]}&/@ps;
f3=Transpose[{xt,wr,\[Zeta]}];
g3=Transpose[{xt,wt,\[Zeta]}]+(U3D[-\[Pi]/2+2 \[Phi]]*#&)/@st;
i3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@c3;
j3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@d3;
k3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@e3;
pfn=Style[Polygon/@Drop[Transpose[{#2,#1,RotateLeft[#1],RotateLeft[#2]}],-1],Paper3DFill]&;
ffw=Graphics3D[{
pfn[a3,c3],(*flange face*)
pfn[c3,d3],(*flange side*)
pfn[d3,f3],(*panel*)
pfn[f3,g3],(*flange side*)
Style[Line[fbfn[a3]],FoldedLine],
Style[Line[fbfn[c3]],FoldedLine],
Style[Line[fbfn[d3]],FoldedLine],
Style[Line[fbfn[f3]],FoldedLine],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{a3,c3,an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{c3,d3,-an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{d3,f3,an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{f3,g3,-an}],Style[Line[{a3[[-1]],c3[[-1]],d3[[-1]],f3[[-1]],g3[[-1]]}],BorderLine]},FilterRules[{opts},Options[Graphics3D]]];
ffsw=Graphics3D[{
pfn[e3,f3],(*semi-panel*)
pfn[f3,g3],(*flange side*)
pfn[g3,i3],(*flange face*)
pfn[i3,j3],(*flange side*)
pfn[j3,k3],(*semi-panel*)
Style[Line[fbfn[f3]],FoldedLine],
Style[Line[fbfn[g3]],FoldedLine],
Style[Line[fbfn[i3]],FoldedLine],
Style[Line[fbfn[j3]],FoldedLine],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{e3,f3,an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{f3,g3,-an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{g3,i3,an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{i3,j3,-an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{j3,k3,an}],Style[Line[{e3[[-1]],f3[[-1]],g3[[-1]],i3[[-1]],j3[[-1]],k3[[-1]]}],BorderLine]},FilterRules[{opts},Options[Graphics3D]]];
ff=Graphics3D[Table[RotateZ3D[ffw[[1]],2 i \[Phi]],{i,0,m-1}],FilterRules[{opts},Options[Graphics3D]]];
MakeTDisplayPair[cp,ff]//AddClass[TRotationalPot,{CrossSection->cs,CreasePatternWedge->cpw,CreasePatternSplitWedge->cpsw,FoldedFormWedge->ffw,FoldedFormSplitWedge->ffsw}]]
Module[{pts,tobj},
pts={{0,0},{1,1},{1,2},{2,3}};
tobj=MakeMoselyPot[pts,8,CreasePatternBoundary->Default];
PartitionedGraphicsGrid[{
Graphics[tobj[CrossSection][[1]],Axes->True,AxesLabel->{"x","z"}],
tobj[CreasePatternWedge],
tobj[FoldedFormWedge],
tobj[CreasePatternSplitWedge],
tobj[FoldedFormSplitWedge],
tobj[CreasePattern],
tobj[FoldedForm2D]},5]/.OrigamiStyle[]
]//ShowExample
FlangeExcess::usage="FlangeExcess is an option to MakeRectUniPot that specifies the extra flange width to add relative to the widest panel.";
Options[MakeRectUniPot]={
MinimumAngle->10.\[Degree],
FlangeExcess->0.05,
FoldedFormGapSize->0.05
};
MakeRectUniPot[pts_,m_,opts___]:=Module[{mb,fe,gs,\[Phi],sf,cf,tf,nn,ps,cs,xt,\[Zeta],wt,wr,rt,hw,vt,st,dl,an, a2,b2,c2,d2,e2,f2,g2,cpw,cpsw,cp,a3,b3,c3,d3,e3,f3,g3,pfn,ffw,ffsw,ff},
mb=MinimumAngle/.{opts}/.Options[MakeRectUniPot];
fe=FlangeExcess/.{opts}/.Options[MakeRectUniPot];
gs = FoldedFormGapSize/.{opts}/.Options[MakeRectUniPot];
(* setup *)
\[Phi]=N[\[Pi]/m];
sf=Sin[\[Phi]];cf=Cos[\[Phi]];tf=sf/cf;
nn=Length[pts];
ps = #-pts[[1]]&/@pts;(* shift points to origin *)
{xt,\[Zeta]}=Transpose[ps];(* x and z coordinates of cross section *)
wt=tf xt;(* half-width of each panel *)
wr=(1-gs)wt;(* reduced half-width of each panel *)
rt=FoldList[Plus,0,Drop[Mag/@(RotateLeft[ps]-ps),-1]];(* x coord of panel in CP *)
hw=Max[wt](1+fe);(* half-width of rectangle *)
vt=Table[hw,{nn}];(* full half-width of (rectangular) wedge in CP *)
st=vt-wt;(* width of flange *)
dl=NormalizeReal/@N[Drop[RotateLeft[ps]-ps,-1]];(* directions of each panel *)
an=Join[{0},Drop[MapThread[ArcTan[#1 . #2,Cross[#1] . #2]&,{dl,RotateLeft[dl]}],-1],{0}];(* fold angle *)
(* CROSS SECTION *)
cs=Graphics[{Line[ps],Line[{-1,1}*#&/@ps]},FilterRules[{opts},Options[Graphics]]];
(* CREASE PATTERN *)
a2=Transpose[{rt,-vt}];
b2=Transpose[{rt,-wt}];
c2={#,0}&/@rt;
d2=Transpose[{rt,+wt}];
e2=Transpose[{rt,+vt}];
f2={0,2hw}+#&/@b2;
g2={0,2hw}+#&/@c2;
cpw=Graphics[{
Style[Line[a2],ValleyLine],
Style[Line[d2],MountainLine],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{a2,d2,an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{d2,e2,-an}],
Style[Line[{a2[[-1]],e2[[-1]]}],BorderLine],
Style[Line[{a2[[1]],e2[[1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics]]];
cpsw=Graphics[{
Style[Line[e2],ValleyLine],
Style[Line[d2],MountainLine],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{c2,d2,an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{d2,e2,-an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{e2,g2,an}],
Style[Line[{c2[[-1]],g2[[-1]]}],BorderLine],
Style[Line[{c2[[1]],g2[[1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics]]];
cp=Graphics[Table[Translate2D[cpw[[1]],{0,2hw i}],{i,0,m-1}],FilterRules[{opts},Options[Graphics]]];
(* FOLDED FORM *)
a3=Transpose[{xt,-vt,\[Zeta]}];
b3=Transpose[{xt,-wt,\[Zeta]}];
c3={#[[1]],0,#[[2]]}&/@ps;
d3=Transpose[{xt,wr,\[Zeta]}];
e3=Transpose[{xt,wt,\[Zeta]}]+(U3D[-\[Pi]/2+2\[Phi]]*#&)/@st;
f3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@b3;
g3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@c3;
pfn=Style[Polygon/@Drop[Transpose[{#2,#1,RotateLeft[#1],RotateLeft[#2]}],-1],Paper3DFill]&;
ffw=Graphics3D[{
pfn[a3,d3],(* flange frontside + panel *)
pfn[d3,e3],(* flange backside *)
Style[Line[a3],FoldedLine],
Style[Line[d3],FoldedLine],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{a3,d3,an}],
Style[Line[{a3[[-1]],d3[[-1]],e3[[-1]]}],BorderLine],
Style[Line[{a3[[1]],d3[[1]],e3[[1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics3D]]];
ffsw=Graphics3D[{
pfn[c3,d3],(* semi-panel *)
pfn[d3,e3],(* flange backside *)
pfn[e3,g3],(* flange frontside + other semi-panel *)
Style[Line[e3],FoldedLine],
Style[Line[d3],FoldedLine],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{c3,d3,an}],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{d3,e3,-an}],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{e3,g3,an}],
Style[Line[{c3[[-1]],d3[[-1]],e3[[-1]],g3[[-1]]}],BorderLine],
Style[Line[{c3[[1]],d3[[1]],e3[[1]],g3[[1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics3D]]];
ff=Graphics3D[Table[RotateZ3D[ffw[[1]],2i \[Phi]],{i,0,m-1}],FilterRules[{opts},Options[Graphics3D]]];
MakeTDisplayPair[cp,ff]//AddClass[TRotationalPot,{CrossSection->cs,CreasePatternWedge->cpw,CreasePatternSplitWedge->cpsw,FoldedFormWedge->ffw,FoldedFormSplitWedge->ffsw}]]
Module[{pts,tobj},
pts={{0,0},{1,1},{1,2},{2,3}};
tobj=MakeRectUniPot[pts,8,FlangeExcess->0.3];
PartitionedGraphicsGrid[{
Graphics[tobj[CrossSection][[1]],Axes->True,AxesLabel->{"x","z"}],
tobj[CreasePatternWedge],
tobj[FoldedFormWedge],
tobj[CreasePatternSplitWedge],
tobj[FoldedFormSplitWedge],
tobj[CreasePattern],
tobj[FoldedForm2D]},5]/.OrigamiStyle[]
]//ShowExample
Options[MakeRectMoselyPot]={
FlangeExcess->0.05,
FoldedFormGapSize->0.05
};
MakeRectMoselyPot[pts_,m_,opts___]:=Module[{mb,fe,gs,\[Phi],sf,cf,tf,nn,ps,fb,cs,xt,\[Zeta],wt,wr,rt,hw,vt,stc,sth,dl,an,a2,b2,c2,d2,e2,f2,g2,h2,i2,j2,k2,cpw,cpsw,cp,a3,b3,c3,d3,e3,f3,g3,h3,i3,j3,k3,pfn,ffw,ffsw,ff},mb=MinimumAngle/.{opts}/.Options[MakeRectMoselyPot];
fe=FlangeExcess/.{opts}/.Options[MakeRectMoselyPot];
gs=FoldedFormGapSize/.{opts}/.Options[MakeRectMoselyPot];
(*setup*)
\[Phi]=N[\[Pi]/m];
sf=Sin[\[Phi]];cf=Cos[\[Phi]];tf=sf/cf;
nn=Length[pts];
ps=#-pts[[1]]&/@pts;(*shift points to origin*)
fb=(ps[[1,2]]==ps[[2,2]]);(*True if base is flat*)
{xt,\[Zeta]}=Transpose[ps];
wt=tf xt;(*half-width of each panel*)
wr=(1-gs) wt;(*reduced half-width of each panel*)
rt=FoldList[Plus,0,Drop[Mag/@(RotateLeft[ps]-ps),-1]];(*x coord of panel in CP*)
hw=Max[wt](1+fe);(* half-width of rectangle *)
vt=Table[hw,{nn}];(*full half-width of wedge in CP*)
sth=(vt-wt)/(1+cf);(*length of side of flange in FF*)
stc=cf sth;(* half-width of face of flange in FF *)
dl=NormalizeReal/@N[Drop[RotateLeft[ps]-ps,-1]];(*directions of each panel*)
an=Join[{0},Drop[MapThread[ArcTan[#1 . #2,Cross[#1] . #2]&,{dl,RotateLeft[dl]}],-1],{0}];(*fold angle*)(*CROSS SECTION*)
cs=Graphics[{Line[ps],Line[{-1,1}*#&/@ps]},FilterRules[{opts},Options[Graphics]]];
(*CREASE PATTERN*)
b2=Transpose[{rt,-vt}];
d2=Transpose[{rt,-wt}];
c2=(b2 +d2 cf)/(1+cf);
e2={#,0}&/@rt;
f2=Transpose[{rt,+wt}];
h2=Transpose[{rt,+vt}];
g2=(f2+h2 cf)/(1+cf);
a2={0,-2hw}+#&/@g2;
h2={0,2hw}+#&/@b2;
i2={0,2hw}+#&/@c2;
j2={0,2hw}+#&/@d2;
k2={0,2hw}+#&/@e2;
cpw=Graphics[{
Style[Line[c2],ValleyLine],
Style[Line[d2],MountainLine],
Style[Line[f2],MountainLine],
Style[Line[g2],ValleyLine],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{a2,c2,an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{c2,d2,-an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{d2,f2,an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{f2,g2,-an}],
Style[Line[{a2[[-1]],c2[[-1]],g2[[-1]]}],BorderLine],
Style[Line[{a2[[1]],c2[[1]],g2[[1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics]]];
cpsw=Graphics[{
Style[Line[f2],MountainLine],
Style[Line[g2],ValleyLine],
Style[Line[i2],ValleyLine],
Style[Line[j2],MountainLine],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{e2,f2,an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{f2,g2,-an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{g2,i2,an}],MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{i2,j2,-an}],
MapThread[StyledFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropFirst/@DropLast/@{j2,k2,an}],
Style[Line[{e2[[-1]],g2[[-1]],i2[[-1]],k2[[-1]]}],BorderLine],
Style[Line[{e2[[1]],g2[[1]],i2[[1]],k2[[1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics]]];
cp=Graphics[Table[Translate2D[cpw[[1]],{0,2hw i}],{i,0,m-1}],FilterRules[{opts},Options[Graphics]]];
(*FOLDED FORM*)
a3=Transpose[{xt,-wt,\[Zeta]}]+(U3D[-\[Pi]/2]*#&)/@stc;
c3=Transpose[{xt,-wt,\[Zeta]}]+(U3D[\[Pi]/2-2 \[Phi]]*#&)/@stc;
d3=Transpose[{xt,-wr,\[Zeta]}];
e3={#[[1]],0,#[[2]]}&/@ps;
f3=Transpose[{xt,wr,\[Zeta]}];
g3=Transpose[{xt,wt,\[Zeta]}]+(U3D[-\[Pi]/2+2 \[Phi]]*#&)/@stc;
i3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@c3;
j3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@d3;
k3=RotationMatrix3Du[2 \[Phi],{0,0,1}] . #&/@e3;
pfn=Style[Polygon/@Drop[Transpose[{#2,#1,RotateLeft[#1],RotateLeft[#2]}],-1],Paper3DFill]&;
ffw=Graphics3D[{
pfn[a3,c3],(*flange face*)
pfn[c3,d3],(*flange side*)
pfn[d3,f3],(*panel*)
pfn[f3,g3],(*flange side*)
Style[Line[a3],FoldedLine],
Style[Line[c3],FoldedLine],
Style[Line[d3],FoldedLine],
Style[Line[f3],FoldedLine],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{a3,c3,an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{c3,d3,-an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{d3,f3,an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{f3,g3,-an}],Style[Line[{a3[[-1]],c3[[-1]],d3[[-1]],f3[[-1]],g3[[-1]]}],BorderLine],
Style[Line[{a3[[1]],c3[[1]],d3[[1]],f3[[1]],g3[[1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics3D]]];
ffsw=Graphics3D[{
pfn[e3,f3],(*semi-panel*)
pfn[f3,g3],(*flange side*)
pfn[g3,i3],(*flange face*)
pfn[i3,j3],(*flange side*)
pfn[j3,k3],(*semi-panel*)
Style[Line[f3],FoldedLine],
Style[Line[g3],FoldedLine],
Style[Line[i3],FoldedLine],
Style[Line[j3],FoldedLine],
MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{e3,f3,an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{f3,g3,-an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{g3,i3,an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{i3,j3,-an}],MapThread[StyledGenericFoldLine[{#1,#2},#3,MinimumAngle->mb]&,DropLast/@{j3,k3,an}],Style[Line[{e3[[-1]],f3[[-1]],g3[[-1]],i3[[-1]],j3[[-1]],k3[[-1]]}],BorderLine],
Style[Line[{e3[[1]],f3[[1]],g3[[1]],i3[[1]],j3[[1]],k3[[1]]}],BorderLine]
},FilterRules[{opts},Options[Graphics3D]]];
ff=Graphics3D[Table[RotateZ3D[ffw[[1]],2 i \[Phi]],{i,0,m-1}],FilterRules[{opts},Options[Graphics3D]]];
MakeTDisplayPair[cp,ff]//AddClass[TRotationalPot,{CrossSection->cs,CreasePatternWedge->cpw,CreasePatternSplitWedge->cpsw,FoldedFormWedge->ffw,FoldedFormSplitWedge->ffsw}]]
Module[{pts,tobj},
pts={{0,0},{1,1},{1,2},{2,3}};
tobj=MakeRectMoselyPot[pts,8,FlangeExcess->0.3];
PartitionedGraphicsGrid[{
Graphics[tobj[CrossSection],Axes->True,AxesLabel->{"x","z"}],
tobj[CreasePatternWedge],
tobj[FoldedFormWedge],
tobj[CreasePatternSplitWedge],
tobj[FoldedFormSplitWedge],
tobj[CreasePattern],
tobj[FoldedForm2D]},5]/.OrigamiStyle[]
]//ShowExample
MakeAltMoselyPot::badm="The rotational order `1` must be positive even.";
MakeAltMoselyPot[pts_,m_,opts___]:=Module[{\[Phi],pts1,ht,cs,cpsw1,ffsw1,cpsw2,ffsw2,w,cpsw,ffsw,cp,ff},
If[Mod[m,2]!=0||m<=0,Message[MakeAltMoselyPot::badm,m];Abort[]];
\[Phi]=\[Pi]/m;
pts1=Which[
pts[[1,1]]<pts[[-1,1]],Append[pts,{pts[[1,1]],pts[[-1,2]]+.0001}],
pts[[1,1]]>pts[[-1,1]],Prepend[pts,{pts[[-1,1]],pts[[1,2]]-.0001}],
True,pts];(* start and end on axis *)
ht=pts[[-1,2]]-pts[[1,2]];(* height of pot *)
{cs,cpsw1,ffsw1}=GetValues[MakeMoselyPot[pts1,m,opts],{CrossSection,CreasePatternSplitWedge,FoldedFormSplitWedge}];
{cpsw2,ffsw2}=GetValues[MakeMoselyPot[Reverse[pts1],m,opts],{CreasePatternSplitWedge,FoldedFormSplitWedge}];
w=GraphicsBoundingBox[cpsw1][[1,2]];(* xmax of first piece of cp *)
cpsw=Graphics[{cpsw1[[1]],
FunctionTransform[cpsw2[[1]],w{Cos[2\[Phi]],Sin[2\[Phi]]}+ReflectionYMatrix2D . RotationMatrix2D[-2\[Pi]/m] . #&]},FilterRules[{opts},Options[Graphics]]];
cp=Graphics[Table[Translate2D[cpsw[[1]],w i{Cos[2\[Phi]]-1,Sin[2\[Phi]]}],{i,0,m/2-1}],FilterRules[{opts},Options[Graphics]]];
ffsw=Graphics3D[{ffsw1[[1]],
FunctionTransform[ffsw2[[1]],{0,0,ht}+RotationZMatrix3D[2\[Pi]/m] . #&]/.Polygon[x_]:>Polygon[Reverse[x]]},FilterRules[{opts},Options[Graphics3D]]];
ff=Graphics3D[Table[MatrixTransform[ffsw[[1]],RotationZMatrix3D[4\[Pi] i/m]],{i,0,m/2-1}],FilterRules[{opts},Options[Graphics3D]]];
MakeTDisplayPair[Rotate2D[cp,-\[Phi]],ff]//AddClass[TRotationalPot,{CrossSection->cs,CreasePatternSplitWedge->Rotate2D[cpsw,-\[Phi]],FoldedFormSplitWedge->ffsw}]
]
Module[{pts,tobj},
pts={{0,0},{1,1},{1,2},{2,3}};
tobj=MakeAltMoselyPot[pts,8,CreasePatternBoundary->Default];
PartitionedGraphicsGrid[{
Graphics[tobj[CrossSection][[1]],Axes->True,AxesLabel->{"x","z"}],
tobj[CreasePatternSplitWedge],
tobj[FoldedFormSplitWedge],
tobj[CreasePattern],
tobj[FoldedForm2D]},5]/.OrigamiStyle[]
]//ShowExample
Module[{h=\[Sqrt]3,pts,tobj},
pts={{0,0},{1,0},{2,h},{1,2h},{0,2h}};
tobj=MakeAltMoselyPot[pts,6,CreasePatternBoundary->Default];
PartitionedGraphicsGrid[{
Graphics[tobj[CrossSection][[1]],Axes->True,AxesLabel->{"x","z"}],
tobj[CreasePatternSplitWedge],
tobj[FoldedFormSplitWedge],
tobj[CreasePattern],
tobj[FoldedForm2D]},5]/.OrigamiStyle[]
]//ShowExample
Module[{pts,tobj},
pts=N[Table[{Sin[\[Phi]],-(1+Cos[\[Phi]])},{\[Phi],0,\[Pi],\[Pi]/16}]];
tobj=MakeAltMoselyPot[pts,8,CreasePatternBoundary->Default,MinimumAngle->15\[Degree]];
PartitionedGraphicsGrid[{
Graphics[tobj[CrossSection][[1]],Axes->True,AxesLabel->{"x","z"}],
tobj[CreasePatternSplitWedge],
tobj[FoldedFormSplitWedge],
tobj[CreasePattern],
tobj[FoldedForm2D]},5]/.OrigamiStyle[]
]//ShowExample
Module[{pts,tobj},
pts=N[Table[{Sin[\[Phi]],-(1+Cos[\[Phi]])},{\[Phi],0,\[Pi],\[Pi]/16}]];
tobj=MakeAltMoselyPot[pts,8,CreasePatternBoundary->Default,MinimumAngle->15\[Degree]];
PartitionedGraphicsGrid[{
Graphics[tobj[CrossSection][[1]],Axes->True,AxesLabel->{"x","z"}],
tobj[CreasePatternSplitWedge],
tobj[FoldedFormSplitWedge],
tobj[CreasePattern],
tobj[FoldedForm2D]},5]/.OrigamiStyle[]
]//ShowExample
TubeHeight::usage="TubeHeight is an option to TwistJoinedTubes that specifies the heights of the top and bottom cylinders.";
PanelOverlap::usage="PanelOverlap is an option to TwistJoinedTubes that specifies whether to add an extra panel that overlaps the first.";
TwistExtension::usage="TwistExtension is an option to ClosedTwistToppedTube that specifies a distance to extend the twist folds beyond the point of convergence.";
Options[ClosedTwistToppedTube]={
TwistDirection->CCW,
TubeHeight->1,
PanelOverlap->False,
TwistExtension->0,
TypeMinimumAngle->0,
TypeMaximumAngle->89\[Degree]
};
ClosedTwistToppedTube[pts_List,ctr_List:{0,0,0},dir_List:{0,0,1},opts___]:=Module[{th,po,te,td,tmna,tmxa,m,lens,plist,w,g,gbot,pp,p,qq,q,z,qx,qx0,qy,qy0,eqns,r,rm,rrr,rr,rrx,rry,rrz,rold,mm,cp,ff,verts,edges,types,verts3d,tobj},
th=TubeHeight/.{opts}/.Options[ClosedTwistToppedTube];
po=PanelOverlap/.{opts}/.Options[ClosedTwistToppedTube];
te=TwistExtension/.{opts}/.Options[ClosedTwistToppedTube];
td=TwistDirection/.{opts}/.Options[ClosedTwistToppedTube];
tmna=TypeMinimumAngle/.{opts}/.Options[ClosedTwistToppedTube];
tmxa=TypeMaximumAngle/.{opts}/.Options[ClosedTwistToppedTube];
m=Length[pts];
lens=Mag/@(RotateLeft[pts]-pts);
(* unwrapped x-coordinates . Double the length so we can index at j=0 and j=m in the cp without wrap-around effects. *)
plist=FoldList[Plus,0,Join[lens,lens]];
w=plist[[-1]]/2;(* total width of cp *)
(* wraparound behavior *)
g[j_]:=g[Mod[j,m]]/;(j<0||j>=m);
(* ff points *)
pp[j_,z_]:=Append[pts[[Mod[j+1,m,1]]],z];
pp[j_]:=pp[j,g[j]];
qq[j_]:=ctr;
(* cp points *)
p[j_,z_]:={plist[[Mod[j+1,m,1]]]+w Floor[j/m],z};
p[j_]:=p[j,g[j]];
(* solve for twist. First, the plane of the twist. *)
Do[g[j]=z/.Solve[pp[j,z] . dir==0,z][[1]],{j,0,m-1}];
gbot=Min[Table[g[j],{j,0,m-1}]]-th;
(* next, cp points at the point of convergence *)
Do[{qx0,qy0}=(p[j]+p[j+1])/2+{0,.1};
eqns={
Mag2[{qx,qy}-p[j]]==Mag2[qq[j]-pp[j]],Mag2[{qx,qy}-p[j+1]]==Mag2[qq[j]-pp[j+1]]};
q[j]={qx,qy}/.FindRoot[eqns,{{qx,qx0},{qy,qy0}}],{j,0,m-1}];
q[j_]:=q[Mod[j,m]]+{w Floor[j/m],0}/;(j<0||j>=m);
(* middle of triangular pleats *)
Do[r[j]=(q[j-1]+q[j])/2,{j,0,m-1}];
r[j_]:=r[Mod[j,m]]+{w Floor[j/m],0}/;(j<0||j>=m);
rm=RotationMatrix2D[\[Pi]/2];
rrr={rrx,rry,rrz};
Do[eqns={
TetrahedronSignedVolume[If[td===CCW,pp[j-1],pp[j+1]],pp[j],rrr,qq[j]]==0,
(qq[j]-rrr) . (rrr-pp[j])==0,
Mag[rrr-qq[j]]==0.5Mag[q[j-1]-q[j]]};
rr[j]=rrr/.FindRoot@@{eqns,Transpose[{rrr,If[td===CCW,pp[j+1],pp[j-1]]}]},{j,0,m-1}];
rr[j_]:=rr[Mod[j,m]]/;(j<0||j>=m);
(* twist extension/reduction *)
If[te!=0,
Do[If[td===CCW,
q[j]=q[j]+te NormalizeReal[q[j]-p[j]];
qq[j]=qq[j]+te NormalizeReal[qq[j]-pp[j]],
q[j]=q[j]+te NormalizeReal[q[j]-p[j+1]];
qq[j]=qq[j]+te NormalizeReal[qq[j]-pp[j+1]]];
r[j]=r[j]+te NormalizeReal[r[j]-p[j]];
rr[j]=rr[j]+te NormalizeReal[rr[j]-pp[j]];
,{j,0,m-1}];
qq[m]=qq[0](* this needed to handle wraparound properly *)
];
(* rendering *)
mm=If[po,m+1,m];
(* cp *)
cp=Graphics[{
Style[Line[Table[p[j,gbot],{j,0,mm}]],Gray],
Style[Table[Line[{p[j,gbot],p[j,g[j]]}],{j,0,mm}],Gray],
Style[Line[Table[p[j],{j,0,mm}]],Red],
Style[Table[Line[{p[j],q[j]}],{j,0,mm-1}],Blue],
Style[Table[Line[{p[j+1],q[j]}],{j,0,mm-1}],Cyan],
Style[Table[Line[{p[j],r[j]}],{j,0,mm}],Green],
Style[Table[Line[{r[j],q[j]}],{j,0,mm-1}],Gray],
Style[Table[Line[{q[j],r[j+1]}],{j,0,mm-1}],Gray],
{}}];
Print[cp]//Hold;
(* ff *)
ff=Graphics3D[{
Style[Line[Table[pp[j,gbot],{j,0,mm}]],Gray],
Style[Table[Line[{pp[j,gbot],pp[j]}],{j,0,mm}],Gray],
Style[Line[Table[pp[j],{j,0,mm}]],Red],
Style[Table[Line[{pp[j],qq[j]}],{j,0,mm-1}],Blue],
Style[Table[Line[{pp[j+1],qq[j]}],{j,0,mm-1}],Cyan],
Style[Table[Line[{pp[j],rr[j]}],{j,0,mm}],Green],
Style[Table[Line[{rr[j],qq[j]}],{j,0,mm-1}],Gray],
Style[Table[Line[{qq[j],rr[j+1]}],{j,0,mm-1}],Gray],
Table[{
Style[{
Polygon[{pp[j,gbot],pp[j+1,gbot],pp[j+1],pp[j]}],
If[td===CCW,Polygon[{qq[j],pp[j-1],pp[j],rr[j]}],Polygon[{pp[j],pp[j+1],qq[j],rr[j]}]],
{}},Opacity[0.75]],
{}},{j,0,mm-1}],
{}}];
Print[ff]//Hold;
(* build the TObj *)
verts=Join[
Table[p[j,gbot],{j,0,mm}],
Table[p[j],{j,0,mm}],
Table[r[j],{j,0,mm}],
Table[q[j],{j,0,mm-1}]];
verts3d=Join[
Table[pp[j,gbot],{j,0,mm}],
Table[pp[j],{j,0,mm}],
Table[rr[j],{j,0,mm}],
Table[qq[j],{j,0,mm-1}]];
edges=Join[
Table[{k,k+1},{k,mm}],(* bottom *)
Table[{k,k+(mm+1)},{k,mm+1}],(* tube verticals *)
Table[{k+(mm+1),k+(mm+1)+1},{k,mm}],(* edge of twist *)
Table[{k+(mm+1),k+2(mm+1)},{k,mm+1}],(* verticals to r[j] *)
If[td===CCW,(* diagonals to q[j] *)
Table[{k+mm+1,k+3(mm+1)},{k,mm}],
Table[{k+mm+2,k+3(mm+1)},{k,mm}]],
Flatten[Table[{{k+2(mm+1),k+3(mm+1)},{k+3(mm+1),k+2(mm+1)+1}},{k,mm}],1],
{}];
(* construct the types explicitly, since we can't rely on FoldAngles *)
types=Table[B,{Length[edges]}];
Do[types[[k]]=M,{k,mm+2,2mm}];(* tube verticals *)
Do[types[[k]]=M,{k,2mm+2,3mm+1}];(* edge of twist *)
Do[types[[k]]=M,{k,3mm+3,4mm+1}];(* vertical to r[j] *)
Do[types[[k]]=V,{k,4mm+3,5mm+2}];(* vertical to q[j] *)
(* build the output *)
tobj=MakeTPlaneGraphAssigned[verts,edges,{},types]//AddTGraph3D[verts3d]//RecalcFoldAngles//TweakFoldAngles[types]//ReassignGraph3D[#,TypeMinimumAngle->tmna,TypeMaximumAngle->tmxa]&]
Module[{pts,ctr,dir,tobj},
pts={{1,1},{-1,1},{-1,-1},{1,-1}};
ctr={0,0,0.5};
dir={0,0,1.};
tobj=ClosedTwistToppedTube[pts,ctr,dir,TwistExtension->.5,PanelOverlap->True,TwistDirection->CCW];
GraphicsColumn[{
FoldAngleCreasePatternGraphics[tobj]/.ScoringStyle[],
FoldedFormGraphics3D[tobj]/.OrigamiStyle[]}]
]//ShowExample
Module[{pts,ctr,dir,tobj},
pts={{1,1},{-1,1},{-1,-1},{1,-1}};
ctr={.4,0,0.2};
dir={-.2,-.3,1};
tobj=ClosedTwistToppedTube[pts,ctr,dir,PanelOverlap->False,TwistDirection->CW];
GraphicsColumn[{
FoldAngleCreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]
]//ShowExample
Module[{m,a,b,pts,tobj},
m=16;
a=GoldenRatio;
b=1;
pts=DiscreteEllipseEquilateral[m,{a,b}];
tobj=ClosedTwistToppedTube[pts,TwistExtension->0.2,PanelOverlap->True,TypeMinimumAngle->45\[Degree]];
GraphicsColumn[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[ShowUnfolded->False]
]//ShowExample
Module[{m,a,b,pts,tobj},
m=16;
a=GoldenRatio;
b=1;
pts=DiscreteEllipseEquilateral[m,{a,b}];
tobj=ClosedTwistToppedTube[pts,TwistExtension->-0.1,PanelOverlap->True,TypeMinimumAngle->45\[Degree]];
GraphicsColumn[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[ShowUnfolded->False]
]//ShowExample
Options[TwistJoinedTubeGraphics]={
TwistDirection->CCW
};
TwistJoinedTubeGraphics::badlens="Lists `1` and `2` must have the same length.";
TwistJoinedTubeGraphics[botpts2d_,toppts2d_,opts___]:=Module[{td,m},
td=TwistDirection/.{opts}/.Options[TwistJoinedTubeGraphics];
m=Length[botpts2d];
If[Length[toppts2d]!=m,Message[TwistJoinedTubeGraphics::badlens,botpts2d,toppts2d];Abort[]];
Graphics[{
Style[Line[AppendFirst[botpts2d]],Red],
Style[Table[If[td===CCW,
{Polygon[{botpts2d[[j]],botpts2d[[Mod[j+1,m,1]]],toppts2d[[Mod[j+1,m,1]]]}],Polygon[{toppts2d[[Mod[j+1,m,1]]],toppts2d[[Mod[j+1,m,1]]],toppts2d[[j]]}]},
{Polygon[{botpts2d[[j]],botpts2d[[Mod[j+1,m,1]]],toppts2d[[j]]}],Polygon[{toppts2d[[j]],botpts2d[[Mod[j+1,m,1]]],toppts2d[[Mod[j+1,m,1]]]}]}],{j,m}],
Opacity[1/m]],
Style[Line[AppendFirst[toppts2d]],Green],
Style[Table[Line[{botpts2d[[j]],toppts2d[[j]]}],{j,m}],Blue],
If[td===CCW,
Style[Table[Line[{botpts2d[[j]],toppts2d[[Mod[j+1,m,1]]]}],{j,m}],Cyan],
Style[Table[Line[{botpts2d[[Mod[j+1,m,1]]],toppts2d[[j]]}],{j,m}],Darker[Cyan]]],
Style[Point[botpts2d[[1]]],Darker[Red],PointSize[.02]],
Style[Point[toppts2d[[1]]],Darker[Green],PointSize[.02]],
{}},FilterRules[{opts},Options[Graphics]]]]
Module[{m,\[Phi],dx,dy,dz,botpts2d,toppts2d},
m=12;(* rotational order *)
\[Phi]=135.\[Degree];(* amount of twist from bottom to top *)
{dx,dy}={0.5,0.4};(* lateral offset from bottom to top *)
dz=0.32;
botpts2d=DiscreteCircle[m,1]//N;
toppts2d={dx,dy}+#&/@DiscreteCircle[m,1,\[Phi]]//N;
TwistJoinedTubeGraphics[botpts2d,toppts2d]
]//ShowExample
Module[{m,\[Phi],dx,dy,dz,botpts2d,toppts2d},
m=12;(* rotational order *)
\[Phi]=135.\[Degree];(* amount of twist from bottom to top *)
{dx,dy}={0.5,0.4};(* lateral offset from bottom to top *)
dz=0.32;
botpts2d=DiscreteCircle[m,1]//N;
toppts2d={dx,dy}+#&/@DiscreteCircle[m,1,\[Phi]]//N;
TwistJoinedTubeGraphics[botpts2d,toppts2d,TwistDirection->CW]
]//ShowExample
Module[{m,a,b,c,\[Phi],\[Theta],dx,dy,dz,botpts2d,toppts2d},
m=16;(* rotational order *)
a=GoldenRatio;
b=1;
c=\[Sqrt](a^2-b^2);
botpts2d=DiscreteEllipseEquilateral[m,{a,b}];
toppts2d=RotateLeft[RotationMatrix2D[90\[Degree]] . #&/@botpts2d,m/4-1];
TwistJoinedTubeGraphics[botpts2d,toppts2d,TwistDirection->CW,Axes->True]
]//ShowExample
TiltAxialAngle::usage = "TiltAxialAngle is an option to TwistJoinedTubes that specifies the angle of the axis of tilt of the top tube.";
TiltAzimuthalAngle::usage="TiltAzimuthalAngle is an option to TwistJoinedTubes that specifies the tilt angle of the top tube.";
TubeHeight::usage="TubeHeight is an option to TwistJoinedTubes that specifies the heights of the top and bottom cylinders.";
PanelOverlap::usage="PanelOverlap is an option to TwistJoinedTubes that specifies whether to add an extra panel that overlaps the first.";
Options[TwistJoinedTubes]={
TwistDirection->CCW,
TiltAxialAngle->0,
TiltAzimuthalAngle->0,
TubeHeight->1,
PanelOverlap->False
};
TwistJoinedTubes::badlens="Lists `1` and `2` must have the same length.";
TwistJoinedTubes::badperi="Lists `1` and `2` must have the same perimeter.";
TwistJoinedTubes[botpts2d_List,toppts2d_List,dz_,opts___]:=Module[{td,tf,tt,th,po,m,blens,tlens,pxvals,qxvals,g,h,gavg,havg,ppavg,qqavg,p,q,trm,tz,pp,qq,dl,dh,gbot,htop,eqns,vars,vars0,soln,mm,cp,ff,verts,edges,types,verts3d,tobj},
td=TwistDirection/.{opts}/.Options[TwistJoinedTubes];
tf=TiltAxialAngle/.{opts}/.Options[TwistJoinedTubes];
tt=TiltAzimuthalAngle/.{opts}/.Options[TwistJoinedTubes];
th=TubeHeight/.{opts}/.Options[TwistJoinedTubes];
po=PanelOverlap/.{opts}/.Options[TwistJoinedTubes];
m=Length[botpts2d];
If[Length[toppts2d]!=m,Message[TwistJoinedTubes::badlens,botpts2d,toppts2d];Abort[]];
blens=Mag/@(RotateLeft[botpts2d]-botpts2d);
tlens=Mag/@(RotateLeft[toppts2d]-toppts2d);
If[Abs[(Plus@@blens)-(Plus@@tlens)]>10^-6,Message[TwistJoinedTubes::badperi,botpts2d,toppts2d];Abort[]];
(* unwrapped x-coordinates of bottom and top. Double the length so we can index at j=0 and j=m in the cp without wrap-around effects. *)
pxvals=FoldList[Plus,0,Join[blens,blens]];
qxvals=FoldList[Plus,0,Join[tlens,tlens]];
(* wraparound behavior *)
g[j_]:=g[Mod[j,m]]/;(j<0||j>=m);
h[j_]:=h[Mod[j,m]]/;(j<0||j>=m);
(* average variables *)
gavg=Sum[g[j],{j,0,m-1}]/m;
havg=Sum[h[j],{j,0,m-1}]/m;
ppavg=Sum[pp[j],{j,0,m-1}]/m;
qqavg=Sum[qq[j],{j,0,m-1}]/m;
(* ff points *)
trm=RotationMatrix3Du[tt,U3D[tf]];(* axis of top rotation *)
tz=trm . {0,0,1};(* direction of top *)
pp[j_,z_]:=Append[botpts2d[[Mod[j+1,m,1]]],z];
pp[j_]:=pp[j,g[j]];
qq[j_,z_]:=trm . Append[toppts2d[[Mod[j+1,m,1]]],z];
qq[j_]:=qq[j,h[j]];
(* cp points; dl and dh are variables to be solved for. *)
p[j_,z_]:={pxvals[[j+1]],z};
p[j_]:=p[j,g[j]];
q[j_,z_]:={qxvals[[j+1]]+dl,z+dh};
q[j_]:=q[j,h[j]];
(* equations: isometries plus offsets *)
eqns=Join[
Table[Mag2[p[j]-q[j]]-Mag2[pp[j]-qq[j]]==0,{j,0,m-1}],
Table[If[td===CCW,
Mag2[p[j]-q[j+1]]-Mag2[pp[j]-qq[j+1]],
Mag2[p[j+1]-q[j]]-Mag2[pp[j+1]-qq[j]]]==0,{j,0,m-1}],
{ppavg[[3]]==-dz/2,qqavg . tz==dz/2}]//Simplify;
PrintThis[eqns]//Hold;
(* Solve *)
vars=Join[
Table[g[j],{j,0,m-1}],
Table[h[j],{j,0,m-1}],
{dl,dh}];
vars0=Table[.1,{Length[vars]}];
(* soln=Solve[eqns,vars]; *)
(* soln=Sort[soln,(dh/.#1)<(dh/.#2)&]//Last; *)
(* Solve takes substantial time and issues a warning, FindRoot is better *)
soln=FindRoot@@{eqns,Transpose[{vars,vars0}]};
(* top and bottom *)
gbot=Min[Table[g[j],{j,0,m-1}]]-th;
htop=Max[Table[h[j],{j,0,m-1}]]+th;
(* rendering for testing/debugging *)
mm=If[po,m+1,m];
cp=Graphics[{
Style[Line[Table[p[j,gbot],{j,0,mm}]],Gray],
Style[Table[Line[{p[j,gbot],p[j]}],{j,0,mm}],Gray],
Style[Line[Table[p[j],{j,0,mm}]],Red],
Style[Table[Line[{p[j],q[j]}],{j,0,mm}],Blue],
If[td===CCW,
Style[Table[Line[{p[j],q[j+1]}],{j,0,mm-1}],Cyan],
Style[Table[Line[{p[j+1],q[j]}],{j,0,mm-1}],Darker[Cyan]]],
Style[Line[Table[q[j],{j,0,mm}]],Green],
Style[Table[Line[{q[j],q[j,htop]}],{j,0,mm}],Gray],
Style[Line[Table[q[j,htop],{j,0,mm}]],Gray],
{}}];
ff=Graphics3D[{
Style[Line[Table[pp[j,gbot],{j,0,mm}]],Gray],
Style[Table[Line[{pp[j,gbot],pp[j]}],{j,0,mm}],Gray],
Style[Line[Table[pp[j],{j,0,mm}]],Red],
Style[Table[Line[{pp[j],qq[j]}],{j,0,mm}],Blue],
If[td===CCW,
Style[Table[Line[{pp[j],qq[j+1]}],{j,0,mm-1}],Cyan],
Style[Table[Line[{pp[j+1],qq[j]}],{j,0,mm-1}],Darker[Cyan]]],
Style[Line[Table[qq[j],{j,0,mm}]],Green],
Style[Table[Line[{qq[j],qq[j,htop]}],{j,0,mm}],Gray],
Style[Line[Table[qq[j,htop],{j,0,mm}]],Gray],
Table[{
Style[{
Polygon[{pp[j,gbot],pp[j+1,gbot],pp[j+1],pp[j]}],
If[td===CCW,
{Polygon[{pp[j],pp[j+1],qq[j+1]}],Polygon[{pp[j],qq[j+1],qq[j]}]},
{Polygon[{pp[j],pp[j+1],qq[j]}],Polygon[{pp[j+1],qq[j+1],qq[j]}]}],
Polygon[{qq[j],qq[j+1],qq[j+1,htop],qq[j,htop]}],
{}},Opacity[0.75]],
{}},{j,0,mm-1}],
{}}];
(* Show the result *)
Print[GraphicsRow[{cp,ff}]/.soln]//Hold;
(* construct the TGraph3DAssigned *)
verts=Join[
Table[p[j,gbot],{j,0,mm}],
Table[p[j],{j,0,mm}],
Table[q[j],{j,0,mm}],
Table[q[j,htop],{j,0,mm}]]/.soln;
verts3d=Join[
Table[pp[j,gbot],{j,0,mm}],
Table[pp[j],{j,0,mm}],
Table[qq[j],{j,0,mm}],
Table[qq[j,htop],{j,0,mm}]]/.soln;
edges=Join[
Table[{k,k+1},{k,mm}](* bottom edge *),
Table[{k,k+(mm+1)},{k,mm+1}](* bottom verticals *),
Table[{k+(mm+1),k+(mm+1)+1},{k,mm}](* twist bottom *),
Table[{k+(mm+1),k+2(mm+1)},{k,mm+1}](* twist verticals *),
Table[If[td===CCW,
{k+(mm+1),k+2(mm+1)+1},
{k+(mm+1)+1,k+2(mm+1)}],{k,mm}],
Table[{k+2(mm+1),k+2(mm+1)+1},{k,mm}](* twist top *),
Table[{k+2(mm+1),k+3(mm+1)},{k,mm+1}](* top verticals *),
Table[{k+3(mm+1),k+3(mm+1)+1},{k,mm}](* top edge *)];
tobj=MakeTGraph3D[verts,edges,{},verts3d];
ReassignGraph3D[tobj,opts]]
Module[{botpts2d,toppts2d,dz,tobj},
dz=1;
botpts2d={{1,1},{-1,1},{-1,-1},{1,-1}};
toppts2d=RotationMatrix2D[30\[Degree]] . #&/@botpts2d;
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,PanelOverlap->True];
GraphicsColumn[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{botpts2d,toppts2d,dz,tobj},
dz=1;
botpts2d={{1,1},{-1,1},{-1,-1},{1,-1}};
toppts2d=RotationMatrix2D[30\[Degree]] . #&/@botpts2d;
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,TwistDirection->CW,PanelOverlap->True];
GraphicsColumn[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{m,\[Phi],dx,dy,dz,botpts2d,toppts2d,tobj},
m=24;(* rotational order *)
\[Phi]=175.\[Degree];(* amount of twist from bottom to top *)
{dx,dy}={0.5,0.5};(* lateral offset from bottom to top *)
dz=0.32;(* hand-tweaked to get tangency of top and bottom *)
botpts2d=DiscreteCircle[m,1];
toppts2d={dx,dy}+#&/@DiscreteCircle[m,1,\[Phi]];
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,PanelOverlap->True,TypeMinimumAngle->30\[Degree]];
GraphicsColumn[{CreasePatternGraphics[tobj]/.OrigamiStyle[],FoldedFormGraphics3D[tobj]/.OrigamiStyle[]}]
]//ShowExample
Module[{m,a,b,botpts2d,toppts2d,dz,tobj},
m=24;(* rotational order *)
a=GoldenRatio;
b=1;
dz=0.2;
botpts2d=DiscreteEllipseEquilateral[m,{a,b}];
toppts2d=RotateLeft[RotationMatrix2D[90\[Degree]] . #&/@botpts2d,3];
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,PanelOverlap->True];
GraphicsColumn[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{m,a,b,botpts2d,toppts2d,dz,tobj},
m=24;(* rotational order *)
a=1.732;
b=1;
dz=0.95;
botpts2d={{a,b},{-a,b},{-a,-b},{a,-b}};
toppts2d=RotateLeft[RotationMatrix2D[60\[Degree]] . #&/@botpts2d,1];
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,TwistDirection->CW,PanelOverlap->True];
GraphicsColumn[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{m,a,b,botpts2d,toppts2d,dz,tobj},
m=24;(* rotational order *)
a=1.732;
b=1;
dz=0.95;
botpts2d={{a,b},{-a,b},{-a,-b},{a,-b}};
toppts2d=RotateLeft[RotationMatrix2D[60\[Degree]] . #&/@botpts2d,1];
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,TwistDirection->CCW,PanelOverlap->True];
GraphicsColumn[{FoldAngleCreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,botpts2d,toppts2d,dz,tobj},
pts=DiscreteCircle[5]//N;
botpts2d=PleatReducePolygon[pts,.8];
toppts2d=RotationMatrix2D[10\[Degree]] . #&/@PleatReducePolygon[pts,.4];
dz=0.5;
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,TwistDirection->CCW,PanelOverlap->True];
GraphicsColumn[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{pts,botpts2d,toppts2d,dz,tobj},
pts=DiscreteCircle[5]//N;
botpts2d=PleatReducePolygon[pts,.8];
toppts2d=RotationMatrix2D[10\[Degree]] . #&/@PleatReducePolygon[pts,.4];
dz=0.5;
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,TwistDirection->CW,PanelOverlap->True];
GraphicsColumn[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{m,\[Phi],dx,dy,dz,tf,tt,botpts2d,toppts2d,tobj},
m=12;(* rotational order *)
\[Phi]=90.\[Degree];(* amount of twist of top *)
{dx,dy}={0.0,0.0};(* lateral offset of top *)
dz=0.8;(* separation between top and bottom surfaces *)
tf=90.\[Degree];(* rotation of axis of top tilt *)
tt=15.\[Degree];(* azimuthal tilt of top *)
botpts2d=DiscreteCircle[m,1];
toppts2d={dx,dy}+#&/@DiscreteCircle[m,1,\[Phi]];
Print[TwistJoinedTubeGraphics[botpts2d,toppts2d]]//Hold;
tobj=TwistJoinedTubes[botpts2d,toppts2d,dz,
TwistDirection->CCW,
TiltAxialAngle->tf,
TiltAzimuthalAngle->tt,
PanelOverlap->True,TypeMinimumAngle->30\[Degree]];
GraphicsColumn[{CreasePatternGraphics[tobj]/.OrigamiStyle[],FoldedFormGraphics3D[tobj]/.OrigamiStyle[]}]
]//ShowExample
DoubleJoinedTubeGraphics::badlens="List `1` should have half as many points as list `2`.";
DoubleJoinedTubeGraphics[botpts2d_,toppts2d_,opts___]:=Module[{m},
TwistDirection/.{opts}/.Options[DoubleJoinedTubeGraphics];
m=Length[botpts2d];
If[Length[toppts2d]!=2m,Message[DoubleJoinedTubeGraphics::badlens,botpts2d,toppts2d];Abort[]];
Graphics[{
Style[Line[AppendFirst[botpts2d]],Red],
Style[Table[{
Polygon[{botpts2d[[j]],botpts2d[[Mod[j+1,m,1]]],toppts2d[[Mod[2j+1,2m,1]]]}],
Polygon[{botpts2d[[j]],toppts2d[[Mod[2j+1,2m,1]]],toppts2d[[Mod[2j,2m,1]]]}],
Polygon[{botpts2d[[Mod[j+1,m,1]]],toppts2d[[Mod[2j+2,2m,1]]],toppts2d[[Mod[2j+1,2m,1]]]}]
},{j,m}],
Opacity[1/m]],
Style[Line[AppendFirst[toppts2d]],Green],
Style[Table[Line[{botpts2d[[j]],toppts2d[[2j]]}],{j,m}],Blue],
Style[Table[Line[{botpts2d[[j]],toppts2d[[Mod[2j+1,2m,1]]]}],{j,m}],Cyan],
Style[Table[Line[{botpts2d[[Mod[j+1,m,1]]],toppts2d[[Mod[2j+1,2m,1]]]}],{j,m}],Darker[Cyan]],
Style[Point[botpts2d[[1]]],Darker[Red],PointSize[.02]],
Style[Point[toppts2d[[2]]],Darker[Green],PointSize[.02]],
{}},FilterRules[{opts},Options[Graphics]]]]
Module[{m,\[Phi],botpts2d,toppts2d},
m=12;(* rotational order *)
\[Phi]=135.\[Degree];(* amount of twist from bottom to top *)
botpts2d=DiscreteCircle[m,1]//N;
toppts2d=RotationMatrix2D[10.\[Degree]] . #&/@PleatReducePolygon[botpts2d,0.5];
DoubleJoinedTubeGraphics[botpts2d,toppts2d]
]//ShowExample
Options[DoubleJoinedTubes]={
	TubeHeight->1,
	PanelOverlap->False
};
DoubleJoinedTubes::badlens="List `1` does not have half as many entries as list `2`.";
DoubleJoinedTubes::badperi="Lists `1` and `2` must have the same perimeter.";
DoubleJoinedTubes[botpts2d_List,toppts2d_List,dz_,opts___]:=Module[{td,th,po,m,m2,mm2,blens,tlens,pxvals,qxvals,g,h,gavg,havg,p,q,pp,qq,dl,dh,gbot,htop,eqns,vars,vars0,soln,mm,cp,ff,verts,edges,types,verts3d,tobj},
td=TwistDirection/.{opts}/.Options[DoubleJoinedTubes];
th=TubeHeight/.{opts}/.Options[DoubleJoinedTubes];
po=PanelOverlap/.{opts}/.Options[DoubleJoinedTubes];
m=Length[botpts2d];
If[Length[toppts2d]!=2m,Message[DoubleJoinedTubes::badlens,botpts2d,toppts2d];Abort[]];
blens=Mag/@(RotateLeft[botpts2d]-botpts2d);
tlens=Mag/@(RotateLeft[toppts2d]-toppts2d);
If[Abs[(Plus@@blens)-(Plus@@tlens)]>10^-6,Message[DoubleJoinedTubes::badperi,botpts2d,toppts2d];Abort[]];
(* unwrapped x-coordinates of bottom and top. Double the length so we can index at j=0 and j=m in the cp without wrap-around effects. *)
pxvals=FoldList[Plus,0,Join[blens,blens]];
qxvals=FoldList[Plus,0,Join[tlens,tlens]];
(* wraparound behavior *)
g[j_]:=g[Mod[j,m]]/;(j<0||j>=m);
h[j_]:=h[Mod[j,m]]/;(j<0||j>=2m);
(* average variables *)
gavg=Sum[g[j],{j,0,m-1}]/m;
havg=Sum[h[j],{j,0,2m-1}]/(2m);
(* ff points *)
pp[j_,z_]:=Append[botpts2d[[Mod[j+1,m,1]]],z];
pp[j_]:=pp[j,g[j]];
qq[j_,z_]:=Append[toppts2d[[Mod[j+1,2m,1]]],z];
qq[j_]:=qq[j,h[j]];
(* cp points; dl and dh are variables to be solved for. *)
p[j_,z_]:={pxvals[[j+1]],z};
p[j_]:=p[j,g[j]];
q[j_,z_]:={qxvals[[j+1]]+dl,z+dh};
q[j_]:=q[j,h[j]];
(* equations: isometries plus offsets *)
eqns=Join[
Table[Mag2[p[j]-q[2j]]-Mag2[pp[j]-qq[2j]]==0,{j,0,m-1}],
Table[Mag2[p[j]-q[2j+1]]-Mag2[pp[j]-qq[2j+1]]==0,{j,0,m-1}],
Table[Mag2[p[j+1]-q[2j+1]]-Mag2[pp[j+1]-qq[2j+1]]==0,{j,0,m-1}],
{g[0]==0,havg-gavg-dz==0}]//Simplify;
PrintThis[eqns]//Hold;
(* Solve *)
vars=Join[
Table[g[j],{j,0,m-1}],
Table[h[j],{j,0,2m-1}],
{dl,dh}];
vars0=Table[.1,{Length[vars]}];
(* soln=Solve[eqns,vars]; *)
(* soln=Sort[soln,(dh/.#1)<(dh/.#2)&]//Last; *)
(* Solve takes substantial time and issues a warning, FindRoot is better *)
soln=FindRoot@@{eqns,Transpose[{vars,vars0}]};
(* top and bottom *)
gbot=Min[Table[g[j],{j,0,m-1}]]-th;
htop=Max[Table[h[j],{j,0,2m-1}]]+th;
(* rendering for testing/debugging *)
mm=If[po,m+1,m];
cp=Graphics[{
Style[Line[Table[p[j,gbot],{j,0,mm}]],Gray],
Style[Table[Line[{p[j,gbot],p[j]}],{j,0,mm}],Gray],
Style[Line[Table[p[j],{j,0,mm}]],Red],
Style[Table[Line[{p[j],q[2j]}],{j,0,mm}],Blue],
Style[Table[Line[{p[j],q[2j+1]}],{j,0,mm-1}],Cyan],
Style[Table[Line[{p[j+1],q[2j+1]}],{j,0,mm-1}],Darker[Cyan]],
Style[Line[Table[q[j],{j,0,2mm}]],Green],
Style[Table[Line[{q[j],q[j,htop]}],{j,0,2mm}],Gray],
Style[Line[Table[q[j,htop],{j,0,2mm}]],Gray],
{}}];
ff=Graphics3D[{
Style[Line[Table[pp[j,gbot],{j,0,mm}]],Gray],
Style[Table[Line[{pp[j,gbot],pp[j]}],{j,0,mm-1}],Gray],
Style[Line[Table[pp[j],{j,0,mm}]],Red],
Style[Table[Line[{pp[j],qq[2j]}],{j,0,mm}],Blue],
Style[Table[Line[{pp[j],qq[2j+1]}],{j,0,mm-1}],Cyan],Style[Table[Line[{pp[j+1],qq[2j+1]}],{j,0,mm-1}],Darker[Cyan]],
Style[Line[Table[qq[j],{j,0,2mm}]],Green],
Style[Table[Line[{qq[j],qq[j,htop]}],{j,0,2mm-1}],Gray],
Style[Line[Table[qq[j,htop],{j,0,2mm}]],Gray],
Table[{
Style[{
Polygon[{pp[j,gbot],pp[j+1,gbot],pp[j+1],pp[j]}],
Polygon[{pp[j],pp[j+1],qq[2j+1]}],
Polygon[{pp[j],qq[2j+1],qq[2j]}],
Polygon[{pp[j+1],qq[2j+2],qq[2j+1]}],
Polygon[{qq[2j],qq[2j+1],qq[2j+1,htop],qq[2j,htop]}],
Polygon[{qq[2j+1],qq[2j+2],qq[2j+2,htop],qq[2j+1,htop]}],
{}},Opacity[0.75]],
{}},{j,0,mm-1}],
{}}];
(* Show the result *)
Print[GraphicsRow[{cp,ff}]/.soln]//Hold;
(* construct the TGraph3DAssigned *)
verts=Join[
Table[p[j,gbot],{j,0,mm}],
Table[p[j],{j,0,mm}],
Table[q[j],{j,0,2mm}],
Table[q[j,htop],{j,0,2mm}]]/.soln;
verts3d=Join[
Table[pp[j,gbot],{j,0,mm}],
Table[pp[j],{j,0,mm}],
Table[qq[j],{j,0,2mm}],
Table[qq[j,htop],{j,0,2mm}]]/.soln;
edges=Join[
Table[{k,k+1},{k,mm}](* bottom edge *),
Table[{k,k+(mm+1)},{k,mm+1}](* bottom verticals *),
Table[{k+(mm+1),k+(mm+1)+1},{k,mm}](* twist bottom *),
Table[{k+(mm+1),(2k-1)+2(mm+1)},{k,mm+1}](* twist verticals *),
Table[{k+(mm+1),2k+2(mm+1)},{k,mm}](* twist upward diagonal *),
Table[{k+(mm+1)+1,2k+2(mm+1)},{k,mm}](* twist downward diagonal *),
Table[{k+2(mm+1),k+2(mm+1)+1},{k,2mm}](* twist top *),
Table[{k+2(mm+1),k+4(mm+1)-1},{k,2mm+1}](* top verticals *),
Table[{k+4(mm+1)-1,k+4(mm+1)},{k,2mm}](* top edge *)];
tobj=MakeTGraph3D[verts,edges,{},verts3d];
ReassignGraph3D[tobj,opts]]
Module[{m,\[Phi],dz,botpts2d,toppts2d,tobj},
m=4;
\[Phi]=45.\[Degree];
dz=0.5;
botpts2d=DiscreteCircle[m,1]//N;
toppts2d=RotationMatrix2D[\[Phi]] . #&/@PleatReducePolygon[botpts2d,0.5];
tobj=DoubleJoinedTubes[botpts2d,toppts2d,dz];
GraphicsColumn[{CreasePatternGraphics[tobj]/.OrigamiStyle[],FoldedFormGraphics3D[tobj]/.OrigamiStyle[]}]
]//ShowExample
Block[{s,f,g,h,k},
f=FunctionInterpolationAlt[{1,s^2},{s,0,1}];
PrintThis[InterpolatingFunctionCount[f]];
g=Functionize[s,f[s]/Mag[f[s]]];
PrintThis[InterpolatingFunctionCount[g]];
h=Functionize[s,g[s]/Mag[g[s]]];
PrintThis[InterpolatingFunctionCount[h]];
k=FunctionInterpolationAlt[h[s],{s,0,1}];
PrintThis[InterpolatingFunctionCount[k]];
]//ShowExample
Block[{f},
f=Cos[#]&;
f'
]//ShowExample
Block[{s,f},
f=FunctionInterpolation[Cos[s],{s,0,\[Pi]}];
Print[f'];
]//ShowExample
Block[{s,f,g,h},
f=FunctionInterpolation[Cos[s],{s,0,\[Pi]}];
Print["f = ",f];
(* Derivatives are taken inside of an InterpolatingFunction *)
Print["f' = ",f'];
g=Functionize[s,f[s]];
(* But if we apply the derivative to a function containing an InterpolatingFunction, it's not taken inside *)
Print["g' = ",g'];
(* If we re-functionize to apply the function, then the derivative can come inside *)
h=Functionize[s,g'[s]];
Print["h = ",h];
]//ShowExample
Block[{s,f,g},
f=FunctionInterpolationAlt[{Cos[s],Sin[s]},{s,0,\[Pi]}];
Print["f' = ",f'];
]//ShowExample
Block[{s,f,g},
f=FunctionInterpolationAlt[{Cos[s],Sin[s]},{s,0,\[Pi]}];
Print["f' = ",f'];
g=Functionize[s,f'[s]];
Print["g = ",g];
]//ShowExample
TangentVectorColor::usage="TangentVectorColor is a color directive that defines the color for a tangent vector of a parameterized curve in 2D or 3D.";
NormalVectorColor::usage="NormalVectorColor is a color directive that defines the color for a normal vector of a parameterized curve in 2D or 3D.";
LeftNormalVectorColor::usage="LeftNormalVectorColor is a color directive that defines the color for theleft normal vector of a parameterized curve in 2D.";
BinormalVectorColor::usage="BinormalVectorColor is a color directive that defines the color for the binormal vector of a parameterized curve in 3D.";
SurfaceNormalVectorColor::usage="SurfaceNormalVectorColor is a color directive that defines the color for the surface normal vector of a parameterized surface or curve on a surface in 3D.";
TangentNormalVectorColor::usage="TangentNormalVectorColor is a color directive that defines the color for the tangent normal vector of a parameterized curve on a surface in 3D.";
DirectorVectorColor::usage="DirectorVectorColor is a color directive that defines the color for a director of a ruled parameterization.";
CurveVectorStyle={
TangentVectorColor->CMYKColor@@({0,87,83,0}/100),
NormalVectorColor->CMYKColor@@({68,0,90,0}/100),
LeftNormalVectorColor->CMYKColor@@({15,26,100,0}/100),
BinormalVectorColor->CMYKColor@@({93,78,0,0}/100),
SurfaceNormalVectorColor->CMYKColor@@({40,67,0,0}/100),
TangentNormalVectorColor->CMYKColor@@({15,26,100,0}/100),
DirectorVectorColor->CMYKColor@@({8,45,92,0}/100)
};
Module[{th},
th=Thickness[.05];
GraphicsGrid[{{
Graphics[{
Style[Line[{{0,0},{1,0}}],TangentVectorColor,th],
Style[Line[{{0,0},{0,1}}],NormalVectorColor,th]}],
Graphics[{
Style[Line[{{0,0},{1,0}}],TangentVectorColor,th],
Style[Line[{{0,0},{0,1}}],LeftNormalVectorColor,th]}]},{
Graphics3D[{
Style[Line[{{0,0,0},{1,0,0}}],TangentVectorColor,th],
Style[Line[{{0,0,0},{0,1,0}}],NormalVectorColor,th],
Style[Line[{{0,0,0},{0,0,1}}],BinormalVectorColor,th]}],
Graphics3D[{
Style[Line[{{0,0,0},{1,0,0}}],TangentVectorColor,th],
Style[Line[{{0,0,0},{0,1,0}}],TangentNormalVectorColor,th],
Style[Line[{{0,0,0},{0,0,1}}],SurfaceNormalVectorColor,th]}]},
{Graphics[{
Style[Line[{{0,0},{1,0}}],TangentVectorColor,th],
Style[Line[{{0,0},{1/\[Sqrt]2,1/\[Sqrt]2}}],DirectorVectorColor,th],
Style[Line[{{0,0},{0,1}}],LeftNormalVectorColor,th]
}],Graphics[]}
}]/.CurveVectorStyle
]//ShowExample
Curve2D::usage="Curve2D is a key to the rules returned by Curve2DSystem that gives the original parameterized plane curve.";
Speed2D::usage="Speed2D is a key to the rules returned by Curve2DSystem that gives the scalar speed function for a parameterized plane curve.";
LeftCurvature2D::usage="LeftCurvature2D is a key to the rules returned by Curve2DSystem that gives the scalar left curvature function for a parameterized plane curve.";
Curvature2D::usage="Curvature2D is a key to the rules returned by Curve2DSystem that gives the scalar curvature function for a parameterized plane curve.";
TangentVector2D::usage="TangentVector2D is a key to the rules returned by Curve2DSystem that gives the tangent vector function for a parameterized plane curve.";
LeftNormalVector2D::usage="LeftNormalVector2D is a key to the rules returned by Curve2DSystem that gives the left normal vector function for a parameterized plane curve.";
NormalVector2D::usage="NormalVector2D is a key to the rules returned by Curve2DSystem that gives the normal vector function for a parameterized plane curve.";
Curve2DSystemPlots[sys_List,{u0_,u1_}]:=Module[{t},
{ParametricPlot[Curve2D[t]/.sys,{t,u0,u1},PlotLabel->"c"],
Plot[Speed2D[t]/.sys,{t,u0,u1},PlotLabel->"ds"],
Plot[LeftCurvature2D[t]/.sys,{t,u0,u1},PlotLabel->"\[Kappa]l"],
Plot[Curvature2D[t]/.sys,{t,u0,u1},PlotLabel->"\[Kappa]"],
ParametricPlot[TangentVector2D[t]/.sys,{t,u0,u1},PlotLabel->"t"],
ParametricPlot[LeftNormalVector2D[t]/.sys,{t,u0,u1},PlotLabel->"l"],
ParametricPlot[NormalVector2D[t]/.sys,{t,u0,u1},PlotLabel->"n"]}]
Module[{csys,plots,u0,u1},
csys={
Curve2D->({Cos[#1],Sin[#1]}&),
Speed2D->(1&),
LeftCurvature2D->(1&),
Curvature2D->(1&),
TangentVector2D->({-Sin[#1],Cos[#1]}&),
LeftNormalVector2D->({-Cos[#1],-Sin[#1]}&),
NormalVector2D->({-Cos[#1],-Sin[#1]}&)};
{u0,u1}={0,.75\[Pi]};
plots=Curve2DSystemPlots[csys,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]
Options[Curve2DSystem]={
Simplification->None,
Assumptions->{}
};
StrictArguments[Curve2DSystem];
Curve2DSystem[c_Function,opts___] := Module[{si,as,s,sfn,dc,ds,t,dt,l,\[Kappa]l,\[Kappa],n},
si=Simplification/.{opts}/.Options[Curve2DSystem];
as=Assumptions/.{opts}/.Options[Curve2DSystem];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
dc=Functionize[s,c'[s]//sfn];
ds=Functionize[s,Mag[dc[s]]//sfn];
t=Functionize[s,dc[s]/ds[s]//sfn];
l=Functionize[s,{{0,-1},{1,0}} . t[s]//sfn];
dt=Functionize[s,t'[s]//sfn];
\[Kappa]l=Functionize[s,l[s] . dt[s]/ds[s]//sfn];
\[Kappa]=Functionize[s,Abs[\[Kappa]l[s]]//sfn];
n=Functionize[s,Sign[\[Kappa]l[s]]l[s]//sfn];
{Curve2D->c,
Speed2D->ds,
LeftCurvature2D->\[Kappa]l,
Curvature2D->\[Kappa],
TangentVector2D->t,
LeftNormalVector2D->l,
NormalVector2D->n}]
Module[{p},
p={Cos[#],Sin[#]}&;
Curve2DSystem[p]// PrettyParameters//ColumnForm
]//ShowExample
Module[{c,pcs},
c={Cos[#],Sin[#]}&;
pcs=Curve2DSystem[c,Simplification->Simplify];
pcs// PrettyParameters//ColumnForm
]//ShowExample
Module[{c,pcs},
c={Cos[#],Sin[#]}&;
pcs=Curve2DSystem[c];
(pcs/.(s_->y_Function):>(s->y[0]))//ColumnForm
]//ShowExample
StrictArguments[Curve2DSystem];
NCurve2DSystem[c_Function|c_InterpolatingFunction,{u0_,u1_},opts___] := Module[{s,dc,ds,t,l,rdc,ddc,\[Kappa],n,\[Kappa]l},
dc=Functionize[s,c'[s]];
ds=Functionize[s,Mag[dc[s]]];
t=Functionize[s,dc[s]/ds[s]];
rdc=Functionize[s,{{0,-1},{1,0}} . dc[s]];
ddc=Functionize[s,dc'[s]];
l=Functionize[s,rdc[s]/ds[s]];
\[Kappa]l=Functionize[s,ddc[s] . rdc[s]/ds[s]^3];
\[Kappa]=Functionize[s,Abs[ddc[s] . rdc[s]]/ds[s]^3];
n=Functionize[s,Sign[ddc[s] . rdc[s]](rdc[s]/ds[s])];
{Curve2D->c,
Speed2D->FunctionInterpolationAlt[ds[s],{s,u0,u1},opts],
LeftCurvature2D->FunctionInterpolationAlt[\[Kappa]l[s],{s,u0,u1},opts],
Curvature2D->FunctionInterpolationAlt[\[Kappa][s],{s,u0,u1},opts],
TangentVector2D->FunctionInterpolationAlt[t[s],{s,u0,u1},opts],
LeftNormalVector2D->FunctionInterpolationAlt[l[s],{s,u0,u1},opts],
NormalVector2D->FunctionInterpolationAlt[n[s],{s,u0,u1},opts]
}]
Module[{c,t,u0,u1,csys,plots},
{u0,u1}={0,.75\[Pi]};
c={Cos[#],Sin[#]}&;
csys=NCurve2DSystem[c,{u0,u1}];
plots=Curve2DSystemPlots[csys,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]//ShowExample
Module[{s,c,u0,u1,csys,plots},
{u0,u1}={0,.75\[Pi]};
c=FunctionInterpolationAlt[{Cos[s],Sin[s]},{s,u0,u1}];
csys=NCurve2DSystem[c,{u0,u1}];
plots=Curve2DSystemPlots[csys,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]//ShowExample
RecoverCurve2DSystem::nosoln="DSolve couldn't integrate the 2D curve equations.";
Options[RecoverCurve2DSystem]={
Simplification->None,
Assumptions->{}
};
RecoverCurve2DSystem[ds_Function,\[Kappa]l_Function,{ui_,ci_List,ti_List},opts___]:=Module[{si,as,s,sfn,dsopts,soln,tx,ty,lx,ly,cx,cy,c,t,l,\[Kappa],n},
si=Simplification/.{opts}/.Options[RecoverCurve2DSystem];
as=Assumptions/.{opts}/.Options[RecoverCurve2DSystem];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
soln=DSolve[{
{cx'[s],cy'[s]}==ds[s]{tx[s],ty[s]},
{tx'[s],ty'[s]}==ds[s]\[Kappa]l[s]{lx[s],ly[s]},
{lx'[s],ly'[s]}==-ds[s]\[Kappa]l[s]{tx[s],ty[s]},
{cx[ui],cy[ui]}==ci,
{tx[ui],ty[ui]}==ti,
{lx[ui],ly[ui]}==RotationMatrix2D[\[Pi]/2] . ti
},{cx[s],cy[s],tx[s],ty[s],lx[s],ly[s]},s,Evaluate[dsopts]]//Flatten;
If[Head[soln]===DSolve,Message[RecoverCurve2DSystem::nosoln];Abort[]];
c=Functionize[s,{cx[s],cy[s]}/.soln//sfn];
t=Functionize[s,{tx[s],ty[s]}/.soln//sfn];
l=Functionize[s,{lx[s],ly[s]}/.soln//sfn];
\[Kappa]=Functionize[s,Abs[\[Kappa]l[s]]//sfn];
n=Functionize[s,Sign[\[Kappa]l[s]]l[s]//sfn];
{Curve2D->c,
Speed2D->ds,
LeftCurvature2D->\[Kappa]l,
Curvature2D->\[Kappa],
TangentVector2D->t,
LeftNormalVector2D->l,
NormalVector2D->n}]
Block[{ds,\[Kappa]l,ui,ci,ti,u0,u1,csys,c},
ds=1&;
\[Kappa]l=1&;
{ui, ci, ti}={0,{1,0},{0,1}};
{u0,u1}={0,\[Pi]};
csys=RecoverCurve2DSystem[ds,\[Kappa]l,{ui,ci,ti},Simplification->Simplify];
Print[csys];
Print[#//PrettyParameters]&/@csys;
c=Curve2D/.csys;
ParametricPlot[c[t],{t,u0,u1}]
]//ShowExample
NRecoverCurve2DSystem::nosoln="NDSolve couldn't integrate the 2D curve equations.";
NRecoverCurve2DSystem[ds_Function|ds_InterpolatingFunction,\[Kappa]l_Function|\[Kappa]l_InterpolatingFunction,{ui_,ci_List,ti_List},{u0_,u1_},opts___]:=Module[{dsopts,s,soln,tx,ty,lx,ly,cx,cy,c,t,l,\[Kappa],n},
dsopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
soln=NDSolve[{
{cx'[s],cy'[s]}==ds[s]{tx[s],ty[s]},
{tx'[s],ty'[s]}==ds[s]\[Kappa]l[s]{lx[s],ly[s]},
{lx'[s],ly'[s]}==-ds[s]\[Kappa]l[s]{tx[s],ty[s]},
{cx[ui],cy[ui]}==ci,
{tx[ui],ty[ui]}==ti,
{lx[ui],ly[ui]}==RotationMatrix2D[\[Pi]/2] . ti
},{cx[s],cy[s],tx[s],ty[s],lx[s],ly[s]},{s,u0,u1},Evaluate[dsopts]]//Flatten;
If[Head[soln]===NDSolve,Message[NRecoverCurve2DSystem::nosoln];Abort[]];
c=Functionize[s,{cx[s],cy[s]}/.soln];
c=FunctionInterpolationAlt[c[s],{s,u0,u1},opts];
t=Functionize[s,{tx[s],ty[s]}/.soln];
t=FunctionInterpolationAlt[t[s],{s,u0,u1},opts];
l=Functionize[s,{lx[s],ly[s]}/.soln];
l=FunctionInterpolationAlt[l[s],{s,u0,u1},opts];
\[Kappa]=FunctionInterpolationAlt[Abs[\[Kappa]l[s]],{s,u0,u1},opts];
n=FunctionInterpolationAlt[Sign[\[Kappa]l[s]]l[s],{s,u0,u1},opts];
{Curve2D->c,
Speed2D->ds,
LeftCurvature2D->\[Kappa]l,
Curvature2D->\[Kappa],
TangentVector2D->t,
LeftNormalVector2D->l,
NormalVector2D->n}]
Block[{ds,\[Kappa]l,ui,ci,ti,u0,u1,csys,c},
ds=1&;
\[Kappa]l=1&;
{ui, ci, ti}={0,{1,0},{0,1}};
{u0,u1}={0,\[Pi]};
csys=NRecoverCurve2DSystem[ds,\[Kappa]l,{ui,ci,ti},{u0,u1}];
c=Curve2D/.csys;
ParametricPlot[c[t],{t,u0,u1}]
]//ShowExample
InitialPosition2D::usage="InitialPosition2D is an option to RecoverCurve2D that specifies the position of the curve at t=0.";
InitialTangentVector2D::usage="InitialTangentVector2D is an option to RecoverCurve2D that specifies the initial tangent vector at t=0.";
Options[RecoverCurve2DSystemOld]={
InitialPosition2D->{0,0},
InitialTangentVector2D->{1,0},
Simplification->None,
Assumptions->{}
};
RecoverCurve2DSystemOld[lkpf_Function,vf_Function, opts___]:=Module[{ip,it,si,as,t,sfn,lkp,ds,ph,ph0,tt,ln,nn,kp,c},
ip=InitialPosition2D/.{opts}/.Options[RecoverCurve2DSystemOld];
it=InitialTangentVector2D/.{opts}/.Options[RecoverCurve2DSystemOld];
si=Simplification/.{opts}/.Options[RecoverCurve2DSystemOld];
as=Assumptions/.{opts}/.Options[RecoverCurve2DSystemOld];
as=Flatten[Join[{t\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
lkp=lkpf[t];(* left curvature *)
ds=vf[t];(* speed *)
ph0=(ArcTan@@it)//sfn;
ph=Integrate[ds lkp,t]//sfn;(* turning angle *)
If[Count[ph,_Integrate,{0,\[Infinity]}]==0,
ph=ph0+(ph-(ph/.t->0))//sfn,(* initial condition *)
ph=ph0+Integrate[ds lkp,{t,0,t}]//sfn];
tt={Cos[ph],Sin[ph]}//sfn;(* tangent *)
ln={{0,-1},{1,0}} . tt//sfn;(* left normal *)
nn=Sign[lkp]ln//sfn;(* normal *)
kp=Abs[lkp];(* curvature *)
c=Integrate[ds tt,t]//sfn;(* Recovered curve *)
If[Count[c,_Integrate,{0,\[Infinity]}]==0,
c=ip+(c-(c/.t->0))//sfn,(* initial condition *)
c=ip+Integrate[ds tt,{t,0,t}]//sfn];
{Curve2D->FunctionizeOld[c,t],
Speed2D->FunctionizeOld[ds,t],
LeftCurvature2D->FunctionizeOld[lkp,t],
Curvature2D->FunctionizeOld[kp,t],
TangentVector2D->FunctionizeOld[tt,t],
LeftNormalVector2D->FunctionizeOld[ln,t],
NormalVector2D->FunctionizeOld[nn,t]}]
RecoverCurve2DSystemOld[kp_Function,opts___]:=RecoverCurve2DSystemOld[kp,1&,opts]
Module[{kp,rcs,c},
kp=1&;(* constant curvature *)
rcs=RecoverCurve2DSystemOld[kp];
rcs//PrettyParameters//ColumnForm//Print;
c=Curve2D/.rcs;
ParametricPlot[c[t],{t,0,\[Pi]/2},Axes->True]
]//ShowExample
Module[{kp,rcs,c},
kp=#&;(* linear curvature *)
rcs=RecoverCurve2DSystemOld[kp];
rcs//PrettyParameters//ColumnForm//Print;
c=Curve2D/.rcs;
ParametricPlot[c[t],{t,0,10},Axes->True]
]//ShowExample
Module[{kp,v,rcs,c},
kp=2&;(* constant curvature *)
v=#&;(* linearly increasing speed *)
rcs=RecoverCurve2DSystemOld[kp,v,InitialPosition2D->{1,0},InitialTangentVector2D->{0,1}];
rcs//PrettyParameters//ColumnForm//Print;
c=Curve2D/.rcs;
ParametricPlot[c[t],{t,0,\[Pi]/2},Axes->True]
]//ShowExample
Options[NRecoverCurve2DSystemOld]={
InitialPosition2D->{0,0},
InitialTangentVector2D->{1,0}
};
NRecoverCurve2DSystemOld[lkpf_Function|lkpf_InterpolatingFunction,vf_Function|vf_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{ip,it,fopts,ndopts,in,t,soln,tx,ty,nx,ny,cx,cy,kpf,nxf,nyf},
ip=InitialPosition2D/.{opts}/.Options[NRecoverCurve2DSystemOld];
it=InitialTangentVector2D/.{opts}/.Options[NRecoverCurve2DSystemOld];
ndopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
fopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
it=it/Mag[it];(* normalize, just in case *)
in=RotationMatrix2D[\[Pi]/2] . it;(* initial left normal *)
soln=NDSolve[{
{tx'[t],ty'[t]}==vf[t]lkpf[t]{nx[t],ny[t]},
{nx'[t],ny'[t]}==-vf[t]lkpf[t]{tx[t],ty[t]},
{cx'[t],cy'[t]}==vf[t]{tx[t],ty[t]},
{tx[0],ty[0]}==it,
{nx[0],ny[0]}==in,
{cx[0],cy[0]}==ip},{tx[t],ty[t],nx[t],ny[t],cx[t],cy[t]},{t,u0,u1},Evaluate[ndopts]]//Flatten;
(* reinterpolate some derived functions *)
kpf=FunctionInterpolation[Abs[lkpf[t]]/.soln,{t,u0,u1},Evaluate[fopts]];
nxf=FunctionInterpolation[Sign[lkpf[t]]nx[t]/.soln,{t,u0,u1},Evaluate[fopts]];
nyf=FunctionInterpolation[Sign[lkpf[t]]ny[t]/.soln,{t,u0,u1},Evaluate[fopts]];
{Curve2D->FunctionizeOld[{cx[t],cy[t]}/.soln,t],
Speed2D->vf,
LeftCurvature2D->lkpf,
Curvature2D->kpf,
TangentVector2D->FunctionizeOld[{tx[t],ty[t]}/.soln,t],
LeftNormalVector2D->FunctionizeOld[{nx[t],ny[t]}/.soln,t],
NormalVector2D->FunctionizeOld[{nxf[t],nyf[t]},t]}]
NRecoverCurve2DSystemOld[kp_Function|kp_InterpolatingFunction,{u0_,u1_},opts___]:=NRecoverCurve2DSystemOld[kp,1&,{u0,u1},opts]
Module[{lkp,u0,u1,rcs,plots},
lkp=1&;(* constant curvature *)
u0=0;
u1=0.75\[Pi];
rcs=NRecoverCurve2DSystemOld[lkp,{u0,u1}];
plots=Curve2DSystemPlots[rcs,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]//ShowExample
Module[{lkp,u0,u1,rcs,plots},
lkp=#&;(* linear curvature *)
u0=0.01;
u1=6;
rcs=NRecoverCurve2DSystemOld[lkp,{u0,u1}];
plots=Curve2DSystemPlots[rcs,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]//ShowExample
Module[{lkp,u0,u1,rcs,plots},
lkp=#&;(* linear curvature *)
u0=0.01;
u1=6;
rcs=NRecoverCurve2DSystemOld[lkp,{u0,u1},InterpolationPoints->20];
plots=Curve2DSystemPlots[rcs,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]//ShowExample
Module[{lkp,u0,u1,rcs,plots},
u0=0;
u1=6;
lkp=FunctionInterpolation[t,{t,u0,u1}];
rcs=NRecoverCurve2DSystemOld[lkp,{u0,u1}];
plots=Curve2DSystemPlots[rcs,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]//ShowExample
Module[{lkp,v,u0,u1,rcs,plots},
lkp=2&;(* constant curvature *)
v=#&;(* linearly increasing speed *)
u0=0;
u1=\[Pi]/2;
rcs=NRecoverCurve2DSystemOld[lkp,v,{u0,u1},InitialPosition2D->{1,0},InitialTangentVector2D->{0,1}];
plots=Curve2DSystemPlots[rcs,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]//ShowExample
Curve3D::usage="Curve3D is a key to the rules returned by Curve3DSystem that gives the original parameterized space curve.";
Speed3D::usage="Speed3D is a key to the rules returned by Curve3DSystem that gives the scalar speed function for a parameterized space curve.";
Curvature3D::usage="Curvature3D is a key to the rules returned by Curve3DSystem that gives the scalar curvature function for a parameterized space curve.";
Torsion3D::usage="Torsion3D is a key to the rules returned by Curve3DSystem that gives the scalar torsion function for a parameterized space curve.";
TangentVector3D::usage="TangentVector3D is a key to the rules returned by Curve3DSystem that gives the tangent vector function for a parameterized space curve.";
NormalVector3D::usage="NormalVector3D is a key to the rules returned by Curve3DSystem that gives the normal vector function for a parameterized space curve.";
BinormalVector3D::usage="BinormalVector3D is a key to the rules returned by Curve3DSystem that gives the binormal vector function for a parameterized space curve.";
Curve3DSystemPlots[sys_List,{u0_,u1_}]:=Module[{t},
{ParametricPlot3D[Curve3D[t]/.sys,{t,u0,u1},PlotLabel->"Curve3D"],
Plot[Speed3D[t]/.sys,{t,u0,u1},PlotLabel->"Speed3D"],
Plot[Curvature3D[t]/.sys,{t,u0,u1},PlotLabel->"Curvature3D"],
Plot[Torsion3D[t]/.sys,{t,u0,u1},PlotLabel->"Torsion3D"],
ParametricPlot3D[TangentVector3D[t]/.sys,{t,u0,u1},PlotLabel->"TangentVector3D"],
ParametricPlot3D[NormalVector3D[t]/.sys,{t,u0,u1},PlotLabel->"NormalVector3D"],
ParametricPlot3D[BinormalVector3D[t]/.sys,{t,u0,u1},PlotLabel->"BinormalVector3D"]}]
Module[{pcs,u0,u1,plots},
pcs={Curve3D->({Cos[#1],Sin[#1],#1/2}&),Speed3D->((\[Sqrt]5)/2&),Curvature3D->(4/5&),Torsion3D->(2/5&),TangentVector3D->({-((2 Sin[#1])/(\[Sqrt]5)),(2 Cos[#1])/(\[Sqrt]5),1/(\[Sqrt]5)}&),BinormalVector3D->({Sin[#1]/(\[Sqrt]5),-(Cos[#1]/(\[Sqrt]5)),2/(\[Sqrt]5)}&),NormalVector3D->({-Cos[#1],-Sin[#1],0}&)};
{u0,u1}={0,1.9\[Pi]};
plots=Curve3DSystemPlots[pcs,{u0,u1}];
PartitionedGraphicsGrid[plots,4]
]//ShowExample
Options[Curve3DSystem]={
Simplification->None,
Assumptions->{}
};
StrictArguments[Curve3DSystem];
Curve3DSystem[c_Function,opts___] := Module[{si,as,sfn,s,dc,ds,t,dt,mdt,\[Kappa],n,b,\[Tau]},
si=Simplification/.{opts}/.Options[Curve3DSystem];
as=Assumptions/.{opts}/.Options[Curve3DSystem];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
dc=Functionize[s,c'[s]//sfn];
ds=Functionize[s,Mag[dc[s]]//sfn];
t=Functionize[s,dc[s]/ds[s]//sfn];
dt=Functionize[s,t'[s]//sfn];
mdt=Functionize[s,Mag[dt[s]]//sfn];
\[Kappa]=Functionize[s,mdt[s]/ds[s]//sfn];
n=Functionize[s,dt[s]/mdt[s]//sfn];
b=Functionize[s,t[s]\[Cross]n[s]//sfn];
\[Tau]=Functionize[s,-b'[s] . n[s]/ds[s]//sfn];
{Curve3D->c,
Speed3D->ds,
Curvature3D->\[Kappa],
Torsion3D->\[Tau],
TangentVector3D->t,
BinormalVector3D->b,
NormalVector3D->n}]
Module[{cc},
cc={Cos[#],Sin[#],0}&;
Curve3DSystem[cc]// PrettyParameters//ColumnForm
]//ShowExample
Module[{cc},
cc=2{Cos[#],Sin[#],0}&;
Curve3DSystem[cc,Simplification->Simplify]// PrettyParameters//ColumnForm
]//ShowExample
Module[{cc,sys},
cc={Cos[#],Sin[#],0}&;
sys=Curve3DSystem[cc,Simplification->Simplify];
(sys/.(x_->y_Function):>(x->y[0]))//ColumnForm
]//ShowExample
Module[{cc,sys},
cc={Cos[#],Sin[#],0.1#}&;
sys=Curve3DSystem[cc,Simplification->Simplify];
(sys/.(x_->y_Function):>(x->y[0]))//ColumnForm
]//ShowExample
Block[{h,c,pcs,sc,u0,v0},
c={Cos[#],Sin[#],h #}&;
pcs=Curve3DSystem[c,Simplification->Simplify];
pcs//ColumnForm//PrettyParameters//Print;
sc=Speed3D/.pcs;
Flatten[Solve[Integrate[sc[t],{t,u0,ueor}]==v0,ueor]//Simplify]
]//ShowExample
StrictArguments[NCurve3DSystem];
NCurve3DSystem[c_Function|c_InterpolatingFunction,{u0_,u1_},opts___] := Module[{s,dc,mdc,ddc,dddc,dcxddc,ds,t,\[Kappa],n,b,\[Tau]},
dc=Functionize[s,c'[s]];
mdc=Functionize[s,Mag[dc[s]]];
ddc=Functionize[s,c''[s]];
dddc=Functionize[s,c'''[s]];
dcxddc=Functionize[s,dc[s]\[Cross]ddc[s]];
ds=FunctionInterpolationAlt[mdc[s],{s,u0,u1},opts];
t=FunctionInterpolationAlt[dc[s]/mdc[s],{s,u0,u1},opts];
\[Kappa]=FunctionInterpolationAlt[Mag[dcxddc[s]]/mdc[s]^3,{s,u0,u1},opts];
n=FunctionInterpolationAlt[NormalizeReal[dcxddc[s]\[Cross]dc[s]],{s,u0,u1},opts];
b=FunctionInterpolationAlt[NormalizeReal[dcxddc[s]],{s,u0,u1},opts];
\[Tau]=FunctionInterpolationAlt[dcxddc[s] . dddc[s]/Mag2[dcxddc[s]],{s,u0,u1},opts];
{Curve3D->c,
Speed3D->ds,
Curvature3D->\[Kappa],
Torsion3D->\[Tau],
TangentVector3D->t,
BinormalVector3D->b,
NormalVector3D->n}]
Block[{h,u0,u1,s,c,csys},
h=0.5;
{u0,u1}={0,.75\[Pi]};
c=FunctionInterpolationAlt[RotationYMatrix3D[15.\[Degree]] . {Cos[s],Sin[s],h s},{s,u0,u1}];
csys=NCurve3DSystem[c,{u0,u1}];
Curve3DSystemPlots[csys,{u0,u1}]
]//ShowExample
RecoverCurve3DSystem::nosoln="DSolve couldn't integrate the Frenet-Serret equations.";
Options[RecoverCurve3DSystem]={
Simplification->None,
Assumptions->{}
};
RecoverCurve3DSystem[ds_Function,\[Kappa]_Function,\[Tau]_Function,{ui_,ci_List,ti_List,bi_List},opts___] := Module[{si,as,sfn,dsopts,s,cx,cy,cz,tx,ty,tz,nx,ny,nz,bx,by,bz,soln,c,t,n,b},
si=Simplification/.{opts}/.Options[RecoverCurve3DSystem];
as=Assumptions/.{opts}/.Options[RecoverCurve3DSystem];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
(* Integrate the Frenet-Serret differential equation *)
soln=DSolve[{
{cx'[s],cy'[s],cz'[s]}==ds[s]{tx[s],ty[s],tz[s]},
{tx'[s],ty'[s],tz'[s]}==ds[s](\[Kappa][s]{nx[s],ny[s],nz[s]}),
{nx'[s],ny'[s],nz'[s]}==ds[s](-\[Kappa][s]{tx[s],ty[s],tz[s]}+\[Tau][s]{bx[s],by[s],bz[s]}),
{bx'[s],by'[s],bz'[s]}==ds[s](-\[Tau][s]{nx[s],ny[s],nz[s]}),
{cx[ui],cy[ui],cz[ui]}==ci,
{tx[ui],ty[ui],tz[ui]}==ti,
{nx[ui],ny[ui],nz[ui]}==bi\[Cross]ti,
{bx[ui],by[ui],bz[ui]}==bi
},{cx[s],cy[s],cz[s],tx[s],ty[s],tz[s],nx[s],ny[s],nz[s],bx[s],by[s],bz[s]},s,Evaluate[dsopts]];
If[Head[soln]===DSolve,Message[RecoverCurve3DSystem::nosoln];Abort[]];
soln=Flatten[soln];
c=Functionize[s,{cx[s],cy[s],cz[s]}/.soln//sfn];
t=Functionize[s,{tx[s],ty[s],tz[s]}/.soln//sfn];
n=Functionize[s,{nx[s],ny[s],nz[s]}/.soln//sfn];
b=Functionize[s,{bx[s],by[s],bz[s]}/.soln//sfn];
{Curve3D->c,
Speed3D->ds,
Curvature3D->\[Kappa],
Torsion3D->\[Tau],
TangentVector3D->t,
BinormalVector3D->b,
NormalVector3D->n}]
Module[{ds,\[Kappa],\[Tau],ui,ci,ti,bi,csys},
ds=1&;
\[Kappa]=1&;
\[Tau]=0&;
{ui,ci,ti,bi}={0,{1,0,0},{0,1,0},{0,0,1}};
csys=RecoverCurve3DSystem[ds,\[Kappa],\[Tau],{ui,ci,ti,bi}];
csys// PrettyParameters//ColumnForm
]//ShowExample
Block[{h,c,pcs,\[Theta]},
c={Cos[#],Sin[#],Tan[\[Theta]] #}&;
pcs=RecoverCurve3DSystem[c,Simplification->Simplify,Assumptions->{\[Theta]>0,\[Theta]<\[Pi]/2}];
pcs//ColumnForm//PrettyParameters//Print;
PrintThis[Curve3D[0]/.pcs];
PrintThis[TangentVector3D[0]/.pcs];
PrintThis[BinormalVector3D[0]/.pcs];
]//ShowExample
Block[{\[Theta],as,ds,\[Kappa],\[Tau],ui,ci,ti,bi,csys,c},
as={\[Theta]>0,\[Theta]<\[Pi]/2};
ds=Sec[\[Theta]]&;
\[Kappa]=Cos[\[Theta]]^2&;
\[Tau]=Cos[\[Theta]] Sin[\[Theta]]&;
{ui,ci,ti,bi}={0,{1,0,0},{0,Cos[\[Theta]],Sin[\[Theta]]},{0,-Sin[\[Theta]],Cos[\[Theta]]}};
csys=RecoverCurve3DSystem[ds,\[Kappa],\[Tau],{ui,ci,ti,bi},Simplification->FullSimplify,Assumptions->as];
csys// PrettyParameters//ColumnForm//Print;
c=Curve3D/.csys/.\[Theta]->15.\[Degree];
ParametricPlot3D[c[s],{s,0,2\[Pi]}]
]//ShowExample
NRecoverCurve3DSystem::nosoln="NDSolve couldn't integrate the Frenet-Serret equations.";
NRecoverCurve3DSystem[ds_Function|ds_InterpolatingFunction,\[Kappa]_Function|\[Kappa]_InterpolatingFunction,\[Tau]_Function|\[Tau]_InterpolatingFunction,{ui_,ci_List,ti_List,bi_List},{u0_,u1_},opts___] := Module[{dsopts,s,cx,cy,cz,tx,ty,tz,nx,ny,nz,bx,by,bz,soln,c,t,n,b},
dsopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
(* Integrate the Frenet-Serret differential equation *)
soln=NDSolve[{
{cx'[s],cy'[s],cz'[s]}==ds[s]{tx[s],ty[s],tz[s]},
{tx'[s],ty'[s],tz'[s]}==ds[s](\[Kappa][s]{nx[s],ny[s],nz[s]}),
{nx'[s],ny'[s],nz'[s]}==ds[s](-\[Kappa][s]{tx[s],ty[s],tz[s]}+\[Tau][s]{bx[s],by[s],bz[s]}),
{bx'[s],by'[s],bz'[s]}==ds[s](-\[Tau][s]{nx[s],ny[s],nz[s]}),
{cx[ui],cy[ui],cz[ui]}==ci,
{tx[ui],ty[ui],tz[ui]}==ti,
{nx[ui],ny[ui],nz[ui]}==bi\[Cross]ti,
{bx[ui],by[ui],bz[ui]}==bi
},{cx[s],cy[s],cz[s],tx[s],ty[s],tz[s],nx[s],ny[s],nz[s],bx[s],by[s],bz[s]},{s,u0,u1},Evaluate[dsopts]];
If[Head[soln]===DSolve,Message[NRecoverCurve3DSystem::nosoln];Abort[]];
soln=Flatten[soln];
c=Functionize[s,{cx[s],cy[s],cz[s]}/.soln];
c=FunctionInterpolationAlt[c[s],{s,u0,u1},opts];
t=Functionize[s,{tx[s],ty[s],tz[s]}/.soln];
t=FunctionInterpolationAlt[t[s],{s,u0,u1},opts];
n=Functionize[s,{nx[s],ny[s],nz[s]}/.soln];
n=FunctionInterpolationAlt[n[s],{s,u0,u1},opts];
b=Functionize[s,{bx[s],by[s],bz[s]}/.soln];
b=FunctionInterpolationAlt[b[s],{s,u0,u1},opts];
{Curve3D->c,
Speed3D->ds,
Curvature3D->\[Kappa],
Torsion3D->\[Tau],
TangentVector3D->t,
BinormalVector3D->b,
NormalVector3D->n}]
Block[{\[Theta],ds,\[Kappa],\[Tau],ui,ci,ti,bi,u0,u1,csys,c},
\[Theta]=15.\[Degree];
ds=Sec[\[Theta]]&;
\[Kappa]=Cos[\[Theta]]^2&;
\[Tau]=Cos[\[Theta]] Sin[\[Theta]]&;
{ui,ci,ti,bi}={0,{1,0,0},{0,Cos[\[Theta]],Sin[\[Theta]]},{0,-Sin[\[Theta]],Cos[\[Theta]]}};
{u0,u1}={0,2\[Pi]};
csys=NRecoverCurve3DSystem[ds,\[Kappa],\[Tau],{ui,ci,ti,bi},{u0,u1}];
c=Curve3D/.csys;
ParametricPlot3D[c[s],{s,u0,u1}]
]//ShowExample
InitialPosition3D::usage="InitialPosition3D is an option to RecoverCurve3D that specifies the position of the curve at t=0.";
InitialTangentVector3D::usage="InitialTangentVector3D is an option to RecoverCurve3D that specifies the direction of the tangent vector at t=0.";
InitialNormalVector3D::usage="InitialNormalVector3D is an optiopn to RecoverCurve3DSystemOld that specifies the initial direction of the normal vector at t=0.";
Options[RecoverCurve3DSystemOld]={
InitialPosition3D->{0,0,0},
InitialTangentVector3D->{1,0,0},
InitialNormalVector3D->{0,1,0},
Simplification->None,
Assumptions->{}
};
RecoverCurve3DSystemOld::nosoln="DSolve couldn't integrate the Frenet-Serret equations.";
RecoverCurve3DSystemOld[{kp_Function,ta_Function},v_Function,opts___]:=Module[{ip,it,in,si,as,t,sfn,ib,dsopts,soln,tx,ty,tz,nx,ny,nz,bx,by,bz,cx,cy,cz},
ip=InitialPosition3D/.{opts}/.Options[RecoverCurve3DSystemOld];
it=InitialTangentVector3D/.{opts}/.Options[RecoverCurve3DSystemOld];
in=InitialNormalVector3D/.{opts}/.Options[RecoverCurve3DSystemOld];
si=Simplification/.{opts}/.Options[RecoverCurve3DSystemOld];
as=Assumptions/.{opts}/.Options[RecoverCurve3DSystemOld];
as=Flatten[Join[{t\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
it=NormalizeReal[it];
in=NormalizeReal[in];
ib=it\[Cross]in;
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
(* Integrate the matrix system *)
soln=DSolve[{
{tx'[t],ty'[t],tz'[t]}==v[t]kp[t]{nx[t],ny[t],nz[t]},
{nx'[t],ny'[t],nz'[t]}==-v[t]kp[t]{tx[t],ty[t],tz[t]}+v[t] ta[t]{bx[t],by[t],bz[t]},
{bx'[t],by'[t],bz'[t]}==-v[t] ta[t]{nx[t],ny[t],nz[t]},
{cx'[t],cy'[t],cz'[t]}==v[t]{tx[t],ty[t],tz[t]},
{tx[0],ty[0],tz[0]}==it,
{nx[0],ny[0],nz[0]}==in,
{bx[0],by[0],bz[0]}==ib,
{cx[0],cy[0],cz[0]}==ip},{tx[t],ty[t],tz[t],nx[t],ny[t],nz[t],bx[t],by[t],bz[t],cx[t],cy[t],cz[t]},t,Evaluate[dsopts]]//Flatten;
If[Head[soln]===DSolve,Message[RecoverCurve3DSystemOld::nosoln];Abort[]];
soln=soln//sfn;
{Curve3D->FunctionizeOld[{cx[t],cy[t],cz[t]}/.soln,t],
Curvature3D->kp,
Torsion3D->ta,
TangentVector3D->FunctionizeOld[{tx[t],ty[t],tz[t]}/.soln,t],
NormalVector3D->FunctionizeOld[{nx[t],ny[t],nz[t]}/.soln,t],
BinormalVector3D->FunctionizeOld[{bx[t],by[t],bz[t]}/.soln,t]}]
RecoverCurve3DSystemOld[{kp_Function,ta_Function},opts___]:=RecoverCurve3DSystemOld[{kp,ta},1&,opts]
Module[{kp,rcs,ta,cc},
kp=1&;
ta=0&;
rcs=RecoverCurve3DSystemOld[{kp,ta},Simplification->Simplify];
rcs//PrettyParameters//ColumnForm
]//ShowExample
Module[{kp,ta,rcs,cc},
kp=1&;
ta=h&;
rcs=RecoverCurve3DSystemOld[{kp,ta},Simplification->Simplify];
rcs//PrettyParameters//ColumnForm//Print;
cc=Curve3D/.rcs;
Block[{h=0.5},
ParametricPlot3D[cc[t],{t,0,4\[Pi]}]]
]//ShowExample
Module[{kp,ta,rcs,cc},
kp=Cos[\[Theta]]&;
ta=Sin[\[Theta]]&;
rcs=RecoverCurve3DSystemOld[{kp,ta},Simplification->Simplify];
rcs//PrettyParameters//ColumnForm//Print;
cc=Curve3D/.rcs;
Block[{\[Theta]=30\[Degree]},
ParametricPlot3D[cc[t],{t,0,4\[Pi]}]]
]//ShowExample
Module[{kp,ta,rcs,cc},
kp=Cos[\[Theta]]&;
ta=Sin[\[Theta]]&;
rcs=RecoverCurve3DSystemOld[{kp,ta},Simplification->FullSimplify,Assumptions->{\[Theta]>0,\[Theta]<\[Pi]/2},
InitialPosition3D->{Cos[\[Theta]],0,0},
InitialTangentVector3D->{0,Cos[\[Theta]],Sin[\[Theta]]},
InitialNormalVector3D->{-1,0,0}];
rcs//PrettyParameters//ColumnForm//Print;
cc=Curve3D/.rcs;
Block[{\[Theta]=30\[Degree]},
ParametricPlot3D[cc[t],{t,0,4\[Pi]}]]
]//ShowExample
Options[NRecoverCurve3DSystemOld]={
InitialPosition3D->{0,0,0},
InitialTangentVector3D->{1,0,0},
InitialNormalVector3D->{0,1,0}
};
NRecoverCurve3DSystemOld[{kp_Function|kp_InterpolatingFunction,ta_Function|ta_InterpolatingFunction},v_Function|v_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{ip,it,in,ib,ndopts,t,soln,tx,ty,tz,nx,ny,nz,bx,by,bz,cx,cy,cz},
ip=InitialPosition3D/.{opts}/.Options[NRecoverCurve3DSystemOld];
it=InitialTangentVector3D/.{opts}/.Options[NRecoverCurve3DSystemOld];
in=InitialNormalVector3D/.{opts}/.Options[NRecoverCurve3DSystemOld];
it=NormalizeReal[it];
in=NormalizeReal[in];
ib=it\[Cross]in;
ndopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
(* Integrate the matrix system *)
soln=NDSolve[{
{tx'[t],ty'[t],tz'[t]}==v[t]kp[t]{nx[t],ny[t],nz[t]},
{nx'[t],ny'[t],nz'[t]}==-v[t]kp[t]{tx[t],ty[t],tz[t]}+v[t] ta[t]{bx[t],by[t],bz[t]},
{bx'[t],by'[t],bz'[t]}==-v[t] ta[t]{nx[t],ny[t],nz[t]},
{cx'[t],cy'[t],cz'[t]}==v[t]{tx[t],ty[t],tz[t]},
{tx[0],ty[0],tz[0]}==it,
{nx[0],ny[0],nz[0]}==in,
{bx[0],by[0],bz[0]}==ib,
{cx[0],cy[0],cz[0]}==ip},{tx[t],ty[t],tz[t],nx[t],ny[t],nz[t],bx[t],by[t],bz[t],cx[t],cy[t],cz[t]},{t,u0,u1},ndopts]//Flatten;
{Curve3D->FunctionizeOld[{cx[t],cy[t],cz[t]}/.soln,t],
Curvature3D->kp,
Torsion3D->ta,
TangentVector3D->FunctionizeOld[{tx[t],ty[t],tz[t]}/.soln,t],
NormalVector3D->FunctionizeOld[{nx[t],ny[t],nz[t]}/.soln,t],
BinormalVector3D->FunctionizeOld[{bx[t],by[t],bz[t]}/.soln,t]}]
NRecoverCurve3DSystemOld[{kp_Function|kp_InterpolatingFunction,ta_Function|ta_InterpolatingFunction},{u0_,u1_},opts___]:=NRecoverCurve3DSystemOld[{kp,ta},1&,{u0,u1},opts]
Module[{u0,u1,kp,nrcs,ta,cc},
u0=0;
u1=\[Pi];
kp=1&;
ta=0&;
nrcs=NRecoverCurve3DSystemOld[{kp,ta},{u0,u1}];
PartitionedGraphicsGrid[Curve3DSystemPlots[nrcs,{u0,u1}],4]
]//ShowExample
Module[{u0,u1,kp,ta,nrcs,cc},
u0=0;
u1=3\[Pi];
kp=1&;
ta=0.5&;
nrcs=NRecoverCurve3DSystemOld[{kp,ta},{u0,u1}];
PartitionedGraphicsGrid[Curve3DSystemPlots[nrcs,{u0,u1}],4]
]//ShowExample
Module[{u0,u1,kp,ta,nrcs,cc},
u0=0;
u1=3\[Pi];
kp=1&;
ta=0.5&;
nrcs=NRecoverCurve3DSystemOld[{kp,ta},{u0,u1},
InitialPosition3D->{1,0,0},
InitialTangentVector3D->{0,.5,-1},
InitialNormalVector3D->{-1,0,0}];
PartitionedGraphicsGrid[Curve3DSystemPlots[nrcs,{u0,u1}],4]
]//ShowExample
Module[{u0,u1,kp,ta,rcs,nrcs,cc},
u0=0;
u1=3\[Pi];
kp=1.2&;
ta=0.5&;
rcs=RecoverCurve3DSystemOld[{kp,ta},Simplification->Simplify];
nrcs=NRecoverCurve3DSystemOld[{kp,ta},{u0,u1}];
ParametricPlot3D[{(Curve3D/.rcs)[t],(Curve3D/.nrcs)[t]},{t,u0,u1},PlotStyle->{Red,Green}]//Print;
PartitionedGraphicsGrid[Curve3DSystemPlots[rcs,{u0,u1}],4]//Print;
PartitionedGraphicsGrid[Curve3DSystemPlots[nrcs,{u0,u1}],4]//Print;
]//ShowExample
FrenetVectorLength::usage="FrenetVectorLength is an option to StyledFrenetTrihedron that specifies the lengths of the Frenet frame vectors.";
FrenetVectorLabels::usage="FrenetVectorLabels is an option to StyledFrenetTrihedron that specifies the labels on the Frenet frame vectors.";
Options[StyledFrenetTrihedron]={
FrenetVectorLength->1,
FrenetVectorLabels->{"","",""}
};
StyledFrenetTrihedron[p_List, t_List,n_List,b_List,opts___]:=Module[{fvr,fvl},
fvr=FrenetVectorLength/.{opts}/.Options[StyledFrenetTrihedron];
fvl=FrenetVectorLabels/.{opts}/.Options[StyledFrenetTrihedron];
{StyledVector[{p,p+fvr t},VectorColor->TangentVectorColor,VectorLabel->fvl[[1]],opts],
StyledVector[{p,p+fvr n},VectorColor->NormalVectorColor,VectorLabel->fvl[[2]],opts],
StyledVector[{p,p+fvr b},VectorColor->BinormalVectorColor,VectorLabel->fvl[[3]],opts]}]
Module[{ffe},
ffe=StyledFrenetTrihedron[{0,0,0},{1,0,0},{0,1,0},{0,0,1},
FrenetVectorLength->1,FrenetVectorLabels->{"t","n","b"}];
Graphics3D[ffe]/.CurveVectorStyle
]//ShowExample
FrenetTrihedrons::usage="FrenetTrihedrons is an option to FrenetTrihedronPlot3D that specifies the number of Frenet frames to place along the curve.";
FrenetDrop::usage="FrenetDrop is an option to FrenetTrihedronPlot3D that specifies whether to drop the first or last frame from the curve.";
Options[FrenetTrihedronPlot3D]={
FrenetVectorLength->0.1,
FrenetTrihedrons->5,
FrenetDrop->0
};
FrenetTrihedronPlot3D[pp_Function, {u0_,u1_}, opts___]:=Module[{flen,fn,fd,tt,nn,bb,dt,glist,pplist,ttlist,nnlist,bblist},
flen=FrenetVectorLength/.{opts}/.Options[FrenetTrihedronPlot3D];
fn=FrenetTrihedrons/.{opts}/.Options[FrenetTrihedronPlot3D];
fd=FrenetDrop/.{opts}/.Options[FrenetTrihedronPlot3D];
{tt,nn,bb}={TangentVector3D,NormalVector3D,BinormalVector3D}/.Curve3DSystem[pp,opts];
glist={StyledCurve[pp,{u0,u1},LineStyle->{Black,Thickness[.01]}]};
If[fn>0,
dt=(u1-u0)/(fn-1);
pplist=Drop[Table[pp[t],{t,u0,u1,dt}],fd];
ttlist=Drop[Table[tt[t],{t,u0,u1,dt}],fd];
nnlist=Drop[Table[nn[t],{t,u0,u1,dt}],fd];
bblist=Drop[Table[bb[t],{t,u0,u1,dt}],fd];
AppendTo[glist,MapThread[StyledFrenetTrihedron[#1,#2,#3,#4,opts]&,{pplist,ttlist,nnlist,bblist}]]];
Graphics3D[glist,Sequence@@FilterRules[{opts},Options[Graphics3D]]]]
Module[{pp,u0,u1,dt},
pp={Cos[#],Sin[#],+0.4#}&;
{u0,u1,dt}={0,\[Pi],\[Pi]/32}//N;
Show[{Graphics3D[Styled3DUnitDiskFromNormal[{0,0,1},FillStyle->{GrayLevel[0.7],Opacity[0.5]}]],FrenetTrihedronPlot3D[pp,{u0,u1},FrenetVectorLength->0.5,FrenetTrihedrons->7,VectorThickness2D->.05,FrenetDrop->-1]},Axes->True,PlotRange->{{-1.2,1.2},{-1.2,1.2},{-.5,1.8}}]/.CurveVectorStyle
]//ShowExample
FrenetRibbonWidth::usage="FrenetRibbonWidth is an option to FrenetRibbonPlotPair that specifies the width of the ribbon.";
Options[FrenetRibbonPlotPair]={
FrenetRibbonWidth->1.0
};
FrenetRibbonPlotPair[c_Function|c_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{rw,gopts,csys,cc,b,n,ip,cd,bcolor,ncolor,gb,gn},
rw=FrenetRibbonWidth/.{opts}/.Options[FrenetRibbonPlotPair];
gopts=Sequence@@FilterRules[{opts},Options[Graphics3D]];
csys=NCurve3DSystem[c,{u0,u1},opts];
{cc,b,n}={Curve3D,BinormalVector3D,NormalVector3D}/.csys;
bcolor=BinormalVectorColor/.CurveVectorStyle;
ncolor=NormalVectorColor/.CurveVectorStyle;
gn=Graphics3D[{
StyledCurve[c,{u0,u1},
opts],
StyledRuledPatch[c,n,{u0,u1},{0,rw},
FillStyle->{FaceForm[ncolor,Lighter[ncolor,.5]],Opacity[0.85],EdgeForm[]},
opts]//AddShadow,
{}}];
gb=Graphics3D[{
StyledCurve[c,{u0,u1},
opts],
StyledRuledPatch[c,b,{u0,u1},{0,rw},
FillStyle->{FaceForm[bcolor,Lighter[bcolor,.5]],Opacity[0.85],EdgeForm[]},
opts]//AddShadow,
{}}];
{gn,gb}]
Module[{c,u0,u1,frpp},
c=KnotData[{"TorusKnot",{1,3}},"SpaceCurve"];
c//PrettyParameters//Print;
{u0,u1}={0,2\[Pi]};
frpp=FrenetRibbonPlotPair[c,{u0,u1},
InterpolationPoints->64,
CurveDivisions->500,
Lighting->NeutralLighting[.8]];
GraphicsRow[frpp,Method->{"ShrinkWrap"->True}]/.OrigamiStyle[]
]//ShowExample
Options[CurveSpeed]={
Simplification->None,
Assumptions->{}
};
CurveSpeed[c_Function,opts___]:=Module[{si,as,sfn,dc,s},
si=Simplification/.{opts}/.Options[CurveSpeed];
as=Assumptions/.{opts}/.Options[CurveSpeed];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
dc=Functionize[s,c'[s]//sfn];
Functionize[s,Mag[dc[s]]//sfn]]
Module[{c,ds},
c=2{Cos[#],Sin[#]}&;
Print["c = ",c//PrettyParameters];
ds=CurveSpeed[c,Simplification->Simplify];
Print["ds = ",ds//PrettyParameters];
]//ShowExample
Module[{c,ds},
c={2Cos[#],Sin[#]}&;
Print["c = ",c//PrettyParameters];
ds=CurveSpeed[c,Simplification->Simplify];
Print["ds = ",ds//PrettyParameters];
]//ShowExample
NCurveSpeed[c_Function|c_InterpolatingFunction, {u0_, u1_}, opts___]:=Module[{s,dc},
dc=Functionize[s,c'[s]];
FunctionInterpolationAlt[Mag[dc[s]],{s,u0,u1},opts]]
Module[{c,ds},
c=2{Cos[#],Sin[#]}&;
Print["c = ",c//PrettyParameters];
ds=NCurveSpeed[c,{0,\[Pi]}];
Print["ds = ",ds];
]//ShowExample
Module[{c,ds},
c={2Cos[#],Sin[#]}&;
Print["c = ",c//PrettyParameters];
ds=NCurveSpeed[c,{0,\[Pi]}];
Print["ds = ",ds];
]//ShowExample
MatchCurveSpeed::nosoln="DSolve couldn's solve for the reparameterization.";
Options[MatchCurveSpeed]={
Simplification->None,
Assumptions->{}
};
StrictArguments[MatchCurveSpeed];
MatchCurveSpeed[c1_Function,c2_Function,ui_,opts___]:=Module[{dsopts,si,as,sfn,s,dc1,dc2,f,soln},
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
si=Simplification/.{opts}/.Options[MatchCurveSpeed];
as=Assumptions/.{opts}/.Options[MatchCurveSpeed];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
dc1=Functionize[s,c1'[s]//sfn];
dc2=Functionize[s,c2'[s]//sfn];
soln=DSolve[{
f'[s]\[Sqrt](dc2[f[s]] . dc2[f[s]])==\[Sqrt](dc1[s] . dc1[s]),
f[ui]==ui},
f[s],s,Evaluate[dsopts]];
If[Head[soln]===DSolve,Message[MatchCurveSpeed::nosoln];Abort[]];
soln=Flatten[soln];
Functionize[s,c2[f[s]]/.soln//sfn]]
Module[{s,c1,sd1,c2,sd2,c3,sd3},
c1=2{Cos[#],Sin[#]}&;
sd1=Simplify[Mag[D[c1[s],s]],{s\[Element]Reals}];
Print["c1 = ",c1//PrettyParameters];
Print["sd1 = ",sd1/.s->"s"];
c2=3{Cos[#],Sin[#]}&;
sd2=Simplify[Mag[D[c2[s],s]],{s\[Element]Reals}];
Print["c2 = ",c2//PrettyParameters];
Print["sd2 = ",sd2/.s->"s"];
c3=MatchCurveSpeed[c1,c2,0,Simplification->Simplify];
sd3=Simplify[Mag[D[c3[s],s]],{s\[Element]Reals}];
Print["c3 = ",c3//PrettyParameters];
Print["sd3 = ",sd3/.s->"s"];
]//ShowExample
Module[{s,c1,sd1,c2,sd2,c3,sd3},
c1={#,0}&;
sd1=Simplify[Mag[D[c1[s],s]],{s\[Element]Reals}];
Print["c1 = ",c1//PrettyParameters];
Print["sd1 = ",sd1/.s->"s"];
c2={#,#^2}&;
sd2=Simplify[Mag[D[c2[s],s]],{s\[Element]Reals}];
Print["c2 = ",c2//PrettyParameters];
Print["sd2 = ",sd2/.s->"s"];
c3=MatchCurveSpeed[c1,c2,0,Simplification->Simplify];
sd3=Simplify[Mag[D[c3[s],s]],{s\[Element]Reals}];
Print["c3 = ",c3//PrettyParameters];
Print["sd3 = ",sd3/.s->"s"];
]//ShowExample
NMatchCurveSpeed::nosoln="NDSolve couldn's solve for the reparameterization.";
StrictArguments[NMatchCurveSpeed];
NMatchCurveSpeed[c1_Function|c1_InterpolatingFunction,c2_Function|c2_InterpolatingFunction,ui_, {u0_,u1_},opts___]:=Module[{dsopts,s,dc1,dc2,f,soln},
dsopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
dc1=Functionize[s,c1'[s]];
dc2=Functionize[s,c2'[s]];
soln=NDSolve[{
f'[s]\[Sqrt](dc2[f[s]] . dc2[f[s]])==\[Sqrt](dc1[s] . dc1[s]),
f[ui]==ui},
f[s],{s,u0,u1},Evaluate[dsopts]];
If[Head[soln]===NDSolve,Message[NMatchCurveSpeed::nosoln];Abort[]];
soln=Flatten[soln];
f=Functionize[s,f[s]/.soln];
FunctionInterpolationAlt[c2[f[s]],{s,u0,u1},opts]]
Module[{u0,u1,s,c1,sd1,c2,sd2,c3,sd3},
{u0,u1}={0,1};
c1=2{Cos[#],Sin[#]}&;
sd1=CurveSpeed[c1];
Print["c1 = ",c1];
c2=3{Cos[#],Sin[#]}&;
sd2=CurveSpeed[c2];
Print["c2 = ",c2];
c3=NMatchCurveSpeed[c1,c2,0,{u0,u1}];
sd3=NCurveSpeed[c3,{u0,u1}];
Print["c3 = ",c3];
GraphicsGrid[{{
ParametricPlot[{c1[s],c2[s]},{s,u0,u1},
PlotRange->{{1,3},{0,1}},
PlotLabel->"unmatched curves"],
Plot[{sd1[s],sd2[s]},{s,u0,u1},
PlotRange->{All,{0,4}},
PlotLabel->"unmatched speeds"]},{
ParametricPlot[{c1[s],c3[s]},{s,u0,u1},
PlotRange->{{1,3},{0,1}},
PlotLabel->"matched curves"],
Plot[{sd1[s],sd3[s]},{s,u0,u1},
PlotRange->{All,{0,4}},
PlotLabel->"matched speeds"]}}]
]//ShowExample
Module[{u0,u1,s,c1,sd1,c2,sd2,c3,sd3,dom3},
{u0,u1}={0.01,1};
c1={#,0}&;
sd1=CurveSpeed[c1];
Print["c1 = ",c1];
Print["sd1 = ",sd1//PrettyParameters];
c2={#,#^2}&;
sd2=CurveSpeed[c2];
Print["c2 = ",c2];
Print["sd2 = ",sd2//PrettyParameters];
c3=NMatchCurveSpeed[c1,c2,0,{u0,u1}];
sd3=NCurveSpeed[c3,{u0,u1}];
GraphicsGrid[{{
ParametricPlot[{c1[s],c2[s]},{s,u0,u1},
PlotRange->{{0,1},{0,1}},
PlotLabel->"unmatched curves"],
Plot[{sd1[s],sd2[s]},{s,u0,u1},
PlotRange->{All,{0,4}},
PlotLabel->"unmatched speeds"]},{
ParametricPlot[{c1[s],c3[s]},{s,u0,u1},
PlotRange->{{0,1},{0,1}},
PlotLabel->"matched curves"],
Plot[{sd1[s],sd3[s]},{s,u0,u1},
PlotRange->{All,{0,4}},
PlotLabel->"matched speeds"]}}]
]//ShowExample
NormalVectorLength::usage="NormalVectorLength is an option to StyledSurfaceNormalGrid that specifies the lengths of the surface normal vectors.";
SurfaceColorFunction::usage="SurfaceColorFunction is an option to StyledSurfaceNormalGrid and GaussMapGrid that specifies the color to use to represent surface normal vectors.";
GridDivisions::usage="GridDivisions is an option to StyledSurfaceNormalGrid that specifies the number of divisions in the u and v directions.";
Options[StyledSurfaceNormalGrid]={
NormalVectorLength->.5,
GridDivisions->{5,5},
SurfaceColorFunction->Automatic
};
StyledSurfaceNormalGrid[ss_Function,uu_Function,{u0_,u1_},{v0_,v1_},opts___]:=Module[{nvl,nu,nv,sncf,du,dv},
nvl=NormalVectorLength/.{opts}/.Options[StyledSurfaceNormalGrid];
{nu,nv}=GridDivisions/.{opts}/.Options[StyledSurfaceNormalGrid];
sncf=SurfaceColorFunction/.{opts}/.Options[StyledSurfaceNormalGrid];
If[sncf===Automatic,sncf=SurfaceNormalVectorColor&];
du=(u1-u0)/nu;
dv=(v1-v0)/nv;
Table[StyledVector[{ss[u,v],ss[u,v]+nvl uu[u,v]},VectorColor->sncf[u,v],opts],{u,u0,u1,du},{v,v0,v1,dv}]]
Module[{a,b,ss,uu,u0,u1,v0,v1,sng},
ss={#1,#2,a #1^2+b #2^2}&;
uu={-((2 a #1)/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))),-((2 b #2)/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))),1/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))}&;
{a,b}={-.4,-.6};
{u0,u1}={-1,1};
{v0,v1}={-1,1};
sng=StyledSurfaceNormalGrid[ss,uu,{u0,u1},{v0,v1}];
Graphics3D[{
Styled3DAxes[1,1,1],
StyledPatch[ss,{u0,u1},{v0,v1}],
sng,
{}},Lighting->NeutralLighting[.8]]/.CurveVectorStyle/.OrigamiStyle[]
]//ShowExample
Module[{a,b,ss,uu,u0,u1,v0,v1,sng},
ss={#1,#2,a #1^2+b #2^2}&;
uu={-((2 a #1)/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))),-((2 b #2)/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))),1/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))}&;
{a,b}={-.4,-.6};
{u0,u1}={-1,1};
{v0,v1}={-1,1};
sng=StyledSurfaceNormalGrid[ss,uu,{u0,u1},{v0,v1},
NormalVectorLength->0.25,
SurfaceColorFunction->RainbowSurfaceColorFunction[{u0,u1},{v0,v1}]];
Graphics3D[{
Styled3DAxes[1,1,1],
StyledPatch[ss,{u0,u1},{v0,v1}],
sng,
{}},Lighting->NeutralLighting[.8]]/.CurveVectorStyle/.OrigamiStyle[]
]//ShowExample
SurfaceOrientation::usage="SurfaceOrientation is an option to SurfaceNormalFromSurface and related functions that specifies the desired orientation of the surface.";
Options[SurfaceNormalFromSurface]={
SurfaceOrientation->1,
Simplification->None,
Assumptions->{}
};
SurfaceNormalFromSurface[ss_Function, opts___]:=Module[{so,si,as,u,v,sfn,su,sv,uu},
so=SurfaceOrientation/.{opts}/.Options[SurfaceNormalFromSurface];
si=Simplification/.{opts}/.Options[SurfaceNormalFromSurface];
as=Assumptions/.{opts}/.Options[SurfaceNormalFromSurface];
as=Flatten[Join[{u\[Element]Reals,v\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
su=D[ss[u,v],u]//sfn;
sv=D[ss[u,v],v]//sfn;
uu=su\[Cross]sv//sfn;
uu=so uu/Mag[uu]//sfn;
FunctionizeOld[uu,{u,v}]]
Module[{ss},
ss=2{#1,Sin[#2],(1-Cos[#2])}&;
SurfaceNormalFromSurface[ss]// PrettyParameters//Print;
SurfaceNormalFromSurface[ss,SurfaceOrientation->-1]// PrettyParameters//Print;
]//ShowExample
Module[{ss},
ss=2{#1,Sin[#2],(1-Cos[#2])}&;
SurfaceNormalFromSurface[ss,Simplification->Simplify]// PrettyParameters//Print;
SurfaceNormalFromSurface[ss,SurfaceOrientation->-1,Simplification->Simplify]// PrettyParameters//Print;
]//ShowExample
Options[NSurfaceNormalFromSurface]={
SurfaceOrientation->1
};
NSurfaceNormalFromSurface[ss_Function|ss_InterpolatingFunction,{u0_,u1_},{v0_,v1_}, opts___]:=Module[{so,u,v,su,sv,uu},
so=SurfaceOrientation/.{opts}/.Options[NSurfaceNormalFromSurface];
su=D[ss[u,v],u];
sv=D[ss[u,v],v];
uu=su\[Cross]sv;
uu=so uu/Mag[uu];
FunctionInterpolationAlt[uu,{u,u0,u1},{v,v0,v1},Sequence@@FilterRules[opts,Options[FunctionInterpolation]]]]
Module[{u0,u1,v0,v1,ss,uu},
{u0,u1}={0,1};
{v0,v1}={-\[Pi]/3,\[Pi]/3};
ss=2{#1,Sin[#2],Cos[#2]-1}&;
uu=NSurfaceNormalFromSurface[ss,{u0,u1},{v0,v1},SurfaceOrientation->+1];
Graphics3D[{
Styled3DAxes[2.2,2,1],
StyledPatch[ss,{u0,u1},{v0,v1}],
StyledSurfaceNormalGrid[ss,uu,{u0,u1},{v0,v1}],
{}},Lighting->NeutralLighting[.9]]/.CurveVectorStyle/.OrigamiStyle[]
]//ShowExample
Options[StyledGaussianSphere]={
ShowGaussianSphere->True,
GaussianSphereRadius->0.99
};
StyledGaussianSphere[opts___]:=Module[{sgs,gsr},
sgs=ShowGaussianSphere/.{opts}/.Options[StyledGaussianSphere];
gsr=GaussianSphereRadius/.{opts}/.Options[StyledGaussianSphere];
If[sgs,Style[Sphere[{0,0,0},gsr],Opacity[0.5]],{}]]
Module[{},
Graphics3D[StyledGaussianSphere[]]
]//ShowExample
Options[StyledGaussMapGrid]={
UDivisions->5,
VDivisions->5,
GaussMapPointSize->.02,
SurfaceColorFunction->Automatic
};
GaussMapPointSize::usage="GaussMapPointSize is an option to StyledGaussMapGrid that specifies the point size to use for the grid points.";
StyledGaussMapGrid[uu_Function,{u0_,u1_},{v0_,v1_},opts___]:=Module[{nvl,nu,nv,gmps,sncf,du,dv},
nvl=NormalVectorLength/.{opts}/.Options[StyledGaussMapGrid];
nu=UDivisions/.{opts}/.Options[StyledGaussMapGrid];
nv=VDivisions/.{opts}/.Options[StyledGaussMapGrid];
gmps=GaussMapPointSize/.{opts}/.Options[StyledGaussMapGrid];
sncf=SurfaceColorFunction/.{opts}/.Options[StyledGaussMapGrid];
If[sncf===Automatic,sncf=SurfaceNormalVectorColor&];
du=(u1-u0)/nu;
dv=(v1-v0)/nv;
Table[Style[Sphere[uu[u,v],gmps],sncf[u,v]],{u,u0,u1,du},{v,v0,v1,dv}]]
Module[{a,b,ss,uu,u0,u1,v0,v1,sncf,sng,gmg,ggs,ggm},
ss={#1,#2,a #1^2+b #2^2}&;
uu={-((2 a #1)/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))),-((2 b #2)/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))),1/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))}&;
{a,b}={-.3,-.5};
{u0,u1}={-1,1};
{v0,v1}={-1,1};
sncf=RainbowSurfaceColorFunction[{u0,u1},{v0,v1}];
sng=StyledSurfaceNormalGrid[ss,uu,{u0,u1},{v0,v1},NormalVectorLength->0.25,SurfaceColorFunction->sncf];
gmg=StyledGaussMapGrid[uu,{u0,u1},{v0,v1},
GaussMapPointSize->0.1,
SurfaceColorFunction->sncf];
ggs=Graphics3D[{StyledPatch[ss,{u0,u1},{v0,v1}],sng},
Lighting->NeutralLighting[.8]]/.CurveVectorStyle/.OrigamiStyle[];
ggm=Graphics3D[{StyledGaussianSphere[],gmg}]/.CurveVectorStyle/.OrigamiStyle[];
GraphicsRow[{ggs,ggm}]
]//ShowExample
Module[{a,b,ss,uu,u0,u1,v0,v1,sncf,sng,gmg,ggs,ggm},
ss={#1,#2,a #1^2+b #2^2}&;
uu={-((2 a #1)/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))),-((2 b #2)/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))),1/(\[Sqrt](1+4 a^2 #1^2+4 b^2 #2^2))}&;
{a,b}={-.3,+.3};
{u0,u1}={-1,1};
{v0,v1}={-1,1};
sncf=RainbowSurfaceColorFunction[{u0,u1},{v0,v1}];
sng=StyledSurfaceNormalGrid[ss,uu,{u0,u1},{v0,v1},NormalVectorLength->0.25,SurfaceColorFunction->sncf];
gmg=StyledGaussMapGrid[uu,{u0,u1},{v0,v1},
GaussMapPointSize->0.1,
SurfaceColorFunction->sncf];
ggs=Graphics3D[{StyledPatch[ss,{u0,u1},{v0,v1}],sng},
Lighting->NeutralLighting[.8]]/.CurveVectorStyle/.OrigamiStyle[];
ggm=Graphics3D[{StyledGaussianSphere[],gmg}]/.CurveVectorStyle/.OrigamiStyle[];
GraphicsRow[{ggs,ggm}]
]//ShowExample
SurfaceTangentU::usage="SurfaceTangentU is a key to the rules returned by SurfaceSystem that gives the (unnormalized) tangent vector in the u direction along the surface.";
SurfaceTangentV::usage="SurfaceTangentV is a key to the rules returned by SurfaceSystem that gives the (unnormalized) tangent vector in the v direction along the surface.";
SurfaceNormal::usage="SurfaceNormal is a key to the rules returned by SurfaceSystem that gives the surface normal vector.";
FundamentalFormE::usage="FundamentalFormE is a key to the rules returned by SurfaceSystem that gives the E coefficient of the first fundamental form of the surface.";
FundamentalFormF::usage="FundamentalFormF is a key to the rules returned by SurfaceSystem that gives the F coefficient of the first fundamental form of the surface.";
FundamentalFormG::usage="FundamentalFormG is a key to the rules returned by SurfaceSystem that gives the G coefficient of the first fundamental form of the surface.";
FundamentalFormL::usage="FundamentalFormL is a key to the rules returned by SurfaceSystem that gives the L coefficient of the second fundamental form of the surface.";
FundamentalFormM::usage="FundamentalFormM is a key to the rules returned by SurfaceSystem that gives the M coefficient of the second fundamental form of the surface.";
FundamentalFormN::usage="FundamentalFormN is a key to the rules returned by SurfaceSystem that gives the N coefficient of the second fundamental form of the surface.";
GaussianCurvature::usage="GaussianCurvature is a key to the rules returned by SurfaceSystem that gives the Gaussian curvature of the surface.";
MeanCurvature::usage="MeanCurvature is a key to the rules returned by SurfaceSystem that gives the mean curvature of the surface.";
CurvatureMatrix::usage="CurvatureMatrix is a key to the rules returned by SurfaceSystem that gives the curvature matrix of the surface.";
PrincipalCurvatures::usage="PrincipalCurvatures is a key to the rules returned by SurfaceSystem that gives the two principal curvatures of the surface.";
PrincipalDirectionsUV::usage="PrincipalDirectionsUV is a key to the rules returned by SurfaceSystem that gives the two principal directions of the surface in the parameterized domain.";
PrincipalDirections::usage="PrincipalDirections is a key to the rules returned by SurfaceSystem that gives the two principal directions of curvature of the surface.";
PrincipalAnalysis::usage="PrincipalAnalysis is an option to SurfaceSystem that specifies whether to compute the principal directions and curvatures from the curvature matrix.";
Options[SurfaceSystem]={
Simplification->None,
Assumptions->{},
PrincipalAnalysis->True
};
SurfaceSystem[ss_Function,opts___] := Module[{si,as,pa,u,v,sfn,s,su,sv,E,F,G,n,suu,suv,svv,L,M,N,K,H,F1,F2,A,ret,vals,vecs,dirs},
si=Simplification/.{opts}/.Options[SurfaceSystem];
as=Assumptions/.{opts}/.Options[SurfaceSystem];
as=Flatten[Join[{u\[Element]Reals,v\[Element]Reals},as]];
pa=PrincipalAnalysis/.{opts}/.Options[SurfaceSystem];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
s=ss[u,v];
(* first fundamental form *)
su=D[s,u]//sfn;
sv=D[s,v]//sfn;
E=su . su//sfn;
F=su . sv//sfn;
G=sv . sv//sfn;
(* normal vector *)
n=With[{suxsv=su\[Cross]sv//sfn},suxsv/Mag[suxsv]//sfn];
(* second fundamental form *)
suu=D[su,u]//sfn;
suv=D[su,v]//sfn;
svv=D[sv,v]//sfn;
L=suu . n//sfn;
M=suv . n//sfn;
N=svv . n//sfn;
(* Gaussian curvature *)
K=(L N-M^2)/(E G-F^2)//sfn;
(* Mean curvature *)
H=(E N - 2 F M+G L)/(2(E G-F^2))//sfn;
(* first fundamental form matrix *)
F1={{E,F},{F,G}};
(* second fundamental form matrix *)
F2={{L,M},{M,N}};
(* curvature matrix *)
A=Inverse[F1] . F2//sfn;
(* basic return values *)
ret={
SurfaceTangentU-> FunctionizeOld[su,{u,v}],
SurfaceTangentV-> FunctionizeOld[sv,{u,v}],
SurfaceNormal->FunctionizeOld[n,{u,v}],
FundamentalFormE->FunctionizeOld[E,{u,v}],
FundamentalFormF->FunctionizeOld[F,{u,v}],
FundamentalFormG->FunctionizeOld[G,{u,v}],
FundamentalFormL->FunctionizeOld[L,{u,v}],
FundamentalFormM->FunctionizeOld[M,{u,v}],
FundamentalFormN->FunctionizeOld[N,{u,v}],
GaussianCurvature->FunctionizeOld[K,{u,v}],
MeanCurvature->FunctionizeOld[H,{u,v}],
CurvatureMatrix->FunctionizeOld[A,{u,v}]};
If[pa,
{vals,vecs}=Eigensystem[A]//sfn;
dirs=vecs . {su,sv}//sfn;
vecs=NormalizeReal/@vecs//sfn;
dirs=NormalizeReal/@dirs//sfn;
JoinTo[ret,
{PrincipalCurvatures->(FunctionizeOld[#,{u,v}]&/@vals),
PrincipalDirectionsUV->(FunctionizeOld[#,{u,v}]&/@vecs),
PrincipalDirections->(FunctionizeOld[#,{u,v}]&/@dirs)}]];
ret]
Module[{ss},
ss=2{#1,Sin[#2],(1-Cos[#2])}&;
SurfaceSystem[ss]// PrettyParameters
]//ShowExample
Module[{ss},
ss=2{#1,Sin[#2],(1-Cos[#2])}&;
SurfaceSystem[ss,Simplification->Simplify]// PrettyParameters
]//ShowExample
NormalCurvature3D::usage="NormalCurvature3D is a key to the rules returned by CurveInSurface3DSystem that gives the normal curvature for a parameterized space curve embedded in a surface.";
GeodesicCurvature3D::usage="GeodesicCurvature3D is a key to the rules returned by CurveInSurface3DSystem that gives the geodesic curvature for a parameterized space curve embedded in a surface.";
GeodesicTorsion3D::usage="GeodesicTorsion3D is a key to the rules returned by CurveInSurface3DSystem that gives the geodesic torsion for a parameterized space curve embedded in a surface.";
FrenetDarbouxAngle::usage="FrenetDarbouxAngle is a key to the rules returned by CurveInSurface3DSystem that gives the rotation angle from the Frenet frame to the Darboux frame for a parameterized space curve embedded in a surface.";
SurfaceNormalVector3D::usage="SurfaceNormalVector3D is a key to the rules returned by CurveInSurface3DSystem that gives the oriented surface normal vector function for a parameterized space curve embedded in a surface.";
TangentNormalVector3D::usage="SurfaceNormalVector3D is a key to the rules returned by CurveInSurface3DSystem that gives the oriented tangent normal vector function for a parameterized space curve embedded in a surface.";
DarbouxVectorLength::usage="DarbouxVectorLength is an option to DarboxFrameElems that specifies the lengths of the Darboux frame vectors to use in rendering.";
DarbouxVectorLabels::usage="DarbouxVectorLabels is an option to StyledDarbouxTrihedron that specifies the labels on the Darboux frame vectors.";
Options[StyledDarbouxTrihedron]={
DarbouxVectorLength->1,
DarbouxVectorLabels->{"","",""}
};
StyledDarbouxTrihedron[p_List, t_List,l_List,u_List,opts___]:=Module[{dvr,dvl},
dvr=DarbouxVectorLength/.{opts}/.Options[StyledDarbouxTrihedron];
dvl=DarbouxVectorLabels/.{opts}/.Options[StyledDarbouxTrihedron];
{StyledVector[{p,p+dvr t},VectorColor->TangentVectorColor,VectorLabel->dvl[[1]],opts],
StyledVector[{p,p+dvr l},VectorColor->TangentNormalVectorColor,VectorLabel->dvl[[2]],opts],
StyledVector[{p,p+dvr u},VectorColor->SurfaceNormalVectorColor,VectorLabel->dvl[[3]],opts]}]
Module[{dfe},
dfe=StyledDarbouxTrihedron[{0,0,0},{1,0,0},{0,1,0},{0,0,1},DarbouxVectorLength->1,DarbouxVectorLabels->{"t","l","u"}];
Graphics3D[dfe]/.CurveVectorStyle
]//ShowExample
Options[Darboux3DSystem]={
Simplification->None,
Assumptions->{}
};
Darboux3DSystem[c_Function,u_Function,opts___]:=Module[{si,as,s,sfn,dc,ds,t,l,dt,\[Kappa]g,\[Kappa]n,\[Tau]g},
si=Simplification/.{opts}/.Options[Darboux3DSystem];
as=Assumptions/.{opts}/.Options[Darboux3DSystem];
as=Flatten[Join[{t\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
(* curve speed *)
dc=Functionize[s,c'[s]//sfn];
ds=Functionize[s,Mag[dc[s]]//sfn];
(* Darboux frame *)
t=Functionize[s,dc[s]/ds[s]//sfn];
l=Functionize[s,u[s]\[Cross]t[s]//sfn];
(* geodesic curvature, normal curvature, geodesic torsion *)
dt=Functionize[s,t'[s]//sfn];
\[Kappa]g=Functionize[s,l[s] . dt[s]/ds[s]//sfn];
\[Kappa]n=Functionize[s,u[s] . dt[s]/ds[s]//sfn];
\[Tau]g=Functionize[s,-l[s] . u'[s]/ds[s]//sfn];
{Speed3D->ds,
GeodesicCurvature3D->\[Kappa]g,
NormalCurvature3D->\[Kappa]n,
GeodesicTorsion3D->\[Tau]g,
TangentVector3D->t,
TangentNormalVector3D->l,
SurfaceNormalVector3D->u}]
Block[{sfn,as,ss,u,v,t,ssu,ssv,soln,uuu,\[Alpha],qq,cc,uu,csys,dsys},
Assumptions->{\[Alpha]\[Element]Reals};
sfn=Simplify[#,as]&;
(* the surface *)
ss={#1,#2,#1^2+3#2^2}&;
Print["ss[u,v] = ",ss//PrettyParameters];
(* two principle lines of curvature *)
ssu=Functionize[u,ss[u,0]//sfn];
ssv=Functionize[v,ss[0,v]//sfn];
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss,Simplification->Simplify,Assumptions->as];
Print["uuu[u,v] = ",uuu//PrettyParameters];
(* line of curve in parameterized space, rotated at angle \[Alpha] *)
qq={# Cos[\[Alpha]],# Sin[\[Alpha]]}&;
Print["qq[t] = ",qq//PrettyParameters];
(* curve function on one variable *)
cc=Functionize[t,ss@@qq[t]];
Print["cc[t] = ",cc//PrettyParameters];
(* surface normal on one variable *)
uu=Functionize[t,uuu@@qq[t]];
Print["uu[t] = ",uu//PrettyParameters];
(* compute the system *)
csys=Curve3DSystem[cc,Simplification->Simplify,Assumptions->as];
Print["Curve3DSystem"];
csys//PrettyParameters//ColumnForm//Print;
dsys=Darboux3DSystem[cc,uu,Simplification->Simplify,Assumptions->as];
Print["Darboux3DSystem"];
dsys//PrettyParameters//ColumnForm//Print;
Block[{r,dr,t0,fda,kn,kg,tg,kp,ta,ds,tt,nn,bb,ll},
r=0.3;(* lateral size of plot *)
dr=0.1;(* vector lengths *)
t0=0.15;(* point to plot *)
\[Alpha]=30\[Degree]; (* rotation angle *)
Print["*** NUMERICAL ***"];
dsys//PrettyParameters//ColumnForm//Print;
{ds,tt,nn,bb,ll,uu,kn,kg,tg,kp,ta}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D,TangentNormalVector3D,SurfaceNormalVector3D,NormalCurvature3D,GeodesicCurvature3D,GeodesicTorsion3D,Curvature3D,Torsion3D}/.csys/.dsys;
Print["\[Alpha] = ",\[Alpha]/\[Degree],"\[Degree]"];
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(n\)]\)[t0] = ",kn[t0]];
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(g\)]\)[t0] = ",kg[t0]];
Print["\!\(\*SubscriptBox[\(\[Tau]\), \(g\)]\)[t0] = ",tg[t0]];
Print["\[Kappa][t0] = ",kp[t0]];
Print["\[Tau][t0] = ",ta[t0]];
(* Check consistency with the Darboux frame differential equation. *)
Print["\[CapitalDelta]dt = ",tt'[t0]-ds[t0](0 tt[t0]+kg[t0]ll[t0]+kn[t0]uu[t0])//Chop];
Print["\[CapitalDelta]dl = ",ll'[t0]-ds[t0](-kg[t0]tt[t0]+0 ll[t0]+tg[t0]uu[t0])//Chop];
Print["\[CapitalDelta]du = ",uu'[t0]-ds[t0](-kn[t0]tt[t0]-tg[t0]ll[t0]+0uu[t0])//Chop];
Graphics3D[{
StyledPatch[ss,{-r,r},{-r,r},OutlineStyle->BorderLine],
StyledCurve[cc,{-r,r},LineStyle->{DarkGray,Thickness[.005]}],
StyledCurve[ssu,{-r,r},LineStyle->{Gray}],
StyledCurve[ssv,{-r,r},LineStyle->{Gray}],
StyledFrenetTrihedron[cc[t0],tt[t0],nn[t0],bb[t0],FrenetVectorLength->dr],
StyledDarbouxTrihedron[cc[t0],tt[t0],ll[t0],uu[t0],DarbouxVectorLength->dr],
Style[Sphere[cc[t0],.015],Black],
{}}//AddShadow]/.OrigamiStyle[]/.CurveVectorStyle
]]//ShowExample
Module[{ss1,ss2,soln,uuu,ff,uu,csys,dsys},
ss1={#1,Sin[#2],1-Cos[#2]}&;
Print["ss1 = ",ss1//PrettyParameters];
ss2={1-Cos[#2],Sin[#2],#1}&;
Print["ss2 = ",ss2]//PrettyParameters;
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss1,Simplification->Simplify];
Print["uuu = ",uuu//PrettyParameters];
(* curve function and surface normal on one variable *)
ff={1-Cos[#],Sin[#],1-Cos[#]}&;
Print["ff = ",ff//PrettyParameters];
uu={0,-Sin[#],Cos[#]}&;
Print["uu = ",uu//PrettyParameters];
(* compute the system *)
csys=Curve3DSystem[ff,Simplification->Simplify];
Print[csys//PrettyParameters//ColumnForm];
dsys=Darboux3DSystem[ff,uu,Simplification->Simplify];
Print[dsys//PrettyParameters//ColumnForm];
Graphics3D[{
StyledPatch[ss1,{-1.,1.5},{-\[Pi]/2,\[Pi]/2},OutlineStyle->BorderLine],
StyledPatch[ss2,{-.5,1.5},{-\[Pi]/2,\[Pi]/2},OutlineStyle->BorderLine,FillStyle->{Gray,Opacity[0.25],EdgeForm[]}],
StyledCurve[ff,{-\[Pi]/2,\[Pi]/2},LineStyle->{DarkGray,Thickness[.015]}],
{}}//AddShadow]/.OrigamiStyle[]
]//ShowExample
Block[{ss,t,ff,uu,csys,dsys,tt,nn,bb,ll,du,dv,dt,t0,dr,\[Kappa]g,\[Kappa]n,\[Eta],gg},
du=1/10;
dv=1/10;
dt=1/10;
dr=0.3;
t0=0.5;
(* curved surface, which happens to be an isometric mapping *)
ss={#1,#2,(1-Cos[#2])}&;
(* curved function, sinusoid in original paper *)
ff=Functionize[t,ss[Cos[t]-1,t]];
Print["ff = ",ff//PrettyParameters];
uu=Functionize[t,SurfaceNormalFromSurface[ss][Cos[t]-1,t]];
Print["uu = ",uu//PrettyParameters];
csys=Curve3DSystem[ff,Simplification->Simplify];
Print[csys//PrettyParameters//ColumnForm];
dsys=Darboux3DSystem[ff,uu,Simplification->Simplify];
Print[dsys//PrettyParameters//ColumnForm];
(* Frenet-Darboux angle *)
{\[Kappa]g,\[Kappa]n}={GeodesicCurvature3D,NormalCurvature3D}/.dsys;
PrintThis[\[Kappa]g[t0]];
PrintThis[\[Kappa]n[t0]];
(* Frenet and Darboux frame components *)
{tt,nn,bb}={TangentVector3D,NormalVector3D,BinormalVector3D}/.csys;
ll=TangentNormalVector3D/.dsys;
(* Plot the Frenet and Darboux frames at a specified point *)
gg=
Graphics3D[{
StyledPatch[ss,{-1,.5},{-1,1},OutlineStyle->BorderLine],
StyledCurve[ff,{-1,1},LineStyle->{Thickness[0.005],DarkGray}],
Style[Sphere[ff[t0],.05],Black],
{}}//AddShadow,Boxed->False,Axes->False];
GraphicsRow[{
Show[gg,Graphics3D[{
StyledFrenetTrihedron[ff[t0],tt[t0],nn[t0],bb[t0],FrenetVectorLength->dr],
{}}],PlotLabel->"Frenet frame"],
Show[gg,Graphics3D[{
StyledDarbouxTrihedron[ff[t0],tt[t0],ll[t0],uu[t0],DarbouxVectorLength->dr],
{}}],PlotLabel->"Darboux frame"]},ImageSize->600]/.CurveVectorStyle/.OrigamiStyle[]
]//ShowExample
Block[{as,k1,k2,ss,u,v,t,ssu,ssv,soln,uuu,\[Alpha],qq,ff,uu,csys,dsys,tt,nn,bb,ll,fda,kn,kg,tg,r},
as={\[Alpha]\[Element]Reals};
(* the surface *)
ss={#1,#2,(1/2)k1 #1^2+(1/2)k2 #2^2}&;
Print["ss = ",ss//PrettyParameters];
(* two principle lines of curvature *)
ssu=Functionize[u,ss[u,0]];
ssv=Functionize[v,ss[0,v]];
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss,Simplification->Simplify];
Print["uuu = ",uuu//PrettyParameters];
(* line of curve in parameterized space *)
qq={# Cos[\[Alpha]],# Sin[\[Alpha]]}&;
Print["qq = ",qq//PrettyParameters];
(* curve function on one variable *)
ff=Functionize[t,ss@@qq[t]];
Print["ff = ",ff//PrettyParameters];
(* surface normal on one variable *)
uu=Functionize[t,uuu@@qq[t]];
Print["uu = ",uu//PrettyParameters];
(* compute the system *)
csys=Curve3DSystem[ff,Simplification->Simplify,Assumptions->as];
Print[csys//PrettyParameters//ColumnForm]//Hold;
dsys=Darboux3DSystem[ff,uu,Simplification->Simplify,Assumptions->as];
Print[dsys//PrettyParameters//ColumnForm]//Hold;
{tt,nn,bb,ll,kn,kg,tg}={TangentVector3D,NormalVector3D,BinormalVector3D,TangentNormalVector3D,NormalCurvature3D,GeodesicCurvature3D,GeodesicTorsion3D}/.csys/.dsys;
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(n\)]\)[0] = ",Simplify[kn[0],as]];
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(g\)]\)[0] = ",Simplify[kg[0],as]];
Print["\!\(\*SubscriptBox[\(\[Tau]\), \(g\)]\)[0] = ",Simplify[tg[0],as]];
r=0.3;
\[Alpha]=30.\[Degree];
k1=1;
k2=2;
Graphics3D[{
StyledPatch[ss,{-r,r},{-r,r},OutlineStyle->BorderLine],
StyledCurve[ssu,{-r,r},LineStyle->{Gray}],
StyledCurve[ssv,{-r,r},LineStyle->{Gray}],
StyledCurve[ff,{-r,r},LineStyle->{DarkGray,Thickness[.015]}],
{}}//AddShadow]/.OrigamiStyle[]/.CurveVectorStyle
]//ShowExample
Block[{as,k1,k2,ss,ssu,ssv,soln,uuu,qq,\[Alpha],u,v,t,ff,uu,csys,dsys,tt,nn,bb,ll,fda,kn,kg,tg,r},
as={\[Alpha]\[Element]Reals};
(* the surface *)
ss={#1,#2,(1/2)k1 #1^2+(1/2)k2 #2^2}&;
Print["ss[u,v] = ",ss//PrettyParameters];
(* two principle lines of curvature *)
ssu=Functionize[u,ss[u,0]];
ssv=Functionize[v,ss[0,v]];
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss,Simplification->Simplify];
Print["uuu[u,v] = ",uuu//PrettyParameters];
(* line of curve in parameterized space *)
qq={Cos[\[Alpha]] #1-Sin[\[Alpha]] #1^2,Sin[\[Alpha]] #1+Cos[\[Alpha]] #1^2}&;
Print["qq[t] = ",qq//PrettyParameters];
(* curve function on one variable *)
ff=FunctionizeOld[ss@@qq[t],t];
Print["ff[t] = ",ff//PrettyParameters];
(* surface normal on one variable *)
uu=FunctionizeOld[uuu@@qq[t],t];
Print["uu[t] = ",uu//PrettyParameters];
(* compute the system *)
csys=Curve3DSystem[ff,Simplification->None,Assumptions->as];
Print[csys//PrettyParameters//ColumnForm]//Hold;
dsys=Darboux3DSystem[ff,uu,Simplification->None,Assumptions->as];
Print[dsys//PrettyParameters//ColumnForm]//Hold;
{tt,nn,bb,ll,kn,kg,tg}={TangentVector3D,NormalVector3D,BinormalVector3D,TangentNormalVector3D,NormalCurvature3D,GeodesicCurvature3D,GeodesicTorsion3D}/.csys/.dsys;
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(n\)]\)[0] = ",Simplify[kn[0],as]];
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(g\)]\)[0] = ",Simplify[kg[0],as]];
Print["\!\(\*SubscriptBox[\(\[Tau]\), \(g\)]\)[0] = ",Simplify[tg[0],as]];
r=0.3;
\[Alpha]=30.\[Degree];
k1=1;
k2=2;
Graphics3D[{
StyledPatch[ss,{-r,r},{-r,r},OutlineStyle->BorderLine],
StyledCurve[ff,{-r,r},LineStyle->{DarkGray,Thickness[.015]}],
StyledCurve[ssu,{-r,r},LineStyle->{Gray}],
StyledCurve[ssv,{-r,r},LineStyle->{Gray}],
{}}//AddShadow]/.OrigamiStyle[]/.CurveVectorStyle
]//ShowExample
Options[NDarboux3DSystem]={
Simplification->None,
Assumptions->{}
};
NDarboux3DSystem[c_Function|c_InterpolatingFunction,u_Function|u_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{fiopts,s,dc,ds,t,l,dt,\[Kappa]g,\[Kappa]n,\[Tau]g},
fiopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
(* curve speed *)
dc=Functionize[s,c'[s]];
ds=Functionize[s,Mag[dc[s]]];
(* Darboux frame *)
t=Functionize[s,dc[s]/ds[s]];
l=Functionize[s,u[s]\[Cross]t[s]];
(* geodesic curvature, normal curvature, geodesic torsion *)
dt=Functionize[s,t'[s]];
\[Kappa]g=Functionize[s,l[s] . dt[s]/ds[s]];
\[Kappa]n=Functionize[s,u[s] . dt[s]/ds[s]];
\[Tau]g=Functionize[s,-l[s] . u'[s]/ds[s]];
{Speed3D->FunctionInterpolation[ds[s],{s,u0,u1}],
GeodesicCurvature3D->FunctionInterpolation[\[Kappa]g[s],{s,u0,u1}],
NormalCurvature3D->FunctionInterpolation[\[Kappa]n[s],{s,u0,u1}],
GeodesicTorsion3D->FunctionInterpolation[\[Tau]g[s],{s,u0,u1}],
TangentVector3D->FunctionInterpolationAlt[t[s],{s,u0,u1},fiopts],
TangentNormalVector3D->FunctionInterpolationAlt[l[s],{s,u0,u1},fiopts],
SurfaceNormalVector3D->FunctionInterpolationAlt[u[s],{s,u0,u1},fiopts]}]
Module[{s,cc,uu,u0,u1,dsys,nds,spl,vpl},
cc={#,.1#,.1#^2}&;
uu=Functionize[s,NormalizeReal[{.1s,.1s^2,1}]//Simplify];
{u0,u1}={0,1};
dsys=Darboux3DSystem[cc,uu];
nds=NDarboux3DSystem[cc,uu,{u0,u1}];
spl[var_]:=Module[{},
Print[ToString[var]];
Print[Plot[{(var/.dsys)[s],(var/.dsys)[s]},{s,u0,u1},PlotStyle->{{Red},{Green,Dashed}}]]];
spl[Speed3D];
spl[GeodesicCurvature3D];
spl[NormalCurvature3D];
spl[GeodesicTorsion3D];
vpl[var_]:=Module[{},
Print[ToString[var]];
Print[ParametricPlot3D[{(var/.dsys)[s],(var/.dsys)[s]},{s,u0,u1},PlotStyle->{{Red},{Green,Dashed}}]]];
vpl[TangentVector3D];
vpl[TangentNormalVector3D];
vpl[SurfaceNormalVector3D];
]//ShowExample
Options[Darboux3DSystemOld]={
Simplification->None,
Assumptions->{}
};
Darboux3DSystemOld[ccf_Function,uuf_Function,opts___]:=Module[{si,as,t,sfn,cc,uu,c3s,tt,ds,kp,ta,dcc,ddcc,ll,sd2,kn,ndf3,uuxdcc,kg,fda,dfda,tg},
si=Simplification/.{opts}/.Options[Darboux3DSystemOld];
as=Assumptions/.{opts}/.Options[Darboux3DSystemOld];
as=Flatten[Join[{t\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
cc=ccf[t]//sfn;(* curve *)
uu=uuf[t]//sfn;(* surface normal *)
c3s=Curve3DSystem[ccf,opts];
{tt,ds,kp,ta}=#[t]&/@{TangentVector3D,Speed3D,Curvature3D,Torsion3D}/.c3s;
dcc=D[cc,t]//sfn;(* velocity *)
ddcc=D[dcc,t]//sfn;(* acceleration *)
ll=uu\[Cross]tt//sfn;(* tangent normal *)
sd2=ds^2//sfn;
kn=ddcc . uu/sd2//sfn;(* normal curvature *)
ndf3=ds^3//sfn;
uuxdcc=uu\[Cross]dcc//sfn;
kg=ddcc . uuxdcc/ndf3//sfn;(* geodesic curvature *)
fda=ArcTan[kg,kn]//sfn;(* Frenet-Darboux angle *)
dfda=(kg D[kn,t]-kn D[kg,t])/kp^2//sfn;
tg=ta-dfda/ds//sfn;(* geodesic torsion *)
{(* 3D scalars *)
Speed3D->(Speed3D/.c3s),
Curvature3D->(Curvature3D/.c3s),
Torsion3D->(Torsion3D/.c3s),
NormalCurvature3D->FunctionizeOld[kn,t],
GeodesicCurvature3D->FunctionizeOld[kg,t],
FrenetDarbouxAngle->FunctionizeOld[fda,t],
GeodesicTorsion3D->FunctionizeOld[tg,t],
(* 3D vectors *)
Curve3D->FunctionizeOld[cc,t],
TangentVector3D->(TangentVector3D/.c3s),
NormalVector3D->(NormalVector3D/.c3s),
BinormalVector3D->(BinormalVector3D/.c3s),
SurfaceNormalVector3D->FunctionizeOld[uu,t],
TangentNormalVector3D->FunctionizeOld[ll,t]}]
Block[{ss,u,v,t,ssu,ssv,soln,uuu,\[Alpha],qq,cc,uu,cs3s},
(* the surface *)
ss={#1,#2,#1^2+3#2^2}&;
Print["ss[u,v] = ",ss//PrettyParameters];
(* two principle lines of curvature *)
ssu=FunctionizeOld[ss[u,0],u];
ssv=FunctionizeOld[ss[0,v],v];
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss,Simplification->Simplify];
Print["uuu[u,v] = ",uuu//PrettyParameters];
(* line of curve in parameterized space, rotated at angle \[Alpha] *)
qq={# Cos[\[Alpha]],# Sin[\[Alpha]]}&;
Print["qq[t] = ",qq//PrettyParameters];
(* curve function on one variable *)
cc=FunctionizeOld[ss@@qq[t],t];
Print["cc[t] = ",cc//PrettyParameters];
(* surface normal on one variable *)
uu=FunctionizeOld[uuu@@qq[t],t];
Print["uu[t] = ",uu//PrettyParameters];
(* compute the system *)
cs3s=Darboux3DSystemOld[cc,uu,Simplification->Simplify,Assumptions->{\[Alpha]\[Element]Reals}];
cs3s//PrettyParameters//ColumnForm//Print;
Block[{r,dr,t0,fda,kn,kg,tg,kp,ta,ds,tt,nn,bb,ll},
r=0.3;(* lateral size of plot *)
dr=0.1;(* vector lengths *)
t0=0.15;(* point to plot *)
\[Alpha]=30\[Degree]; (* rotation angle *)
Print["*** NUMERICAL ***"];
cs3s//PrettyParameters//ColumnForm//Print;
{ds,tt,nn,bb,ll,uu,fda,kn,kg,tg,kp,ta}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D,TangentNormalVector3D,SurfaceNormalVector3D,FrenetDarbouxAngle,NormalCurvature3D,GeodesicCurvature3D,GeodesicTorsion3D,Curvature3D,Torsion3D}/.cs3s;
Print["\[Alpha] = ",\[Alpha]/\[Degree],"\[Degree]"];
Print["\[Eta][t0] = ",fda[t0]/\[Degree],"\[Degree]"];
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(n\)]\)[t0] = ",kn[t0]];
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(g\)]\)[t0] = ",kg[t0]];
Print["\!\(\*SubscriptBox[\(\[Tau]\), \(g\)]\)[t0] = ",tg[t0]];
Print["\[Kappa][t0] = ",kp[t0]];
Print["\[Tau][t0] = ",ta[t0]];
(* Check consistency with the Darboux frame differential equation. *)
Print["\[CapitalDelta]dt = ",tt'[t0]-ds[t0](0 tt[t0]+kg[t0]ll[t0]+kn[t0]uu[t0])//Chop];
Print["\[CapitalDelta]dl = ",ll'[t0]-ds[t0](-kg[t0]tt[t0]+0 ll[t0]+tg[t0]uu[t0])//Chop];
Print["\[CapitalDelta]du = ",uu'[t0]-ds[t0](-kn[t0]tt[t0]-tg[t0]ll[t0]+0uu[t0])//Chop];
Graphics3D[{
StyledPatch[ss,{-r,r},{-r,r},OutlineStyle->BorderLine],
StyledCurve[cc,{-r,r},LineStyle->{DarkGray,Thickness[.01]}],
StyledCurve[ssu,{-r,r},LineStyle->{Gray}],
StyledCurve[ssv,{-r,r},LineStyle->{Gray}],
StyledFrenetTrihedron[cc[t0],tt[t0],nn[t0],bb[t0],FrenetVectorLength->dr],
StyledDarbouxTrihedron[cc[t0],tt[t0],ll[t0],uu[t0],DarbouxVectorLength->dr],
Style[Sphere[cc[t0],.015],Black],
{}}//AddShadow]/.OrigamiStyle[]/.CurveVectorStyle
]]//ShowExample
Module[{ss1,ss2,soln,uuu,ff,uu,cs3s},
ss1={#1,Sin[#2],1-Cos[#2]}&;
Print["ss1 = ",ss1//PrettyParameters];
ss2={1-Cos[#2],Sin[#2],#1}&;
Print["ss2 = ",ss2]//PrettyParameters;
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss1,Simplification->Simplify];
Print["uuu = ",uuu//PrettyParameters];
(* curve function and surface normal on one variable *)
ff={1-Cos[#],Sin[#],1-Cos[#]}&;
Print["ff = ",ff//PrettyParameters];
uu={0,-Sin[#],Cos[#]}&;
Print["uu = ",uu//PrettyParameters];
(* compute the system *)
cs3s=Darboux3DSystemOld[ff,uu,Simplification->Simplify];
Print[cs3s//PrettyParameters//ColumnForm];
Graphics3D[{
StyledPatch[ss1,{-1.,1.5},{-\[Pi]/2,\[Pi]/2},OutlineStyle->BorderLine],
StyledPatch[ss2,{-.5,1.5},{-\[Pi]/2,\[Pi]/2},OutlineStyle->BorderLine,FillStyle->{Gray,Opacity[0.25],EdgeForm[]}],
StyledCurve[ff,{-\[Pi]/2,\[Pi]/2},LineStyle->{DarkGray,Thickness[.015]}],
{}}]/.OrigamiStyle[]
]//ShowExample
Block[{ss,t,ff,uu,cs3s,tt,nn,bb,ll,du,dv,dt,t0,dr,\[Kappa]g,\[Kappa]n,\[Eta],gg},
du=1/10;
dv=1/10;
dt=1/10;
dr=0.3;
t0=0.5;
(* curved surface, which happens to be an isometric mapping *)
ss={#1,#2,(1-Cos[#2])}&;
(* curved function, sinusoid in original paper *)
ff=FunctionizeOld[ss[Cos[t]-1,t],t];
Print["ff = ",ff//PrettyParameters];
uu=FunctionizeOld[SurfaceNormalFromSurface[ss][Cos[t]-1,t],t];
Print["uu = ",uu//PrettyParameters];
cs3s=Darboux3DSystemOld[ff,uu,Simplification->Simplify];
Print[cs3s//PrettyParameters//ColumnForm];
(* Frenet-Darboux angle *)
{\[Kappa]g,\[Kappa]n,\[Eta]}={GeodesicCurvature3D,NormalCurvature3D,FrenetDarbouxAngle}/.cs3s;
PrintThis[\[Kappa]g[t0]];
PrintThis[\[Kappa]n[t0]];
PrintThis[\[Eta][t0]/\[Degree]];
(* Frenet and Darboux frame components *)
{tt,nn,bb,ll}={TangentVector3D,NormalVector3D,BinormalVector3D,TangentNormalVector3D}/.cs3s;
(* Plot the Frenet and Darboux frames at a specified point *)
gg=
Graphics3D[{
StyledPatch[ss,{-1,.5},{-1,1},OutlineStyle->BorderLine],
StyledCurve[ff,{-1,1},LineStyle->{Thickness[0.005],DarkGray}],
Style[Sphere[ff[t0],.05],Black],
{}}//AddShadow,Boxed->False,Axes->False];
GraphicsRow[{
Show[gg,Graphics3D[{
StyledFrenetTrihedron[ff[t0],tt[t0],nn[t0],bb[t0],FrenetVectorLength->dr],
{}}],PlotLabel->"Frenet frame"],
Show[gg,Graphics3D[{
StyledDarbouxTrihedron[ff[t0],tt[t0],ll[t0],uu[t0],DarbouxVectorLength->dr],
{}}],PlotLabel->"Darboux frame"]},ImageSize->600]/.CurveVectorStyle/.OrigamiStyle[]
]//ShowExample
Block[{k1,k2,ss,u,v,t,ssu,ssv,soln,uuu,\[Alpha],qq,ff,uu,cs3s,tt,nn,bb,ll,fda,kn,kg,tg,r},
(* the surface *)
ss={#1,#2,(1/2)k1 #1^2+(1/2)k2 #2^2}&;
Print["ss = ",ss//PrettyParameters];
(* two principle lines of curvature *)
ssu=FunctionizeOld[ss[u,0],u];
ssv=FunctionizeOld[ss[0,v],v];
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss,Simplification->Simplify];
Print["uuu = ",uuu//PrettyParameters];
(* line of curve in parameterized space *)
qq={# Cos[\[Alpha]],# Sin[\[Alpha]]}&;
Print["qq = ",qq//PrettyParameters];
(* curve function on one variable *)
ff=FunctionizeOld[ss@@qq[t],t];
Print["ff = ",ff//PrettyParameters];
(* surface normal on one variable *)
uu=FunctionizeOld[uuu@@qq[t],t];
Print["uu = ",uu//PrettyParameters];
(* compute the system *)
cs3s=Darboux3DSystemOld[ff,uu,Simplification->Simplify];
Print[cs3s//PrettyParameters//ColumnForm]//Hold;
{tt,nn,bb,ll,fda,kn,kg,tg}={TangentVector3D,NormalVector3D,BinormalVector3D,TangentNormalVector3D,FrenetDarbouxAngle,NormalCurvature3D,GeodesicCurvature3D,GeodesicTorsion3D}/.cs3s;
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(n\)]\)[0] = ",Simplify[kn[0]]];
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(g\)]\)[0] = ",Simplify[kg[0]]];
Print["\!\(\*SubscriptBox[\(\[Tau]\), \(g\)]\)[0] = ",tg[0]];
r=0.3;
\[Alpha]=30.\[Degree];
k1=1;
k2=2;
Graphics3D[{
StyledPatch[ss,{-r,r},{-r,r},OutlineStyle->BorderLine],
StyledCurve[ssu,{-r,r},LineStyle->{Gray}],
StyledCurve[ssv,{-r,r},LineStyle->{Gray}],
StyledCurve[ff,{-r,r},LineStyle->{DarkGray,Thickness[.015]}],
{}}//AddShadow]/.OrigamiStyle[]/.CurveVectorStyle
]//ShowExample
Block[{k1,k2,ss,ssu,ssv,soln,uuu,qq,\[Alpha],u,v,t,ff,uu,cs3s,tt,nn,bb,ll,fda,kn,kg,tg,r},
(* the surface *)
ss={#1,#2,(1/2)k1 #1^2+(1/2)k2 #2^2}&;
Print["ss[u,v] = ",ss//PrettyParameters];
(* two principle lines of curvature *)
ssu=FunctionizeOld[ss[u,0],u];
ssv=FunctionizeOld[ss[0,v],v];
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss,Simplification->Simplify];
Print["uuu[u,v] = ",uuu//PrettyParameters];
(* line of curve in parameterized space *)
qq={Cos[\[Alpha]] #1-Sin[\[Alpha]] #1^2,Sin[\[Alpha]] #1+Cos[\[Alpha]] #1^2}&;
Print["qq[t] = ",qq//PrettyParameters];
(* curve function on one variable *)
ff=FunctionizeOld[ss@@qq[t],t];
Print["ff[t] = ",ff//PrettyParameters];
(* surface normal on one variable *)
uu=FunctionizeOld[uuu@@qq[t],t];
Print["uu[t] = ",uu//PrettyParameters];
(* compute the system *)
cs3s=Darboux3DSystemOld[ff,uu,Simplification->None];
Print[cs3s//PrettyParameters//ColumnForm]//Hold;
{tt,nn,bb,ll,fda,kn,kg,tg}={TangentVector3D,NormalVector3D,BinormalVector3D,TangentNormalVector3D,FrenetDarbouxAngle,NormalCurvature3D,GeodesicCurvature3D,GeodesicTorsion3D}/.cs3s;
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(n\)]\)[0] = ",Simplify[kn[0]]];
Print["\!\(\*SubscriptBox[\(\[Kappa]\), \(g\)]\)[0] = ",Simplify[kg[0]]];
Print["\!\(\*SubscriptBox[\(\[Tau]\), \(g\)]\)[0] = ",Simplify[tg[0]]];
r=0.3;
\[Alpha]=30.\[Degree];
k1=1;
k2=2;
Graphics3D[{
StyledPatch[ss,{-r,r},{-r,r},OutlineStyle->BorderLine],
StyledCurve[ff,{-r,r},LineStyle->{DarkGray,Thickness[.015]}],
StyledCurve[ssu,{-r,r},LineStyle->{Gray}],
StyledCurve[ssv,{-r,r},LineStyle->{Gray}],
{}}//AddShadow]/.OrigamiStyle[]/.CurveVectorStyle
]//ShowExample
Options[RecoverDarboux3D]={
Simplification->None,
Assumptions->{}
};
RecoverDarboux3D::nosoln="DSolve couldn't integrate the Darboux frame equations.";
StrictArguments[RecoverDarboux3D];
RecoverDarboux3D[{ds_Function,sd\[Kappa]g_Function,sd\[Kappa]n_Function,sd\[Tau]g_Function},{ui_,cci_,tti_,lli_,uui_},opts___]:=Module[{sm,as,sfn,dsopts,s,
soln,ccx,ccy,ccz,ttx,tty,ttz,llx,lly,llz,uux,uuy,uuz,
tt,ll,uu,cc},
sm=Simplification/.{opts}/.Options[RecoverDarboux3D];
as=Join[{s\[Element]Reals},Assumptions/.{opts}/.Options[RecoverDarboux3D]];
sfn=If[sm===None,#&,sm[#,Assumptions->as]&];
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
(* integrate the Darboux frame, which must be done component-wise. *)
soln=DSolve[{
{ccx'[s],ccy'[s],ccz'[s]}==ds[s]{ttx[s],tty[s],ttz[s]},
{ttx'[s],tty'[s],ttz'[s]}==sd\[Kappa]g [s]{llx[s],lly[s],llz[s]}+sd\[Kappa]n[s]{uux[s],uuy[s],uuz[s]},
{llx'[s],lly'[s],llz'[s]}==-sd\[Kappa]g[s] {ttx[s],tty[s],ttz[s]}+sd\[Tau]g[s]{uux[s],uuy[s],uuz[s]},
{uux'[s],uuy'[s],uuz'[s]}==-sd\[Kappa]n[s] {ttx[s],tty[s],ttz[s]}-sd\[Tau]g[s]{llx[s],lly[s],llz[s]},
{ccx[ui],ccy[ui],ccz[ui]}==cci,
{ttx[ui],tty[ui],ttz[ui]}==tti,
{llx[ui],lly[ui],llz[ui]}==lli,
{uux[ui],uuy[ui],uuz[ui]}==uui
},{ccx,ccy,ccz,ttx,tty,ttz,llx,lly,llz,uux,uuy,uuz},s,Evaluate[dsopts]]//Flatten;
If[Head[soln]===DSolve,Message[RecoverDarboux3D::nosoln];Abort[]];
cc=Functionize[s,{ccx[s],ccy[s],ccz[s]}/.soln//sfn];
tt=Functionize[s,{ttx[s],tty[s],ttz[s]}/.soln//sfn];
ll=Functionize[s,{llx[s],lly[s],llz[s]}/.soln//sfn];
uu=Functionize[s,{uux[s],uuy[s],uuz[s]}/.soln//sfn];
{cc,tt,ll,uu}]
Module[{ds,sd\[Kappa]n,sd\[Kappa]g,sd\[Tau]g,ui,cci,tti,lli,uui,cc,tt,ll,uu,u0,u1,u2},
{ds,sd\[Kappa]n,sd\[Kappa]g,sd\[Tau]g}={1&,1&,0&,0&};
{ui,cci,tti,lli,uui}={0,{0,0,0},{1,0,0},{0,1,0},{0,0,1}};
{cc,tt,ll,uu}=RecoverDarboux3D[{ds,sd\[Kappa]n,sd\[Kappa]g,sd\[Tau]g},{ui,cci,tti,lli,uui},Simplification->Simplify];
Print["cc = ",cc//PrettyParameters];
Print["tt = ",tt//PrettyParameters];
Print["ll = ",ll//PrettyParameters];
Print["uu = ",uu//PrettyParameters];
{u0,u1}={0,\[Pi]};
u2=\[Pi]/2;
Graphics3D[{
Styled3DAxes[],
StyledCurve[cc,{u0,u1},CurveDirected->True],
StyledDarbouxTrihedron[cc[u2],tt[u2],ll[u2],uu[u2],DarbouxVectorLength->.5],
{}},Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
NRecoverDarboux3D::nosoln="NDSolve couldn't integrate the Darboux frame equations.";
StrictArguments[NRecoverDarboux3D];
NRecoverDarboux3D[{ds_Function|ds_InterpolatingFunction,sd\[Kappa]g_Function|sd\[Kappa]g_InterpolatingFunction,sd\[Kappa]n_Function|sd\[Kappa]n_InterpolatingFunction,sd\[Tau]g_Function|sd\[Tau]g_InterpolatingFunction},{ui_,cci_,tti_,lli_,uui_},{u0_,u1_},opts___]:=Module[{dsopts,s,
soln,ccx,ccy,ccz,ttx,tty,ttz,llx,lly,llz,uux,uuy,uuz,
tt,ll,uu,cc},
dsopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
(* integrate the Darboux frame, which must be done component-wise. *)
soln=NDSolve[{
{ccx'[s],ccy'[s],ccz'[s]}==ds[s]{ttx[s],tty[s],ttz[s]},
{ttx'[s],tty'[s],ttz'[s]}==sd\[Kappa]g [s]{llx[s],lly[s],llz[s]}+sd\[Kappa]n[s]{uux[s],uuy[s],uuz[s]},
{llx'[s],lly'[s],llz'[s]}==-sd\[Kappa]g[s] {ttx[s],tty[s],ttz[s]}+sd\[Tau]g[s]{uux[s],uuy[s],uuz[s]},
{uux'[s],uuy'[s],uuz'[s]}==-sd\[Kappa]n[s] {ttx[s],tty[s],ttz[s]}-sd\[Tau]g[s]{llx[s],lly[s],llz[s]},
{ccx[ui],ccy[ui],ccz[ui]}==cci,
{ttx[ui],tty[ui],ttz[ui]}==tti,
{llx[ui],lly[ui],llz[ui]}==lli,
{uux[ui],uuy[ui],uuz[ui]}==uui
},{ccx,ccy,ccz,ttx,tty,ttz,llx,lly,llz,uux,uuy,uuz},{s,u0,u1},Evaluate[dsopts]]//Flatten;
If[Head[soln]===NDSolve,Message[NRecoverDarboux3D::nosoln];Abort[]];
cc=Functionize[s,{ccx[s],ccy[s],ccz[s]}/.soln];
tt=Functionize[s,{ttx[s],tty[s],ttz[s]}/.soln];
ll=Functionize[s,{llx[s],lly[s],llz[s]}/.soln];
uu=Functionize[s,{uux[s],uuy[s],uuz[s]}/.soln];
{cc,tt,ll,uu}]
Module[{ds,sd\[Kappa]n,sd\[Kappa]g,sd\[Tau]g,ui,cci,tti,lli,uui,cc,tt,ll,uu,u0,u1,u2},
{ds,sd\[Kappa]n,sd\[Kappa]g,sd\[Tau]g}={1&,1&,0&,0&};
{ui,cci,tti,lli,uui}={0,{0,0,0},{1,0,0},{0,1,0},{0,0,1}};
{u0,u1}={0,\[Pi]};
{cc,tt,ll,uu}=NRecoverDarboux3D[{ds,sd\[Kappa]n,sd\[Kappa]g,sd\[Tau]g},{ui,cci,tti,lli,uui},{u0,u1}];
u2=\[Pi]/2;
Graphics3D[{
Styled3DAxes[],
StyledCurve[cc,{u0,u1},CurveDirected->True],
StyledDarbouxTrihedron[cc[u2],tt[u2],ll[u2],uu[u2],DarbouxVectorLength->.5],
{}},Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
RuledSurfaceNormal[{bbf_Function,ddf_Function, \[Sigma]_},opts___]:=Module[{si,as,sfn,u,v,ss},
si=Simplification/.{opts}/.Options[RuledSurfaceNormal];
as=Assumptions/.{opts}/.Options[RuledSurfaceNormal];
as=Flatten[Join[{u\[Element]Reals,v\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
ss=Functionize[{u,v},bbf[u]+v ddf[u]//sfn];
SurfaceNormalFromSurface[ss,SurfaceOrientation->\[Sigma],opts]]
Block[{bb,dd,\[Theta],u,v,ss,uu1,uu2,u0,u1,nu,du},
bb={Cos[#],Sin[#],0}&;
dd=FunctionizeOld[RotationMatrix3Du[\[Theta],-bb[u]] . {0,0,1},u];
ss=FunctionizeOld[bb[u]+v dd[u],{u,v}];
uu1=RuledSurfaceNormal[{bb,dd,1},SurfaceOrientation->1,Simplification->Simplify];
uu2=RuledSurfaceNormal[{bb,dd,-1},SurfaceOrientation->1,Simplification->Simplify];
\[Theta]=45\[Degree];
u0=-.5\[Pi];
u1=1.4\[Pi];
nu=10;
du=(u1-u0)/nu;
GraphicsRow[{
Graphics3D[{
StyledRuledPatch[ss,{u0,u1},{-1,1},CurveDivisions->200],
StyledCurve[bb,{u0,u1}],
Table[StyledVector[bb[u],.5uu1[u,0],VectorColor->Purple],{u,u0,u1,du}],
{}}],
Graphics3D[{
StyledRuledPatch[ss,{u0,u1},{-1,1},CurveDivisions->200,SurfaceOrientation->-1],
StyledCurve[bb,{u0,u1}],
Table[StyledVector[bb[u],.5uu2[u,0],VectorColor->Purple],{u,u0,u1,du}],
{}}]}]
/.OrigamiStyle[]
]//ShowExample
DevelopableSurface::usage="DevelopableSurface is a key to the rules returned by developable surface functions that gives the surface function.";
Directrix::usage="Directrix is a key to the rules returned by developable surface functions that gives the directrix for a developable surface in canonical form.";
Director::usage="Director is a key to the rules returned by developable surface functions that gives the director for a developable surface in canonical form.";
CrossCurveSurface::usage="CrossCurveSurface is a key to the rules returned by developable surface functions that gives the family of cross curves for a developable surface in canonical form.";
Options[CanonicalCylinderDevelopableSystem]={
Simplification->None,
Assumptions->{}
};
CanonicalCylinderDevelopableSystem::baddir="Director `1` is not a constant function.";
CanonicalCylinderDevelopableSystem[bbf_Function,ddf_Function,opts___]:=Module[{si,as,sfn,u,v,ss,bb,dd,ndd},
si=Simplification/.{opts}/.Options[CanonicalCylinderDevelopableSystem];
as=Assumptions/.{opts}/.Options[CanonicalCylinderDevelopableSystem];
as=Flatten[Join[{u\[Element]Reals,v\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
If[SlotCount[ddf]!=0,Message[CanonicalCylinderDevelopableSystem::baddir];Abort[]];
bb=bbf[u]//sfn;(* evaluated director *)
dd=ddf[u]//sfn;(* evaluated director *)
ndd=Mag[dd]//sfn;(* its magnitude *)
dd=dd/ndd//sfn;(* new unit director *)
bb=bb-(bb . dd)dd//sfn;(* canonical directrix *)
ss=bb+v dd//sfn;(* surface function *)
{Directrix->FunctionizeOld[bb,u],
Director->FunctionizeOld[dd ,u],
DevelopableSurface -> FunctionizeOld[ss,{u,v}],
CrossCurveSurface->FunctionizeOld[ss,{u,v}]
}]
Module[{bb,dd,ccds,ss},
bb={Cos[#],Sin[#],2#}&;
dd={0,0,2}&;
ccds=CanonicalCylinderDevelopableSystem[bb,dd,Simplification->Simplify];
ccds//PrettyParameters//ColumnForm//Print;
ss=DevelopableSurface/.ccds;
Graphics3D[{
Styled3DAxes[],
StyledCrossRuledPatch[ss,{-\[Pi]/4,3\[Pi]/4},{0,1},CrossLineStyle->Purple],
{}}]/.OrigamiStyle[]
]//ShowExample
Options[CanonicalConeDevelopableSystem]={
Simplification->None,
Assumptions->{}
};
CanonicalConeDevelopableSystem::baddir="Directrix `1` is not a constant function.";
CanonicalConeDevelopableSystem[bbf_Function,ddf_Function,opts___]:=Module[{si,as,sfn,u,v,ss,bb,dd,ndd},
si=Simplification/.{opts}/.Options[CanonicalConeDevelopableSystem];
as=Assumptions/.{opts}/.Options[CanonicalConeDevelopableSystem];
as=Flatten[Join[{u\[Element]Reals,v\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
If[SlotCount[bb]!=0,Message[CanonicalConeDevelopableSystem::baddir];Abort[]];
bb=bbf[u]//sfn;(* evaluated directrix *)
dd=ddf[u]//sfn;(* evaluated director *)
ndd=Mag[dd]//sfn;(* its magnitude *)
dd=dd/ndd//sfn;(* new unit director *)
ss=bb+v dd//sfn;(* surface function *)
{Directrix->FunctionizeOld[bb,u],
Director->FunctionizeOld[dd ,u],
DevelopableSurface -> FunctionizeOld[ss,{u,v}],
CrossCurveSurface -> FunctionizeOld[ss,{u,v}]
}]
Module[{\[Theta],bb,dd,ccds,ss},
bb={0,0,1/2}&;
dd=2{Cos[\[Theta]],Sin[\[Theta]]Sin[#],-Sin[\[Theta]]Cos[#]}&;
ccds=CanonicalConeDevelopableSystem[bb,dd,Simplification->Simplify];
(ccds/.{\[Theta]->"\[Theta]"})//PrettyParameters//ColumnForm//Print;
ss=DevelopableSurface/.ccds/.\[Theta]->30\[Degree];
Graphics3D[{
Styled3DAxes[],
StyledCrossRuledPatch[ss,{0,\[Pi]},{0,1},CrossLineStyle->Purple]//ReverseFillStyle,
{}},Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
Options[CanonicalTangentDevelopableSystem]={
Simplification->None,
Assumptions->{}
};
CanonicalTangentDevelopableSystem[bbf_Function,opts___]:=Module[{si,as,sfn,u,v,bb,dbb,ds,dd,ss,al,alf,cc},
si=Simplification/.{opts}/.Options[CanonicalTangentDevelopableSystem];
as=Assumptions/.{opts}/.Options[CanonicalTangentDevelopableSystem];
as=Flatten[Join[{u\[Element]Reals,v\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
bb=bbf[u]//sfn;(* directrix *)
dbb=D[bb,u]//sfn; (* velocity of directrix *)
ds=Mag[dbb]//sfn;(* speed of directrix *)
dd=dbb/ds//sfn;(* director *)
ss=bb+v dd//sfn;(* surface function *)
al=Integrate[ds,u]//sfn;(* arc length of directrix *)
alf=FunctionizeOld[al,u];(* arc length function *)
cc=bb+(alf[v]-1alf[u])dd//sfn;(* cross curve surface *)
{Directrix->FunctionizeOld[bb,u],
Director->FunctionizeOld[dd ,u],
DevelopableSurface -> FunctionizeOld[ss,{u,v}],
CrossCurveSurface->FunctionizeOld[cc,{u,v}]
}]
Module[{\[Theta],u,v,bb,ctds,ss,cc,ccc},
\[Theta]=30\[Degree];
bb={Cos[\[Theta]]Cos[#],Cos[\[Theta]]Sin[#],Sin[\[Theta]]#}&;
ctds=CanonicalTangentDevelopableSystem[bb,Simplification->Simplify];
ctds//PrettyParameters//ColumnForm//Print;
{bb,ss,cc}={Directrix,DevelopableSurface,CrossCurveSurface}/.ctds;
ccc=FunctionizeOld[If[u<=v,cc[u,v],bb[u]],{u,v}];
Graphics3D[{
Styled3DAxes[],
StyledCrossRuledPatch[ccc,{0,\[Pi]},{0,\[Pi]},CrossLineStyle->Purple,CurveDivisions->50,CurveDivisions->50]//ReverseFillStyle,
{}},Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
Module[{\[Theta],u,v,bb,ctds,ss,cc},
\[Theta]=30\[Degree];
bb={Cos[\[Theta]]Cos[#],Cos[\[Theta]]Sin[#],Sin[\[Theta]]#}&;
ctds=CanonicalTangentDevelopableSystem[bb,Simplification->Simplify];
ctds//PrettyParameters//ColumnForm//Print;
{bb,ss,cc}={Directrix,DevelopableSurface,CrossCurveSurface}/.ctds;
Graphics3D[{
Styled3DAxes[],
StyledCurve[bb,{0,\[Pi]}],
StyledCrossRuledPatch[cc,{0,\[Pi]},{0,\[Pi]},CrossLineStyle->Purple,CurveDivisions->50,CurveDivisions->50]//ReverseFillStyle,
{}},Lighting->NeutralLighting[.8]]/.OrigamiStyle[]
]//ShowExample
Options[CanonicalDevelopableSystem]={
Simplification->None,
Assumptions->{}
};
CanonicalDevelopableSystem[bbf_Function,ddf_Function,opts___]:=Module[{si,as,sfn,u,v,bb,dbb,ddd,dim,ds,dd,ss,al,alf,cc},
si=Simplification/.{opts}/.Options[CanonicalDevelopableSystem];
as=Assumptions/.{opts}/.Options[CanonicalDevelopableSystem];
as=Flatten[Join[{u\[Element]Reals,v\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
bb=bbf[u]//sfn;(* directrix *)
dd=ddf[u]/Mag[ddf[u]]//sfn;(* director, now normalized *)
dbb=D[bb,u]//sfn; 
ddd=D[dd,u]//sfn;
dim=Length[bb];
If[ddd===Table[0,{dim}],
Print["CYLINDER"]//Hold;
bb=bb-(bb . dd)dd//sfn;
cc=bb + v dd//sfn,
Print["CONE OR TANDEV"]//Hold;
bb=bb-(dbb . ddd/ddd . ddd)dd//sfn;
dbb=D[bb,u]//sfn; 
If[dbb===Table[0,{dim}],
Print["CONE"]//Hold;
cc=bb+v dd//sfn,
Print["TANDEV"]//Hold;
ds=Mag[dbb]//sfn;
al=Integrate[ds,u]//sfn;(* arc length of directrix *)
alf=FunctionizeOld[al,u];(* arc length function *)
cc=bb+(alf[v]-1alf[u])dd//sfn;(* cross curve surface *)
]];
ss=bb+v dd//sfn;
{Directrix->FunctionizeOld[bb,u],
Director->FunctionizeOld[dd ,u],
DevelopableSurface -> FunctionizeOld[ss,{u,v}],
CrossCurveSurface->FunctionizeOld[cc,{u,v}]
}]
Module[{bb0,dd0,bb1,u,v,bb,ctds,dd,ss,cc},
bb0={Cos[#],Sin[#],0}&;
dd0={0,0,1}&;
Print["solution"];
{Directrix->bb0,Director->dd0}//PrettyParameters//ColumnForm//Print;
bb1=FunctionizeOld[bb0[u]+u dd0[u],u];(* scrambled directrix *)
Print["scrambled directrix"];
{Directrix->bb1}//PrettyParameters//ColumnForm//Print;
ctds=CanonicalDevelopableSystem[bb1,dd0,Simplification->Simplify];
Print["canonical system"];
ctds//PrettyParameters//ColumnForm//Print;
{bb,dd,ss,cc}={Directrix,Director,DevelopableSurface,CrossCurveSurface}/.ctds;
Block[{\[Theta]=30\[Degree]},Graphics3D[{
Styled3DAxes[],
StyledCrossRuledPatch[cc,{0,\[Pi]},{-1,1},CrossLineStyle->Purple,CurveDivisions->50,CurveDivisions->50]//ReverseFillStyle,
{}},Lighting->NeutralLighting[1]]/.OrigamiStyle[]]
]//ShowExample
Module[{bb0,dd0,bb1,u,v,bb,ctds,dd,ss,cc},
bb0={0,0,1/2}&;
dd0={Cos[\[Theta]],Sin[#] Sin[\[Theta]],-Cos[#] Sin[\[Theta]]}&;
Print["solution"];
{Directrix->bb0,Director->dd0}//PrettyParameters//ColumnForm//Print;
bb1=FunctionizeOld[bb0[u]+u dd0[u],u];(* scrambled directrix *)
Print["scrambled directrix"];
{Directrix->bb1}//PrettyParameters//ColumnForm//Print;
ctds=CanonicalDevelopableSystem[bb1,dd0,Simplification->Simplify];
Print["canonical system"];
ctds//PrettyParameters//ColumnForm//Print;
{bb,dd,ss,cc}={Directrix,Director,DevelopableSurface,CrossCurveSurface}/.ctds;
Block[{\[Theta]=30\[Degree]},Graphics3D[{
Styled3DAxes[],
StyledCrossRuledPatch[cc,{0,\[Pi]},{0,1},CrossLineStyle->Purple,CurveDivisions->50,CurveDivisions->50]//ReverseFillStyle,
{}},Lighting->NeutralLighting[1]]/.OrigamiStyle[]]
]//ShowExample
Module[{bb0,dd0,bb1,u,v,bb,ctds,dd,ss,cc,ccc},
bb0={Cos[\[Theta]]Cos[#],Cos[\[Theta]]Sin[#],Sin[\[Theta]]#}&;
dd0={-Cos[\[Theta]] Sin[#],Cos[#] Cos[\[Theta]],Sin[\[Theta]]}&;
Print["solution"];
{Directrix->bb0,Director->dd0}//PrettyParameters//ColumnForm//Print;
bb1=FunctionizeOld[bb0[u]+u dd0[u],u];(* scrambled directrix *)
Print["scrambled directrix"];
{Directrix->bb1}//PrettyParameters//ColumnForm//Print;
ctds=CanonicalDevelopableSystem[bb1,dd0,Simplification->Simplify];
Print["canonical system"];
ctds//PrettyParameters//ColumnForm//Print;
{bb,dd,ss,cc}={Directrix,Director,DevelopableSurface,CrossCurveSurface}/.ctds;
ccc=FunctionizeOld[If[u<=v,cc[u,v],bb[u]],{u,v}];
Block[{\[Theta]=30\[Degree]},Graphics3D[{
Styled3DAxes[],
StyledCrossRuledPatch[ccc,{0,\[Pi]},{0,\[Pi]},CrossLineStyle->Purple,CurveDivisions->50,CurveDivisions->50]//ReverseFillStyle,
{}},Lighting->NeutralLighting[.8]]/.OrigamiStyle[]]
]//ShowExample
Options[UncurlCurveInDevelopableSystem]={
Simplification->None,
Assumptions->{}
};
UncurlCurveInDevelopableSystem[ccf_Function,uuf_Function,opts___]:=Module[{si,as,sfn,cis3s,sdf,kgf,rc2s},
si=Simplification/.{opts}/.Options[UncurlCurveInDevelopableSystem];
as=Assumptions/.{opts}/.Options[UncurlCurveInDevelopableSystem];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
cis3s=Darboux3DSystemOld[ccf,uuf,opts];
{sdf,kgf}={Speed3D,GeodesicCurvature3D}/.cis3s;
rc2s=RecoverCurve2DSystemOld[kgf,sdf,opts];
Join[cis3s,rc2s]]
Module[{ss1,ss2,v1,t,soln,u1,uuu,ff,uu,ucids,f},
ss1={#1,Sin[#2],1-Cos[#2]}&;
Print["ss1 = ",ss1//PrettyParameters];
ss2={1-#1,#2,#1}&;
Print["ss2 = ",ss2//PrettyParameters];
(* surface normal, parameterized on two variables *)
uuu=SurfaceNormalFromSurface[ss1,Simplification->Simplify];
Print["uuu = ",uuu//PrettyParameters];
(* Solve for intersection, parameterized on v1 = t. *)
soln=Join[{v1->t},Flatten[Solve[ss1[u1,t]==ss2[u2,v2],{u1,u2,v2}]]];
Print["soln = ",soln];
(* curve function and surface normal on one variable *)
ff=FunctionizeOld[ss1[u1,v1]/.soln,t];
Print["ff = ",ff//PrettyParameters];
(* DevelopableSurface normal on one variable *)
uu=FunctionizeOld[uuu[u1,v1]/.soln,t];
Print["uu = ",uu//PrettyParameters];
(* compute the system *)
ucids=UncurlCurveInDevelopableSystem[ff,uu,Simplification->Simplify];
Print[ucids//PrettyParameters//ColumnForm];
f=Curve2D/.ucids;
GraphicsRow[{
Graphics3D[{
StyledPatch[ss1,{-1.,2.0},{-\[Pi]/2,\[Pi]/2},OutlineStyle->BorderLine],
StyledPatch[ss2,{-.5,1.5},{-\[Pi]/2,\[Pi]/2},OutlineStyle->BorderLine,FillStyle->{Gray,Opacity[0.25],EdgeForm[]}],
StyledCurve[ff,{-\[Pi]/2,\[Pi]/2},LineStyle->{DarkGray,Thickness[.015]}],
{}}],
Graphics[StyledCurve[f,{-\[Pi]/2,\[Pi]/2},LineStyle->{DarkGray,Thickness[.015]}]]}]/.OrigamiStyle[]
]//ShowExample
Planarize::badfn="`1` is not a pure function whose return value is a list of length 3.";
Planarize[f_Function]:=Module[{},
If[Length[f]==1,
(* a pure function *)
If[Head[f[[1]]]!=List||Length[f[[1]]]!=3,Message[Planarize::badfn,f];Abort[]];
ReplacePart[f,1->Take[f[[1]],2]],
(* function with parameters *)
If[Head[f[[2]]]!=List||Length[f[[2]]]!=3,Message[Planarize::badfn,f];Abort[]];
ReplacePart[f,2->Take[f[[2]],2]]]]
Module[{f,ff},
f={Cos[#],Sin[#],Tan[#]}&;
ff=Planarize[f];
Print[ff]
]//ShowExample
Module[{f,ff},
f=Function[x,{Cos[x],Sin[x],Tan[x]}];
ff=Planarize[f];
Print[ff]
]//ShowExample
Module[{t,f,ff},
f=FunctionInterpolationAlt[{Cos[t],Sin[t],0},{t,0,1}];
ff=Planarize[f];
Print[ff]
]//ShowExample
Unplanarize::badfn="`1` is not a pure function whose return value is a list of length 2.";
Unplanarize[f_Function]:=Module[{},
If[Length[f]==1,
(* a pure function *)
If[Head[f[[1]]]!=List||Length[f[[1]]]!=2,Message[Unplanarize::badfn,f];Abort[]];
ReplacePart[f,1->Append[f[[1]],0]],
(* function with parameters *)
If[Head[f[[2]]]!=List||Length[f[[2]]]!=2,Message[Unplanarize::badfn,f];Abort[]];
ReplacePart[f,2->Append[f[[2]],0]]]]
Module[{f,ff},
f={Cos[#],Sin[#]}&;
ff=Unplanarize[f];
Print[ff]
]//ShowExample
Module[{t,f,ff},
f=FunctionInterpolationAlt[{Cos[t],Sin[t]},{t,0,1}];
ff=Unplanarize[f];
Print[ff]
]//ShowExample
Options[RibbonPair]={
Simplification->None,
Assumptions->{}
};
StrictArguments[RibbonPair];
RibbonPair[cc_Function,\[Eta]_Function,\[Sigma]_,{ui_,ci_List,ti_List},opts___]:=Module[{si,as,s,sfn,csys3d,ds,tt,nn,bb,ll,uu,duu,c,t,l,u,c\[Rho]L,s\[Rho]L,dd,\[Kappa]l,csys2d,d},
si=Simplification/.{opts}/.Options[RibbonPair];
as=Assumptions/.{opts}/.Options[RibbonPair];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
csys3d=Curve3DSystem[cc,opts];
{ds,tt,nn,bb}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.csys3d;
ll=Functionize[s,Cos[\[Eta][s]]nn[s]-Sin[\[Eta][s]]bb[s]//sfn];
uu=Functionize[s,Sin[\[Eta][s]]nn[s]+Cos[\[Eta][s]]bb[s]//sfn];
duu=Functionize[s,uu'[s]//sfn];
s\[Rho]L=Functionize[s,Abs[duu[s] . tt[s]]/Mag[duu[s]]//sfn];
c\[Rho]L=Functionize[s,-Sign[duu[s] . tt[s]](duu[s] . ll[s]/Mag[duu[s]])//sfn];
dd=Functionize[s,\[Sigma](c\[Rho]L[s] tt[s]+s\[Rho]L [s]ll[s])//sfn];
\[Kappa]l=Functionize[s,ll[s] . tt'[s]/ds[s]//sfn];
csys2d=RecoverCurve2DSystem[ds,\[Kappa]l,{ui,ci,ti},opts];
{c,t,l}={Curve2D,TangentVector2D,LeftNormalVector2D}/.csys2d;
d=Functionize[s,\[Sigma](c\[Rho]L[s] t[s]+s\[Rho]L[s] l[s])//sfn];
{c,d,cc,dd}]
Module[{cc,\[Eta],b,d,bb,dd},
cc={Cos[#],Sin[#],0}&;
\[Eta]=\[Pi]/4&;
{b,d,bb,dd}=RibbonPair[cc,\[Eta],+1,{0,{0,0},{1,0}},Simplification->Simplify];
Print["b = ",b//PrettyParameters];
Print["d = ",d//PrettyParameters];
Print["bb = ",bb//PrettyParameters];
Print["dd = ",dd//PrettyParameters];
Block[{h = 0.2,u0,u1,v0,v1,cd,rd},
{u0,u1}={0,\[Pi]};
{v0,v1}={-.5,.5};
cd=200;
rd=20;
GraphicsRow[{
Graphics3D[{
Styled3DAxes[1,1,1],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[bb,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{bb[u0],bb[u0]+dd[u0]},VectorColor->Orange],
{}},Lighting->NeutralLighting[0.8]],
Graphics[{
Styled2DAxes[1,1],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[b,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{b[u0],b[u0]+d[u0]},VectorColor->Brown],
{}}]
}]/.OrigamiStyle[]]
]//ShowExample
Module[{cc,\[Eta],b,d,bb,dd},
cc={Cos[#],Sin[#],0.5 #}&;
\[Eta]=0.35\[Pi]&;
{b,d,bb,dd}=RibbonPair[cc,\[Eta],+1,{0,{0,0},{1,0}},Simplification->Simplify];
Block[{h = 0.2,u0,u1,v0,v1,cd,rd},
{u0,u1}={0,\[Pi]};
{v0,v1}={-.5,.5};
cd=200;
rd=20;
GraphicsRow[{
Graphics3D[{
Styled3DAxes[1,1,1],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[bb,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{bb[u0],bb[u0]+dd[u0]},VectorColor->Orange],
{}},Lighting->NeutralLighting[0.8]],
Graphics[{
Styled2DAxes[1,1],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[b,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{b[u0],b[u0]+d[u0]},VectorColor->Brown],
{}}]
}]/.OrigamiStyle[]]
]//ShowExample
StrictArguments[NRibbonPair];
NRibbonPair[cc_Function|cc_InterpolatingFunction,\[Eta]_Function|\[Eta]_InterpolatingFunction,\[Sigma]_,{ui_,ci_List,ti_List},{u0_,u1_},opts___]:=Module[{s,csys3d,ds,tt,nn,bb,ll,uu,duu,c,t,l,u,c\[Rho]L,s\[Rho]L,dd,\[Kappa]l,csys2d,d},
csys3d=NCurve3DSystem[cc,{u0,u1},opts];
{ds,tt,nn,bb}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.csys3d;
ll=Functionize[s,Cos[\[Eta][s]]nn[s]-Sin[\[Eta][s]]bb[s]];
uu=Functionize[s,Sin[\[Eta][s]]nn[s]+Cos[\[Eta][s]]bb[s]];
duu=Functionize[s,uu'[s]];
s\[Rho]L=FunctionInterpolationAlt[Abs[duu[s] . tt[s]]/Mag[duu[s]],{s,u0,u1},opts];
c\[Rho]L=FunctionInterpolationAlt[-Sign[duu[s] . tt[s]](duu[s] . ll[s]/Mag[duu[s]]),{s,u0,u1},opts];
dd=FunctionInterpolationAlt[\[Sigma](c\[Rho]L[s] tt[s]+s\[Rho]L [s]ll[s]),{s,u0,u1},opts];
\[Kappa]l=FunctionInterpolationAlt[ll[s] . tt'[s]/ds[s],{s,u0,u1},opts];
csys2d=NRecoverCurve2DSystem[ds,\[Kappa]l,{ui,ci,ti},{u0,u1},opts];
{c,t,l}={Curve2D,TangentVector2D,LeftNormalVector2D}/.csys2d;
d=FunctionInterpolationAlt[\[Sigma](c\[Rho]L[s] t[s]+s\[Rho]L[s] l[s]),{s,u0,u1},opts];
{c,d,cc,dd}]
Module[{cc,\[Eta],b,d,bb,dd,u0,u1},
cc={Cos[#],Sin[#],0}&;
\[Eta]=\[Pi]/4&;
{u0,u1}={0,\[Pi]};
{b,d,bb,dd}=NRibbonPair[cc,\[Eta],1,{0,{0,0},{1,0}},{u0,u1}];
Block[{h ,v0,v1,cd,rd},
h=0.2;
{v0,v1}={-.5,.5};
cd=200;
rd=20;
GraphicsRow[{
Graphics3D[{
Styled3DAxes[1,1,1],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[bb,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{bb[u0],bb[u0]+dd[u0]},VectorColor->Orange],
{}},Lighting->NeutralLighting[0.8]],
Graphics[{
Styled2DAxes[1,1],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[b,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{b[u0],b[u0]+d[u0]},VectorColor->Brown],
{}}]
}]/.OrigamiStyle[]]
]//ShowExample
Module[{cc,\[Eta],u0,u1,b,d,bb,dd},
cc={Cos[#],Sin[#],0.5 #}&;
\[Eta]=0.35\[Pi]&;
{u0,u1}={0,\[Pi]};
{b,d,bb,dd}=NRibbonPair[cc,\[Eta],1,{0,{0,0},{1,0}},{u0,u1}];
Block[{h = 0.2,v0,v1,cd,rd},
{v0,v1}={-.5,.5};
cd=200;
rd=20;
GraphicsRow[{
Graphics3D[{
Styled3DAxes[1,1,1],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[bb,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{bb[u0],bb[u0]+dd[u0]},VectorColor->Orange],
{}},Lighting->NeutralLighting[0.8]],
Graphics[{
Styled2DAxes[1,1],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[b,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{b[u0],b[u0]+d[u0]},VectorColor->Brown],
{}}]
}]/.OrigamiStyle[]]
]//ShowExample
Module[{cc,\[Eta],u0,u1,b,d,bb,dd},
cc={2Cos[#],Sin[#],0.03#(1+#)}&;
\[Eta]=0.35\[Pi]&;
{u0,u1}={0,4\[Pi]};
{b,d,bb,dd}=NRibbonPair[cc,\[Eta],1,{0,{0,0},{1,0}},{u0,u1},InterpolationPoints->30];
Block[{h = 0.2,v0,v1,cd,rd},
{v0,v1}={-1,1};
cd=200;
rd=40;
GraphicsRow[{
Graphics3D[{
Styled3DAxes[1,1,1],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[bb,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{bb[u0],bb[u0]+dd[u0]},VectorColor->Orange],
{}},Lighting->NeutralLighting[0.8]],
Graphics[{
Styled2DAxes[1,1],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},CurveDivisions->cd,RulingLineDivisions->rd],
StyledCurve[b,{u0,u1},CurveDirected->True,CurveDivisions->cd],
StyledVector[{b[u0],b[u0]+d[u0]},VectorColor->Brown],
{}}]
}]/.OrigamiStyle[]]
]//ShowExample
Options[MatchCurvesPair]={
Simplification->None,
Assumptions->{}
};
StrictArguments[MatchCurvesPair];
MatchCurvesPair[c_Function,cc_Function,\[Psi]_,\[Sigma]_,opts___]:=Module[{si,as,s,sfn,c2dsys,ds,\[Kappa]l,t,l,c3dsys,tt,nn,bb,\[Kappa],c\[Eta],s\[Eta],ll,uu,duu,c\[Rho]L,s\[Rho]L,dd,d},
si=Simplification/.{opts}/.Options[MatchCurvesPair];
as=Assumptions/.{opts}/.Options[MatchCurvesPair];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
c2dsys=Curve2DSystem[c,opts];
{ds,\[Kappa]l,t,l}={Speed2D,LeftCurvature2D,TangentVector2D,LeftNormalVector2D}/.c2dsys;
c3dsys=Curve3DSystem[cc,opts];
{tt,nn,bb,\[Kappa]}={TangentVector3D,NormalVector3D,BinormalVector3D,Curvature3D}/.c3dsys;
c\[Eta]=Functionize[s,\[Kappa]l[s]/\[Kappa][s]//sfn];
s\[Eta]=Functionize[s,\[Psi]((\[Sqrt](\[Kappa][s]^2-\[Kappa]l[s]^2))/\[Kappa][s])//sfn];
ll=Functionize[s,c\[Eta][s]nn[s]-s\[Eta][s]bb[s]//sfn];
uu=Functionize[s,s\[Eta][s]nn[s]+c\[Eta][s]bb[s]//sfn];
duu=Functionize[s,uu'[s]//sfn];
s\[Rho]L=Functionize[s,Abs[duu[s] . tt[s]]/Mag[duu[s]]//sfn];
c\[Rho]L=Functionize[s,-Sign[duu[s] . tt[s]](duu[s] . ll[s]/Mag[duu[s]])//sfn];
dd=Functionize[s,\[Sigma](c\[Rho]L[s] tt[s]+s\[Rho]L [s]ll[s])//sfn];
d=Functionize[s,\[Sigma](c\[Rho]L[s] t[s]+s\[Rho]L[s] l[s])//sfn];
{c,d,cc,dd}]
Module[{r2d,c,cc,mcids,d,dd,u0,u1},
r2d=2;
c=r2d{Cos[#/r2d],Sin[#/r2d]}&;
cc={Cos[#],Sin[#],1}&;
{u0,u1}={0,\[Pi]};
{c,d,cc,dd}=MatchCurvesPair[c,cc,1,1,Simplification->Simplify];
Print["c[t] = ",c//PrettyParameters];
Print["d[t] = ",d//PrettyParameters];
Print["cc[t] = ",cc//PrettyParameters];
Print["dd[t] = ",dd//PrettyParameters];
GraphicsRow[{
Graphics[{
StyledRuledPatch[c,d,{u0,u1},{-1,1}],
StyledCurve[c,{u0,u1}],
StyledVector[{c[u0],c[u0]+d[u0]},VectorColor->Orange],
{}}]/.OrigamiStyle[],
Graphics3D[{
StyledRuledPatch[cc,dd,{u0,u1},{-1,1}],
StyledCurve[cc,{u0,u1}],
StyledVector[{cc[u0],cc[u0]+dd[u0]},VectorColor->Orange],
{}}//AddShadow]/.OrigamiStyle[]}]
]//ShowExample
StrictArguments[NMatchCurvesPair];
NMatchCurvesPair[c_Function|c_InterpolatingFunction,cc_Function|cc_InterpolatingFunction,\[Psi]_,\[Sigma]_,{u0_,u1_},opts___]:=Module[{s,c2dsys,ds,\[Kappa]l,t,l,c3dsys,tt,nn,bb,\[Kappa],c\[Eta],s\[Eta],ll,uu,duu,\[Kappa]n,\[Tau]g,c\[Rho]L,s\[Rho]L,dd,d},
c2dsys=NCurve2DSystem[c,{u0,u1},opts];
{ds,\[Kappa]l,t,l}={Speed2D,LeftCurvature2D,TangentVector2D,LeftNormalVector2D}/.c2dsys;
c3dsys=NCurve3DSystem[cc,{u0,u1},opts];
{tt,nn,bb,\[Kappa]}={TangentVector3D,NormalVector3D,BinormalVector3D,Curvature3D}/.c3dsys;
c\[Eta]=Functionize[s,\[Kappa]l[s]/\[Kappa][s]];
s\[Eta]=Functionize[s,\[Psi]((\[Sqrt](\[Kappa][s]^2-\[Kappa]l[s]^2))/\[Kappa][s])];
ll=FunctionInterpolationAlt[c\[Eta][s]nn[s]-s\[Eta][s]bb[s],{s,u0,u1},opts];
uu=FunctionInterpolationAlt[s\[Eta][s]nn[s]+c\[Eta][s]bb[s],{s,u0,u1},opts];
duu=Functionize[s,uu'[s]];
s\[Rho]L=FunctionInterpolationAlt[Abs[duu[s] . tt[s]]/Mag[duu[s]],{s,u0,u1},opts];
c\[Rho]L=FunctionInterpolationAlt[-Sign[duu[s] . tt[s]](duu[s] . ll[s]/Mag[duu[s]]),{s,u0,u1},opts];
dd=FunctionInterpolationAlt[\[Sigma](c\[Rho]L[s] tt[s]+s\[Rho]L [s]ll[s]),{s,u0,u1},opts];
d=FunctionInterpolationAlt[\[Sigma](c\[Rho]L[s] t[s]+s\[Rho]L[s] l[s]),{s,u0,u1},opts];
{c,d,cc,dd}]
Module[{r2d,c,cc,mcids,d,dd,u0,u1},
r2d=2;
c=r2d{Cos[#/r2d],Sin[#/r2d]}&;
cc={Cos[#],Sin[#],1}&;
{u0,u1}={0,\[Pi]};
{c,d,cc,dd}=NMatchCurvesPair[c,cc,1,1,{u0,u1}];
GraphicsRow[{
Graphics[{
StyledRuledPatch[c,d,{u0,u1},{-1,1}],
StyledCurve[c,{u0,u1}],
StyledVector[{c[u0],c[u0]+d[u0]},VectorColor->Orange],
{}}]/.OrigamiStyle[],
Graphics3D[{
StyledRuledPatch[cc,dd,{u0,u1},{-1,1}],
StyledCurve[cc,{u0,u1}],
StyledVector[{cc[u0],cc[u0]+dd[u0]},VectorColor->Orange],
{}}//AddShadow]/.OrigamiStyle[]}]
]//ShowExample
Options[NearConstantWidthScale]={
Simplification->None,
Assumptions->{}
};
StrictArguments[NearConstantWidthScale];
NearConstantWidthScale[b_Function,d_Function,opts___]:=Module[{sm,as,sfn,s,t},
sm=Simplification/.{opts}/.Options[NearConstantWidthScale];
as=Join[{s\[Element]Reals},Assumptions/.{opts}/.Options[NearConstantWidthScale]];
sfn=If[sm===None,#&,sm[#,Assumptions->as]&];
t=Functionize[s,NormalizeReal[b'[s]]//sfn];
Functionize[s,1/\[Sqrt](1-(t[s] . d[s])^2)//sfn]]
Module[{b,d,u0,u1,ws,s,w},
b={#,0}&;
d={Sin[#],Cos[#]}&;
{u0,u1}={0,\[Pi]/3};
ws=NearConstantWidthScale[b,d,Simplification->Simplify];
Print["ws[t] = ",ws//PrettyParameters];
w=Functionize[s,0.5ws[s]];
Graphics[{
StyledRuledPatch[b,d,{u0,u1},{0,w}],
{}},Axes->True]/.OrigamiStyle[]
]//ShowExample
StrictArguments[NNearConstantWidthScale];
NNearConstantWidthScale[b_Function|b_InterpolatingFunction,d_Function|d_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{s,t},
t=Functionize[s,NormalizeReal[b'[s]]];
FunctionInterpolationAlt[1/\[Sqrt](1-(t[s] . d[s])^2),{s,u0,u1},opts]]
Module[{b,d,u0,u1,ws,s,w},
{u0,u1}={0,\[Pi]/3};
b=FunctionInterpolationAlt[{#,0}&[s],{s,u0,u1}];
d=FunctionInterpolationAlt[{Sin[#],Cos[#]}&[s],{s,u0,u1}];
ws=NNearConstantWidthScale[b,d,{u0,u1}];
Print["ws[t] = ",ws//PrettyParameters];
w=Functionize[s,0.5ws[s]];
Graphics[{
StyledRuledPatch[b,d,{u0,u1},{0,w}],
{}},Axes->True]/.OrigamiStyle[]
]//ShowExample
NConstantWidthScale2D::nosoln="FindRoot couldn't find a root to the width equation at `1`.";
StrictArguments[NConstantWidthScale2D];
NConstantWidthScale2D[b_Function|b_InterpolatingFunction,d_Function|d_InterpolatingFunction,w0_,{u0_,u1_},opts___]:=Module[{fiopts,s,bp,t,l,be,te,le,ui,wi,wfn},
fiopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
(* tangent and left normal *)
bp=Functionize[s,b'[s]];
t=Functionize[s,NormalizeReal[bp[s]]];
l=Functionize[s,RotationMatrix2D[\[Pi]/2] . t[s]];
(* extended versions to allow for extrapolation. Assume straight lines. *)
be=Functionize[s,Which[s<=u0,b[u0]+(s-u0)bp[u0],s>=u1,b[u1]+(s-u1)bp[u1],True,b[s]]];
te=Functionize[s,Which[s<=u0,t[u0],s>=u1,t[u1],True,t[s]]];
le=Functionize[s,Which[s<=u0,l[u0],s>=u1,l[u1],True,l[s]]];
(* This solves the width equation. Note the restriction to numeric, otherwise badness. *)
wfn[s_?NumericQ]:=Check[FindRoot[{b[s]+wi d[s]==b[ui]+w0 l[ui]Sign[l[ui] . d[ui]]},{{wi,.5w0,w0},{ui,s,s+.01(u1-u0)}}][[1,2]],Message[NConstantWidthScale2D::nosoln,s];Abort[],{FindRoot::cvmit}];
Quiet[FunctionInterpolation[wfn[s],{s,u0,u1},Evaluate[fiopts]],{FunctionInterpolation::dmval,FunctionInterpolation::ncvb}]
]
Module[{b,d,w0,u0,u1,wL,wR,s},
b={Cos[#],Sin[#]}&;
d={-1,0}&;
w0=0.10;
{u0,u1}={0,.35\[Pi]};
wL=NConstantWidthScale2D[b,d,w0,{u0,u1}];
wR=NConstantWidthScale2D[b,d,-w0,{u0,u1}];
Graphics[{
StyledRuledPatch[b,d,{u0,u1},{wL,wR}],
StyledCurve[b,{u0,u1},LineStyle->{Black}],
StyledCurve[Functionize[s,b[s]+w0 d[s]],{u0,u1},LineStyle->{Dashed,Gray}],
StyledCurve[Functionize[s,b[s]-w0 d[s]],{u0,u1},LineStyle->{Dashed,Gray}],
{}}]/.OrigamiStyle[]
]//ShowExample
Options[FlattenGeneric2D]={
Simplification->None,
Assumptions->{}
};
StrictArguments[FlattenGeneric2D];
FlattenGeneric2D[{bb_Function,dd_Function,\[Sigma]_},{ui_,bi_List,ti_List},opts___]:=Module[{sim,as,sfn,dsopts,s,uu,cc,tt,ll,d3dsys,ds,\[Kappa]g,c\[Rho]L,s\[Rho]L,c2dsys,b,t,l,d},
sim=Simplification/.{opts}/.Options[ReshapeGeneric3D];
as=Join[{s\[Element]Reals},Assumptions/.{opts}/.Options[ReshapeGeneric3D]];
sfn=If[sim===None,#&,sim[#,Assumptions->as]&];
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
uu=Functionize[s,With[{txd=bb'[s]\[Cross]dd[s]},\[Sigma] NormalizeReal[txd]]//sfn];
d3dsys=Darboux3DSystem[bb,uu,opts];
{tt,ll,ds,\[Kappa]g}={TangentVector3D,TangentNormalVector3D,Speed3D,GeodesicCurvature3D}/.d3dsys;
c\[Rho]L=Functionize[s,\[Sigma] tt[s] . dd[s]//sfn];
s\[Rho]L=Functionize[s,\[Sigma] ll[s] . dd[s]//sfn];
c2dsys=RecoverCurve2DSystem[ds,\[Kappa]g,{ui,bi,ti},opts];
{b,t,l}={Curve2D,TangentVector2D,LeftNormalVector2D}/.c2dsys;
d=Functionize[s,\[Sigma](c\[Rho]L[s] t[s]+s\[Rho]L[s]l[s])//sfn];
{b,d,\[Sigma]}]
Block[{s,\[Theta],as,bb,dd,\[Sigma],ui,bi,ti,b,d,u0,u1,v0,v1},
as={\[Theta]>0,\[Theta]<\[Pi]/2};
bb=Functionize[s,{Cos[\[Theta]],-Sin[\[Theta]]Cos[s],Sin[\[Theta]]Sin[s]}];dd=Functionize[s,-{Cos[\[Theta]],-Sin[\[Theta]]Cos[s],Sin[\[Theta]]Sin[s]}];
\[Sigma]=+1;
{b,d,\[Sigma]}=FlattenGeneric2D[{bb,dd,\[Sigma]},{0,{1,0},{0,1}},Simplification->Simplify,Assumptions->as];
{b,d,\[Sigma]}//PrettyParameters//Print;
{u0,u1}={0,\[Pi]};
{v0,v1}={-1,1};
\[Theta]=30.\[Degree];
GraphicsRow[{
Graphics[{
StyledRuledPatch[b,d,{u0,u1},{v0,v1}],
StyledCurve[b,{u0,u1},
CurveDirected->True]},
Axes->True],
Graphics3D[{
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1}],
StyledCurve[bb,{u0,u1},
CurveDirected->True]},
Axes->True]}]/.OrigamiStyle[]
]
StrictArguments[NFlattenGeneric2D];
NFlattenGeneric2D[{bb_Function,dd_Function,\[Sigma]_},{ui_,bi_List,ti_List},{u0_,u1_},opts___]:=Module[{s,uu,cc,tt,ll,d3dsys,ds,\[Kappa]g,c\[Rho]L,s\[Rho]L,c2dsys,b,t,l,d},
uu=Functionize[s,With[{txd=bb'[s]\[Cross]dd[s]},\[Sigma] NormalizeReal[txd]]];
d3dsys=NDarboux3DSystem[bb,uu,{u0,u1},opts];
{tt,ll,ds,\[Kappa]g}={TangentVector3D,TangentNormalVector3D,Speed3D,GeodesicCurvature3D}/.d3dsys;
c\[Rho]L=Functionize[s,\[Sigma] tt[s] . dd[s]];
s\[Rho]L=Functionize[s,\[Sigma] ll[s] . dd[s]];
c2dsys=NRecoverCurve2DSystem[ds,\[Kappa]g,{ui,bi,ti},{u0,u1},opts];
{b,t,l}={Curve2D,TangentVector2D,LeftNormalVector2D}/.c2dsys;
d=FunctionInterpolationAlt[\[Sigma](c\[Rho]L[s] t[s]+s\[Rho]L[s]l[s]),{s,u0,u1},opts];
{b,d,\[Sigma]}]
Block[{s,\[Theta],as,bb,dd,\[Sigma],ui,bi,ti,b,d,u0,u1,v0,v1},
{u0,u1}={0,\[Pi]};
\[Theta]=30.\[Degree];
bb=Functionize[s,{Cos[\[Theta]],-Sin[\[Theta]]Cos[s],Sin[\[Theta]]Sin[s]}];dd=Functionize[s,-{Cos[\[Theta]],-Sin[\[Theta]]Cos[s],Sin[\[Theta]]Sin[s]}];
\[Sigma]=+1;
{b,d,\[Sigma]}=NFlattenGeneric2D[{bb,dd,\[Sigma]},{0,{1,0},{0,1}},{u0,u1}];
{v0,v1}={-1,1};
GraphicsRow[{
Graphics[{
StyledRuledPatch[b,d,{u0,u1},{v0,v1}],
StyledCurve[b,{u0,u1},
CurveDirected->True]},
Axes->True],
Graphics3D[{
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1}],
StyledCurve[bb,{u0,u1},
CurveDirected->True]},
Axes->True]}]/.OrigamiStyle[]
]//ShowExample
Options[ReshapeGeneric3D]={
Simplification->None,
Assumptions->{}
};
ReshapeGeneric3D::nosoln="DSolve couldn't integrate the Darboux frame equations.";
StrictArguments[ReshapeGeneric3D];
ReshapeGeneric3D[{b_Function,d_Function,\[Sigma]_},\[Kappa]n_Function,{ui_,bbi_List,ddi_List,tti_List},opts___]:=Module[{sim,as,sfn,dsopts,
s,ds,t,l,u,
c\[Rho]L,s\[Rho]L,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g,sd\[Kappa]n1,sd\[Tau]g1,
lli,uui,soln,ttx,tty,ttz,llx,lly,llz,uux,uuy,uuz,bbx,bby,bbz,
tt,ll,uu,bb,dd},
sim=Simplification/.{opts}/.Options[ReshapeGeneric3D];
as=Join[{s\[Element]Reals},Assumptions/.{opts}/.Options[ReshapeGeneric3D]];
sfn=If[sim===None,#&,sim[#,Assumptions->as]&];
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
(* curve speed *)
ds=Functionize[s,Mag[D[b[s],s]]//sfn];
(* Darboux frame *)
t=Functionize[s,With[{db=D[b[s],s]},NormalizeReal[db]]//sfn];
u=Functionize[s,With[{txd=t[s]\[Cross]d[s]},\[Sigma] NormalizeReal[txd]]//sfn];
l=Functionize[s,u[s]\[Cross]t[s]//sfn];
(* left ruling angle trig functions *)
c\[Rho]L=Functionize[s,\[Sigma] t[s] . d[s]//sfn];
s\[Rho]L=Functionize[s,\[Sigma] l[s] . d[s]//sfn];
(* compute curve speed * geodesic curvature, normal curvature, geodesic torsion *)
sd\[Kappa]g=Functionize[s,l[s] . t'[s]//sfn];
sd\[Kappa]n=Functionize[s,u[s] . t'[s]//sfn];
sd\[Tau]g=Functionize[s,-l[s] . u'[s]//sfn];
(* New normal curvature and geodesic torsion products *)
sd\[Kappa]n1=Functionize[s,ds[s]\[Kappa]n[s]//sfn];
sd\[Tau]g1=Functionize[s,-ds[s] \[Kappa]n[s](t[s] . d[s]/l[s] . d[s])//sfn];
(* remaining initial conditions of Darboux frame *)
uui=NormalizeReal[\[Sigma] tti\[Cross]ddi]//sfn;
lli=RotationMatrix3Du[\[Pi]/2,uui] . tti//sfn;
(* construct the new Darboux frame *)
{bb,tt,ll,uu}=RecoverDarboux3D[{ds,sd\[Kappa]g,sd\[Kappa]n1,sd\[Tau]g1},{ui,bbi,tti,lli,uui},opts];
(* rotate to get the new director *)
dd=Functionize[s,\[Sigma](c\[Rho]L[s]tt[s]+s\[Rho]L [s]ll[s])//sfn];
{bb,dd,\[Sigma]}]
Module[{\[Sigma],bb,dd,ui,bi,ti,di,\[Kappa]n,b,d,u0,u1,v0,v1},
(* a cylinder *)
bb=Function[u,{-Cos[u],0,Sin[u]}];
dd={0,1,0}&;
\[Sigma]=1;
(* initial conditions that put the surface in the x-y plane *)
{ui,bi,di,ti}={0,{0,0,0},{0,1,0},{1,0,0}};
(* desired normal curvature to achieve flatness *)
\[Kappa]n=0&;
(* the surface *)
{b,d,\[Sigma]}=ReshapeGeneric3D[{bb,dd,\[Sigma]},\[Kappa]n,{ui,bi,di,ti},Simplification->Simplify];
(* print the functions *)
Print["b = ",b//PrettyParameters];
Print["d = ",d//PrettyParameters];
(* plot range *)
{u0,u1}={0,\[Pi]};
{v0,v1}={0,1};
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2.5,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[bb,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[4,2.5,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[b,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics[{
Styled2DAxes[4,2],
StyledRuledPatch[Planarize[b],Planarize[d],{u0,u1},{v0,v1}],
StyledCurve[Planarize[b],{u0,u1},CurveDirected->True],
{}}]},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
Module[{\[Sigma],bb,dd,ui,bi,ti,di,\[Kappa]n,b,d,u0,u1,v0,v1},
(* a flattened cylinder in 3D *)
bb=Unplanarize[Function[u,{u,0}]];
dd=Unplanarize[{0,1}&];
\[Sigma]=+1;
(* initial conditions for the curled cylinder *)
{ui,bi,di,ti}={0,{0,0,0},{0,1,0},{1,0,0}};
(* desired normal curvature with radius 1 *)
\[Kappa]n=1&;
(* the surface *)
{b,d,\[Sigma]}=ReshapeGeneric3D[{bb,dd,\[Sigma]},\[Kappa]n,{ui,bi,di,ti},Simplification->Simplify];
(* print the functions *)
Print["b = ",b//PrettyParameters];
Print["d = ",d//PrettyParameters];
(* plot range *)
{u0,u1}={0,\[Pi]};
{v0,v1}={0,1};
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2.5,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[bb,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2.5,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[b,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}]
},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
NReshapeGeneric3D::nosoln="NDSolve couldn't integrate the Darboux frame equations.";
StrictArguments[NReshapeGeneric3D];
NReshapeGeneric3D[{b_Function|b_InterpolatingFunction,d_Function|d_InterpolatingFunction,\[Sigma]_},\[Kappa]n_Function,{ui_,bbi_List,ddi_List,tti_List},{u0_,u1_},opts___]:=Module[{dsopts,fiopts,
s,ds,t,l,u,
c\[Rho]L,s\[Rho]L,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g,sd\[Kappa]n1,sd\[Tau]g1,
lli,uui,soln,ttx,tty,ttz,llx,lly,llz,uux,uuy,uuz,bbx,bby,bbz,
tt,ll,uu,bb,dd},
dsopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
fiopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
(* curve speed *)
ds=Functionize[s,Mag[D[b[s],s]]];
(* Darboux frame *)
t=Functionize[s,With[{db=D[b[s],s]},NormalizeReal[db]]];
u=Functionize[s,With[{txd=t[s]\[Cross]d[s]},\[Sigma] NormalizeReal[txd]]];
l=Functionize[s,u[s]\[Cross]t[s]];
(* left ruling angle trig functions *)
c\[Rho]L=Functionize[s,\[Sigma] t[s] . d[s]];
s\[Rho]L=Functionize[s,\[Sigma] l[s] . d[s]];
(* compute curve speed * geodesic curvature, normal curvature, geodesic torsion *)
sd\[Kappa]g=Functionize[s,l[s] . t'[s]];
sd\[Kappa]n=Functionize[s,u[s] . t'[s]];
sd\[Tau]g=Functionize[s,-l[s] . u'[s]];
(* New normal curvature and geodesic torsion products *)
sd\[Kappa]n1=Functionize[s,ds[s]\[Kappa]n[s]];
sd\[Tau]g1=Functionize[s,-ds[s] \[Kappa]n[s](t[s] . d[s]/l[s] . d[s])];
(* initial conditions on 2D Darboux frame *)
uui=NormalizeReal[\[Sigma] tti\[Cross]ddi];
lli=RotationMatrix3Du[\[Pi]/2,uui] . tti;
(* construct the new Darboux frame *)
{bb,tt,ll,uu}=NRecoverDarboux3D[{ds,sd\[Kappa]g,sd\[Kappa]n1,sd\[Tau]g1},{ui,bbi,tti,lli,uui},{u0,u1},opts];
(* rotate back to get the new director *)
dd=FunctionInterpolationAlt[\[Sigma](c\[Rho]L[s]tt[s]+s\[Rho]L [s]ll[s]),{s,u0,u1},fiopts];
{bb,dd,\[Sigma]}]
Module[{\[Sigma],bb,dd,ui,bi,ti,di,\[Kappa]n,b,d,u0,u1,v0,v1},
(* a cylinder *)
bb=Function[u,{-Cos[u],0,Sin[u]}];
dd={0,1,0}&;
\[Sigma]=+1;
(* initial conditions that put the surface in the s-y plane *)
{ui,bi,di,ti}={0,{0,0,0},{0,1,0},{1,0,0}};
(* interpolation range *)
{u0,u1}={0,\[Pi]};
(* desired normal curvature to achieve flatness *)
\[Kappa]n=0&;
(* the surface *)
{b,d,\[Sigma]}=NReshapeGeneric3D[{bb,dd,\[Sigma]},\[Kappa]n,{ui,bi,di,ti},{u0,u1}];
(* plot range *)
{v0,v1}={0,1};
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2.5,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[bb,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[4,2.5,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[b,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics[{
Styled2DAxes[4,2],
StyledRuledPatch[Planarize[b],Planarize[d],{ui,u1},{v0,v1}],
StyledCurve[Planarize[b],{u0,u1},CurveDirected->True],
{}}]},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
Module[{\[Sigma],bb,dd,ui,bi,ti,di,\[Kappa]n,b,d,u0,u1,v0,v1},
(* a flattened cylinder in 3D *)
bb=Unplanarize[Function[u,{u,0}]];
dd=Unplanarize[{0,1}&];
\[Sigma]=+1;
(* initial conditions for the curled cylinder *)
{ui,bi,di,ti}={0,{0,0,0},{0,1,0},{1,0,0}};
(* interpolation range *)
{u0,u1}={0,\[Pi]};
(* desired normal curvature with radius 1 *)
\[Kappa]n=1&;
(* the surface *)
{b,d,\[Sigma]}=NReshapeGeneric3D[{bb,dd,\[Sigma]},\[Kappa]n,{ui,bi,di,ti},{u0,u1}];
(* plot range *)
{v0,v1}={0,1};
GraphicsRow[{
Graphics3D[{
Styled3DAxes[4,2.5,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[bb,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[4,2.5,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[b,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}]
},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
Options[ReshapeCone3D]={
Simplification->None,
Assumptions->{}
};
ReshapeCone3D::nosoln="DSolve couldn't integrate the Darboux frame equations.";
StrictArguments[ReshapeCone3D];
ReshapeCone3D[{b_Function,d_Function,\[Sigma]_},\[Beta]_Function,\[Psi]_,{ui_,bbi_List,ddi_List,uui_List},opts___]:=Module[{sim,as,sfn,dsopts,
s,ds,t,l,u,
sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g,
lli,tti,soln,ttx,tty,ttz,llx,lly,llz,uux,uuy,uuz,bbx,bby,bbz,
tt,ll,uu,bb,dd},
sim=Simplification/.{opts}/.Options[ReshapeCone3D];
as=Join[{s\[Element]Reals},Assumptions/.{opts}/.Options[ReshapeCone3D]];
sfn=If[sim===None,#&,sim[#,Assumptions->as]&];
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
(* curve speed, can be unit-speed *)
ds=1&;
sd\[Kappa]g=Functionize[s,-\[Sigma] \[Psi] Mag[d'[s]]//sfn];
sd\[Kappa]n=Functionize[s,\[Beta][s]//sfn];
sd\[Tau]g=0&;
(* remaining initial conditions of Darboux frame *)
lli=\[Sigma] ddi//sfn;
tti=lli\[Cross]uui//sfn;
(* construct the new Darboux frame *)
{bb,tt,ll,uu}=RecoverDarboux3D[{ds,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g},{ui,bbi,tti,lli,uui},opts];
(* rotate to get the new director *)
dd=Functionize[s,\[Sigma] ll[s]//sfn];
(* discard the cross curve we calculated and replace with cone point *)
bb=bbi&;
(* return the new cone parameterization *)
{bb,dd,\[Sigma]}]
Block[{\[Sigma],\[Psi],\[Theta],bb,dd,ui,bi,uui,di,\[Beta],b,d,s,u0,u1,v0,v1,cc,c},
(* a cone *)
bb={0,0,0}&;
dd={-Sin[\[Theta]]Cos[#],Cos[\[Theta]],Sin[\[Theta]]Sin[#]}&;
\[Sigma]=-1;
\[Psi]=+1;
(* initial conditions that put the surface in the s-y plane *)
{ui,bi,di,uui}={0,{0,0,0},{0,1,0},{0,0,1}};
(* desired normal curvature to achieve flatness *)
\[Beta]=0&;
(* the surface *)
{b,d,\[Sigma]}=ReshapeCone3D[{bb,dd,\[Sigma]},\[Beta],+1,{ui,bi,di,uui},Simplification->FullSimplify,Assumptions->{\[Theta]>0,\[Theta]<\[Pi]/2}];
(* print the functions *)
Print["b = ",b//PrettyParameters];
Print["d = ",d//PrettyParameters];
(* plot range, note sign of v *)
{u0,u1}={0,\[Pi]};
{v0,v1}=If[\[Psi]==1,{0,1},{-1,0}];
(* pick a value of \[Theta] *)
\[Theta]=30\[Degree];
(* add a directed cross curve *)
cc=Functionize[s,bb[s]+ dd[s]];
c=Functionize[s,b[s]+ d[s]];
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[cc,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[c,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics[{
Styled2DAxes[2,2],
StyledRuledPatch[Planarize[b],Planarize[d],{u0,u1},{v0,v1}],
StyledCurve[Planarize[c],{u0,u1},CurveDirected->True],
{}}]},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
Block[{b,d,\[Sigma],\[Theta],ui,bbi,uui,ddi,\[Beta],\[Beta]0,bb,dd,s,u0,u1,v0,v1,cc,c},
(* a cone *)
b=Unplanarize[{0,0}&];
d=Unplanarize[{-Cos[#],Sin[#]}&];
\[Sigma]=1;
(* initial conditions *)
{ui,bbi,ddi,uui}={0,{0,0,0},{-1,0,0},{0,0,1}};
(* desired normal curvature to achieve flatness *)
\[Beta]=\[Beta]0&;
(* the surface *)
{bb,dd,\[Sigma]}=ReshapeCone3D[{b,d,\[Sigma]},\[Beta],+1,{ui,bbi,ddi,uui},Simplification->Simplify,Assumptions->{\[Beta]0>0}];
(* print the functions *)
Print["bb = ",bb//PrettyParameters];
Print["dd = ",dd//PrettyParameters];
(* plot range *)
{u0,u1}={0,\[Pi]};
{v0,v1}={0,1};
(* pick a value of \[Beta]0 *)
\[Beta]0=.7;
(* add a directed cross curve *)
cc=Functionize[s,bb[s]+ dd[s]];
c=Functionize[s,b[s]+ d[s]];
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[cc,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[c,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}]
},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
NReshapeCone3D::nosoln="NDSolve couldn't integrate the Darboux frame equations.";
StrictArguments[ReshapeCone3D];
NReshapeCone3D[{b_Function|b_InterpolatingFunction,d_Function|d_InterpolatingFunction,\[Sigma]_},\[Beta]_Function,\[Psi]_,{ui_,bbi_List,ddi_List,uui_List},{u0_,u1_},opts___]:=Module[{dsopts,fiopts,
s,ds,t,l,u,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g,lli,tti,tt,ll,uu,bb,dd},
dsopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
fiopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
(* curve speed, can be unit-speed *)
ds=1&;
(* Darboux frame *)
sd\[Kappa]g=Functionize[s,-\[Sigma] \[Psi] Mag[d'[s]]];
sd\[Kappa]n=\[Beta];
sd\[Tau]g=0&;
(* remaining initial conditions of Darboux frame *)
lli=\[Sigma] ddi;
tti=lli\[Cross]uui;
(* construct the new Darboux frame *)
{bb,tt,ll,uu}=NRecoverDarboux3D[{ds,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g},{ui,bbi,tti,lli,uui},{u0,u1},opts];
(* rotate to get the new director *)
dd=FunctionInterpolationAlt[\[Sigma] ll[s],{s,u0,u1},opts];
(* discard the cross curve we calculated and replace with cone point *)
bb=bbi&;
(* return the new cone parameterization *)
{bb,dd,\[Sigma]}]
Block[{\[Sigma],\[Theta],bb,dd,ui,bi,uui,di,\[Beta],b,d,s,u0,u1,v0,v1,cc,c},
\[Theta]=30.\[Degree];
(* a cone *)
bb={0,0,0}&;
dd={-Sin[\[Theta]]Cos[#],Cos[\[Theta]],Sin[\[Theta]]Sin[#]}&;
\[Sigma]=+1;
(* initial conditions that put the surface in the x-y plane *)
{ui,bi,di,uui}={0,{0,0,0},{0,1,0},{0,0,1}};
(* desired normal curvature to achieve flatness *)
\[Beta]=0&;
(* interpolation range *)
{u0,u1}={0,\[Pi]};
(* the surface *)
{b,d,\[Sigma]}=NReshapeCone3D[{bb,dd,\[Sigma]},\[Beta],+1,{ui,bi,di,uui},{u0,u1}];
(* plot range *)
{v0,v1}={0,1};
(* pick a value of \[Theta] *)
\[Theta]=30\[Degree];
(* add a directed cross curve *)
cc=Functionize[s,bb[s]+ dd[s]];
c=Functionize[s,b[s]+ d[s]];
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[cc,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[c,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics[{
Styled2DAxes[2,2],
StyledRuledPatch[Planarize[b],Planarize[d],{u0,u1},{v0,v1}],
StyledCurve[Planarize[c],{u0,u1},CurveDirected->True],
{}}]},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
Block[{b,d,\[Sigma],\[Theta],ui,bbi,uui,ddi,\[Beta],bb,dd,s,u0,u1,v0,v1,cc,c},
(* a cone *)
b=Unplanarize[{0,0}&];
d=Unplanarize[{-Cos[#],Sin[#]}&];
\[Sigma]=+1;
(* initial conditions *)
{ui,bbi,ddi,uui}={0,{0,0,0},{-1,0,0},{0,0,1}};
(* desired normal curvature to achieve flatness *)
\[Beta]=0.7&;
(* interpolation range *)
{u0,u1}={0,\[Pi]};
(* the surface *)
{bb,dd,\[Sigma]}=NReshapeCone3D[{b,d,\[Sigma]},\[Beta],+1,{ui,bbi,ddi,uui},{u0,u1}];
(* plot range *)
{v0,v1}={0,1};
(* add a directed cross curve *)
cc=Functionize[s,bb[s]+ dd[s]];
c=Functionize[s,b[s]+ d[s]];
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[cc,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1},SurfaceOrientation->\[Sigma]],
StyledCurve[c,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}]
},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
Options[ReshapeTandev3D]={
Simplification->None,
Assumptions->{}
};
ReshapeTandev3D::nosoln="DSolve couldn't integrate the Darboux frame equations.";
StrictArguments[ReshapeTandev3D];
ReshapeTandev3D[{b_Function,d_Function,\[Sigma]_},\[Tau]_Function,\[Psi]_,{ui_,bbi_List,ddi_List,uui_List},opts___]:=Module[{sim,as,sfn,dsopts,s,ds,t,l,u,c\[Rho]L,s\[Rho]L,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g,\[Zeta],
lli,tti,tt,ll,uu,bb,dd},
sim=Simplification/.{opts}/.Options[ReshapeTandev3D];
as=Join[{s\[Element]Reals},Assumptions/.{opts}/.Options[ReshapeTandev3D]];
sfn=If[sim===None,#&,sim[#,Assumptions->as]&];
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
(* algorithm *)
ds=Functionize[s,Mag[D[b[s],s]]//sfn];
t=Functionize[s,With[{db=b'[s]},NormalizeReal[db]]//sfn];
u=Functionize[s,With[{ddd=d'[s]},\[Sigma] \[Psi] NormalizeReal[ddd]\[Cross]d[s]]//sfn];
l=Functionize[s,u[s]\[Cross]t[s]//sfn];
sd\[Kappa]g=Functionize[s,l[s] . t'[s]//sfn];
sd\[Kappa]n=0&;
sd\[Tau]g=\[Tau];
\[Zeta]=t[ui] . d[ui];
tti=\[Zeta] ddi;
lli = uui \[Cross]tti;
{bb,tt,ll,uu}=RecoverDarboux3D[{ds,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g},{ui,bbi,tti,lli,uui},opts];
dd=Functionize[s,\[Zeta] tt[s]//sfn];
{bb,dd,\[Sigma]}]
Module[{bb,dd,\[Sigma],\[Tau],ui,bbi,uui,ddi,b,d,u0,u1,v0,v1},
bb={-(1/2) \[Sqrt]3 Cos[#],(1/2) \[Sqrt]3 Sin[#],#/2}&;
dd={(1/2) \[Sqrt]3 Sin[#],(1/2) \[Sqrt]3 Cos[#],1/2}&;
\[Sigma]=1;
(* torsion for flat shape *)
\[Tau]=0&;
(* initial conditions in the flat state *)
{ui,bbi,ddi,uui}={0,{-1,0,0},{0,1,0},{0,0,1}};
{b,d,\[Sigma]}=ReshapeTandev3D[{bb,dd,\[Sigma]},\[Tau],+1,{ui,bbi,ddi,uui},Simplification->Simplify];
Print["b = ",b//PrettyParameters];
Print["d = ",d//PrettyParameters];
(* plot range *)
{u0,u1}={0,\[Pi]};
{v0,v1}={0,1};
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1}],
StyledCurve[bb,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1}],
StyledCurve[b,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics[{
Styled2DAxes[2,2],
StyledRuledPatch[Planarize[b],Planarize[d],{u0,u1},{v0,v1}],
StyledCurve[Planarize[b],{u0,u1},CurveDirected->True],
{}}]},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
Module[{bb,dd,\[Sigma],\[Tau],ui,bbi,uui,ddi,b,d,u0,u1,v0,v1},
b={-1+(4 Sin[(\[Sqrt]3 #)/4]^2)/(\[Sqrt]3),(2 Sin[(\[Sqrt]3 #)/2])/(\[Sqrt]3),0}&;
d={Sin[(\[Sqrt]3 #)/2],Cos[(\[Sqrt]3 #)/2],0}&;
\[Sigma]=1;
(* torsion for 3D shape *)
\[Tau]=-1/2&;
(* initial conditions in the 3D state *)
{ui,bbi,ddi,uui}={0,{-1,0,0},{0,(\[Sqrt]3)/2,1/2},{0,-(1/2),(\[Sqrt]3)/2}};
{bb,dd,\[Sigma]}=ReshapeTandev3D[{b,d,\[Sigma]},\[Tau],+1,{ui,bbi,ddi,uui},Simplification->Simplify];
Print["bb = ",bb//PrettyParameters];
Print["dd = ",dd//PrettyParameters];
(* plot range *)
{u0,u1}={0,\[Pi]};
{v0,v1}={0,1};
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1}],
StyledCurve[bb,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1}],
StyledCurve[b,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics[{
Styled2DAxes[2,2],
StyledRuledPatch[Planarize[b],Planarize[d],{u0,u1},{v0,v1}],
StyledCurve[Planarize[b],{u0,u1},CurveDirected->True],
{}}]},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
NReshapeTandev3D::nosoln="NDSolve couldn't integrate the Darboux frame equations.";
StrictArguments[NReshapeTandev3D];
NReshapeTandev3D[{b_Function|b_InterpolatingFunction,d_Function|d_InterpolatingFunction,\[Sigma]_},\[Tau]_Function,sv_,{ui_,bbi_List,ddi_List,uui_List},{u0_,u1_},opts___]:=Module[{dsopts,fiopts,s,ds,t,l,u,c\[Rho]L,s\[Rho]L,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g,\[Zeta],lli,tti,tt,ll,uu,bb,dd},
dsopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
fiopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
(* algorithm *)
ds=Functionize[s,Mag[D[b[s],s]]];
t=FunctionInterpolationAlt[With[{db=b'[s]},NormalizeReal[db]],{s,u0,u1},opts];
u=FunctionInterpolationAlt[With[{ddd=d'[s]},\[Sigma] sv NormalizeReal[ddd]\[Cross]d[s]],{s,u0,u1},opts];
l=FunctionInterpolationAlt[u[s]\[Cross]t[s],{s,u0,u1},opts];
sd\[Kappa]g=FunctionInterpolationAlt[l[s] . t'[s],{s,u0,u1},opts];
sd\[Kappa]n=0&;
sd\[Tau]g=\[Tau];
\[Zeta]=t[ui] . d[ui];
tti=\[Zeta] ddi;
lli = uui \[Cross]tti;
{bb,tt,ll,uu}=NRecoverDarboux3D[{ds,sd\[Kappa]g,sd\[Kappa]n,sd\[Tau]g},{ui,bbi,tti,lli,uui},{u0,u1},opts];
dd=FunctionInterpolationAlt[\[Zeta] tt[s],{s,u0,u1},fiopts];
{bb,dd,\[Sigma]}]
Module[{bb,dd,\[Sigma],\[Tau],ui,bbi,uui,ddi,b,d,u0,u1,v0,v1},
{u0,u1}={0,\[Pi]};
bb=FunctionInterpolationAlt[{-(1/2) \[Sqrt]3 Cos[#],(1/2) \[Sqrt]3 Sin[#],#/2}&[s],{s,u0,u1}];
dd=FunctionInterpolationAlt[{(1/2) \[Sqrt]3 Sin[#],(1/2) \[Sqrt]3 Cos[#],1/2}&[s],{s,u0,u1}];
\[Sigma]=1;
(* torsion for flat shape *)
\[Tau]=0&;
(* initial conditions in the flat state *)
{ui,bbi,ddi,uui}={0,{-1,0,0},{0,1,0},{0,0,1}};
{b,d,\[Sigma]}=NReshapeTandev3D[{bb,dd,\[Sigma]},\[Tau],+1,{ui,bbi,ddi,uui},{u0,u1},Simplification->Simplify];
(* plot range *)
{v0,v1}={0,1};
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1}],
StyledCurve[bb,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1}],
StyledCurve[b,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics[{
Styled2DAxes[2,2],
StyledRuledPatch[Planarize[b],Planarize[d],{u0,u1},{v0,v1}],
StyledCurve[Planarize[b],{u0,u1},CurveDirected->True],
{}}]},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
Module[{bb,dd,\[Sigma],\[Tau],ui,bbi,uui,ddi,b,d,u0,u1,v0,v1},
b={-1+(4 Sin[(\[Sqrt]3 #)/4]^2)/(\[Sqrt]3),(2 Sin[(\[Sqrt]3 #)/2])/(\[Sqrt]3),0}&;
d={Sin[(\[Sqrt]3 #)/2],Cos[(\[Sqrt]3 #)/2],0}&;
\[Sigma]=1;
(* torsion for 3D shape *)
\[Tau]=-1/2&;
(* initial conditions in the 3D state *)
{ui,bbi,ddi,uui}={0,{-1,0,0},{0,(\[Sqrt]3)/2,1/2},{0,-(1/2),(\[Sqrt]3)/2}};
(* interpolation domain *)
{u0,u1}={0,\[Pi]};
(* the surface *)
{bb,dd,\[Sigma]}=NReshapeTandev3D[{b,d,\[Sigma]},\[Tau],+1,{ui,bbi,ddi,uui},{u0,u1}];
(* plot range *)
{v0,v1}={0,1};
GraphicsRow[{
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[bb,dd,{u0,u1},{v0,v1}],
StyledCurve[bb,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}],
Graphics3D[{
Styled3DAxes[2,2,2],
StyledRuledPatch[b,d,{u0,u1},{v0,v1}],
StyledCurve[b,{u0,u1},CurveDirected->True],
{}},Lighting->NeutralLighting[.8],Method->{"ShrinkWrap"->True}]},ImageSize->600]/.OrigamiStyle[]
]//ShowExample
StrictArguments[CurvedFoldShapePlots2D];
CurvedFoldShapePlots2D[f_Function|f_InterpolatingFunction,rL_Function|rL_InterpolatingFunction,rR_Function|rR_InterpolatingFunction,\[Gamma]_Function|\[Gamma]_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{csys,\[Kappa]l,t},
csys=If[ContainsInterpolatingFunctionQ[f],
NCurve2DSystem[f,{u0,u1},opts],
Curve2DSystem[f,opts]];
{\[Kappa]l,t}={LeftCurvature2D,TangentVector2D}/.csys;
{Plot[{\[Kappa]l[s],0},{s,u0,u1},PlotLabel->Style["\!\(\*SubscriptBox[\(\[Kappa]\), \(l\)]\)",Blue],PlotStyle->{Blue,White}],
Plot[{ArcCos[rL[s] . t[s]]/\[Degree],ArcCos[rR[s] . t[s]]/\[Degree],\[Gamma][s]/\[Degree],0},{s,u0,u1},PlotLabel->{Style["\!\(\*SubscriptBox[\(\[Rho]\), \(L\)]\)/\[Degree]",Red],Style["\!\(\*SubscriptBox[\(\[Rho]\), \(R\)]\)/\[Degree]",Darker[Green]],Style["\[Gamma]/\[Degree]",Purple]},PlotStyle->{{Red},{Darker[Green],Dashed},{Purple,Dotted},White}]}]
Module[{u0,u1,f,rL,rR,\[Gamma],plots},
{u0,u1}={0,\[Pi]};
\[Gamma]=60\[Degree]+60\[Degree](#/\[Pi])&;
{f,rL,rR,\[Gamma]}=NCurvedFoldHelix2D[1,30\[Degree],\[Gamma],{u0,u1}];
plots=CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}];
GraphicsRow[plots]
]//Hold;
StrictArguments[CurvedFoldShapePlots3D];
CurvedFoldShapePlots3D[f_Function|ff_InterpolatingFunction,rrL_Function|rrL_InterpolatingFunction,rrR_Function|rRr_InterpolatingFunction,\[Gamma]_Function|\[Gamma]_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{csys,\[Kappa],\[Tau],tt,\[Kappa]g},
csys=If[ContainsInterpolatingFunctionQ[f],
NCurve3DSystem[f,{u0,u1},opts],
Curve3DSystem[f,opts]];
{\[Kappa],\[Tau],tt}={Curvature3D,Torsion3D,TangentVector3D}/.csys;
{Plot[{\[Kappa][s],\[Kappa][s]Cos[\[Gamma][s]/2],\[Tau][s],0},{s,u0,u1},PlotLabel->{Style["\[Kappa]",Darker[Blue]],Style["\!\(\*SubscriptBox[\(\[Kappa]\), \(g\)]\)",Blue],Style["\[Tau]",Magenta]},PlotStyle->{Darker[Blue],Blue,Magenta,White}],
Plot[{ArcCos[rrL[s] . tt[s]]/\[Degree],ArcCos[rrR[s] . tt[s]]/\[Degree],\[Gamma][s]/\[Degree],0},{s,u0,u1},PlotLabel->{Style["\!\(\*SubscriptBox[\(\[Rho]\), \(L\)]\)/\[Degree]",Red],Style["\!\(\*SubscriptBox[\(\[Rho]\), \(R\)]\)/\[Degree]",Darker[Green]],Style["\[Gamma]/\[Degree]",Purple]},PlotStyle->{{Red},{Darker[Green],Dashed},{Purple,Dotted},White}]}]
Module[{u0,u1,\[Gamma],ip,ff,rrL,rrR,plots},
{u0,u1}={0,\[Pi]};
\[Gamma]=60\[Degree]+60\[Degree](#/\[Pi])&;
ip=64;
{ff,rrL,rrR,\[Gamma]}=NCurvedFoldHelix3D[1,30\[Degree],\[Gamma],{u0,u1},InterpolationPoints->ip];
plots=CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}];
GraphicsRow[plots]
]//Hold;
StrictArguments[CurvedFoldGraphics];
CurvedFoldGraphics[f_Function|f_InterpolatingFunction,rL_|rL_InterpolatingFunction,rR_|rR_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{},
Graphics[{
StyledCurvedFold[f,{rL,rR},{u0,u1}],
StyledVector[{f[u0],f[u0]+rL[u0]},VectorColor->Red],
StyledVector[{f[u0],f[u0]+rR[u0]},VectorColor->Green],
{}},opts]]
StrictArguments[CurvedFoldGraphics3D];
CurvedFoldGraphics3D[ff_Function|ff_InterpolatingFunction,rrL_|rrL_InterpolatingFunction,rrR_|rrR_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{},
Graphics3D[{
StyledCurvedFold[ff,{rrL,rrR},{u0,u1}],
StyledVector[{ff[u0],ff[u0]+rrL[u0]},VectorColor->Red],
StyledVector[{ff[u0],ff[u0]+rrR[u0]},VectorColor->Green],
{}},opts]]
Options[FlattenFold2D]={
Simplification->None,
Assumptions->{}
};
StrictArguments[FlattenFold2D];
FlattenFold2D[ff_Function,rrL_Function,rrR_Function,{ui_,fi_List,ti_List},opts___]:=Module[{si,as,s,sfn,dff,ds,tt,uuL,llL,c\[Rho]L,s\[Rho]L,uuR,llR,c\[Rho]R,s\[Rho]R,\[Kappa]g,csys,f,t,rL,rR},
si=Simplification/.{opts}/.Options[FlattenFold2D];
as=Assumptions/.{opts}/.Options[FlattenFold2D];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
(* speed and tangent *)
dff=Functionize[s,ff'[s]//sfn];
ds=Functionize[s,Mag[dff[s]]//sfn];
tt=Functionize[s,dff[s]/ds[s]//sfn];
(* Left side *)
uuL=Functionize[s,With[{txr=tt[s]\[Cross]rrL[s]},NormalizeReal[txr]]//sfn];
llL=Functionize[s,uuL[s]\[Cross]tt[s]//sfn];
c\[Rho]L=Functionize[s,rrL[s] . tt[s]//sfn];
s\[Rho]L=Functionize[s,rrL[s] . llL[s]//sfn];
(* Right side *)
uuR=Functionize[s,With[{txr=-tt[s]\[Cross]rrR[s]},NormalizeReal[txr]]//sfn];
llR=Functionize[s,uuR[s]\[Cross]tt[s]//sfn];
c\[Rho]R=Functionize[s,rrR[s] . tt[s]//sfn];
s\[Rho]R=Functionize[s,-rrR[s] . llR[s]//sfn];
(* Integrate planar Darboux frame equation for the 2D curved fold *)
\[Kappa]g=Functionize[s,llL[s] . tt'[s]/ds[s]//sfn];
(* add this extra simplification step if we are FullSimplify-ing. *)
If[si==FullSimplify,
\[Kappa]g=Functionize[s,\[Kappa]g[s]//CombineSquareRootsInProducts//sfn]];
csys=RecoverCurve2DSystem[ds,\[Kappa]g,{ui,fi,ti},opts];
{f,t}={Curve2D,TangentVector2D}/.csys;
rL=Functionize[s,RotationMatrix2D[{c\[Rho]L[s],s\[Rho]L[s]}] . t[s]//sfn];
rR=Functionize[s,RotationMatrix2D[{c\[Rho]R[s],-s\[Rho]R[s]}] . t[s]//sfn];
{f,rL,rR}]
Block[{s,\[Gamma]0,\[Gamma],u0,u1,ff,rrL,rrR,f,rL,rR,ui,fi,ti},
\[Gamma]0=120\[Degree];
\[Gamma]=\[Gamma]0&;
{u0,u1}={0,\[Pi]};
{ui,fi,ti}={0,{1,0},{0,1}};
ff=Functionize[s,{Cos[s],Sin[s],0}];
rrL={-Cos[\[Gamma]0/2] Cos[#1],-Cos[\[Gamma]0/2] Sin[#1],Sin[\[Gamma]0/2]}&;
rrR={Cos[\[Gamma]0/2] Cos[#1],Cos[\[Gamma]0/2] Sin[#1],Sin[\[Gamma]0/2]}&;
GraphicsRow[CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}]]//Print;
{f,rL,rR}=FlattenFold2D[ff,rrL,rrR,{ui,fi,ti},Simplification->Simplify];
GraphicsRow[CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]]//Print;
GraphicsRow[{
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}],
CurvedFoldGraphics[f,rL,rR,{u0,u1}]}]/.OrigamiStyle[]
]//ShowExample
StrictArguments[NFlattenFold2D];
NFlattenFold2D[ff_Function|ff_InterpolatingFunction,rrL_Function|rrL_InterpolatingFunction,rrR_Function|rrR_InterpolatingFunction,{ui_,fi_List,ti_List},{u0_,u1_},opts___]:=Module[{s,dff,ds,tt,uuL,llL,c\[Rho]L,s\[Rho]L,uuR,llR,c\[Rho]R,s\[Rho]R,\[Kappa]g,csys,f,t,\[Kappa]l,rL,rR},
(* speed and tangent *)
dff=Functionize[s,ff'[s]];
ds=Functionize[s,Mag[dff[s]]];
tt=Functionize[s,dff[s]/ds[s]];
(* Left side *)
uuL=Functionize[s,With[{txr=tt[s]\[Cross]rrL[s]},NormalizeReal[txr]]];
llL=Functionize[s,uuL[s]\[Cross]tt[s]];
c\[Rho]L=Functionize[s,rrL[s] . tt[s]];
s\[Rho]L=Functionize[s,rrL[s] . llL[s]];
(* Right side *)
uuR=Functionize[s,With[{txr=-tt[s]\[Cross]rrR[s]},NormalizeReal[txr]]];
llR=Functionize[s,uuR[s]\[Cross]tt[s]];
c\[Rho]R=Functionize[s,rrR[s] . tt[s]];
s\[Rho]R=Functionize[s,-rrR[s] . llR[s]];
(* Integrate planar Darboux frame equation for the 2D curved fold *)
\[Kappa]g=Functionize[s,llL[s] . tt'[s]/ds[s]];
csys=NRecoverCurve2DSystem[ds,\[Kappa]g,{ui,fi,ti},{u0,u1},opts];
{f,t,\[Kappa]l}={Curve2D,TangentVector2D,LeftCurvature2D}/.csys;
rL=FunctionInterpolationAlt[RotationMatrix2D[{c\[Rho]L[s],s\[Rho]L[s]}] . t[s],{s,u0,u1},opts];
rR=FunctionInterpolationAlt[RotationMatrix2D[{c\[Rho]R[s],-s\[Rho]R[s]}] . t[s],{s,u0,u1},opts];
{f,rL,rR}]
Block[{s,\[Gamma]0,\[Gamma],u0,u1,ff,rrL,rrR,f,rL,rR,ui,fi,ti},
\[Gamma]0=120\[Degree];
\[Gamma]=\[Gamma]0&;
{u0,u1}={0,\[Pi]};
{ui,fi,ti}={0,{1,0},{0,1}};
ff=Functionize[s,{Cos[s],Sin[s],0}];
rrL={-Cos[\[Gamma]0/2] Cos[#1],-Cos[\[Gamma]0/2] Sin[#1],Sin[\[Gamma]0/2]}&;
rrR={Cos[\[Gamma]0/2] Cos[#1],Cos[\[Gamma]0/2] Sin[#1],Sin[\[Gamma]0/2]}&;
GraphicsRow[CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}]]//Print;
{f,rL,rR}=NFlattenFold2D[ff,rrL,rrR,{ui,fi,ti},{u0,u1}];
GraphicsRow[CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]]//Print;
GraphicsRow[{
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}],
CurvedFoldGraphics[f,rL,rR,{u0,u1}]}]/.OrigamiStyle[]
]//ShowExample
Options[FoldSpaceCurve3D]={
Simplification->None,
Assumptions->{}
};
StrictArguments[FoldSpaceCurve3D];
FoldSpaceCurve3D[ff_Function,\[Gamma]_Function,\[FinalSigma]_,opts___]:=Module[{si,as,s,sfn,csys,ds,tt,nn,bb,llL,uuL,duuL,mduuL,c\[Rho]L,s\[Rho]L,rrL,llR,uuR,duuR,mduuR,c\[Rho]R,s\[Rho]R,rrR},
si=Simplification/.{opts}/.Options[FoldSpaceCurve3D];
as=Assumptions/.{opts}/.Options[FoldSpaceCurve3D];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
(* Get the Frenet frame of the curve *)
csys=Curve3DSystem[ff,opts];
{ds,tt,nn,bb}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.csys;
(* Left side *)
llL=Functionize[s,\[FinalSigma] Cos[\[Gamma][s]/2]nn[s]+\[FinalSigma] Sin[\[Gamma][s]/2]bb[s]//sfn];
uuL=Functionize[s,-\[FinalSigma] Sin[\[Gamma][s]/2]nn[s]+\[FinalSigma] Cos[\[Gamma][s]/2]bb[s]//sfn];
duuL=Functionize[s,uuL'[s]];
mduuL=Functionize[s,Mag[duuL[s]]];
c\[Rho]L=Functionize[s,-Sign[duuL[s] . tt[s]](duuL[s] . llL[s]/mduuL[s])];
s\[Rho]L=Functionize[s,Abs[duuL[s] . tt[s]]/mduuL[s]];
rrL=Functionize[s,c\[Rho]L[s]tt[s]+s\[Rho]L[s] llL[s]//sfn];
(* Right side *)
llR=Functionize[s,\[FinalSigma] Cos[\[Gamma][s]/2]nn[s]-\[FinalSigma] Sin[\[Gamma][s]/2]bb[s]//sfn];
uuR=Functionize[s,\[FinalSigma] Sin[\[Gamma][s]/2]nn[s]+\[FinalSigma] Cos[\[Gamma][s]/2]bb[s]//sfn];
duuR=Functionize[s,uuR'[s]];
mduuR=Functionize[s,Mag[duuR[s]]];
c\[Rho]R=Functionize[s,+Sign[duuR[s] . tt[s]](duuR[s] . llR[s]/mduuR[s])];
s\[Rho]R=Functionize[s,Abs[duuR[s] . tt[s]]/mduuR[s]];
rrR=Functionize[s,c\[Rho]R[s]tt[s]-s\[Rho]R[s] llR[s]//sfn];
{ff,rrL,rrR}]
Block[{h,\[Gamma]0,ff,\[Gamma],as,cfsys,rrL,rrR,u0,u1},
ff={Cos[#],Sin[#],h #}&;
\[Gamma]=\[Gamma]0&;
as={h\[Element]Reals,\[Gamma]0\[Element]Reals};
{ff,rrL,rrR}=FoldSpaceCurve3D[ff,\[Gamma],+1,Simplification->Simplify,Assumptions->as];
Print["rrL = ",rrL//PrettyParameters]//Hold;
Print["rrR = ",rrR//PrettyParameters]//Hold;
h=0.5;
\[Gamma]0=90.\[Degree];
{u0,u1}={0,\[Pi]};
GraphicsRow[CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}]]//Print;
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]/.OrigamiStyle[]//Print;
]//ShowExample
StrictArguments[NSpaceCurveFold3D];
NSpaceCurveFold3D[ff_Function|ff_InterpolatingFunction,\[Gamma]_Function|\[Gamma]_InterpolatingFunction,\[FinalSigma]_,{u0_,u1_},opts___]:=Module[{s,csys,ds,tt,nn,bb,llL,uuL,duuL,mduuL,c\[Rho]L,s\[Rho]L,rrL,llR,uuR,duuR,mduuR,c\[Rho]R,s\[Rho]R,rrR},
(* Get the Frenet frame of the curve *)
csys=NCurve3DSystem[ff,{u0,u1},opts];
{ds,tt,nn,bb}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.csys;
(* Left side *)
llL=Functionize[s,\[FinalSigma] Cos[\[Gamma][s]/2]nn[s]+\[FinalSigma] Sin[\[Gamma][s]/2]bb[s]];
uuL=Functionize[s,-\[FinalSigma] Sin[\[Gamma][s]/2]nn[s]+\[FinalSigma] Cos[\[Gamma][s]/2]bb[s]];
duuL=Functionize[s,uuL'[s]];
mduuL=Functionize[s,Mag[duuL[s]]];
c\[Rho]L=Functionize[s,-Sign[duuL[s] . tt[s]](duuL[s] . llL[s]/mduuL[s])];
s\[Rho]L=Functionize[s,Abs[duuL[s] . tt[s]]/mduuL[s]];
rrL=FunctionInterpolationAlt[c\[Rho]L[s]tt[s]+s\[Rho]L[s] llL[s],{s,u0,u1},opts];
(* Right side *)
llR=Functionize[s,\[FinalSigma] Cos[\[Gamma][s]/2]nn[s]-\[FinalSigma] Sin[\[Gamma][s]/2]bb[s]];
uuR=Functionize[s,\[FinalSigma] Sin[\[Gamma][s]/2]nn[s]+\[FinalSigma] Cos[\[Gamma][s]/2]bb[s]];
duuR=Functionize[s,uuR'[s]];
mduuR=Functionize[s,Mag[duuR[s]]];
c\[Rho]R=Functionize[s,+Sign[duuR[s] . tt[s]](duuR[s] . llR[s]/mduuR[s])];
s\[Rho]R=Functionize[s,Abs[duuR[s] . tt[s]]/mduuR[s]];
rrR=FunctionInterpolationAlt[c\[Rho]R[s]tt[s]-s\[Rho]R[s] llR[s],{s,u0,u1},opts];
{ff,rrL,rrR}]
Block[{h,\[Gamma]0,ff,\[Gamma],cfsys,rrL,rrR,u0,u1},
ff={Cos[#],Sin[#],h #}&;
\[Gamma]=\[Gamma]0&;
h=0.5;
\[Gamma]0=90.\[Degree];
{u0,u1}={0,\[Pi]};
{ff,rrL,rrR}=NSpaceCurveFold3D[ff,\[Gamma],+1,{u0,u1}];
GraphicsRow[CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}]]//Print;
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]/.OrigamiStyle[]//Print;
]//ShowExample
Block[{\[Gamma]0,ff,\[Gamma],cfsys,rrL,rrR,u0,u1,rld,cd},
ff=KnotData["Trefoil","SpaceCurve"];
Print["f[t] = ",ff//PrettyParameters];
\[Gamma]=\[Gamma]0&;
\[Gamma]0=135.\[Degree];
{u0,u1}={\[Pi]/3,2\[Pi]+\[Pi]/3};
{ff,rrL,rrR}=NSpaceCurveFold3D[ff,\[Gamma],+1,{u0,u1},InterpolationPoints->256];
{rld,cd}={75,500};
GraphicsRow[CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}]]//Print;
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1},Lighting->NeutralLighting[.8]]/.OrigamiStyle[]//Print;
]//ShowExample
CurvedFoldUniformHelix3D[r_,\[Theta]_,\[Gamma]0_]:=Module[{ff,rrL,rrR,\[Gamma]},
ff=r{Cos[#],Sin[#],Tan[\[Theta]]#}&;
\[Gamma]=\[Gamma]0&;
{r {Cos[#1],Sin[#1],Tan[\[Theta]] #1}&,{-((Cos[\[Theta]] (Cos[#1] Sin[\[Gamma]0]+(1+Cos[\[Gamma]0]) Sin[\[Theta]] Sin[#1]))/(\[Sqrt]2 \[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2))),(Cos[\[Theta]] ((1+Cos[\[Gamma]0]) Cos[#1] Sin[\[Theta]]-Sin[\[Gamma]0] Sin[#1]))/(\[Sqrt]2 \[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2)),(\[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2))/(\[Sqrt]2)}&,{(Cos[\[Theta]] (Cos[#1] Sin[\[Gamma]0]-(1+Cos[\[Gamma]0]) Sin[\[Theta]] Sin[#1]))/(\[Sqrt]2 \[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2)),(Cos[\[Theta]] ((1+Cos[\[Gamma]0]) Cos[#1] Sin[\[Theta]]+Sin[\[Gamma]0] Sin[#1]))/(\[Sqrt]2 \[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2)),(\[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2))/(\[Sqrt]2)}&,\[Gamma]0&}]
Block[{r,\[Theta],\[Gamma]0,as,ff,rrL,rrR,\[Gamma],s},
ff=r{Cos[#],Sin[#],Tan[\[Theta]]#}&;
\[Gamma]=\[Gamma]0&;
as={r>0,\[Gamma]0>0,\[Theta]\[Element]Reals,Sec[\[Theta]]>0,Cos[\[Theta]]>0,Sin[\[Gamma]0/2]>0};
{ff,rrL,rrR}=FoldSpaceCurve3D[ff,\[Gamma],+1,Simplification->FullSimplify,Assumptions->as];
Print["ff = ",ff//PrettyParameters];
Print["rrL = ",rrL//PrettyParameters];
Print["rrR = ",rrR//PrettyParameters];
(* some more simplification *)
rrL=Functionize[s,FullSimplify[rrL[s]/.{Sin[x_/2]^2:>(1/2)(1-Cos[x]),Cos[x_/2]^2:>(1/2)(1+Cos[x])},Assumptions->as]];
rrR=Functionize[s,FullSimplify[rrR[s]/.{Sin[x_/2]^2:>(1/2)(1-Cos[x]),Cos[x_/2]^2:>(1/2)(1+Cos[x])},Assumptions->as]];
Print["after another round"];
Print["rrL = ",rrL//PrettyParameters];
Print["rrR = ",rrR//PrettyParameters];
{ff,rrL,rrR,\[Gamma]}
]//Hold;
Module[{u0,u1,ff,rrL,rrR,\[Gamma]},
{u0,u1}={0,\[Pi]};
{ff,rrL,rrR,\[Gamma]}=CurvedFoldUniformHelix3D[1,30\[Degree],90\[Degree]];
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
NCurvedFoldUniformHelix3D[r_,\[Theta]_,\[Gamma]0_,{u0_,u1_},opts___]:=Module[{s,ff,rrL,rrR,\[Gamma]},
{ff,rrL,rrR,\[Gamma]}=CurvedFoldUniformHelix3D[r,\[Theta],\[Gamma]0];
ff=FunctionInterpolationAlt[ff[s],{s,u0,u1},opts];
rrL=FunctionInterpolationAlt[rrL[s],{s,u0,u1},opts];
rrR=FunctionInterpolationAlt[rrR[s],{s,u0,u1},opts];
\[Gamma]=FunctionInterpolationAlt[\[Gamma][s],{s,u0,u1},opts];
{ff,rrL,rrR,\[Gamma]}]
Module[{u0,u1,ff,rrL,rrR,\[Gamma]},
{u0,u1}={0,\[Pi]};
{ff,rrL,rrR,\[Gamma]}=NCurvedFoldUniformHelix3D[1,30\[Degree],90\[Degree],{0,\[Pi]}];
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
StrictArguments[CurvedFoldUniformHelix2D];
CurvedFoldUniformHelix2D[r_,\[Theta]_,\[Gamma]0_]:=Module[{ff,rrL,rrR,\[Gamma]},
ff=r{Cos[#],Sin[#],Tan[\[Theta]]#}&;
\[Gamma]=\[Gamma]0&;
{{(1/4) (3+(1+4 r (-1+Cos[Cos[\[Gamma]0/2] Cos[\[Theta]] #1]) Sec[\[Gamma]0/2]) Sec[\[Theta]]^2-Tan[\[Theta]]^2),r Sec[\[Gamma]0/2] Sec[\[Theta]]^2 Sin[Cos[\[Gamma]0/2] Cos[\[Theta]] #1]}&,{-((\[Sqrt]2 (Cos[\[Theta]] Cos[Cos[\[Gamma]0/2] Cos[\[Theta]] #1] Sin[\[Gamma]0/2]+Sin[\[Theta]] Sin[Cos[\[Gamma]0/2] Cos[\[Theta]] #1]))/(\[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2))),(\[Sqrt]2 (Cos[Cos[\[Gamma]0/2] Cos[\[Theta]] #1] Sin[\[Theta]]-Cos[\[Theta]] Sin[\[Gamma]0/2] Sin[Cos[\[Gamma]0/2] Cos[\[Theta]] #1]))/(\[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2))}&,{(\[Sqrt]2 (Cos[\[Theta]] Cos[Cos[\[Gamma]0/2] Cos[\[Theta]] #1] Sin[\[Gamma]0/2]-Sin[\[Theta]] Sin[Cos[\[Gamma]0/2] Cos[\[Theta]] #1]))/(\[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2)),(\[Sqrt]2 (Cos[Cos[\[Gamma]0/2] Cos[\[Theta]] #1] Sin[\[Theta]]+Cos[\[Theta]] Sin[\[Gamma]0/2] Sin[Cos[\[Gamma]0/2] Cos[\[Theta]] #1]))/(\[Sqrt](1-Cos[\[Gamma]0] Cos[\[Theta]]^2+Sin[\[Theta]]^2))}&,\[Gamma]0&}]
Block[{r,\[Theta],\[Gamma]0,as,ff,rrL,rrR,\[Gamma],s},
{ff,rrL,rrR,\[Gamma]}=CurvedFoldUniformHelix3D[r,\[Theta],\[Gamma]0];
as=as={r>0,\[Gamma]0>0,\[Theta]\[Element]Reals,Sec[\[Theta]]>0,Sin[\[Gamma]0/2]>0,Cos[\[Gamma]0/2]>0,Cos[\[Theta]]>0};
{ff,rrL,rrR}=FlattenFold2D[ff,rrL,rrR,{0,{1,0},{0,1}},Simplification->FullSimplify,Assumptions->as];
(* some further simplification *)
ff=Functionize[s,FullSimplify[ff[s]/.{\[Sqrt](-1-Cos[\[Gamma]0])->I \[Sqrt](1+Cos[\[Gamma]0])},as]];
rrL=Functionize[s,FullSimplify[rrL[s]/.{\[Sqrt](-1-Cos[\[Gamma]0])->I \[Sqrt](1+Cos[\[Gamma]0])},as]];
rrR=Functionize[s,FullSimplify[rrR[s]/.{\[Sqrt](-1-Cos[\[Gamma]0])->I \[Sqrt](1+Cos[\[Gamma]0])},as]];
{ff,rrL,rrR,\[Gamma]}
]//Hold;
Module[{u0,u1,f,rL,rR,\[Gamma]},
{u0,u1}={0,\[Pi]};
{f,rL,rR,\[Gamma]}=CurvedFoldUniformHelix2D[1,30\[Degree],90\[Degree]];
CurvedFoldGraphics[f,rL,rR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
StrictArguments[NCurvedFoldUniformHelix2D];
NCurvedFoldUniformHelix2D[r_,\[Theta]_,\[Gamma]0_,{u0_,u1_},opts___]:=Module[{ff,rrL,rrR,\[Gamma],s},
{ff,rrL,rrR,\[Gamma]}=CurvedFoldUniformHelix2D[r,\[Theta],\[Gamma]0];
ff=FunctionInterpolationAlt[ff[s],{s,u0,u1},opts];
rrL=FunctionInterpolationAlt[rrL[s],{s,u0,u1},opts];
rrR=FunctionInterpolationAlt[rrR[s],{s,u0,u1},opts];
\[Gamma]=FunctionInterpolationAlt[\[Gamma][s],{s,u0,u1},opts];
{ff,rrL,rrR,\[Gamma]}]
Module[{u0,u1,f,rL,rR,\[Gamma]},
{u0,u1}={0,\[Pi]};
{f,rL,rR,\[Gamma]}=NCurvedFoldUniformHelix2D[1,30\[Degree],90\[Degree],{u0,u1}];
CurvedFoldGraphics[f,rL,rR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
Module[{u0,u1,f,rL,rR,ff,rrL,rrR,\[Gamma]},
{u0,u1}={0,\[Pi]};
{ff,rrL,rrR,\[Gamma]}=CurvedFoldUniformHelix3D[1,30\[Degree],90\[Degree]];
{f,rL,rR,\[Gamma]}=CurvedFoldUniformHelix2D[1,30\[Degree],90\[Degree]];
GraphicsGrid[{
CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}],
CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]
}]//Print;
GraphicsRow[{
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}],
CurvedFoldGraphics[f,rL,rR,{u0,u1}]}]/.OrigamiStyle[]
]//ShowExample
Module[{u0,u1,ip,f,rL,rR,ff,rrL,rrR,\[Gamma]},
{u0,u1}={0,\[Pi]};
ip=32;
{ff,rrL,rrR,\[Gamma]}=NCurvedFoldUniformHelix3D[1,30\[Degree],90\[Degree],{u0,u1},InterpolationPoints->ip];
{f,rL,rR,\[Gamma]}=NCurvedFoldUniformHelix2D[1,30\[Degree],90\[Degree],{u0,u1},InterpolationPoints->ip];
GraphicsGrid[{
CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}],
CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]
}]//Print;
GraphicsRow[{
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}],
CurvedFoldGraphics[f,rL,rR,{u0,u1}]}]/.OrigamiStyle[]
]//ShowExample
CurvedFoldHelix3D[r_,\[Theta]_,\[Gamma]_Function|\[Gamma]_InterpolatingFunction]:=Module[{ff,rrL,rrR},
ff=r{Cos[#],Sin[#],Tan[\[Theta]]#}&;
{r {Cos[#1],Sin[#1],Tan[\[Theta]] #1}&,{-((Cos[\[Theta]] ((1+Cos[\[Gamma][#1]]) Sin[\[Theta]] Sin[#1]+Cos[#1] Sin[\[Gamma][#1]]+Sin[#1] Derivative[1][\[Gamma]][#1]))/(\[Sqrt](3-Cos[2 \[Theta]]-2 Cos[\[Theta]]^2 Cos[\[Gamma][#1]]+4 Sin[\[Theta]] Derivative[1][\[Gamma]][#1]+Derivative[1][\[Gamma]][#1]^2))),(Cos[\[Theta]] (Cos[#1] (1+Cos[\[Gamma][#1]]) Sin[\[Theta]]-Sin[#1] Sin[\[Gamma][#1]]+Cos[#1] Derivative[1][\[Gamma]][#1]))/(\[Sqrt](3-Cos[2 \[Theta]]-2 Cos[\[Theta]]^2 Cos[\[Gamma][#1]]+4 Sin[\[Theta]] Derivative[1][\[Gamma]][#1]+Derivative[1][\[Gamma]][#1]^2)),(-Cos[\[Theta]]^2 (-1+Cos[\[Gamma][#1]])+2 Sin[\[Theta]]^2+Sin[\[Theta]] Derivative[1][\[Gamma]][#1])/(\[Sqrt](3-Cos[2 \[Theta]]-2 Cos[\[Theta]]^2 Cos[\[Gamma][#1]]+4 Sin[\[Theta]] Derivative[1][\[Gamma]][#1]+Derivative[1][\[Gamma]][#1]^2))}&,{(Cos[\[Theta]] (-(1+Cos[\[Gamma][#1]]) Sin[\[Theta]] Sin[#1]+Cos[#1] Sin[\[Gamma][#1]]+Sin[#1] Derivative[1][\[Gamma]][#1]))/(\[Sqrt](3-Cos[2 \[Theta]]-2 Cos[\[Theta]]^2 Cos[\[Gamma][#1]]-4 Sin[\[Theta]] Derivative[1][\[Gamma]][#1]+Derivative[1][\[Gamma]][#1]^2)),(Cos[\[Theta]] (Cos[#1] (1+Cos[\[Gamma][#1]]) Sin[\[Theta]]+Sin[#1] Sin[\[Gamma][#1]]-Cos[#1] Derivative[1][\[Gamma]][#1]))/(\[Sqrt](3-Cos[2 \[Theta]]-2 Cos[\[Theta]]^2 Cos[\[Gamma][#1]]-4 Sin[\[Theta]] Derivative[1][\[Gamma]][#1]+Derivative[1][\[Gamma]][#1]^2)),(-Cos[\[Theta]]^2 (-1+Cos[\[Gamma][#1]])+2 Sin[\[Theta]]^2-Sin[\[Theta]] Derivative[1][\[Gamma]][#1])/(\[Sqrt](3-Cos[2 \[Theta]]-2 Cos[\[Theta]]^2 Cos[\[Gamma][#1]]-4 Sin[\[Theta]] Derivative[1][\[Gamma]][#1]+Derivative[1][\[Gamma]][#1]^2))}&,\[Gamma]}]
Block[{r,\[Theta],\[Gamma],\[Gamma]fn,as,ff,rrL,rrR,s},
ff=r{Cos[#],Sin[#],Tan[\[Theta]]#}&;
\[Gamma]fn=\[Gamma][#]&;
as={r>0,\[Theta]\[Element]Reals,Sec[\[Theta]]>0,Cos[\[Theta]]>0,Sin[\[Gamma][s]/2]>0};
{ff,rrL,rrR}=FoldSpaceCurve3D[ff,\[Gamma]fn,+1,Simplification->Simplify,Assumptions->as];
Print["ff = ",ff//PrettyParameters];
Print["rrL = ",rrL//PrettyParameters];
Print["rrR = ",rrR//PrettyParameters];
(* Some additional simplification *)
rrL=Functionize[s,FullSimplify[rrL[s],Assumptions->as]];
rrR=Functionize[s,FullSimplify[rrR[s],Assumptions->as]];
Print["after FullSimplify"];
Print["rrL = ",rrL//PrettyParameters];
Print["rrR = ",rrR//PrettyParameters];
(* and one more round *)
rrL=Functionize[s,FullSimplify[rrL[s]/.{Sin[x_/2]^2:>(1/2)(1-Cos[x]),Cos[x_/2]^2:>(1/2)(1+Cos[x])},Assumptions->as]];
rrR=Functionize[s,FullSimplify[rrR[s]/.{Sin[x_/2]^2:>(1/2)(1-Cos[x]),Cos[x_/2]^2:>(1/2)(1+Cos[x])},Assumptions->as]];
Print["after another round"];
Print["rrL = ",rrL//PrettyParameters];
Print["rrR = ",rrR//PrettyParameters];
{ff,rrL,rrR,\[Gamma]}
]//Hold;
Block[{r,\[Theta],\[Gamma],\[Gamma]fn},
\[Gamma]fn=\[Gamma][#]&;
CurvedFoldHelix3D[r,\[Theta],\[Gamma]fn]//PrettyParameters
]//ShowExample
Module[{u0,u1,ff,rrL,rrR,\[Gamma]},
{u0,u1}={0,\[Pi]};
{ff,rrL,rrR,\[Gamma]}=CurvedFoldHelix3D[1,30\[Degree],90\[Degree]&];
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
NCurvedFoldHelix3D[r_,\[Theta]_,\[Gamma]_Function|\[Gamma]_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{s,ff,rrL,rrR,\[Gamma]1},
{ff,rrL,rrR,\[Gamma]1}=CurvedFoldHelix3D[r,\[Theta],\[Gamma]];
ff=FunctionInterpolationAlt[ff[s],{s,u0,u1},opts];
rrL=FunctionInterpolationAlt[rrL[s],{s,u0,u1},opts];
rrR=FunctionInterpolationAlt[rrR[s],{s,u0,u1},opts];
If[InterpolatingFunctionCount[\[Gamma]]!=3,
\[Gamma]1=FunctionInterpolationAlt[\[Gamma][s],{s,u0,u1},opts]];
{ff,rrL,rrR,\[Gamma]1}]
Module[{u0,u1,ff,rrL,rrR,\[Gamma]},
{u0,u1}={0,\[Pi]};
{ff,rrL,rrR,\[Gamma]}=NCurvedFoldHelix3D[1,30\[Degree],90\[Degree]&,{0,\[Pi]}];
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
StrictArguments[NCurvedFoldHelix2D];
NCurvedFoldHelix2D[r_,\[Theta]_,\[Gamma]_Function|\[Gamma]_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{ff,rrL,rrR,\[Gamma]1,f,rL,rR},
{ff,rrL,rrR,\[Gamma]1}=NCurvedFoldHelix3D[r,\[Theta],\[Gamma],{u0,u1}];
{f,rL,rR}=NFlattenFold2D[ff,rrL,rrR,{u0,{1,0},{0,1}},{u0,u1}];
{f,rL,rR,\[Gamma]1}]
Module[{u0,u1,f,rL,rR,\[Gamma]},
{u0,u1}={0,\[Pi]};
{f,rL,rR,\[Gamma]}=NCurvedFoldHelix2D[1,30\[Degree],90\[Degree]&,{u0,u1}];
CurvedFoldGraphics[f,rL,rR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
Module[{u0,u1,r,\[Theta],\[Gamma],ip,f,rL,rR,ff,rrL,rrR},
{u0,u1}={0,\[Pi]};
r=1;
\[Theta]=30\[Degree];
\[Gamma]=60\[Degree]+60\[Degree](#/u1)&;
ip=128;
{ff,rrL,rrR,\[Gamma]}=NCurvedFoldHelix3D[r,\[Theta],\[Gamma],{u0,u1},InterpolationPoints->ip];
{f,rL,rR,\[Gamma]}=NCurvedFoldHelix2D[r,\[Theta],\[Gamma],{u0,u1},InterpolationPoints->ip];
GraphicsGrid[{
CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}],
CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]
}]//Print;
GraphicsRow[{
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}],
CurvedFoldGraphics[f,rL,rR,{u0,u1}]}]/.OrigamiStyle[]
]//ShowExample
Options[FoldCurvedFold3D]={
Simplification->None,
Assumptions->{}
};
FoldCurvedFold3D::nosoln="DSolve couldn't integrate the fold angle equation.";
StrictArguments[FoldCurvedFold3D];
FoldCurvedFold3D[f_Function,rL_Function,rR_Function,{ui_,\[Gamma]i_,ffi_,tti_,bbti_},opts___]:=Module[{si,as,s,sfn,dsopts,c2dsys,ds,\[Kappa]l,t,l,cot\[Rho]L,cot\[Rho]R,\[Gamma],soln,\[Tau],\[Kappa],c3dsys,ff,tt,nn,bb,\[FinalSigma],llL,\[Kappa]g,\[Kappa]n,\[Tau]g,c\[Rho]L,s\[Rho]L,rrL,llR,c\[Rho]R,s\[Rho]R,rrR},
si=Simplification/.{opts}/.Options[FoldCurvedFold3D];
as=Assumptions/.{opts}/.Options[FoldCurvedFold3D];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
dsopts=Sequence@@FilterRules[{opts},Options[DSolve]];
c2dsys=Curve2DSystem[f,opts];
{ds,\[Kappa]l,t,l}={Speed2D,LeftCurvature2D,TangentVector2D,LeftNormalVector2D}/.c2dsys;
c\[Rho]L=Functionize[s,t[s] . rL[s]//sfn];
s\[Rho]L=Functionize[s,l[s] . rL[s]//sfn];
c\[Rho]R=Functionize[s,t[s] . rR[s]//sfn];
s\[Rho]R=Functionize[s,-l[s] . rR[s]//sfn];
cot\[Rho]L=Functionize[s,c\[Rho]L[s]/s\[Rho]L[s]//sfn];
cot\[Rho]R=Functionize[s,c\[Rho]R[s]/s\[Rho]R[s]//sfn];
soln=DSolve[{\[Gamma]'[s]Cot[\[Gamma][s]/2]==ds[s]\[Kappa]l[s](cot\[Rho]L[s]-cot\[Rho]R[s]),\[Gamma][ui]==\[Gamma]i},\[Gamma],s,Evaluate[dsopts]];
If[Head[soln]===DSolve,Message[FoldCurvedFold3D::nosoln];Abort[]];
\[Gamma]=\[Gamma]/.Flatten[soln];
\[Kappa]=Functionize[s,Abs[\[Kappa]l[s]] Sec[\[Gamma][s]/2]//sfn];
\[Tau]=Functionize[s,(1/2)Tan[\[Gamma][s]/2]\[Kappa]l[s](cot\[Rho]L[s]+cot\[Rho]R[s])//sfn];
\[FinalSigma]=Functionize[s,Sign[\[Kappa]l[s]]//sfn];
c3dsys=RecoverCurve3DSystem[ds,\[Kappa],\[Tau],{ui,ffi,tti, \[FinalSigma][ui]bbti},opts];
{ff,tt,nn,bb}={Curve3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.c3dsys;
llL=Functionize[s,\[FinalSigma] [s](Cos[\[Gamma][s]/2]nn[s]+Sin[\[Gamma][s]/2]bb[s])//sfn];
rrL=Functionize[s,c\[Rho]L[s]tt[s]+s\[Rho]L[s] llL[s]//sfn];
llR=Functionize[s,\[FinalSigma] [s](Cos[\[Gamma][s]/2]nn[s]-Sin[\[Gamma][s]/2]bb[s])//sfn];
rrR=Functionize[s,c\[Rho]R[s]tt[s]-s\[Rho]R[s] llR[s]//sfn];
{ff,rrL,rrR}]
Block[{u0,u1,f,rL,rR,\[Gamma]0,\[Gamma],ui,\[Gamma]i,ffi,tti,bbti,ff,rrL,rrR},
{u0,u1}={0,\[Pi]};
f= {-1+2 Cos[#1/2],2 Sin[#1/2]}&;
rL={-Cos[#1/2],-Sin[#1/2]}&;
rR= {Cos[#1/2],Sin[#1/2]}&;
\[Gamma]0=120\[Degree];
\[Gamma]=\[Gamma]0&;
{ui,\[Gamma]i,ffi,tti,bbti}={0,\[Gamma]0,{1,0,0},{0,1,0},{0,0,1}};
{ff,rrL,rrR}=FoldCurvedFold3D[f,rL,rR,{ui,\[Gamma]i,ffi,tti,bbti},Simplification->Simplify];
GraphicsGrid[{
CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}],
CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]
}]//Print;
GraphicsRow[{
CurvedFoldGraphics[f,rL,rR,{u0,u1}],
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]
}]
/.OrigamiStyle[]
]//ShowExample
Block[{u0,u1,f,rL,rR,\[Gamma]0,\[Gamma],ui,\[Gamma]i,ffi,tti,bbti,ff,rrL,rrR},
{u0,u1}={0,\[Pi]};
f= {1-2 Cos[#1/2],2 Sin[#1/2]}&;
rL= {-Cos[#1/2],Sin[#1/2]}&;
rR={Cos[#1/2],-Sin[#1/2]}&;
\[Gamma]0=-120\[Degree];
\[Gamma]=\[Gamma]0&;
{ui,\[Gamma]i,ffi,tti,bbti}={0,\[Gamma]0,{1,0,0},{0,1,0},{0,0,1}};
{ff,rrL,rrR}=FoldCurvedFold3D[f,rL,rR,{ui,\[Gamma]i,ffi,tti,bbti},Simplification->Simplify];
GraphicsGrid[{
CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}],
CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]
}]//Print;
GraphicsRow[{
CurvedFoldGraphics[f,rL,rR,{u0,u1}],
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]
}]
/.OrigamiStyle[]
]//ShowExample
NFoldCurvedFold3D::nosoln="NDSolve couldn't integrate the fold angle equation.";
StrictArguments[NFoldCurvedFold3D];
NFoldCurvedFold3D[f_Function|f_InterpolatingFunction,rL_Function|rL_InterpolatingFunction,rR_Function|rR_InterpolatingFunction,{ui_,\[Gamma]i_,ffi_,tti_,bbti_},{u0_,u1_},opts___]:=Module[{s,dsopts,c2dsys,ds,\[Kappa]l,t,l,cot\[Rho]L,cot\[Rho]R,\[Gamma],soln,\[Tau],\[Kappa],c3dsys,ff,tt,nn,bb,\[FinalSigma],llL,\[Kappa]g,\[Kappa]n,\[Tau]g,c\[Rho]L,s\[Rho]L,rrL,llR,c\[Rho]R,s\[Rho]R,rrR},
dsopts=Sequence@@FilterRules[{opts},Options[NDSolve]];
(* Get the 2D frame of the curve *)
c2dsys=NCurve2DSystem[f,{u0,u1},opts];
{ds,\[Kappa]l,t,l}={Speed2D,LeftCurvature2D,TangentVector2D,LeftNormalVector2D}/.c2dsys;
c\[Rho]L=Functionize[s,t[s] . rL[s]];
s\[Rho]L=Functionize[s,l[s] . rL[s]];
c\[Rho]R=Functionize[s,t[s] . rR[s]];
s\[Rho]R=Functionize[s,-l[s] . rR[s]];
cot\[Rho]L=Functionize[s,c\[Rho]L[s]/s\[Rho]L[s]];
cot\[Rho]R=Functionize[s,c\[Rho]R[s]/s\[Rho]R[s]];
soln=NDSolve[{\[Gamma]'[s]Cot[\[Gamma][s]/2]==ds[s]\[Kappa]l[s](cot\[Rho]L[s]-cot\[Rho]R[s]),\[Gamma][ui]==\[Gamma]i},\[Gamma],{s,u0,u1},Evaluate[dsopts]];
If[Head[soln]===NDSolve,Message[NFoldCurvedFold3D::nosoln];Abort[]];
\[Gamma]=\[Gamma]/.Flatten[soln];
\[Kappa]=FunctionInterpolationAlt[Abs[\[Kappa]l[s]] Sec[\[Gamma][s]/2],{s,u0,u1},opts];
\[Tau]=FunctionInterpolationAlt[(1/2)Tan[\[Gamma][s]/2]\[Kappa]l[s](cot\[Rho]L[s]+cot\[Rho]R[s]),{s,u0,u1},opts];
\[FinalSigma]=Functionize[s,Sign[\[Kappa]l[s]]];
c3dsys=NRecoverCurve3DSystem[ds,\[Kappa],\[Tau],{ui,ffi,tti,\[FinalSigma][ui]bbti},{u0,u1},opts];
{ff,tt,nn,bb}={Curve3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.c3dsys;
llL=Functionize[s,\[FinalSigma][s](Cos[\[Gamma][s]/2]nn[s]+Sin[\[Gamma][s]/2]bb[s])];
rrL=FunctionInterpolationAlt[c\[Rho]L[s]tt[s]+s\[Rho]L[s] llL[s],{s,u0,u1},opts];
llR=Functionize[s,\[FinalSigma][s](Cos[\[Gamma][s]/2]nn[s]-Sin[\[Gamma][s]/2]bb[s])];
rrR=FunctionInterpolationAlt[c\[Rho]R[s]tt[s]-s\[Rho]R[s] llR[s],{s,u0,u1},opts];
{ff,rrL,rrR}]
Block[{u0,u1,\[Gamma]0,\[Gamma],s,f,rL,rR,ui,\[Gamma]i,ffi,tti,bbti,ff,rrL,rrR},
{u0,u1}={0,\[Pi]};
f=FunctionInterpolationAlt[ {-1+2 Cos[#1/2],2 Sin[#1/2]}&[s],{s,u0,u1}];
rL=FunctionInterpolationAlt[{-Cos[#1/2],-Sin[#1/2]}&[s],{s,u0,u1}];
rR=FunctionInterpolationAlt[ {Cos[#1/2],Sin[#1/2]}&[s],{s,u0,u1}];
\[Gamma]0=120\[Degree];
\[Gamma]=\[Gamma]0&;
{ui,\[Gamma]i,ffi,tti,bbti}={u0,\[Gamma][u0],{1,0,0},{0,1,0},{0,0,1}};
{ff,rrL,rrR}=NFoldCurvedFold3D[f,rL,rR,{ui,\[Gamma]i,ffi,tti,bbti},{u0,u1}];
GraphicsGrid[{
CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}],
CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]
}]//Print;
GraphicsRow[{
CurvedFoldGraphics[f,rL,rR,{u0,u1}],
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]
}]
/.OrigamiStyle[]
]//ShowExample
Block[{u0,u1,f,rL,rR,\[Gamma]0,\[Gamma],ui,\[Gamma]i,ffi,tti,bbti,ff,rrL,rrR},
{u0,u1}={0,\[Pi]};
f= {1-2 Cos[#1/2],2 Sin[#1/2]}&;
rL= {-Cos[#1/2],Sin[#1/2]}&;
rR={Cos[#1/2],-Sin[#1/2]}&;
\[Gamma]0=-120\[Degree];
\[Gamma]=\[Gamma]0&;
{ui,\[Gamma]i,ffi,tti,bbti}={0,\[Gamma]0,{1,0,0},{0,1,0},{0,0,1}};
{ff,rrL,rrR}=NFoldCurvedFold3D[f,rL,rR,{ui,\[Gamma]i,ffi,tti,bbti},{u0,u1}];
GraphicsGrid[{
CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}],
CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]
}]//Print;
GraphicsRow[{
CurvedFoldGraphics[f,rL,rR,{u0,u1}],
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]
}]
/.OrigamiStyle[]
]//ShowExample
Module[{u0,u1,r,\[Theta],\[Gamma],ip,f,rL,rR,ff,rrL,rrR,csys,ui,\[Gamma]i,ffi,tti,bbti,ff1,rrL1,rrR1},
{u0,u1}={0,\[Pi]};
r=1;
\[Theta]=30\[Degree];
\[Gamma]=120\[Degree]-60\[Degree](#/\[Pi])&;
ip=128;
{ff,rrL,rrR,\[Gamma]}=NCurvedFoldHelix3D[r,\[Theta],\[Gamma],{u0,u1},InterpolationPoints->ip];
Print["original 3D"];
GraphicsRow[CurvedFoldShapePlots3D[ff,rrL,rrR,\[Gamma],{u0,u1}]]//Print;
(* Unfolded 2D *)
{f,rL,rR,\[Gamma]}=NCurvedFoldHelix2D[r,\[Theta],\[Gamma],{u0,u1},InterpolationPoints->ip];
Print["Unfolded 2D"];
GraphicsRow[CurvedFoldShapePlots2D[f,rL,rR,\[Gamma],{u0,u1}]]//Print;
(* Refolded 3D *)
csys=NCurve3DSystem[ff,{u0,u1},InterpolationPoints->ip];
ui=.5u0+.5u1;
{\[Gamma]i,ffi,tti,bbti}={
\[Gamma][ui],
ff[ui],
(TangentVector3D/.csys)[ui],
(BinormalVector3D/.csys)[ui]};
{ff1,rrL1,rrR1}=NFoldCurvedFold3D[f,rL,rR,{ui,\[Gamma]i,ffi,tti,bbti},{u0,u1},InterpolationPoints->ip];
Print["refolded 3D"];
GraphicsRow[CurvedFoldShapePlots3D[ff1,rrL1,rrR1,\[Gamma],{u0,u1}]]//Print;
(* Show all three versions *)
GraphicsRow[{
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}],
CurvedFoldGraphics[f,rL,rR,{u0,u1}],
CurvedFoldGraphics3D[ff1,rrL1,rrR1,{u0,u1}]
}]/.OrigamiStyle[]
]//ShowExample
Options[FoldAcrossRight2D]={
Simplification->None,
Assumptions->{}
};
StrictArguments[FoldAcrossRight2D];
FoldAcrossRight2D[f_Function,rL_Function,\[Gamma]_Function, opts___]:=Module[{si,as,s,sfn,csys,ds,\[Kappa]g,t,l,cot\[Rho]L,expr1,expr2,c\[Rho]L,s\[Rho]L,rR},
si=Simplification/.{opts}/.Options[FoldAcrossRight2D];
as=Assumptions/.{opts}/.Options[FoldAcrossRight2D];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
(* curve fold system and Frenet frame *)
csys=Curve2DSystem[f,opts];
{ds,\[Kappa]g,t,l}={Speed2D,LeftCurvature2D,TangentVector2D,LeftNormalVector2D}/.csys;
(* Left side *)
t = Functionize[s,NormalizeReal[f'[s]]//sfn];
l=Functionize[s,RotationMatrix2D[\[Pi]/2] . t[s]//sfn];
cot\[Rho]L=Functionize[s,t[s] . rL[s]/l[s] . rL[s]//sfn];
(* Right ruling angle sines and cosines *)
expr1=Functionize[s,Tan[\[Gamma][s]/2]cot\[Rho]L[s]-\[Gamma]'[s]/(ds[s] \[Kappa]g[s])//sfn];
expr2=Functionize[s,\[Sqrt](Tan[\[Gamma][s]/2]^2+expr1[s]^2)//sfn];
c\[Rho]L=Functionize[s,Sign[\[Gamma][s]](expr1[s] /expr2[s])//sfn];
s\[Rho]L=Functionize[s,Abs[Tan[\[Gamma][s]/2]]/expr2[s]//sfn];
(* Right ruling vector *)
rR=Functionize[s,RotationMatrix2D[{c\[Rho]L[s],-s\[Rho]L[s]}] . t[s]//sfn];
{f,rL,rR}]
Block[{s,f,rL,rR,\[Gamma],\[Gamma]0,as,u0,u1},
f={Cos[#],Sin[#]}&;
rL={-Cos[#],-Sin[#]}&;
\[Gamma]=\[Gamma]0 #&;
as={\[Gamma]0>0};
{f,rL,rR}=FoldAcrossRight2D[f,rL,\[Gamma],Simplification->Simplify,Assumptions->as];
Print["rR[t] = ",rR//PrettyParameters];
{u0,u1}={0.001,\[Pi]/2};
\[Gamma]0=1/2;
CurvedFoldGraphics[f,rL,rR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
StrictArguments[NFoldAcrossRight2D];
NFoldAcrossRight2D[f_Function|f_InterpolatingFunction,rL_Function|rL_InterpolatingFunction,\[Gamma]_Function|\[Gamma]_InterpolatingFunction,{u0_,u1_}, opts___]:=Module[{s,csys,ds,\[Kappa]g,t,l,cot\[Rho]L,expr1,expr2,c\[Rho]L,s\[Rho]L,c\[Rho]R,s\[Rho]R,rR},
(* curve fold system and Frenet frame *)
csys=NCurve2DSystem[f,{u0,u1},opts];
{ds,\[Kappa]g,t,l}={Speed2D,LeftCurvature2D,TangentVector2D,LeftNormalVector2D}/.csys;
(* Left side *)
t = Functionize[s,NormalizeReal[f'[s]]];
l=Functionize[s,RotationMatrix2D[\[Pi]/2] . t[s]];
cot\[Rho]L=Functionize[s,t[s] . rL[s]/l[s] . rL[s]];
(* Right ruling angle sines and cosines *)
expr1=Functionize[s,Tan[\[Gamma][s]/2]cot\[Rho]L[s]-\[Gamma]'[s]/(ds[s] \[Kappa]g[s])];
expr2=Functionize[s,\[Sqrt](Tan[\[Gamma][s]/2]^2+expr1[s]^2)];
c\[Rho]R=Functionize[s,Sign[\[Gamma][s]](expr1[s] /expr2[s])];
s\[Rho]R=Functionize[s,Abs[Tan[\[Gamma][s]/2]]/expr2[s]];
(* Right ruling vector *)
rR=FunctionInterpolationAlt[RotationMatrix2D[{c\[Rho]R[s],-s\[Rho]R[s]}] . t[s],{s,u0,u1},opts];
{f,rL,rR}]
Block[{s,ip,u0,u1,f,rL,rR,\[Gamma],\[Gamma]0,gc,gf},
ip=64;
{u0,u1}={0.001,\[Pi]/2};
\[Gamma]0=1/2;
f=FunctionInterpolationAlt[{Cos[#],Sin[#]}&[s],{s,u0,u1},InterpolationPoints->ip];
rL=FunctionInterpolationAlt[{-Cos[#],-Sin[#]}&[s],{s,u0,u1},InterpolationPoints->ip];
\[Gamma]=FunctionInterpolationAlt[\[Gamma]0 #&[s],{s,u0,u1},InterpolationPoints->ip];
{f,rL,rR}=NFoldAcrossRight2D[f,rL,\[Gamma],{u0,u1}];
CurvedFoldGraphics[f,rL,rR,{u0,u1}]/.OrigamiStyle[]
]//ShowExample
Block[{s,ip,u0,u1,f,rL,rR,\[Gamma],\[Gamma]0,ui,\[Gamma]i,ffi,tti,bbti,ff,rrL,rrR,gc,gf},
ip=64;
{u0,u1}={0,\[Pi]/2};
\[Gamma]0=150.\[Degree](1-.9999#/u1)&;
{ui,\[Gamma]i,ffi,tti,bbti}={u0,\[Gamma]0[u0],{1,0,0},{0,1,0},{0,0,1}};
f=FunctionInterpolationAlt[{Cos[#],Sin[#]}&[s],{s,u0,u1},InterpolationPoints->ip];
rL=FunctionInterpolationAlt[{-Cos[#],-Sin[#]}&[s],{s,u0,u1},InterpolationPoints->ip];
\[Gamma]=FunctionInterpolationAlt[\[Gamma]0[s],{s,u0,u1},InterpolationPoints->ip];
{f,rL,rR}=NFoldAcrossRight2D[f,rL,\[Gamma],{u0,u1}];
{ff,rrL,rrR}=NFoldCurvedFold3D[f,rL,rR,{ui,\[Gamma]i,ffi,tti,bbti},{u0,u1},InterpolationPoints->ip];
GraphicsRow[{
CurvedFoldGraphics[f,rL,rR,{u0,u1}],
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]
}]/.OrigamiStyle[]
]//ShowExample
Options[FoldAcrossRight3D]={
Simplification->None,
Assumptions->{}
};
StrictArguments[FoldAcrossRight3D];
FoldAcrossRight3D[ff_Function,rrL_Function,opts___]:=Module[{si,as,s,sfn,csys,dff,ds,tt,nn,bb,uuL,llL,c\[Rho]L,s\[Rho]L,c\[Eta]L,s\[Eta]L,c\[Eta]R,s\[Eta]R,uuR,llR,duuR,mduuR,\[Kappa]g,\[Kappa]n,\[Tau]g,c\[Rho]R,s\[Rho]R,rrR},
si=Simplification/.{opts}/.Options[FoldAcrossRight3D];
as=Assumptions/.{opts}/.Options[FoldAcrossRight3D];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
(* curve fold system and Frenet frame *)
csys=Curve3DSystem[ff,opts];
{ds,tt,nn,bb}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.csys;
(* Left side *)
uuL=Functionize[s,With[{txr=tt[s]\[Cross]rrL[s]},NormalizeReal[txr]]//sfn];
llL=Functionize[s,uuL[s]\[Cross]tt[s]//sfn];
c\[Rho]L=Functionize[s,rrL[s] . tt[s]//sfn];
s\[Rho]L=Functionize[s,rrL[s] . llL[s]//sfn];
c\[Eta]L=Functionize[s,llL[s] . nn[s]//sfn];
s\[Eta]L=Functionize[s,uuL[s] . nn[s]//sfn];
(* Right side *)
uuR=Functionize[s,-s\[Eta]L[s]nn[s]+c\[Eta]L[s]bb[s]//sfn];
llR=Functionize[s,c\[Eta]L[s]nn[s]+s\[Eta]L[s]bb[s]//sfn];
duuR=Functionize[s,uuR'[s]//sfn];
mduuR=Functionize[s,Mag[duuR[s]]//sfn];
c\[Rho]R=Functionize[s,Sign[duuR[s] . tt[s]](duuR[s] . llR[s]/mduuR[s])//sfn];
s\[Rho]R=Functionize[s,Abs[duuR[s] . tt[s]]/mduuR[s]//sfn];
rrR=Functionize[s,c\[Rho]R[s]tt[s]-s\[Rho]R[s]llR[s]//sfn];
{ff,rrL,rrR}]
Block[{s,\[Gamma]0,u0,u1,ff,rrL,rrR,f,rL,rR,ui,fi,ti},
\[Gamma]0=120\[Degree];
{u0,u1}={0,\[Pi]};
{ui,fi,ti}={0,{1,0},{0,1}};
ff=Functionize[s,{Cos[s],Sin[s],0}];
rrL={-Cos[\[Gamma]0/2] Cos[#1],-Cos[\[Gamma]0/2] Sin[#1],Sin[\[Gamma]0/2]}&;
rrR={Cos[\[Gamma]0/2] Cos[#1],Cos[\[Gamma]0/2] Sin[#1],Sin[\[Gamma]0/2]}&;
{ff,rrL,rrR}=FoldAcrossRight3D[ff,rrL,Simplification->Simplify];
rrR//PrettyParameters//Print;
CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}]
/.OrigamiStyle[]
]//ShowExample
StrictArguments[NFoldAcrossRight3D];
NFoldAcrossRight3D[ff_Function|ff_InterpolatingFunction,rrL_Function|rrL_InterpolatingFunction,{u0_,u1_}, opts___]:=Module[{s,csys,dff,ds,tt,nn,bb,uuL,llL,c\[Rho]L,s\[Rho]L,c\[Eta]L,s\[Eta]L,c\[Eta]R,s\[Eta]R,uuR,llR,duuR,mduuR,\[Kappa]g,\[Kappa]n,\[Tau]g,c\[Rho]R,s\[Rho]R,rrR},
(* curve fold system and Frenet frame *)
csys=NCurve3DSystem[ff,{u0,u1},opts];
{ds,tt,nn,bb}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.csys;
(* Left side *)
uuL=FunctionInterpolationAlt[With[{txr=tt[s]\[Cross]rrL[s]},NormalizeReal[txr]],{s,u0,u1}];
llL=Functionize[s,uuL[s]\[Cross]tt[s]];
c\[Rho]L=Functionize[s,rrL[s] . tt[s]];
s\[Rho]L=Functionize[s,rrL[s] . llL[s]];
c\[Eta]L=Functionize[s,llL[s] . nn[s]];
s\[Eta]L=Functionize[s,uuL[s] . nn[s]];
(* Right side *)
uuR=FunctionInterpolationAlt[-s\[Eta]L[s]nn[s]+c\[Eta]L[s]bb[s],{s,u0,u1},opts];
llR=FunctionInterpolationAlt[c\[Eta]L[s]nn[s]+s\[Eta]L[s]bb[s],{s,u0,u1},opts];
duuR=Functionize[s,uuR'[s]];
mduuR=Functionize[s,Mag[duuR[s]]];
c\[Rho]R=Functionize[s,Sign[duuR[s] . tt[s]](duuR[s] . llR[s]/mduuR[s])];
s\[Rho]R=Functionize[s,Abs[duuR[s] . tt[s]]/mduuR[s]];
rrR=FunctionInterpolationAlt[c\[Rho]R[s]tt[s]-s\[Rho]R[s]llR[s],{s,u0,u1},opts];
{ff,rrL,rrR}]
Module[{s,\[Gamma]0,u0,u1,ff,rrL,rrR,f,rL,rR,ui,fi,ti},
\[Gamma]0=120\[Degree];
{u0,u1}={0,\[Pi]};
{ui,fi,ti}={0,{1,0},{0,1}};
ff=FunctionInterpolationAlt[{Cos[s],Sin[s],0},{s,u0,u1}];
rrL=FunctionInterpolationAlt[{-Cos[\[Gamma]0/2] Cos[s],-Cos[\[Gamma]0/2] Sin[s],Sin[\[Gamma]0/2]},{s,u0,u1}];
rrR=FunctionInterpolationAlt[{Cos[\[Gamma]0/2] Cos[s],Cos[\[Gamma]0/2] Sin[s],Sin[\[Gamma]0/2]},{s,u0,u1}];
{ff,rrL,rrR}=NFoldAcrossRight3D[ff,rrL,{u0,u1}];
Graphics3D[{
StyledCurvedFold[ff,{rrL,rrR},{u0,u1}],
StyledVector[{ff[u0],ff[u0]+.5rrL[u0]},VectorColor->Red],
StyledVector[{ff[u0],ff[u0]+.5rrR[u0]},VectorColor->Green],
{}}]
/.OrigamiStyle[]
]//ShowExample
Options[FoldAcrossRightBoth]={
Simplification->None,
Assumptions->{}
};
StrictArguments[FoldAcrossRightBoth];
FoldAcrossRightBoth[f_Function,rL_Function,ff_Function,rrL_Function,opts___]:=Module[{si,as,s,sfn,c3dsys,dff,ds,tt,nn,bb,uuL,llL,c\[Rho]L,s\[Rho]L,c\[Eta]L,s\[Eta]L,c\[Eta]R,s\[Eta]R,uuR,llR,duuR,mduuR,\[Kappa]g,\[Kappa]n,\[Tau]g,c\[Rho]R,s\[Rho]R,rrR,c2dsys,t,l,rR},
si=Simplification/.{opts}/.Options[FoldAcrossRightBoth];
as=Assumptions/.{opts}/.Options[FoldAcrossRightBoth];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
(* curve fold system and Frenet frame *)
c3dsys=Curve3DSystem[ff,opts];
{ds,tt,nn,bb}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.c3dsys;
(* Left side *)
uuL=Functionize[s,With[{txr=tt[s]\[Cross]rrL[s]},NormalizeReal[txr]]//sfn];
llL=Functionize[s,uuL[s]\[Cross]tt[s]//sfn];
c\[Rho]L=Functionize[s,rrL[s] . tt[s]//sfn];
s\[Rho]L=Functionize[s,rrL[s] . llL[s]//sfn];
c\[Eta]L=Functionize[s,llL[s] . nn[s]//sfn];
s\[Eta]L=Functionize[s,uuL[s] . nn[s]//sfn];
(* Right side *)
uuR=Functionize[s,-s\[Eta]L[s]nn[s]+c\[Eta]L[s]bb[s]//sfn];
llR=Functionize[s,c\[Eta]L[s]nn[s]+s\[Eta]L[s]bb[s]//sfn];
duuR=Functionize[s,uuR'[s]//sfn];
mduuR=Functionize[s,Mag[duuR[s]]//sfn];
c\[Rho]R=Functionize[s,Sign[duuR[s] . tt[s]](duuR[s] . llR[s]/mduuR[s])//sfn];
s\[Rho]R=Functionize[s,Abs[duuR[s] . tt[s]]/mduuR[s]//sfn];
rrR=Functionize[s,c\[Rho]R[s]tt[s]-s\[Rho]R[s]llR[s]//sfn];
(* 2D *)
c2dsys=Curve2DSystem[f,opts];
{t,l}={TangentVector2D,LeftNormalVector2D}/.c2dsys;
rR=Functionize[s,c\[Rho]R[s]t[s]-s\[Rho]R[s]l[s]//sfn];
{f,rL,rR,ff,rrL,rrR}]
Module[{s,\[Theta],ff,rrL,rrR,f,rL,rR,u0,u1},
(* The basic cone in 3D and 2D *)
ff=Functionize[s,{-Sin[\[Theta]]Sin[s],Cos[\[Theta]],Sin[\[Theta]]Cos[s]}];
rrL=Functionize[s,-{-Sin[\[Theta]]Sin[s],Cos[\[Theta]],Sin[\[Theta]]Cos[s]}];
f=Functionize[s,{-Sin[s Sin[\[Theta]]],Cos[s Sin[\[Theta]]]}];
rL=Functionize[s,-{-Sin[s Sin[\[Theta]]],Cos[s Sin[\[Theta]]]}];
\[Theta]=30\[Degree];
{u0,u1}={-\[Pi]/2,\[Pi]/2};
{f,rL,rR,ff,rrL,rrR}=FoldAcrossRightBoth[f,rL,ff,rrL,Simplification->Simplify,Assumptions->{\[Theta]>0,\[Theta]<\[Pi]/2}];
GraphicsRow[{CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}],CurvedFoldGraphics[f,rL,rR,{u0,u1}]}]/.OrigamiStyle[]
]//ShowExample
StrictArguments[NFoldAcrossRightBoth];
NFoldAcrossRightBoth[f_Function|f_InterpolatingFunction,rL_Function|rL_InterpolatingFunction,ff_Function|ff_InterpolatingFunction,rrL_Function|rrL_InterpolatingFunction,{u0_,u1_}, opts___]:=Module[{s,c3dsys,dff,ds,tt,nn,bb,uuL,llL,c\[Rho]L,s\[Rho]L,c\[Eta]L,s\[Eta]L,c\[Eta]R,s\[Eta]R,uuR,llR,duuR,mduuR,\[Kappa]g,\[Kappa]n,\[Tau]g,c\[Rho]R,s\[Rho]R,rrR,c2dsys,t,l,rR},
(* curve fold system and Frenet frame *)
c3dsys=NCurve3DSystem[ff,{u0,u1},opts];
{ds,tt,nn,bb}={Speed3D,TangentVector3D,NormalVector3D,BinormalVector3D}/.c3dsys;
(* Left side *)
uuL=FunctionInterpolationAlt[With[{txr=tt[s]\[Cross]rrL[s]},NormalizeReal[txr]],{s,u0,u1}];
llL=Functionize[s,uuL[s]\[Cross]tt[s]];
c\[Rho]L=Functionize[s,rrL[s] . tt[s]];
s\[Rho]L=Functionize[s,rrL[s] . llL[s]];
c\[Eta]L=Functionize[s,llL[s] . nn[s]];
s\[Eta]L=Functionize[s,uuL[s] . nn[s]];
(* Right side *)
uuR=FunctionInterpolationAlt[-s\[Eta]L[s]nn[s]+c\[Eta]L[s]bb[s],{s,u0,u1},opts];
llR=FunctionInterpolationAlt[c\[Eta]L[s]nn[s]+s\[Eta]L[s]bb[s],{s,u0,u1},opts];
duuR=Functionize[s,uuR'[s]];
mduuR=Functionize[s,Mag[duuR[s]]];
c\[Rho]R=Functionize[s,Sign[duuR[s] . tt[s]](duuR[s] . llR[s]/mduuR[s])];
s\[Rho]R=Functionize[s,Abs[duuR[s] . tt[s]]/mduuR[s]];
rrR=FunctionInterpolationAlt[c\[Rho]R[s]tt[s]-s\[Rho]R[s]llR[s],{s,u0,u1},opts];
(* 2D *)
c2dsys=NCurve2DSystem[f,{u0,u1},opts];
{t,l}={TangentVector2D,LeftNormalVector2D}/.c2dsys;
rR=FunctionInterpolationAlt[c\[Rho]R[s]t[s]-s\[Rho]R[s]l[s],{s,u0,u1},opts];
{f,rL,rR,ff,rrL,rrR}]
Module[{s,\[Theta],ff,rrL,rrR,f,rL,rR,u0,u1},
\[Theta]=30\[Degree];
{u0,u1}={-\[Pi]/2,\[Pi]/2};
(* The basic cone in 3D and 2D *)
ff=FunctionInterpolationAlt[{-Sin[\[Theta]]Sin[s],Cos[\[Theta]],Sin[\[Theta]]Cos[s]},{s,u0,u1}];
rrL=FunctionInterpolationAlt[-{-Sin[\[Theta]]Sin[s],Cos[\[Theta]],Sin[\[Theta]]Cos[s]},{s,u0,u1}];
f=FunctionInterpolationAlt[{-Sin[s Sin[\[Theta]]],Cos[s Sin[\[Theta]]]},{s,u0,u1}];
rL=FunctionInterpolationAlt[-{-Sin[s Sin[\[Theta]]],Cos[s Sin[\[Theta]]]},{s,u0,u1}];
{f,rL,rR,ff,rrL,rrR}=NFoldAcrossRightBoth[f,rL,ff,rrL,{u0,u1}];
GraphicsRow[{CurvedFoldGraphics3D[ff,rrL,rrR,{u0,u1}],CurvedFoldGraphics[f,rL,rR,{u0,u1}]}]/.OrigamiStyle[]
]//ShowExample
Module[{bl,cl,dl,el,br,cr,dr,er,xh,v0,vhl,vhr,f,eqns,soln},
bl=cl={hl,ul};
dl={-1,0};
br=cr={hr,ur};
dr={-1,0};
f=cl+vl dl;
xh={1,0};
v0=-((xh . cl)/(xh . dl)+(xh . cr)/(xh . dr))/.{ul->0,ur->0};
vhl=(hl-xh . cl)/(xh . dl)/.{ul->0};
vhr=(hr-xh . cr)/(xh . dr)/.{ur->0};
el=cl+vhl dl;
er=cr+vhr dr;
eqns={(cl+vl dl)==( cr+vr dr),vl+vr==v0};
soln=Flatten[FullSimplify[Solve[eqns,{vl,ur,vr}]/.C[_]->0]];
FullSimplify[{f,bl,cl,dl,el,br,cr,dr,er}/.soln/.ul->t]
]//ShowExample
Module[{bl,cl,dl,el,br,cr,dr,er,xh,v0,vhl,vhr,f,eqns,soln},
bl=cl={fl,0};
dl={-Cos[ul],-Sin[ul]};
br=cr={fl,0};
dr={-Cos[ur],-Sin[ur]};
f=cl+vl dl;
xh={1,0};
v0=-((xh . cl)/(xh . dl)+(xh . cr)/(xh . dr))/.{ul->0,ur->0};
vhl=(hl-xh . cl)/(xh . dl)/.{ul->0};
vhr=(hr-xh . cr)/(xh . dr)/.{ur->0};
el=cl+vhl dl;
er=cr+vhr dr;
eqns={(cl+vl dl)==( cr+vr dr),vl+vr==v0};
soln=Flatten[FullSimplify[Solve[eqns,{vl,ur,vr}]/.C[_]->0]];
FullSimplify[{f,bl,cl,dl,el,br,cr,dr,er}/.soln/.ul->t]
]//ShowExample
Module[{bl,cl,dl,el,br,cr,dr,er,xh,v0,vhl,vhr,f,eqns,soln},
bl=cl={hl,ul};
dl={-1,0};
br=cr={fr,0};
dr={-Cos[ur],Sin[ur]};
f=cl+vl dl;
xh={1,0};
v0=-((xh . cl)/(xh . dl)+(xh . cr)/(xh . dr))/.{ul->0,ur->0};
vhl=(hl-xh . cl)/(xh . dl)/.{ul->0};
vhr=(hr-xh . cr)/(xh . dr)/.{ur->0};
el=cl+vhl dl;
er=cr+vhr dr;
eqns={(cl+vl dl)==( cr+vr dr),vl+vr==v0};
soln=Flatten[FullSimplify[Solve[eqns,{vl,ur,vr}]/.C[_]->0]];
FullSimplify[{f,bl,cl,dl,el,br,cr,dr,er}/.soln/.ul->t]
]//ShowExample
Module[{bl,cl,dl,el,br,cr,dr,er,xh,v0,vhl,vhr,f,eqns,soln},
bl=cl={fl,0};
dl={-Cos[ul],Sin[ul]};
br=cr={hr,ur};
dr={-1,0};
f=cl+vl dl;
xh={1,0};
v0=-((xh . cl)/(xh . dl)+(xh . cr)/(xh . dr))/.{ul->0,ur->0};
vhl=(hl-xh . cl)/(xh . dl)/.{ul->0};
vhr=(hr-xh . cr)/(xh . dr)/.{ur->0};
el=cl+vhl dl;
er=cr+vhr dr;
eqns={(cl+vl dl)==( cr+vr dr),vl+vr==v0};
soln=Flatten[FullSimplify[Solve[eqns,{vl,ul,vr}]/.C[_]->0]];
FullSimplify[{f,bl,cl,dl,el,br,cr,dr,er}/.soln/.ur->t]
]//ShowExample
Module[{bl,cl,dl,el,br,cr,dr,er,xh,v0,vhl,vhr,f,eqns,soln},
bl=cl={fl,0};
dl={-Cos[ul],-Sin[ul]};
br=cr={fr,0};
dr={-Cos[ur],-Sin[ur]};
f=cl+vl dl;
xh={1,0};
v0=-((xh . cl)/(xh . dl)+(xh . cr)/(xh . dr))/.{ul->0,ur->0};
vhl=(hl-xh . cl)/(xh . dl)/.{ul->0};
vhr=(hr-xh . cr)/(xh . dr)/.{ur->0};
el=cl+vhl dl;
er=cr+vhr dr;
eqns={(cl+vl dl)==( cr+vr dr),vl+vr==v0};
soln=Flatten[FullSimplify[Solve[eqns,{vl,ur,vr}]/.C[_]->0]];
FullSimplify[{f,bl,cl,dl,el,br,cr,dr,er}/.soln/.ul->t]
]//ShowExample
DirectrixLeft2D::usage="DirectrixLeft2D is a key to the rules returned by conic section functions that gives the left-side directrix of a conic section fold.";
DirectorLeft2D::usage="DirectorLeft2D is a key to the rules returned by conic section functions that gives the left-side director of a conic section fold.";
CrossCurveLeft2D::usage="CrossCurveLeft2D is a key to the rules returned by conic section functions that gives the left-side cross curve of a conic section fold.";
SecondCrossCurveLeft2D::usage="SecondCrossCurveLeft2D is a key to the rules returned by conic section functions that gives a second left-side cross curve of a conic section fold.";
DirectrixRight2D::usage="DirectrixRight2D is a key to the rules returned by conic section functions that gives the right-side directrix of a conic section fold.";
DirectorRight2D::usage="DirectorRight2D is a key to the rules returned by conic section functions that gives the right-side director of a conic section fold.";
CrossCurveRight2D::usage="CrossCurveRight2D is a key to the rules returned by conic section functions that gives the right-side cross curve of a conic section fold.";
SecondCrossCurveRight2D::usage="SecondCrossCurveRight2D is a key to the rules returned by conic section functions that gives a second right-side cross curve of a conic section fold.";
ConicSection2DSystem::badleft="The left focus position `1` must be a nonzero number or -\[Infinity].";
ConicSection2DSystem::badright="The right focus position `1` must be a nonzero number or +\[Infinity].";
Options[ConicSection2DSystem]={
Simplification->None,
Assumptions->{}
};
ConicSection2DSystem[{fl_, fr_}, {hl_, hr_}, opts___]:=Module[{si,as,sfn,t,f,bl,cl,dl,el,br,cr,dr,er},
If[fl==0||fl==\[Infinity],Message[ConicSection2DSystem::badleft,fl];Abort[]];
If[fr==0||fr==-\[Infinity],Message[ConicSection2DSystem::badright,fr];Abort[]];
si=Simplification/.{opts}/.Options[ConicSection2DSystem];
as=Assumptions/.{opts}/.Options[ConicSection2DSystem];
as=Flatten[Join[{t\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
Which[
fl==-\[Infinity]&&fr==\[Infinity], (* cylinder-cylinder, straight line *)
{f,bl,cl,dl,el,br,cr,dr,er}={{0,t},{hl,t},{hl,t},{-1,0},{hl,t},{hr,t},{hr,t},{-1,0},{hr,t}}//sfn,
fl==fr,(* Circle *)
{f,bl,cl,dl,el,br,cr,dr,er}={{fl-fl Cos[t],-fl Sin[t]},{fl,0},{fl,0},{-Cos[t],-Sin[t]},{fl+(-fl+hl) Cos[t],(-fl+hl) Sin[t]},{fl,0},{fl,0},{-Cos[t],-Sin[t]},{fl+(-fl+hr) Cos[t],(-fl+hr) Sin[t]}}//sfn,
fl==fr,(* cone-cone, circle *)
{f,bl,cl,dl,el,br,cr,dr,er}={{fl-fl Cos[t],-fl Sin[t]},{fl,0},{fl,0},{-Cos[t],-Sin[t]},{fl+(-fl+hl) Cos[t],(-fl+hl) Sin[t]},{fl,0},{fl,0},{-Cos[t],-Sin[t]},{fl+(-fl+hr) Cos[t],(-fl+hr) Sin[t]}}//sfn,
fl==-\[Infinity],(* cylinder-cone, parabola, collimated left *)
{f,bl,cl,dl,el,br,cr,dr,er}={{t^2/(4 fr),t},{hl,t},{hl,t},{-1,0},{hl,t},{fr,0},{fr,0},{1-(8 fr^2)/(4 fr^2+t^2),(4 fr t)/(4 fr^2+t^2)},{(4 fr^2 hr+(2 fr-hr) t^2)/(4 fr^2+t^2),(4 fr (fr-hr) t)/(4 fr^2+t^2)}}//sfn,
fr==\[Infinity],(* cone-cylinder, parabola, collimated right *)
{f,bl,cl,dl,el,br,cr,dr,er}={{t^2/(4 fl),t},{fl,0},{fl,0},{1-(8 fl^2)/(4 fl^2+t^2),(4 fl t)/(4 fl^2+t^2)},{(4 fl^2 hl+(2 fl-hl) t^2)/(4 fl^2+t^2),(4 fl (fl-hl) t)/(4 fl^2+t^2)},{hr,t},{hr,t},{-1,0},{hr,t}}//sfn,
True,(* cone-cone, ellipse or hyperbola *)
{f,bl,cl,dl,el,br,cr,dr,er}={{fl-(2 fl fr Cos[t])/(fl+fr+(-fl+fr) Cos[t]),-((2 fl fr Sin[t])/(fl+fr+(-fl+fr) Cos[t]))},{fl,0},{fl,0},{-Cos[t],-Sin[t]},{fl+(-fl+hl) Cos[t],(-fl+hl) Sin[t]},{fr,0},{fr,0},{1-(2 fr^2)/(fr^2+fl^2 Tan[t/2]^2),-((2 fl fr Tan[t/2])/(fr^2+fl^2 Tan[t/2]^2))},{-hr+2 fr (1+(fr (-fr+hr))/(fr^2+fl^2 Tan[t/2]^2)),(2 fl fr (-fr+hr) Tan[t/2])/(fr^2+fl^2 Tan[t/2]^2)}}//sfn];
{CurvedFold2D->FunctionizeOld[f,t],
DirectrixLeft2D->FunctionizeOld[cl,t],
DirectorLeft2D->FunctionizeOld[dl,t],
CrossCurveLeft2D->FunctionizeOld[cl,t],
SecondCrossCurveLeft2D->FunctionizeOld[el,t],
DirectrixRight2D->FunctionizeOld[cr,t],
DirectorRight2D->FunctionizeOld[dr,t],
CrossCurveRight2D->FunctionizeOld[cr,t],
SecondCrossCurveRight2D->FunctionizeOld[er,t]}]
Module[{cs2,f,el,er,cl,cr},
cs2=ConicSection2DSystem[{-\[Infinity],\[Infinity]},{-1,1},Simplification->Simplify];
cs2//PrettyParameters//ColumnForm//Print;
{f,el,er,cl,cr}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.cs2;
Graphics[StyledCurvedFoldOptical[f,{el,er},{cl,cr},{0\[Degree],90\[Degree]},
FoldLineStyle->{Black,Thickness[.005]}]]/.OrigamiStyle[]
]//ShowExample
Module[{cs2,f,el,er,cl,cr},
cs2=ConicSection2DSystem[{-1,-1},{-1/2,1/2},Simplification->Simplify];
cs2//PrettyParameters//ColumnForm//Print;
{f,el,er,cl,cr}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.cs2;
Graphics[StyledCurvedFoldOptical[f,{el,er},{cl,cr},{0\[Degree],90\[Degree]},
FoldLineStyle->{Black,Thickness[.005]},
DirectrixLeftPointStyle->{Darker[Red],PointSize[.015]},DirectrixRightPointStyle->{Darker[Green],PointSize[.015]}]]/.OrigamiStyle[]
]//ShowExample
Module[{cs2,f,el,er,cl,cr},
cs2=ConicSection2DSystem[{-\[Infinity],-1},{-3/2,3/2},Simplification->Simplify];
cs2//PrettyParameters//ColumnForm//Print;
{f,el,er,cl,cr}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.cs2;
Graphics[StyledCurvedFoldOptical[f,{el,er},{cl,cr},{0\[Degree],90\[Degree]},
FoldLineStyle->{Black,Thickness[.005]},
DirectrixLeftPointStyle->{Darker[Red],PointSize[.015]},DirectrixRightPointStyle->{Darker[Green],PointSize[.015]}]]/.OrigamiStyle[]
]//ShowExample
Module[{cs2,f,el,er,cl,cr},
cs2=ConicSection2DSystem[{-1,\[Infinity]},{-1/2,1},Simplification->Simplify];
cs2//PrettyParameters//ColumnForm//Print;
{f,el,er,cl,cr}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.cs2;
Graphics[StyledCurvedFoldOptical[f,{el,er},{cl,cr},{0\[Degree],90\[Degree]},
FoldLineStyle->{Black,Thickness[.005]},
DirectrixLeftPointStyle->{Darker[Red],PointSize[.015]},DirectrixRightPointStyle->{Darker[Green],PointSize[.015]}]]/.OrigamiStyle[]
]//ShowExample
Module[{cs2,f,el,er,cl,cr},
cs2=ConicSection2DSystem[{-2,-1},{-3/2,1},Simplification->Simplify];
cs2//PrettyParameters//ColumnForm//Print;
{f,el,er,cl,cr}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.cs2;
Graphics[StyledCurvedFoldOptical[f,{el,er},{cl,cr},{0\[Degree],90\[Degree]},
FoldLineStyle->{Black,Thickness[.005]},
DirectrixLeftPointStyle->{Darker[Red],PointSize[.015]},DirectrixRightPointStyle->{Darker[Green],PointSize[.015]}]]/.OrigamiStyle[]
]//ShowExample
Module[{cs2,f,el,er,cl,cr},
cs2=ConicSection2DSystem[{-2,+1},{-3/2,1/2},Simplification->Simplify];
cs2//PrettyParameters//ColumnForm//Print;
{f,el,er,cl,cr}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.cs2;
Graphics[StyledCurvedFoldOptical[f,{el,er},{cl,cr},{0\[Degree],45\[Degree]},
FoldLineStyle->{Black,Thickness[.005]},
DirectrixLeftPointStyle->{Darker[Red],PointSize[.015]},DirectrixRightPointStyle->{Darker[Green],PointSize[.015]}]]/.OrigamiStyle[]
]//ShowExample
DirectrixLeft3D::usage="DirectrixLeft3D is a key to the rules returned by conic section functions that gives the left-side 3D directrix of a conic section fold.";
DirectorLeft3D::usage="DirectorLeft3D is a key to the rules returned by conic section functions that gives the left-side 3D director of a conic section fold.";
CrossCurveLeft3D::usage="CrossCurveLeft3D is a key to the rules returned by conic section functions that gives the left-side 3D cross curve of a conic section fold.";
SecondCrossCurveLeft3D::usage="SecondCrossCurveLeft3D is a key to the rules returned by conic section functions that gives a second left-side 3D cross curve of a conic section fold.";
DirectrixRight3D::usage="DirectrixRight3D is a key to the rules returned by conic section functions that gives the right-side 3D directrix of a conic section fold.";
DirectorRight3D::usage="DirectorRight3D is a key to the rules returned by conic section functions that gives the right-side 3D director of a conic section fold.";
CrossCurveRight3D::usage="CrossCurveRight3D is a key to the rules returned by conic section functions that gives the right-side 3D cross curve of a conic section fold.";
SecondCrossCurveRight3D::usage="SecondCrossCurveRight3D is a key to the rules returned by conic section functions that gives a second right-side 3D cross curve of a conic section fold.";
Module[{s,fL,fR,hL,hR,css,f,bL,dL,cL,bR,dR,cR,rL,rR,u0,u1,ff,rrL,rrR,bbL,ddL,ccL,bbR,ddR,ccR,gc1,gc2,gf},
(* 2D description *)
{fL,fR}={-1,-2};(* focal positions *)
{hL,hR}={-1/2,1/2};(* positions of cross curves *)
{u0,u1}={-60\[Degree],60\[Degree]};(* parameter domain *)
css=ConicSection2DSystem[{fL,fR},{hL,hR},Simplification->Simplify];
css//PrettyParameters//ColumnForm//Hold;
{f,cL,cR,bL,bR}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.css;
(* Fold into 3D *)
{u0,u1}={0\[Degree],120.\[Degree]};
rL=Functionize[s,NormalizeReal[cL[s]-f[s]]];
rR=Functionize[s,NormalizeReal[cR[s]-f[s]]];
{ff,rrL,rrR}=NFoldCurvedFold3D[f,rL,rR,{u0,-60.\[Degree],Append[f[0],0],{0,1,0},{0,0,1}},{u0,u1}];
bbL=Functionize[s,ff[s]+rrL[s](rL[s] . (bL[s]-f[s]))];
bbR=Functionize[s,ff[s]+rrR[s](rR[s] . (bR[s]-f[s]))];
ccL=Functionize[s,ff[s]+rrL[s](rL[s] . (cL[s]-f[s]))];
ccR=Functionize[s,ff[s]+rrR[s](rR[s] . (cR[s]-f[s]))];
(* optical coloring *)
gc1=Graphics[StyledCurvedFoldOptical[f,{cL,cR},{bL,bR},{u0,u1},
Sequence@@CurvedFoldOpticalStyles]];
(* 2D crease pattern *)
gc2=Graphics[StyledCurvedFoldOptical[f,{cL,cR},{bL,bR},{u0,u1},
RulingLineOffset->True,
RulingLineLeftStyle->ValleyLine,
RulingLineRightStyle->MountainLine,
FoldLineStyle->ValleyLine,
FillStyle->NoFill]];
(* 3D folded form *)
gf=Graphics3D[{StyledCurvedFoldOptical[ff,{ccL,ccR},{bbL,bbR},{u0,u1},
RulingLineOffset->True],
Style[Sphere[bbL[u0],.03],Red],
Style[Sphere[bbR[u0],.03],Green]
},
Lighting->NeutralLighting[.8],
Method->{"ShrinkWrap"->True}];
GraphicsRow[{gc1,gc2,gf}]/.OrigamiStyle[]
]//ShowExample
ComposeReflections::usage="ComposeReflections is an option to PlanarCurvedFold3DSequence that specifies whether to compose the planar reflections.";
Options[PlanarCurvedFold3DSequence]={
ComposeReflections->True,
Simplification->None,
Assumptions->{}
};
StrictArguments[PlanarCurvedFold3DSequence];
PlanarCurvedFold3DSequence[bblf_Function,ddlf_Function,pm_List,opts___]:=Block[{cr,si,as,t,sfn,ret,epm,p,m,bbl,ddl,vf,ff,bbr,ddr},
cr=ComposeReflections/.{opts}/.Options[PlanarCurvedFold3DSequence];
si=Simplification/.{opts}/.Options[PlanarCurvedFold3DSequence];
as=Assumptions/.{opts}/.Options[PlanarCurvedFold3DSequence];
as=Flatten[Join[{t\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
ret={{0&,bblf,bblf,ddlf}};(* initial entry in the output list *)
epm=pm;(* an editable copy that we will manipulate *)
bbl=Functionize[t,bblf[t]//sfn];
ddl=Functionize[t,ddlf[t]//sfn];
While[Length[epm]>0,
(* pop off the first point/mirror pair *)
{p,m}=epm[[1]];
epm=Drop[epm,1];
vf=Functionize[t,(p-bbl[t]) . m/ddl[t] . m//sfn];
ff=Functionize[t,bbl[t]+vf[t] ddl[t]//sfn];
ddr=Functionize[t,Reflectu[ddl[t],m]//sfn];
bbr=Functionize[t,Reflectu[bbl[t],p,m]//sfn];
(* add this set to the output list *)
AppendTo[ret,{vf,bbr,ff,ddr}];
(* mirror all subsequent point/mirror pairs in this one unless we're composing reflections. *)
If[cr,epm={Reflectu[#[[1]],p,m],Reflectu[#[[2]],m]}&/@epm];
(* and setup the next left parameterization *)
bbl=bbr;
ddl=ddr];
ret]
Module[{\[Theta],bb,dd,pm,pcf3ds,cclist,b,d,t,clist,u0,u1,v1},
\[Theta]=30.\[Degree];
bb={0,0,0}&;
dd={Sin[\[Theta]]Cos[#],Sin[\[Theta]]Sin[#],Cos[\[Theta]]}&;
pm={{{0,0,1},{0,0,1}},
{{0,0,2},RotationXMatrix3D[10.\[Degree]] . {0,0,1}},
{{0,0,3},RotationYMatrix3D[10.\[Degree]] . {0,0,1}},
{{0,0,4},{0,0,1}}};
pcf3ds=PlanarCurvedFold3DSequence[bb,dd,pm,Simplification->Simplify];
cclist=#[[3]]&/@pcf3ds;
(* we know what the 2D ruled parameterization is, so can build the CP, too *)
b={0,0}&;
d={ Cos[# Sin[\[Theta]]],Sin[# Sin[\[Theta]]]}&;
clist=Functionize[t,b[t]+#[[1]][t]d[t]]&/@pcf3ds;
{u0,u1}={0,1\[Pi]};
v1=4Sec[\[Theta]];
GraphicsRow[{
Graphics3D[{
Styled3DAxes[],
StyledRuledPatch[bb,dd,{u0,u1},{0,v1}]//ReverseFillStyle,
Table[Styled3DDisk[pm[[i,1]],pm[[i,2]],2.5,FillStyle->{LightGray,Opacity[.2]}],{i,Length[pm]}],
{}},Lighting->NeutralLighting[.8]],
Graphics3D[{
Styled3DAxes[],
StyledRuledPatchSequence[cclist,{u0,u1}],
{}},Lighting->NeutralLighting[.8]],
Graphics[{
StyledRuledPatchSequence[clist,{u0,u1},
TransverseLineStyle->{BorderLine,MountainLine,ValleyLine,MountainLine,BorderLine},
RulingLineStyle->{ValleyRulingLine,MountainRulingLine,ValleyRulingLine,MountainRulingLine}],
{}}]}]/.OrigamiStyle[]
]//ShowExample
Module[{u,u0,u1,bb,dd,pm,pcf3ds,cclist,cclast,b,d,clist,clast,v1},
{u0,u1}={-\[Pi]/4,\[Pi]/4};
bb=Functionize[u,{Cos[u],Sin[u],0}];
dd=Functionize[u,{0,0,1}];
pm={{{1,0,1},NormalizeReal[{-1,0,1}]},
{{2,0,1},NormalizeReal[{-1,0,1}]}};
pcf3ds=PlanarCurvedFold3DSequence[bb,dd,pm,ComposeReflections->False,Simplification->Simplify];
v1=3;
cclast=Functionize[u,pcf3ds[[-1,3]][u]+(v1-pcf3ds[[-1,1]][u])pcf3ds[[-1,4]][u]];
cclist=Append[#[[3]]&/@pcf3ds,cclast];
(* we know what the 2D ruled parameterization is, so can build the CP, too *)
b=Functionize[u,{0,u}];
d=Functionize[u,{1,0}];
clast=Functionize[u,b[u]+v1 d[u]];
clist=Append[Functionize[u,b[u]+#[[1]][u]d[u]]&/@pcf3ds,clast];
GraphicsRow[{
Graphics3D[{
Styled3DAxes[],
StyledRuledPatch[bb,dd,{u0,u1},{0,v1}]//ReverseFillStyle,
Table[Styled3DDisk[pm[[i,1]],pm[[i,2]],1,FillStyle->{LightGray,Opacity[.2]}],{i,Length[pm]}],
{}},Lighting->NeutralLighting[.8]],
Graphics3D[{
Styled3DAxes[],
StyledRuledPatchSequence[cclist,{u0,u1}],
Table[StyledCurve[cclist[[i]],{u0,u1}],{i,Length[cclist]}],
{}},Lighting->NeutralLighting[.8]],
Graphics[{
StyledRuledPatchSequence[clist,{u0,u1}],
Table[StyledCurve[clist[[i]],{u0,u1}],{i,Length[clist]}],
{}}]}]/.OrigamiStyle[]
]//ShowExample

StrictArguments[NPlanarCurvedFold3DSequence];
NPlanarCurvedFold3DSequence[bblf_Function|bblf_InterpolatingFunction,ddlf_Function|ddlf_InterpolatingFunction,pm_List,{u0_,u1_},opts___]:=Module[{cr,fiopts,u,sfn,ret,epm,p,m,bbl,ddl,vf,ff,bbr,ddr},
cr=ComposeReflections/.{opts}/.Options[PlanarCurvedFold3DSequence];
fiopts=Sequence@@FilterRules[{opts},Options[FunctionInterpolation]];
ret={{0&,bblf,bblf,ddlf}};(* initial entry in the output list *)
epm=pm;(* an editable copy that we will manipulate *)
{bbl,ddl}={bblf,ddlf};
While[Length[epm]>0,
(* pop off the first point/mirror pair *)
{p,m}=epm[[1]];
epm=Drop[epm,1];
vf=FunctionInterpolationAlt[(p-bbl[u]) . m/ddl[u] . m,{u,u0,u1},fiopts];
ff=FunctionInterpolationAlt[bbl[u]+((p-bbl[u]) . m/ddl[u] . m) ddl[u],{u,u0,u1},fiopts];
ddr=FunctionInterpolationAlt[Reflectu[ddl[u],m],{u,u0,u1},fiopts];
bbr=FunctionInterpolationAlt[Reflectu[bbl[u],p,m],{u,u0,u1},fiopts];
(* add this set to the output list *)
AppendTo[ret,{vf,bbr,ff,ddr}];
(* mirror all subsequent point/mirror pairs in this one *)
If[cr,epm={Reflectu[#[[1]],p,m],Reflectu[#[[2]],m]}&/@epm];
(* and setup the next left parameterization *)
bbl=bbr;
ddl=ddr];
ret]
Module[{\[Theta],bb,dd,pm,pcf3ds,cclist,b,d,clist,u,u0,u1,v1},
\[Theta]=30.\[Degree];
{u0,u1}={0,1\[Pi]};
bb={0,0,0}&;
dd={Sin[\[Theta]]Cos[#],Sin[\[Theta]]Sin[#],Cos[\[Theta]]}&;
pm={{{0,0,1},{0,0,1}},
{{0,0,2},RotationXMatrix3D[10.\[Degree]] . {0,0,1}},
{{0,0,3},RotationYMatrix3D[10.\[Degree]] . {0,0,1}},
{{0,0,4},{0,0,1}}};
pcf3ds=NPlanarCurvedFold3DSequence[bb,dd,pm,{u0,u1}];
cclist=#[[3]]&/@pcf3ds;
(* we know what the 2D ruled parameterization is, so can build the CP, too *)
b={0,0}&;
d={ Cos[# Sin[\[Theta]]],Sin[# Sin[\[Theta]]]}&;
clist=Functionize[u,b[u]+#[[1]][u]d[u]]&/@pcf3ds;
v1=4Sec[\[Theta]];
GraphicsRow[{
Graphics3D[{
Styled3DAxes[],
StyledRuledPatch[bb,dd,{u0,u1},{0,v1}]//ReverseFillStyle,
Table[Styled3DDisk[pm[[i,1]],pm[[i,2]],2.5,FillStyle->{LightGray,Opacity[.2]}],{i,Length[pm]}],
{}},Lighting->NeutralLighting[.8]],
Graphics3D[{
Styled3DAxes[],
StyledRuledPatchSequence[cclist,{u0,u1}],
{}},Lighting->NeutralLighting[.8]],
Graphics[{
StyledRuledPatchSequence[clist,{u0,u1},
TransverseLineStyle->{BorderLine,MountainLine,ValleyLine,MountainLine,BorderLine},
RulingLineStyle->{ValleyRulingLine,MountainRulingLine,ValleyRulingLine,MountainRulingLine}],
{}}]}]/.OrigamiStyle[]
]//ShowExample
Options[FoldSurfaceToCone]={
Simplification->None,
Assumptions->{}
};
StrictArguments[FoldSurfaceToCone];
FoldSurfaceToCone[b1_Function,d1_Function,bb1_Function,dd1_Function,{ui_,b2i_List,bb2i_List},opts___]:=Module[{si,as,s,sfn,v,f,ff,d2i,dd2i,\[Psi],b2,d2,bb2,dd2},
si=Simplification/.{opts}/.Options[FoldSurfaceToCone];
as=Assumptions/.{opts}/.Options[FoldSurfaceToCone];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
(* v-parameter solution *)
v=Functionize[s,(Mag2[b2i-b1[s]]-Mag2[bb2i-bb1[s]])/(2((b2i-b1[s]) . d1[s]-(bb2i-bb1[s]) . dd1[s]))//sfn];
f=Functionize[s,b1[s]+v[s]d1[s]//sfn];
ff=Functionize[s,bb1[s]+v[s]dd1[s]//sfn];
d2i=NormalizeReal[b2i-f[ui]]//sfn;
dd2i=NormalizeReal[bb2i-ff[s]]//sfn;
\[Psi]=Sign[d1[ui] . d2i-dd1[ui] . dd2i];
b2=Functionize[s,b2i];
bb2=Functionize[s,bb2i];
d2=Functionize[s,\[Psi] NormalizeReal[b2i-f[s]]//sfn];
dd2=Functionize[s,\[Psi] NormalizeReal[bb2i-ff[s]]//sfn];
{b2,d2,bb2,dd2,f,ff}]
Module[{um,u0,u1,b1,d1,bb1,dd1,b2i,bb2i,b2,d2,bb2,dd2,f,ff,s},
{u0,u1}={-\[Pi]/3,\[Pi]};
b1={-1,#}&;
d1={1,0}&;
bb1={Cos[#],Sin[#],-1}&;
dd1={0,0,1}&;
b2i={2,0};
bb2i={2,0,1};
{b2,d2,bb2,dd2,f,ff}=FoldSurfaceToCone[b1,d1,bb1,dd1,{0,b2i,bb2i},Simplification->Simplify];
GraphicsRow[{
Graphics[{
StyledRuledPatch[b1,Functionize[s,f[s]-b1[s]],{u0,u1},{0,1}],
StyledRuledPatch[f,Functionize[s,b2[s]-f[s]],{u0,u1},{0,1}],
StyledCurve[b1,{u0,u1},
CurveDirected->True],
StyledCurve[f,{u0,u1},
CurveDirected->True],
Style[Point[b2i],Black],
{}}],
Graphics3D[{
StyledRuledPatch[bb1,Functionize[s,ff[s]-bb1[s]],{u0,u1},{0,1},SurfaceOrientation->-1],
StyledRuledPatch[ff,Functionize[s,bb2[s]-ff[s]],{u0,u1},{0,1},SurfaceOrientation->-1],
StyledCurve[bb1,{u0,u1},
CurveDirected->True],
StyledCurve[ff,{u0,u1},
CurveDirected->True],
Style[Point[bb2i],Black],
{}}]
}]/.OrigamiStyle[]
]//ShowExample
StrictArguments[NFoldSurfaceToCone];
NFoldSurfaceToCone[b1_Function,d1_Function,bb1_Function,dd1_Function,{ui_,b2i_List,bb2i_List},{u0_,u1_},opts___]:=Module[{s,vi,fi,ffi,d2i,dd2i,\[Psi],d23,b2,bb2,d2,dd2,f,ff},
vi=(Mag2[b2i-b1[ui]]-Mag2[bb2i-bb1[ui]])/(2((b2i-b1[ui]) . d1[ui]-(bb2i-bb1[ui]) . dd1[ui]));
fi=b1[ui]+vi d1[ui];
ffi=bb1[ui]+vi dd1[ui];
d2i=NormalizeReal[b2i-fi];
dd2i=NormalizeReal[bb2i-ffi];
\[Psi]=Sign[d1[ui] . d2i-dd1[ui] . dd2i];
d23=FunctionInterpolationAlt[Module[{v,fp,ffp},
v=(Mag2[b2i-b1[s]]-Mag2[bb2i-bb1[s]])/(2((b2i-b1[s]) . d1[s]-(bb2i-bb1[s]) . dd1[s]));
fp=b1[s]+v d1[s];
ffp=bb1[s]+v dd1[s];
 Join[\[Psi](b2i-fp),\[Psi](bb2i-ffp),fp,ffp]],{s,u0,u1},opts];
b2=Functionize[s,b2i];
bb2=Functionize[s,bb2i];
d2=Functionize[s,d23[s][[{1,2}]]];
dd2=Functionize[s,d23[s][[{3,4,5}]]];
f=Functionize[s,d23[s][[{6,7}]]];
ff=Functionize[s,d23[s][[{8,9,10}]]];
{b2,d2,bb2,dd2,f,ff}]
Module[{u0,u1,b1,d1,bb1,dd1,b2i,bb2i,b2,d2,bb2,dd2,f,ff,s},
{u0,u1}={-\[Pi]/3,\[Pi]};
b1={-1,#}&;
d1={1,0}&;
bb1={Cos[#],Sin[#],-1}&;
dd1={0,0,1}&;
b2i={2,0};
bb2i={2,0,1};
{b2,d2,bb2,dd2,f,ff}=NFoldSurfaceToCone[b1,d1,bb1,dd1,{0,b2i,bb2i},{u0,u1}];
GraphicsRow[{
Graphics[{
StyledRuledPatch[b1,Functionize[s,f[s]-b1[s]],{u0,u1},{0,1}],
StyledRuledPatch[f,Functionize[s,b2[s]-f[s]],{u0,u1},{0,1}],
StyledCurve[b1,{u0,u1},
CurveDirected->True],
StyledCurve[f,{u0,u1},
CurveDirected->True],
Style[Point[b2i],Black],
{}}],
Graphics3D[{
StyledRuledPatch[bb1,Functionize[s,ff[s]-bb1[s]],{u0,u1},{0,1},SurfaceOrientation->-1],
StyledRuledPatch[ff,Functionize[s,bb2[s]-ff[s]],{u0,u1},{0,1},SurfaceOrientation->-1],
StyledCurve[bb1,{u0,u1},
CurveDirected->True],
StyledCurve[ff,{u0,u1},
CurveDirected->True],
Style[Point[bb2i],Black],
{}}]
}]/.OrigamiStyle[]
]//ShowExample
Options[FoldSurfaceToCylinder]={
Simplification->None,
Assumptions->{}
};
StrictArguments[FoldSurfaceToCylinder];
FoldSurfaceToCylinder[b1_Function,d1_Function,bb1_Function,dd1_Function,{p2i_List,d2i_List,pp2i_List,dd2i_List},opts___]:=Module[{si,as,s,sfn,v,f,ff,b2,bb2,d2,dd2},
si=Simplification/.{opts}/.Options[FoldSurfaceToCylinder];
as=Assumptions/.{opts}/.Options[FoldSurfaceToCylinder];
as=Flatten[Join[{s\[Element]Reals},as]];
sfn=If[si===None,#&,si[#,Assumptions->as]&];
(* v-parameter solution *)
v=Functionize[s,((p2i-b1[s]) . d2i-(pp2i-bb1[s]) . dd2i)/(d1[s] . d2i-dd1[s] . dd2i)//sfn];
f=Functionize[s,b1[s]+v[s]d1[s]//sfn];
ff=Functionize[s,bb1[s]+v[s]dd1[s]//sfn];
b2=Functionize[s,f[s]-((f[s]-p2i) . d2i)d2i//sfn];
bb2=Functionize[s,ff[s]-((ff[s]-pp2i) . dd2i)dd2i//sfn];
d2=Functionize[s,d2i//sfn];
dd2=Functionize[s,dd2i//sfn];
{b2,d2,bb2,dd2,f,ff}]
Module[{\[Phi],\[Epsilon],u0,u1,b1,d1,bb1,dd1,p2i,d2i,pp2i,dd2i,b2,bb2,f,ff,s},
\[Phi]=30\[Degree];
\[Epsilon]=.25;
{u0,u1}={0,\[Pi]};
b1={0,0}&;
d1=Functionize[s,{Cos[s Sin[\[Phi]]],Sin[s Sin[\[Phi]]]}];
bb1={0,0,0}&;
dd1=Functionize[s,{Cos[\[Phi]],-Sin[\[Phi]]Cos[s ],Sin[\[Phi]]Sin[s ]}];
p2i = {1+\[Epsilon],0};
d2i={-1,0};
pp2i={Cos[\[Phi]],-Sin[\[Phi]],0}+\[Epsilon]{-Cos[\[Phi]],-Sin[\[Phi]],0};
dd2i={Cos[\[Phi]],Sin[\[Phi]],0};
{b2,d2i,bb2,dd2i,f,ff}=FoldSurfaceToCylinder[b1,d1,bb1,dd1,{p2i,d2i,pp2i,dd2i},Simplification->Simplify];
GraphicsRow[{
Graphics[{
StyledRuledPatch[b1,Functionize[s,f[s]-b1[s]],{u0,u1},{0,1}],
StyledRuledPatch[f,Functionize[s,b2[s]-f[s]],{u0,u1},{0,1}],
StyledCurve[f,{u0,u1},
CurveDirected->True],
Style[Point[p2i],Red],
Styled2DAxes[.75,.75],
{}}],
Graphics3D[{
Styled3DAxes[1,1,.5],
StyledRuledPatch[bb1,Functionize[s,ff[s]-bb1[s]],{u0,u1},{0,1},SurfaceOrientation->-1],
StyledRuledPatch[ff,Functionize[s,bb2[s]-ff[s]],{u0,u1},{0,1},SurfaceOrientation->-1],
StyledCurve[ff,{u0,u1},
CurveDirected->True],
Style[Point[pp2i],Red],
{}}]
}]/.OrigamiStyle[]
]//ShowExample
StrictArguments[NFoldSurfaceToCylinder];
NFoldSurfaceToCylinder[b1_Function,d1_Function,bb1_Function,dd1_Function,{p2i_List,d2i_List,pp2i_List,dd2i_List},{u0_,u1_},opts___]:=Module[{s,vi,fi,ffi,d20i,dd20i,\[Psi],d23,f,ff,b2,bb2,d2,dd2},
d23=FunctionInterpolationAlt[Module[{v,fp,ffp,b2p,bb2p},
v=((p2i-b1[s]) . d2i-(pp2i-bb1[s]) . dd2i)/(d1[s] . d2i-dd1[s] . dd2i);
fp=b1[s]+v d1[s];
ffp=bb1[s]+v dd1[s];
b2p=fp-((fp-p2i) . d2i)d2i;
bb2p=ffp-((ffp-pp2i) . dd2i)dd2i;
Join[b2p,bb2p,fp,ffp]],{s,u0,u1},opts];
b2=Functionize[s,d23[s][[{1,2}]]];
bb2=Functionize[s,d23[s][[{3,4,5}]]];
f=Functionize[s,d23[s][[{6,7}]]];
ff=Functionize[s,d23[s][[{8,9,10}]]];
d2=Functionize[s,d2i];
dd2=Functionize[s,dd2i];
{b2,d2,bb2,dd2,f,ff}]
Module[{\[Phi],\[Epsilon],u0,u1,b1,d1,bb1,dd1,p2i,d2i,pp2i,dd2i,b2,bb2,f,ff,s},
\[Phi]=30\[Degree];
\[Epsilon]=.25;
{u0,u1}={0,\[Pi]};
b1={0,0}&;
d1=Functionize[s,{Cos[s Sin[\[Phi]]],Sin[s Sin[\[Phi]]]}];
bb1={0,0,0}&;
dd1=Functionize[s,{Cos[\[Phi]],-Sin[\[Phi]]Cos[s ],Sin[\[Phi]]Sin[s ]}];
p2i = {1+\[Epsilon],0};
d2i={-1,0};
pp2i={Cos[\[Phi]],-Sin[\[Phi]],0}+\[Epsilon]{-Cos[\[Phi]],-Sin[\[Phi]],0};
dd2i={Cos[\[Phi]],Sin[\[Phi]],0};
{b2,d2i,bb2,dd2i,f,ff}=NFoldSurfaceToCylinder[b1,d1,bb1,dd1,{p2i,d2i,pp2i,dd2i},{u0,u1}];
GraphicsRow[{
Graphics[{
StyledRuledPatch[b1,Functionize[s,f[s]-b1[s]],{u0,u1},{0,1}],
StyledRuledPatch[f,Functionize[s,b2[s]-f[s]],{u0,u1},{0,1}],
StyledCurve[f,{u0,u1},
CurveDirected->True],
Style[Point[p2i],Red],
Styled2DAxes[.75,.75],
{}}],
Graphics3D[{
Styled3DAxes[1,1,.5],
StyledRuledPatch[bb1,Functionize[s,ff[s]-bb1[s]],{u0,u1},{0,1},SurfaceOrientation->-1],
StyledRuledPatch[ff,Functionize[s,bb2[s]-ff[s]],{u0,u1},{0,1},SurfaceOrientation->-1],
StyledCurve[ff,{u0,u1},
CurveDirected->True],
Style[Point[pp2i],Red],
{}}]
}]/.OrigamiStyle[]
]//ShowExample
HCwCParabola[ti1_?NumericQ,ti2_?NumericQ,\[Gamma]1i_?NumericQ,\[Gamma]2i_?NumericQ]:=Module[{
iopts,q,t,
ti0,ti3,ti12,
f0,ds0,b\[Kappa]g0,b\[Kappa]n0,s\[Lambda]0,
f1,ds1,\[Gamma]1,rR1,rL1,\[Kappa]g1,t1,l1,vR1,
f2,ds2,\[Gamma]2,rL2,rR2,\[Kappa]g2,t2,l2,vR2,
f3,
eqn1,eqn2,eqn3,
d3dsys,\[Kappa]1,\[Tau]1,c3dsys,
ff0,rrR0,
ff1,tt1,nn1,bb1,\[FinalSigma]1,llL1,uuL1,llR1,uuR1,rrR1,
ff2,tt2,rrL2,uuL2,llL2,llR2,uuR2,rrR2,
ff3,
xL,xR,yL,yR,z,pv},
iopts=Sequence[InterpolationPoints->128];
{ti0,ti3}={0,\[Pi]/2};
(* Zeroth fold, cone point *)
f0=Functionize[t,{0,0}];
(* First fold, circle *)
f1=Functionize[t,{Cos[t],Sin[t]}];
rL1=Functionize[t,-{Cos[t],Sin[t]}];
ds1=Functionize[t,1];
t1=Functionize[t,{-Sin[t],Cos[t]}];
l1=Functionize[t,{-Cos[t],-Sin[t]}];
\[Kappa]g1=Functionize[t,1];
(*
From here, can change in/out different curves
*)
(* Second fold, parabola *)
f2=Functionize[q,(4/(1+Cos[q])){Cos[q],Sin[q]}];
rR2=Functionize[q,{1,0}];
ds2=Functionize[q,2 Sec[q/2]^3];
t2=Functionize[q,{-Sin[q/2],Cos[q/2]}];
l2=Functionize[q,{-Cos[q/2],-Sin[q/2]}];
\[Kappa]g2=Functionize[q,(1/4) Cos[q/2]^3];
(* Third fold, right edge of cylinder *)
f3=Functionize[q,{2,(4/(1+Cos[q]))Sin[q]}];
(* Connection ruling *)
r=Functionize[{t,q},{(4 Cos[q]-(1+Cos[q]) Cos[t])/((1+Cos[q]) \[Sqrt]((-((4 Cos[q])/(1+Cos[q]))+Cos[t])^2+(Sin[t]-4 Tan[q/2])^2)),(4 Sin[q]-(1+Cos[q]) Sin[t])/((1+Cos[q]) \[Sqrt]((-((4 Cos[q])/(1+Cos[q]))+Cos[t])^2+(Sin[t]-4 Tan[q/2])^2))}];
(* Consistency equations *)
eqn1=Derivative[1][\[Gamma]1][t]==-((4 Sin[t-q[t]] Tan[\[Gamma]1[t]/2])/(1-4 Cos[t-q[t]]+Cos[q[t]]));
eqn2=Derivative[1][\[Gamma]2][t]== Tan[\[Gamma]2[t]/2] ((2 (-4+Cos[t]+Cos[t-q[t]]) Cos[q[t]/2] Cot[\[Gamma]2[t]/2] Tan[\[Gamma]1[t]/2])/(1-4 Cos[t-q[t]]+Cos[q[t]]))( Sin[t-q[t]]/(-4+Cos[t]+Cos[t-q[t]]));
eqn3=Derivative[1][q][t]==Which[t<ti1,0,t>ti2,0,True,-((2 (-4+Cos[t]+Cos[t-q[t]]) Cos[q[t]/2] Cot[\[Gamma]2[t]/2] Tan[\[Gamma]1[t]/2])/(1-4 Cos[t-q[t]]+Cos[q[t]]))];
(* Solve the differential equation *)
ndsoln=NDSolve[{eqn1,eqn2,eqn3,
q[ti1]==ti0,\[Gamma]1[ti1]==\[Gamma]1i,\[Gamma]2[ti1]==\[Gamma]2i},
{q,\[Gamma]1,\[Gamma]2},
{t,ti0,ti3}]//Flatten;
{q,\[Gamma]1,\[Gamma]2}={q,\[Gamma]1,\[Gamma]2}/.ndsoln;
(* 
Construct the properties that depended on q, \[Gamma]1, or \[Gamma]2, parameterized on t
*)
(* First fold (circle) *)
rR1=Functionize[t,r[t,q[t]]];
(* Second fold (parabola) *)
f2=Functionize[t,f2[q[t]]];
ds2=Functionize[t,ds2[q[t]]];
rL2=Functionize[t,-r[t,q[t]]];
rR2=Functionize[t,rR2[q[t]]];
t2=Functionize[t,t2[q[t]]];
l2=Functionize[t,l2[q[t]]];
(* Third fold (end of cylinder) *)
f3=Functionize[t,f3[q[t]]];
(* distance from first to second fold *)
vR1=Functionize[t,Mag[f2[t]-f1[t]]];
(* distance second to third fold (add a teensy bit to avoid zero-length lines) *)
vR2=Functionize[t,10^-6+(f3[t]-f2[t]) . rR2[t]];
(*
Construct the 3D surface.
*)
(* center of cone in 3D *)
ff0={0,0,0}&;
(* Construct the Darboux frame of first fold left side, which includes the 3D fold line *)
ds0=ds1;
b\[Kappa]g0=1&;
b\[Kappa]n0=Functionize[t,-Tan[\[Gamma]1[t]/2]];
{ff1,tt1,llL1,uuL1}=NRecoverDarboux3D[{ds0,b\[Kappa]g0,b\[Kappa]n0,0&},{ti0,{1,0,0},{0,0,1},{-1,0,0},{0,-1,0}},{ti0,ti3},iopts];
rrR0=Functionize[t,NormalizeReal[ff1[t]]];
(* Darboux frame of first fold right side *)
llR1=Functionize[t,Cos[\[Gamma]1[t]]llL1[t]-Sin[\[Gamma]1[t]]uuL1[t]];
uuR1=Functionize[t,Sin[\[Gamma]1[t]]llL1[t]+Cos[\[Gamma]1[t]]uuL1[t]];
rrR1=Functionize[t,(rR1[t] . t1[t]) tt1[t]+(rR1[t] . l1[t]) llR1[t]];
(* 2nd fold in 3D *)
ff2=FunctionInterpolationAlt[ff1[t]+vR1[t]rrR1[t],{t,ti0,ti3},iopts];
(* 2nd fold, left and right side Darboux frames *)
tt2=Functionize[t,D[ff2[t],t]/Mag[D[ff2[t],t]]];
rrL2=Functionize[t,-rrR1[t]];
uuL2=Functionize[t,uuR1[t]];
llL2=Functionize[t,uuL2[t]\[Cross]tt2[t]];
llR2=Functionize[t,Cos[\[Gamma]2[t]]llL2[t]-Sin[\[Gamma]2[t]]uuL2[t]];
uuR2=Functionize[t,Sin[\[Gamma]2[t]]llL2[t]+Cos[\[Gamma]2[t]]uuL2[t]];
(* Knowing that 3rd surface is cylindrical, we know rrR2 is a constant, so we only need 1 value *)
rrR2=Functionize[t,(rR2[t] . t2[t]) tt2[t]+(rR2[t] . l2[t]) llR2[t]];
ti12=(ti1+ti2)/2;
rrR2=Functionize[t,rrR2[ti12]];
(* third fold, along the the edge of the cylinder *)
ff3=Functionize[t,ff2[t]+vR2[t]rrR2[t]];
(*
Construct the mirror frames and the pivot vector.
*)
(* compute the normal vector to the left vertical plane *)
yL=NormalizeReal[(ff2[ti3]-ff1[ti3])\[Cross](ff0[ti3]-ff1[ti3])];
(* compute the normal vector to the right vertical plane *)
yR=rrR2[ti3];
(* compute the "z" vector, which defines the direction of the axis of rotational symmetry. *)
z=NormalizeReal[yL\[Cross]yR];
(* compute the 3rd vector in each system, used to construct the plane polygons *)
xL=yL\[Cross]z;
xR=yR\[Cross]z;
(* construct the pivot axis *)
pv=NormalizeReal[(ff2[ti0]+ff0[ti0])/2-ff1[ti0]];
(* Return values: 2D and 3D fold sequences, mirror frames, and pivot vector *)
{f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2}]
HCwCGraphics[hcwc_List,opts___]:=Module[{gopts,f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2,gc},
gopts=Sequence@@FilterRules[{opts},Options[Graphics]];
{f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2}=hcwc;
gc={
StyledRuledPatch[{f0,f1},{0,\[Pi]/2},
RulingLineStyle->MountainRulingLine,
RulingLineDivisions->25],
StyledRuledPatch[{f1,f2},{0,\[Pi]/2},
RulingLineStyle->ValleyRulingLine,
RulingLineDivisions->25],
StyledRuledPatch[{f2,f3},{0,\[Pi]/2},
RulingLineStyle->MountainRulingLine,
RulingLineDivisions->25],
StyledCurve[f1,{0,\[Pi]/2},
LineStyle->ValleyLine],
StyledCurve[f2,{0,\[Pi]/2},
LineStyle->MountainLine],
{}};
Graphics[gc,gopts]]
Module[{hcwc},
hcwc=HCwCParabola[5.\[Degree],85.\[Degree],60.\[Degree],-90.\[Degree]];
HCwCGraphics[hcwc,Axes->True]/.OrigamiStyle[]
]//ShowExample
HCwCPairGraphics[hcwc_List,opts___]:=Module[{gg,p0},
gg=HCwCGraphics[hcwc, opts];
p0=hcwc[[2]][0];
ReplacePart[gg,1->{gg[[1]],FunctionTransform[gg[[1]],p0+RotationMatrix2D[\[Pi]] . (#-p0)&]}]]
Module[{hcwc},
hcwc=HCwCParabola[5.\[Degree],85.\[Degree],60.\[Degree],-90.\[Degree]];
HCwCPairGraphics[hcwc,Axes->True]/.OrigamiStyle[]
]//ShowExample
ShowHCwCPlanes::usage="ShowHCwCPlanes is an option to HCwCGraphics3D that specifies whether to show the various planes that define the symmetries that go into the HCwC.";
Options[HCwCGraphics3D]={
ShowHCwCPlanes->True
};
HCwCGraphics3D[hcwc_List,opts___]:=Module[{gopts,sp,f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2,vr,xe,z3,z0L,z0R,gf},
gopts=Sequence@@FilterRules[{opts},Options[Graphics3D]];
sp=ShowHCwCPlanes/.{opts}/.Options[HCwCGraphics3D];
{f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2}=hcwc;
vr=0.5;(* vector lengths *)
(* points on axis of rotation between mirror planes *)
z3=ff2[\[Pi]/2]+xL((ff3[\[Pi]/2]-ff2[\[Pi]/2]) . yR/xL . yR);
z0L=z3-z(z . (ff3[\[Pi]/2]-ff0[0]));
z0R=z3-z(z . (ff3[\[Pi]/2]-ff3[0]));
xe=0.5+Max[Mag[ff2[\[Pi]/2]-z3],Mag[ff2[0]-z0R]];
gf={
StyledRuledPatch[{ff0,ff1},{0,\[Pi]/2},
RulingLineDivisions->25,
SurfaceOrientation->-1],
StyledRuledPatch[{ff1,ff2},{0,\[Pi]/2},
RulingLineDivisions->25,
SurfaceOrientation->-1],
StyledRuledPatch[{ff2,ff3},{0,\[Pi]/2},
RulingLineDivisions->25,
SurfaceOrientation->-1],
StyledCurve[ff1,{0,\[Pi]/2},
LineStyle->FoldedLine],
StyledCurve[ff2,{0,\[Pi]/2},
LineStyle->FoldedLine],
If[sp,{
(* left plane *)
Style[Polygon[{z0L,z3,z3+xe xL,z0L+xe xL}],Opacity[0.5],Green],
(* right plane *)
Style[Polygon[{z0R,z3,z3+xe xR,z0R+xe xR}],Opacity[0.5],Green]},
{}],
{}};
Graphics3D[gf,gopts]]
Module[{hcwc,f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2},
hcwc=HCwCParabola[5.\[Degree],85.\[Degree],60.\[Degree],-90.\[Degree]];
{f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2}=hcwc;
HCwCGraphics3D[hcwc,
Axes->False,
ViewPoint->5(xL+.8yL+.4z),
ViewVertical->z,
Lighting->NeutralLighting[0.8],
Method->{"ShrinkWrap"->True},
ShowHCwCPlanes->True]/.OrigamiStyle[]
]//ShowExample
Module[{hcwc,f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2,vr,xe,z3,z0L,z0R,gg},
hcwc=HCwCParabola[5.\[Degree],85.\[Degree],60.\[Degree],-90.\[Degree]];
{f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2}=hcwc;
vr=0.5;(* vector lengths *)
(* points on axis of rotation between mirror planes *)
z3=ff2[\[Pi]/2]+xL((ff3[\[Pi]/2]-ff2[\[Pi]/2]) . yR/xL . yR);
z0L=z3-z(z . (ff3[\[Pi]/2]-ff0[0]));
z0R=z3-z(z . (ff3[\[Pi]/2]-ff3[0]));
xe=0.5+Max[Mag[ff2[\[Pi]/2]-z3],Mag[ff2[0]-z0R]];
(* build the Graphics3D representation *)
gg=HCwCGraphics3D[hcwc,
Axes->False,
ViewPoint->5(xL+.8yL+.4z),
ViewVertical->z,
Lighting->NeutralLighting[0.8],
Method->{"ShrinkWrap"->True},
ShowHCwCPlanes->True];
(* but add to it various vectors *)
ReplacePart[gg,1->{gg[[1]],
(* left vectors *)
StyledVector[ff2[\[Pi]/2],vr xL,VectorColor->Red],
StyledVector[ff2[\[Pi]/2],vr yL,VectorColor->Green],
StyledVector[ff2[\[Pi]/2],vr z,VectorColor->Blue],
(* right vectors *)
StyledVector[ff3[\[Pi]/2],vr xR,VectorColor->Red],
StyledVector[ff3[\[Pi]/2],vr yR,VectorColor->Green],
StyledVector[ff3[\[Pi]/2],vr z,VectorColor->Blue],
(* pivot vector *)
StyledVector[ff1[0],2vr pv,VectorColor->Purple],
(* pivot plane *)
Style[Polygon[{ff0[0],ff1[0],ff2[0]}],Opacity[0.2],Purple,EdgeForm[]],
{}}]/.OrigamiStyle[]
]//ShowExample
HCwCPairGraphics3D[hcwc_List,opts___]:=Module[{gg,p0,pv},
gg=HCwCGraphics3D[hcwc,opts];
p0=hcwc[[6]][0];
pv=hcwc[[14]];
ReplacePart[gg,1->{gg[[1]],FunctionTransform[gg[[1]],p0+RotationMatrix3D[\[Pi],pv] . (#-p0)&]}]]
Module[{hcwc},
hcwc=HCwCParabola[5.\[Degree],85.\[Degree],60.\[Degree],-90.\[Degree]];
HCwCPairGraphics3D[hcwc]/.OrigamiStyle[]
]//ShowExample
HCwCCircle4[ti1_?NumericQ,ti2_?NumericQ,\[Gamma]1i_?NumericQ,\[Gamma]2i_?NumericQ]:=Module[{
iopts,q,t,
ti0,ti3,ti12,
f0,ds0,b\[Kappa]g0,b\[Kappa]n0,s\[Lambda]0,
f1,ds1,\[Gamma]1,rR1,rL1,\[Kappa]g1,t1,l1,vR1,
f2,ds2,\[Gamma]2,rL2,rR2,\[Kappa]g2,t2,l2,vR2,
f3,
eqn1,eqn2,eqn3,
d3dsys,\[Kappa]1,\[Tau]1,c3dsys,
ff0,rrR0,
ff1,tt1,nn1,bb1,\[FinalSigma]1,llL1,uuL1,llR1,uuR1,rrR1,
ff2,tt2,rrL2,uuL2,llL2,llR2,uuR2,rrR2,
ff3,
xL,xR,yL,yR,z,pv},
iopts=Sequence[InterpolationPoints->128];
{ti0,ti3}={0,\[Pi]/2};
(* Zeroth fold, cone point *)
f0=Functionize[t,{0,0}];
(* First fold, circle *)
f1=Functionize[t,{Cos[t],Sin[t]}];
rL1=Functionize[t,-{Cos[t],Sin[t]}];
ds1=Functionize[t,1];
t1=Functionize[t,{-Sin[t],Cos[t]}];
l1=Functionize[t,{-Cos[t],-Sin[t]}];
\[Kappa]g1=Functionize[t,1];
(*
From here, can change in/out different curves
*)
(* Second fold, parabola *)
f2=Functionize[q,{2+4 (-1+Cos[q]),4 Sin[q]}];
rR2=Functionize[q,{1,0}];
ds2=Functionize[q,4];
t2=Functionize[q,{-Sin[q],Cos[q]}];
l2=Functionize[q,{-Cos[q],-Sin[q]}];
\[Kappa]g2=Functionize[q,1/4 ];
(* Third fold, right edge of cylinder *)
f3=Functionize[q,{2,4 Sin[q]}];
(* Connection ruling *)
r=Functionize[{t,q},{(-2+4 Cos[q]-Cos[t])/(\[Sqrt](21-16 Cos[q]-8 Cos[q-t]+4 Cos[t])),(4 Sin[q]-Sin[t])/(\[Sqrt](21-16 Cos[q]-8 Cos[q-t]+4 Cos[t]))}];
(* Consistency equations *)
eqn1=Derivative[1][\[Gamma]1][t]==(2 (Sin[t]-2 Sin[t-q[t]]) Tan[\[Gamma]1[t]/2])/(1+2 Cos[t]-4 Cos[t-q[t]]);
eqn2=Derivative[1][\[Gamma]2][t]==(Sec[q[t]] (-Sin[t-2 q[t]]-4 Sin[q[t]]+2 Sin[2 q[t]]) Tan[\[Gamma]1[t]/2])/(-1-2 Cos[t]+4 Cos[t-q[t]]);
eqn3=Derivative[1][q][t]==Which[t<ti1,0,t>ti2,0,True,((-4+Cos[t-q[t]]+2 Cos[q[t]]) Cot[\[Gamma]2[t]/2] Tan[\[Gamma]1[t]/2])/(-1-2 Cos[t]+4 Cos[t-q[t]])];
(* Solve the differential equation *)
ndsoln=NDSolve[{eqn1,eqn2,eqn3,
q[ti1]==ti0,\[Gamma]1[ti1]==\[Gamma]1i,\[Gamma]2[ti1]==\[Gamma]2i},
{q,\[Gamma]1,\[Gamma]2},
{t,ti0,ti3}]//Flatten;
{q,\[Gamma]1,\[Gamma]2}={q,\[Gamma]1,\[Gamma]2}/.ndsoln;
(* 
Construct the properties that depended on q, \[Gamma]1, or \[Gamma]2, parameterized on t
*)
(* First fold *)
rR1=Functionize[t,r[t,q[t]]];
(* Second fold *)
f2=Functionize[t,f2[q[t]]];
ds2=Functionize[t,ds2[q[t]]];
rL2=Functionize[t,-r[t,q[t]]];
rR2=Functionize[t,rR2[q[t]]];
t2=Functionize[t,t2[q[t]]];
l2=Functionize[t,l2[q[t]]];
(* Third fold *)
f3=Functionize[t,f3[q[t]]];
(* distance from first to second fold *)
vR1=Functionize[t,Mag[f2[t]-f1[t]]];
(* distance second to third fold (add a teensy bit to avoid zero-length lines) *)
vR2=Functionize[t,10^-6+(f3[t]-f2[t]) . rR2[t]];
(*
Construct the 3D surface.
*)
(* center of cone in 3D *)
ff0={0,0,0}&;
(* Construct the Darboux frame of first fold left side, which includes the 3D fold line *)
ds0=ds1;
b\[Kappa]g0=1&;
b\[Kappa]n0=Functionize[t,-Tan[\[Gamma]1[t]/2]];
{ff1,tt1,llL1,uuL1}=NRecoverDarboux3D[{ds0,b\[Kappa]g0,b\[Kappa]n0,0&},{ti0,{1,0,0},{0,0,1},{-1,0,0},{0,-1,0}},{ti0,ti3},iopts];
rrR0=Functionize[t,NormalizeReal[ff1[t]]];
(* Darboux frame of first fold right side *)
llR1=Functionize[t,Cos[\[Gamma]1[t]]llL1[t]-Sin[\[Gamma]1[t]]uuL1[t]];
uuR1=Functionize[t,Sin[\[Gamma]1[t]]llL1[t]+Cos[\[Gamma]1[t]]uuL1[t]];
rrR1=Functionize[t,(rR1[t] . t1[t]) tt1[t]+(rR1[t] . l1[t]) llR1[t]];
(* 2nd fold in 3D *)
ff2=FunctionInterpolationAlt[ff1[t]+vR1[t]rrR1[t],{t,ti0,ti3},iopts];
(* 2nd fold, left and right side Darboux frames *)
tt2=Functionize[t,D[ff2[t],t]/Mag[D[ff2[t],t]]];
rrL2=Functionize[t,-rrR1[t]];
uuL2=Functionize[t,uuR1[t]];
llL2=Functionize[t,uuL2[t]\[Cross]tt2[t]];
llR2=Functionize[t,Cos[\[Gamma]2[t]]llL2[t]-Sin[\[Gamma]2[t]]uuL2[t]];
uuR2=Functionize[t,Sin[\[Gamma]2[t]]llL2[t]+Cos[\[Gamma]2[t]]uuL2[t]];
(* Knowing that 3rd surface is cylindrical, we know rrR2 is a constant, so we only need 1 value *)
rrR2=Functionize[t,(rR2[t] . t2[t]) tt2[t]+(rR2[t] . l2[t]) llR2[t]];
ti12=(ti1+ti2)/2;
rrR2=Functionize[t,rrR2[ti12]];
(* third fold, along the the edge of the cylinder *)
ff3=Functionize[t,ff2[t]+vR2[t]rrR2[t]];
(*
Construct the mirror frames and the pivot vector.
*)
(* compute the normal vector to the left vertical plane *)
yL=NormalizeReal[(ff2[ti3]-ff1[ti3])\[Cross](ff0[ti3]-ff1[ti3])];
(* compute the normal vector to the right vertical plane *)
yR=rrR2[ti3];
(* compute the "z" vector, which defines the direction of the axis of rotational symmetry. *)
z=NormalizeReal[yL\[Cross]yR];
(* compute the 3rd vector in each system, used to construct the plane polygons *)
xL=yL\[Cross]z;
xR=yR\[Cross]z;
(* construct the pivot axis *)
pv=NormalizeReal[(ff2[ti0]+ff0[ti0])/2-ff1[ti0]];
(* Return values: 2D and 3D fold sequences, mirror frames, and pivot vector *)
{f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2}]
Module[{fn,hcwc,val,soln,ti1,ti2,\[Gamma]1i,\[Gamma]2i},
fn[ti1a_?NumericQ,ti2a_?NumericQ,\[Gamma]1i_?NumericQ,\[Gamma]2i_?NumericQ]:=Module[{f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2},
{f0,f1,f2,f3,ff0,ff1,ff2,ff3,xL,xR,yL,yR,z,pv,q,\[Gamma]1,\[Gamma]2}=
hcwc=HCwCCircle4[ti1a,ti2a,\[Gamma]1i,\[Gamma]2i];
{q[\[Pi]/2]-\[Pi]/3,
yL . yR-Cos[\[Pi]/6],
(RotationMatrix3D[\[Pi],pv] . yL) . z,
(RotationMatrix3D[\[Pi],pv] . yL) . xR}];
val=fn[33.\[Degree],87.\[Degree],60.\[Degree],-52.\[Degree]];
soln=FindRoot[fn[ti1,ti2,\[Gamma]1i,\[Gamma]2i],{ti1,33.\[Degree]},{ti2,87.\[Degree]},{\[Gamma]1i,60.\[Degree]},{\[Gamma]2i,-52.\[Degree]}];
{ti1,ti2,\[Gamma]1i,\[Gamma]2i}={ti1,ti2,\[Gamma]1i,\[Gamma]2i}/.soln;
HCwCCircle4Parms={ti1,ti2,\[Gamma]1i,\[Gamma]2i}];
Module[{ti1,ti2,\[Gamma]1i,\[Gamma]2i,hcwc},
{ti1,ti2,\[Gamma]1i,\[Gamma]2i}=HCwCCircle4Parms;
hcwc=HCwCCircle4[ti1,ti2,\[Gamma]1i,\[Gamma]2i];
GraphicsRow[{HCwCPairGraphics[hcwc],HCwCPairGraphics3D[hcwc]}]/.OrigamiStyle[]
]//ShowExample
Curve2DSystems::usage="Curve2DSystems is an option to NLinkedFoldsNext2D that specifies the Curve2DSystem for one, two, or all three of the fold lines.";
Options[NLinkedFoldsNext2D]={
InterpolationOrder->4,
InterpolationPoints->32,
Curve2DSystems->Automatic
};
StrictArguments[NLinkedFoldsNext2D];
NLinkedFoldsNext2D[f0_Function|f0_InterpolatingFunction,q0_Function|q0_InterpolatingFunction,\[Gamma]0_Function|\[Gamma]0_InterpolatingFunction,f1_Function|f1_InterpolatingFunction,q1_Function|q1_InterpolatingFunction,f2_Function|f2_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{io,ip,cs,s,c2dsys0,c2dsys1,c2dsys2,l0,ds0,\[Kappa]g0,t1,l1,ds1,\[Kappa]g1,\[Gamma]1,\[Gamma]1vals,rfn,q2},
io=InterpolationOrder/.{opts}/.Options[NLinkedFoldsNext2D];
ip=InterpolationPoints/.{opts}/.Options[NLinkedFoldsNext2D];
cs=Curve2DSystems/.{opts}/.Options[NLinkedFoldsNext2D];
If[cs===Automatic,cs={}];
c2dsys0=If[Length[cs]>=1,cs[[1]],NCurve2DSystem[f0,{u0,u1},opts]];
c2dsys1=If[Length[cs]>=2,cs[[2]],NCurve2DSystem[f1,{u0,u1},opts]];
c2dsys2=If[Length[cs]>=3,cs[[3]],NCurve2DSystem[f2,{u0,u1},opts]];
{l0,ds0,\[Kappa]g0}={LeftNormalVector2D,Speed2D,LeftCurvature2D}/.c2dsys0;
{t1,l1,ds1,\[Kappa]g1}={TangentVector2D,LeftNormalVector2D,Speed2D,LeftCurvature2D}/.c2dsys1;
\[Gamma]1=ListInterpolation[Table[-2ArcTan[((q0'[s]ds0[q0[s]]\[Kappa]g0[q0[s]])/(q1'[s]ds1[q1[s]]\[Kappa]g1[q1[s]]))((f1[q1[s]]-f0[q0[s]]) . l1[q1[s]]/(f1[q1[s]]-f0[q0[s]]) . l0[q0[s]])Tan[\[Gamma]0[s]/2]],{s,u0,u1,(u1-u0)/ip}],{u0,u1},InterpolationOrder->io];
rfn[s_?NumericQ]:=\[Gamma]1'[q1[s]]-q1'[s]ds1[s]\[Kappa]g1[s]Tan[\[Gamma]1[s]/2]((f0[q0[s]]-f1[q1[s]]) . t1[q1[s]]/(f0[q0[s]]-f1[q1[s]]) . l1[q1[s]]+(f2[q2]-f1[q1[s]]) . t1[q1[s]]/(f2[q2]-f1[q1[s]]) . l1[q1[s]]);
q2=ListInterpolation[Table[q2/.FindRoot[rfn[s],{q2,q1[s]}],{s,u0,u1,(u1-u0)/ip}],{u0,u1},InterpolationOrder->io];
{\[Gamma]1,q2}]
Module[{w,e,u0,u1,s,tf,q,\[Gamma],f,flist},
w=0.1;
e=0.1;
{u0,u1}={0,\[Pi]};
tf[i_]:=Functionize[s,(1+i w){Cos[s],Sin[s]}];
f[i_]:=f[i]=Functionize[s,tf[i][q[i][s]]];
q[0]=Functionize[s,s];
q[1]=Functionize[s,s+e Sin[2s]];
\[Gamma][0]=Functionize[s,120.\[Degree]];
{\[Gamma][1],q[2]}=NLinkedFoldsNext2D[tf[0],q[0],\[Gamma][0],tf[1],q[1],tf[2],{u0,u1}];
flist={f[0],f[1],f[2]};
Graphics[{
StyledRuledPatchSequence[flist,{u0,u1},
RulingLineDivisions->50],
StyledCurve[#,{u0,u1}]&/@flist,
{}}]/.OrigamiStyle[]
]//ShowExample
Module[{w,e,u0,u1,s,tf,q,\[Gamma],f,cs,flist},
w=0.1;
e=0.1;
{u0,u1}={0,\[Pi]};
tf[i_]:=Functionize[s,(1+i w){Cos[s],Sin[s]}];
f[i_]:=f[i]=Functionize[s,tf[i][q[i][s]]];
q[0]=Functionize[s,s];
q[1]=Functionize[s,s+e Sin[2s]];
\[Gamma][0]=Functionize[s,120.\[Degree]];
(* precompute the Curve2DSystems analytically *)
cs[i_]:=cs[i]=Curve2DSystem[tf[i]];
Quiet[
{\[Gamma][1],q[2]}=NLinkedFoldsNext2D[tf[0],q[0],\[Gamma][0],tf[1],q[1],tf[2],{u0,u1},Curve2DSystems->{cs[0],cs[1],cs[2]}];
{\[Gamma][2],q[3]}=NLinkedFoldsNext2D[tf[1],q[1],\[Gamma][1],tf[2],q[2],tf[3],{u0,u1},Curve2DSystems->{cs[1],cs[2],cs[3]}];
{\[Gamma][3],q[4]}=NLinkedFoldsNext2D[tf[2],q[2],\[Gamma][2],tf[3],q[3],tf[4],{u0,u1},Curve2DSystems->{cs[2],cs[3],cs[4]}];
,{InterpolatingFunction::dmval}];
flist={f[0],f[1],f[2],f[3],f[4]};
Graphics[{
StyledRuledPatchSequence[flist,{u0,u1},
RulingLineDivisions->50],
StyledCurve[#,{u0,u1}]&/@flist,
{}}]/.OrigamiStyle[]
]//ShowExample
Options[NLinkedFoldsFirst3D]={
Curve2DSystems->Automatic
};
StrictArguments[NLinkedFoldsFirst3D];
NLinkedFoldsFirst3D[f0_Function|f0_InterpolatingFunction,\[Gamma]0_Function|\[Gamma]0_InterpolatingFunction,f1_Function|f1_InterpolatingFunction,{ui_,ffi_List,tti_List,uui_List},{u0_,u1_},opts___]:=Module[{cs,c2dsys,s,ds0,t0,l0,\[Kappa]g0,ds\[Kappa]g0,ds\[Kappa]n0,ds\[Tau]g0,lli,ff,tt,ll,uu},
cs=Curve2DSystems/.{opts}/.Options[NLinkedFoldsFirst3D];
c2dsys=If[cs===Automatic,NCurve2DSystem[f0,{u0,u1},opts],cs[[1]]];
{ds0,t0,l0,\[Kappa]g0}={Speed2D,TangentVector2D,LeftNormalVector2D,LeftCurvature2D}/.c2dsys;
ds\[Kappa]g0=Functionize[s,ds0[s]\[Kappa]g0[s]];
ds\[Kappa]n0=Functionize[s,ds\[Kappa]g0[s]Tan[\[Gamma]0[s]/2]];
ds\[Tau]g0=Functionize[s,-ds\[Kappa]n0[s]((f1[s]-f0[s]) . t0[s]/(f1[s]-f0[s]) . l0[s])];
lli=uui\[Cross]tti;
NRecoverDarboux3D[{ds0,ds\[Kappa]g0,ds\[Kappa]n0,ds\[Tau]g0},{ui,ffi,tti,lli,uui},{u0,u1},opts]]
Module[{w,e,u0,u1,s,tf,q,\[Gamma],f,ff,tt,ll,uu,flist},
w=0.1;
e=0.1;
{u0,u1}={0,\[Pi]};
tf[i_]:=Functionize[s,(1+i w){Cos[s],Sin[s]}];
f[i_]:=f[i]=Functionize[s,tf[i][q[i][s]]];
q[0]=Functionize[s,s];
q[1]=Functionize[s,s+e Sin[2s]];
\[Gamma][0]=Functionize[s,120.\[Degree]];
{ff[0],tt[0],ll[0],uu[0]}=NLinkedFoldsFirst3D[f[0],\[Gamma][0],f[1],{0,{1,0,0},{0,1,0},{0,0,1}},{u0,u1}];
Graphics3D[{
StyledCurve[ff[0],{u0,u1}],
Table[StyledDarbouxTrihedron[ff[0][u],tt[0][u],ll[0][u],uu[0][u],
DarbouxVectorLength->0.2],{u,u0,u1,(u1-u0)/10}],
{}},Axes->True]/.OrigamiStyle[]/.CurveVectorStyle
]//ShowExample
Options[NLinkedFoldsNext3D]={
Curve2DSystems->Automatic
};
StrictArguments[NLinkedFoldsNext3D];
NLinkedFoldsNext3D[f0_Function|f0_InterpolatingFunction,f1_Function|f1_InterpolatingFunction,\[Gamma]1_Function|\[Gamma]1_InterpolatingFunction,ff0_Function|ff0_InterpolatingFunction,tt0_Function|tt0_InterpolatingFunction,ll0_Function|ll0_InterpolatingFunction,{u0_,u1_},opts___]:=Module[{cs,c2dsys0,c2dsys1,t0,l0,t1,l1,s,df,ff1,cd\[Rho],sd\[Rho],tt1,llL1,uuL1,llR1},
cs=Curve2DSystems/.{opts}/.Options[NLinkedFoldsFirst3D];
If[cs===Automatic,cs={}];
c2dsys0=If[Length[cs]>=1,cs[[1]],NCurve2DSystem[f0,{u0,u1},opts]];
c2dsys1=If[Length[cs]>=2,cs[[2]],NCurve2DSystem[f0,{u0,u1},opts]];
{t0,l0}={TangentVector2D,LeftNormalVector2D}/.c2dsys0;
{t1,l1}={TangentVector2D,LeftNormalVector2D}/.c2dsys1;
df=Functionize[s,f1[s]-f0[s]];
ff1=FunctionInterpolationAlt[ff0[s]+(t0[s] . df[s])tt0[s]+(l0[s] . df[s])ll0[s],{s,u0,u1},opts];
cd\[Rho]=Functionize[s,((t0[s] . df[s])(t1[s] . df[s])+(l0[s] . df[s])(l1[s] . df[s]))/df[s] . df[s]];
sd\[Rho]=Functionize[s,((l0[s] . df[s])(t1[s] . df[s])-(t0[s] . df[s])(l1[s] . df[s]))/df[s] . df[s]];
tt1=FunctionInterpolationAlt[cd\[Rho][s]tt0[s]+sd\[Rho][s]ll0[s],{s,u0,u1},opts];
llL1=Functionize[s,-sd\[Rho][s]tt0[s]+cd\[Rho][s]ll0[s]];
uuL1=Functionize[s,tt1[s]\[Cross]llL1[s]];
llR1=FunctionInterpolationAlt[-Sin[\[Gamma]1[s]]uuL1[s]+Cos[\[Gamma]1[s]]llL1[s],{s,u0,u1},opts];
{ff1,tt1,llR1}]
Module[{w,e,u0,u1,s,tf,q,\[Gamma],f,cs,ff,tt,ll,uu,flist,fflist,gc,gf},
w=0.1;
e=0.1;
{u0,u1}={0,\[Pi]};
tf[i_]:=Functionize[s,(1+i w){Cos[s],Sin[s]}];
f[i_]:=f[i]=Functionize[s,tf[i][q[i][s]]];
q[0]=Functionize[s,s];
q[1]=Functionize[s,s+e Sin[2s]];
\[Gamma][0]=Functionize[s,120.\[Degree]];
(* Precompute *)
cs[i_]:=cs[i]=Curve2DSystem[tf[i]];
(* 2D form *)
Quiet[
{\[Gamma][1],q[2]}=NLinkedFoldsNext2D[tf[0],q[0],\[Gamma][0],tf[1],q[1],tf[2],{u0,u1},Curve2DSystems->{cs[0],cs[1],cs[2]}];
{\[Gamma][2],q[3]}=NLinkedFoldsNext2D[tf[1],q[1],\[Gamma][1],tf[2],q[2],tf[3],{u0,u1},Curve2DSystems->{cs[1],cs[2],cs[3]}];
{\[Gamma][3],q[4]}=NLinkedFoldsNext2D[tf[2],q[2],\[Gamma][2],tf[3],q[3],tf[4],{u0,u1},Curve2DSystems->{cs[2],cs[3],cs[4]}];
,{InterpolatingFunction::dmval}];
(* 3D form *)
{ff[0],tt[0],ll[0],uu[0]}=NLinkedFoldsFirst3D[f[0],\[Gamma][0],f[1],{0,{1,0,0},{0,1,0},{0,0,1}},{u0,u1}];
{ff[1],tt[1],ll[1]}=NLinkedFoldsNext3D[f[0],f[1],\[Gamma][1],ff[0],tt[0],ll[0],{u0,u1},Curve2DSystems->{cs[0],cs[1]}];
{ff[2],tt[2],ll[2]}=NLinkedFoldsNext3D[f[1],f[2],\[Gamma][2],ff[1],tt[1],ll[1],{u0,u1},Curve2DSystems->{cs[1],cs[2]}];
{ff[3],tt[3],ll[3]}=NLinkedFoldsNext3D[f[2],f[3],\[Gamma][3],ff[2],tt[2],ll[2],{u0,u1},Curve2DSystems->{cs[2],cs[3]}];
{ff[4],tt[4],ll[4]}=NLinkedFoldsNext3D[f[3],f[4],0&,ff[3],tt[3],ll[3],{u0,u1},Curve2DSystems->{cs[3],cs[4]}];
(* render *)
flist={f[0],f[1],f[2],f[3],f[4]};
gc=Graphics[{
StyledRuledPatchSequence[flist,{u0,u1},
RulingLineDivisions->50],
StyledCurve[#,{u0,u1}]&/@flist,
{}}]/.OrigamiStyle[];
fflist={ff[0],ff[1],ff[2],ff[3],ff[4]};
gf=Graphics3D[{
StyledRuledPatchSequence[fflist,{u0,u1},
RulingLineDivisions->50],
StyledCurve[#,{u0,u1}]&/@fflist,
{}},
Method->{"ShrinkWrap" -> True},
Lighting->NeutralLighting[.8]]/.OrigamiStyle[];
GraphicsRow[{gc,gf}]
]//ShowExample
DiscretizeSystem[sys_List,tlist_List]:=#[[1]]->#[[2]]/@tlist&/@sys
Module[{tlist,c,cc,sys},
tlist=Table[t,{t,0,1,.25}];
c={#,#^2}&;
cc={#,#^2,0}&;
sys={Curve2D->c,Curve3D->cc};
DiscretizeSystem[sys,tlist]
]//ShowExample
DiscretizeCurveUniformly[fn_Function,nt_,{u0_,u1_}]:=Module[{dt,t,tvars,tvars0,dfn,eqns,soln},
dt=(u1-u0)/nt;
tvars=Table[t[i],{i,0,nt}];
tvars0=Table[u0+i dt,{i,0,nt}];
dfn=FunctionizeOld[D[fn[t],t],t];
eqns=Join[{t[0]==u0},Table[((fn[t[i]]-fn[t[i-1]])/Mag[fn[t[i]]-fn[t[i-1]]]-(fn[t[i+1]]-fn[t[i]])/Mag[fn[t[i+1]]-fn[t[i]]]) . dfn[t[i]]==0,{i,nt-1}],{t[nt]==u1}];
soln=FindRoot@@{eqns,Transpose[{tvars,tvars0}]};
tvars/.soln]
Module[{c,u0,u1,nt,tlist},
c={-#^2,#}&;(* parabola *)
{u0,u1}={0,1};
nt=4;
tlist=DiscretizeCurveUniformly[c,nt,{u0,u1}];
Print["tlist = ",tlist];
Graphics[{
Style[Line[Table[c[t],{t,u0,u1,.01}]],Red],
Style[Line[c/@tlist],Gray],
Style[Point[c[#]]&/@tlist,Black,PointSize[.015]],
{}}]
]//ShowExample
FoldAngleMultipliers2D::notff="Vertex `1` is not flat-foldable; it has Kawasaki sum `2` \[Degree].";
FoldAngleMultipliers2D[f_List,{rl_List,rr_List}]:=Module[{n,a1,a2,a3,a4,ak},
n=Length[f];
a1=a2=a3=a4={};(* sector angles at each vertex *)
Do[
AppendTo[a1,If[i!=1,RotationAngle[rl[[i]],f[[i-1]]-f[[i]]],Null]];
AppendTo[a2,If[i!=1,RotationAngle[f[[i-1]]-f[[i]],rr[[i]]],Null]];
AppendTo[a3,If[i!=n,RotationAngle[rr[[i]],f[[i+1]]-f[[i]]],Null]];
AppendTo[a4,If[i!=n,RotationAngle[f[[i+1]]-f[[i]],rl[[i]]],Null]];
,{i,n}];
Do[
ak=a1[[i]]-a2[[i]]+a3[[i]]-a4[[i]];
If[Chop[ak]!=0,Message[FoldAngleMultipliers2D::notff,i,ak/\[Degree]];Abort[]]
,{i,2,n-1}];
Table[If[i!=1,Sin[(a1[[i]]+a2[[i]])/2]/Sin[(a1[[i]]-a2[[i]])/2],Sin[(a4[[i]]+a3[[i]])/2]/Sin[(a4[[i]]-a3[[i]])/2]],{i,n}]]
Module[{cs2,f,cl,cr,bl,br,gg1,tlist,dcs2,gg2,rl,rr},
(* Set up an elliptical system *)
cs2=ConicSection2DSystem[{-2,-1},{-3/2,1},Simplification->Simplify];
cs2//PrettyParameters//ColumnForm//Hold;
{f,cl,cr,bl,br}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.cs2;
gg1=StyledCurvedFoldOptical[f,{cl,cr},{bl,br},{0\[Degree],90\[Degree]},
FoldLineStyle->{Black,Thickness[.005]},
DirectrixLeftPointStyle->{Darker[Red],PointSize[.015]},DirectrixRightPointStyle->{Darker[Green],PointSize[.015]}];
Graphics[gg1]/.OrigamiStyle[]//Hold;
(* discretize the system *)
tlist=DiscretizeCurveUniformly[f,5,{0,90\[Degree]}];
Print["tlist/\[Degree] = ",tlist/\[Degree]]//Hold;
dcs2=DiscretizeSystem[cs2,tlist];
{f,cl,cr,bl,br}={CurvedFold2D,SecondCrossCurveLeft2D,SecondCrossCurveRight2D,DirectrixLeft2D,DirectrixRight2D}/.dcs2;
(* Draw discrete version *)
gg2={
Style[Line[f],Black],
Style[Line[cl],Lighter[Purple,.75]],
Style[Line[cr],Lighter[Purple,.75]],
Style[Line[#],LightGray]&/@Transpose[{bl,f}],
Style[Line[#],LightGray]&/@Transpose[{br,f}],
Style[Line[#],Red]&/@Transpose[{cl,f}],
Style[Line[#],Green]&/@Transpose[{cr,f}],
Style[Point[#],Black,PointSize[.015]]&/@f,
Style[Point[#],Red,PointSize[.015]]&/@cl,
Style[Point[#],Green,PointSize[.015]]&/@cr,
{}};
GraphicsRow[{Graphics[gg1],Graphics[gg2]}]/.OrigamiStyle[]//Print;
(* construct left and right ruling lines and FAMs *)
rl=cl-f;
rr=cr-f;
FoldAngleMultipliers2D[f,{rl,rr}]
]//ShowExample
FlasherRotation2D[k_,m_]:={{Cos[2\[Pi] k/m],-Sin[2\[Pi] k/m]},{Sin[2\[Pi] k/m],Cos[2\[Pi] k/m]}}
FlasherRotation3D[k_,m_]:={{Cos[2\[Pi] k/m],-Sin[2\[Pi] k/m],0},{Sin[2\[Pi] k/m],Cos[2\[Pi] k/m],0},{0,0,1}}
FlasherWrapRules[v_]:=Subscript[v, -1,j_,k_]:>Subscript[v, j,0,k-1]
FlasherDefaultCPRules[p_,m_]:={Subscript[p, i_,j_,k_]:>FlasherRotation2D[k,m] . N[(1/2){Cot[\[Pi]/m],1}+If[i+1>=j,(i+1) U[\[Pi]/2+(2\[Pi])/m]+Tan[\[Pi]/m]j U[(2\[Pi])/m],j U[\[Pi]/2]-Tan[\[Pi]/m](i+1)U[0]]]}
Module[{},
FlasherDefaultCPRules[p,4]
]//ShowExample
Module[{},
Subscript[p, 0,0,0]/.FlasherDefaultCPRules[p,4]
]//ShowExample
FlasherBorderFold:=Black
FlasherSharpFold[f_]:=If[Mod[f,2]==0,RGBColor[1,0,0],RGBColor[0,0,1]]
FlasherMedFold[f_]:=If[Mod[f,2]==0,RGBColor[1,.7,.7],RGBColor[.6,.6,1]]
FlasherLightFold := GrayLevel[.85]
FlasherVertexLabel[u_,Subscript[v_, i_,j_,k_]]:=Text[Subscript[Style[u,Bold], i,j,k],Subscript[v, i,j,k]/.FlasherWrapRules[v]]
Module[{},
FlasherVertexLabel["p",Subscript[p, 0,0,0]]
]//ShowExample
Module[{},
FlasherVertexLabel["p",Subscript[p, -1,2,4]]
]//ShowExample
FlasherFirstSectorAllVerticesLabels[u_,v_,n_]:=Style[Table[FlasherVertexLabel[u,Subscript[v, i,j,0]],{i,-1,n},{j,0,n}],Black]
Module[{n=3,m=5},Graphics[FlasherFirstSectorAllVerticesLabels["p",p,n]/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorQuads[v_,r_,h_,k_]:=Module[{n,i,j,quad},
n=r*h;(* total number of radial increments *)
Flatten[{
(* major region *)
Table[{j=h*ig;
If[Min[j+h,i]>j,quad[Subscript[v, i,j,k],Subscript[v, i-1,j,k],Subscript[v, i-1,Min[j+h,i],k],Subscript[v, i,Min[j+h,i+1],k]],{}]
},{ig,0,r-1},{i,h*ig,n}],
(* minor region *)
Table[{i=h*ig-1;
If[Min[i+h,j-2]>i,quad[Subscript[v, i,j,k],Subscript[v, i,j-1,k],Subscript[v, Min[i+h,j-2],j-1,k],Subscript[v, Min[i+h,j-1],j,k]],{}]
},{ig,0,r-1},{j,h*ig+1,n}]
}]/.quad->List/.FlasherWrapRules[v]]
Module[{r=3,h=2,m=5,fsq,fspolys},
fsq=FlasherSectorQuads[p,r,h,0];
fspolys=MapIndexed[With[{ctr=Plus@@#1/4},{Style[Polygon[ctr+0.8(#1-ctr)],LightGray],Style[Text["q"<>ToString[#2[[1]]],ctr],Darker[Green]]}]&,fsq];
Graphics[{fspolys,FlasherFirstSectorAllVerticesLabels["p",p,r*h]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorTriangles[v_,r_,h_,k_]:=Module[{n,i,j,quad},
n=r*h;(* total number of radial increments *)
Flatten[{
(* major region *)
Table[{j=h*ig;
If[Min[j+h,i]==j,quad[Subscript[v, i,j,k],Subscript[v, i-1,j,k],Subscript[v, i,Min[j+h,i+1],k]],{}]
},{ig,0,r-1},{i,h*ig,n}],
(* minor region *)
Table[{i=h*ig-1;
If[Min[i+h,j-2]==i,quad[Subscript[v, i,j,k],Subscript[v, i,j-1,k],Subscript[v, Min[i+h,j-1],j,k]],{}]
},{ig,0,r-1},{j,h*ig+1,n}]
}]/.quad->List/.FlasherWrapRules[v]]
Module[{r=3,h=2,m=5,fsq,fspolys},
fsq=FlasherSectorTriangles[p,r,h,0];
fspolys=MapIndexed[With[{ctr=Plus@@#1/3},{Style[Polygon[ctr+0.8(#1-ctr)],LightGray],Style[Text["q"<>ToString[#2[[1]]],ctr],Darker[Green]]}]&,fsq];
Graphics[{fspolys,FlasherFirstSectorAllVerticesLabels["p",p,r*h]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorFoldedFoldLines[v_,r_,h_,k_]:=Module[{n,i,j},
n=r*h;(* total number of radial increments *)
Flatten[{
(* major region *)
Table[{j=h*ig;
Style[Line[{Subscript[v, i,j,k],Subscript[v, i-1,j,k]}],FlasherSharpFold[ig]],(* bottom of quadrant *)
Style[Line[{Subscript[v, i,j,k],Subscript[v, i,Min[j+h,i+1],k]}],If[i==n,FlasherBorderFold,FlasherMedFold[ig]]](* left of quadrant *)
},{ig,0,r-1},{i,h*ig,n}],
Style[Line[{Subscript[v, n,h*r,k],Subscript[v, n-1,h*r,k]}],FlasherBorderFold],(* extra segment at corner *)
(* diagonal *)
Table[{i=h*ig+j;
Style[Line[{Subscript[v, i-1,i,k],Subscript[v, i,i+1,k]}],FlasherSharpFold[ig+1]]
},{ig,0,r-1},{j,0,h-1}],
(* minor region *)
Table[{i=h*ig-1;
If[ig!=0,Style[Line[{Subscript[v, i,j,k],Subscript[v, i,j-1,k]}],FlasherSharpFold[ig]],{}],(* bottom of quadrant *)
Style[Line[{Subscript[v, i,j,k],Subscript[v, Min[i+h,j-1],j,k]}],If[j==n,FlasherBorderFold,FlasherMedFold[ig+1]]](* left of quadrant *)
},{ig,0,r-1},{j,h*ig+1,n}]
}]/.FlasherWrapRules[v]]
Module[{r=3,h=2,n,m=5,k=0},
n=r*h;
Graphics[{
FlasherSectorFoldedFoldLines[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]
}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorDiagFoldLinesX[v_,r_,h_,k_]:=Module[{fsq,nmajor,nminor,qmajor,qminor,qrmajor,qrminor,n},
fsq=FlasherSectorQuads[v,r,h,k];
nmajor=(Length[fsq]+r)/2;(* number in first row of major region *)
nminor=nmajor-r;(* number in first row of minor region *)
qmajor=Take[fsq,nmajor];(* the major quads *)
qminor=Take[fsq,-nminor];(* the minor quads *)
(* now partition into individual rows *)
qrmajor = {};n=r*h;(* number of elements in major row *)
While[n>0,AppendTo[qrmajor,Take[qmajor,n]];qmajor=Drop[qmajor,n];n-=h];
qrminor={};n=r*h-1;(* number of elements in 1st minor row *)
While[n>0,AppendTo[qrminor,Take[qminor,n]];qminor=Drop[qminor,n];n-=h];
Flatten[Join[MapIndexed[Style[Line[If[Mod[#2[[2]]+(h-1)*(#2[[1]]-1)+1,2]==0,#1[[{1,3}]],#1[[{2,4}]]]],FlasherLightFold]&,qrminor,{2}],
MapIndexed[Style[Line[If[Mod[#2[[2]]+(h-1)*(#2[[1]]-1)+1,2]==0,#1[[{1,3}]],#1[[{2,4}]]]],FlasherLightFold]&,qrmajor,{2}]]]/.FlasherWrapRules[v]]
Module[{r=4,h=1,n,m=5,k=0},
n=r*h;
Graphics[{
FlasherSectorFoldedFoldLines[p,r,h,k],
FlasherSectorDiagFoldLinesX[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]
}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorDiagFoldLinesY[v_,r_,h_,k_]:=Module[{fsq},
fsq=FlasherSectorQuads[v,r,h,k];
Style[Line[#[[{1,3}]]],FlasherLightFold]&/@fsq/.FlasherWrapRules[v]]
Module[{r=4,h=1,n,m=5,k=0},
n=r*h;
Graphics[{
FlasherSectorFoldedFoldLines[p,r,h,k],
FlasherSectorDiagFoldLinesY[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]
}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorDiagFoldLinesZ[v_,r_,h_,k_]:=Module[{fsq},
fsq=FlasherSectorQuads[v,r,h,k];
Style[Line[#[[{2,4}]]],FlasherLightFold]&/@fsq/.FlasherWrapRules[v]]
Module[{r=4,h=1,n,m=5,k=0},
n=r*h;
Graphics[{
FlasherSectorFoldedFoldLines[p,r,h,k],
FlasherSectorDiagFoldLinesZ[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]
}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorDiagFoldLines::usage="FlasherSectorDiagFoldLines is an option to FlasherSectorFoldLines that specifies which set of diagonal folds to use in the pattern.";
Options[FlasherSectorFoldLines]={
FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesY
};
FlasherSectorFoldLines[v_,r_,h_,k_,opts___]:=Module[{fsdfl},
fsdfl=FlasherSectorDiagFoldLines/.{opts}/.Options[FlasherSectorFoldLines];
Join[FlasherSectorFoldedFoldLines[v,r,h,k],fsdfl[v,r,h,k]]]
Module[{r=4,h=1,n,m=5,k=0},
n=r*h;
Graphics[{FlasherSectorFoldLines[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
Module[{r=4,h=1,n,m=5,k=0},
n=r*h;
Graphics[{FlasherSectorFoldLines[p,r,h,k,FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesZ],
FlasherFirstSectorAllVerticesLabels["p",p,n]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherFirstSectorVertices[v_,r_,h_]:=Union[Cases[{FlasherSectorFoldLines[v,r,h,0]},Subscript[v, ___],\[Infinity]]]
Module[{r=2,h=2},
FlasherFirstSectorVertices[p,r,h]
]
Module[{r=2,h=2,n,m=5},
n=r h;
GraphicsRow[{Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherFirstSectorAllVerticesLabels["p",p,n]}],Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherVertexLabel["p",#]&/@FlasherFirstSectorVertices[p,r,h]}]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherFirstSectorVerticesDistinct[v_,r_,h_]:=Union[Cases[{FlasherSectorFoldLines[v,r,h,0]},Subscript[v, _,_,0],\[Infinity]]]
Module[{r=2,h=2},
FlasherFirstSectorVerticesDistinct[p,r,h]
]//ShowExample
Module[{r=2,h=2,n,m=5},
n=r h;
GraphicsRow[{Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherFirstSectorAllVerticesLabels["p",p,n]}],Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherVertexLabel["p",#]&/@FlasherFirstSectorVerticesDistinct[p,r,h]}]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherOuterRingSectorVertices[v_,r_,h_,m_,k_] :=Join[Table[Subscript[v, r*h,j*h,k],{j,0,r}],Table[Subscript[v, i*h-1,r*h,k],{i,r}]]
Module[{r=3,h=3},
FlasherOuterRingSectorVertices[p,r,h,5,0]
]//ShowExample
FlasherLabeledSector[u_,v_,r_,h_,m_,opts___]:={FlasherSectorFoldLines[v,r,h,0,opts],FlasherVertexLabel[u,#]&/@FlasherFirstSectorVertices[v,r,h]}
Module[{r=2,h=2,m=5},
Graphics[{FlasherLabeledSector["p",p,r,h,m]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherLines[v_, r_,h_,m_,opts___]:=Table[FlasherSectorFoldLines[v,r,h,k,opts],{k,0,m-1}]
Module[{r=2,h=2,m=5},
Graphics[{FlasherLines[p,r,h,m]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherFFPointRotation[i_,j_]:=If[j<=i+1,i+1,j]
Module[{},Graphics[Table[Text[{i,j}->FlasherFFPointRotation[i,j],{-i,j}],{i,0,4},{j,0,4}]]
]//ShowExample
FlasherFFPointRadialOffset[i_,j_]:=If[j<=i+1,i(i+1)+j,j(j+1)-(i+1)]
Module[{},Graphics[Table[Text[{i,j}->FlasherFFPointRadialOffset[i,j],{-i,j}],{i,0,4},{j,0,4}]]
]//ShowExample
FlasherFFPointDiscreteHeight[i_,j_,h_]:=Abs[Mod[Min[i+1,j]-h,2h,0]-h]
Module[{},
Graphics[Table[Text[{i,j}->FlasherFFPointDiscreteHeight[i,j,2],{-i,j}],{i,0,4},{j,0,4}]]
]//ShowExample
FlasherDefaultFFRules[pp_,h_,m_,dr_:.1]:={Subscript[pp, i_,j_,k_]:>N[FlasherRotation3D[k+FlasherFFPointRotation[i,j],m] . ((1/2)(1+dr FlasherFFPointRadialOffset[i,j]/h){Cot[\[Pi]/m],1,0}+{0,0, FlasherFFPointDiscreteHeight[i,j,h]Tan[\[Pi]/m]})]}
Module[{},
FlasherDefaultFFRules[pp,1,4]
]//ShowExample
Module[{},
Subscript[pp, 0,0,0]/.FlasherDefaultFFRules[pp,1,4]
]//ShowExample
Module[{r=3,h=3,m=4,dr=.01},
Graphics3D[FlasherSectorFoldLines[pp,r,h,0]/.FlasherDefaultFFRules[pp,h,m,dr],Axes->True]
]//ShowExample
FlasherVars[]={p,px,py,pp,ppx,ppy,ppz};
FlasherScalarize[vars_,obj_,m_]:=Module[{p,px,py,pp,ppx,ppy,ppz},
{p,px,py,pp,ppx,ppy,ppz}=vars;
obj/.{FlasherWrapRules[p],FlasherWrapRules[pp]}/.{
Subscript[p, i_,j_,k_]:>FlasherRotation2D[k,m] . {Subscript[px, i,j],Subscript[py, i,j]},
Subscript[pp, i_,j_,k_]:>FlasherRotation3D[k,m] . {Subscript[ppx, i,j],Subscript[ppy, i,j],Subscript[ppz, i,j]}}]
Module[{},
FlasherScalarize[FlasherVars[],{Subscript[p, 1,2,0]},4]
]//ShowExample
Module[{},
FlasherScalarize[FlasherVars[],{Subscript[pp, 1,2,0],Subscript[pp, 1,2,1],Subscript[pp, -1,2,1]},4]
]//ShowExample
FlasherDefaultScalarRules[vars_,r_,h_,m_,dr_]:=Module[{p,px,py,pp,ppx,ppy,ppz,cprules,ffrules,fsv,svars,vals},
{p,px,py,pp,ppx,ppy,ppz}=vars;
cprules=FlasherDefaultCPRules[p,m];
ffrules=FlasherDefaultFFRules[pp,h,m,dr];
fsv=Join[FlasherFirstSectorVerticesDistinct[p,r,h],FlasherFirstSectorVerticesDistinct[pp,r,h]];
svars=Flatten[FlasherScalarize[vars,fsv,m]];
vals=Flatten[fsv/.Join[cprules,ffrules]];
MapThread[#1->#2&,{svars,vals}]]
Module[{vars=FlasherVars[],r=2,h=1,m=4,dr=.01},
FlasherDefaultScalarRules[vars,r,h,m,dr]
]//ShowExample
FlasherVertexRules[vars_,m_,srules_]:=Module[{p,px,py,pp,ppx,ppy,ppz},{
{p,px,py,pp,ppx,ppy,ppz}=vars;
Subscript[p, i_,j_,k_]:>(FlasherRotation2D[k,m] . {Subscript[px, i,j],Subscript[py, i,j]}/.srules),
Subscript[pp, i_,j_,k_]:>(FlasherRotation3D[k,m] . {Subscript[ppx, i,j],Subscript[ppy, i,j],Subscript[ppz, i,j]}/.srules)
}]
FlasherCPFns[vars_, m_]:=Module[{p,px,py,pp,ppx,ppy,ppz},
{p,px,py,pp,ppx,ppy,ppz}=vars;
{FlasherScalarize[vars,Subscript[p, 0,0,0],m] . FlasherRotation2D[1,4] . (Subscript[p, 0,0,0]/.FlasherDefaultCPRules[p,m])}]
Module[{vars=FlasherVars[],r=2,h=1,m=4,dr=.01,cpfns},
cpfns=FlasherCPFns[vars,m];
PrintThis[cpfns];
cpfns/.FlasherDefaultScalarRules[vars,r,h,m,dr]
]//ShowExample
FlasherIsometryFns[vars_,r_,h_,m_,opts___]:=Module[{p,px,py,pp,ppx,ppy,ppz,v,fs,lp,dfn,dp,dpp},
{p,px,py,pp,ppx,ppy,ppz}=vars;
(* first sector of flasher, symbolic variable v *)
fs=FlasherSectorFoldLines[v,r,h,0,opts];
(* all line segment vertex pairs in the first sector *)
lp=First/@Flatten[Cases[fs,Line[_],\[Infinity]]];
(* distance fn that takes a list of point pairs *)
dfn=Mag[Subtract@@#]&;
(* Scalarize cp pairs and compute length *)
dp=dfn/@N[FlasherScalarize[vars,lp/.v->p,m]];
(* Scalarize ff pairs and compute length^2 *)
dpp=dfn/@N[FlasherScalarize[vars,lp/.v->pp,m]];
(* return difference between lengths *)
dpp-dp]
Module[{r=2,h=1,m=4,dr=.01,vars,ifns,srules},
vars=FlasherVars[];
ifns=FlasherIsometryFns[vars,r,h,m];
srules=FlasherDefaultScalarRules[vars,r,h,m,dr];
ifns/.srules
]//ShowExample
FlasherXYFns[vars_,r_,h_,m_,dr_]:=Module[{p,px,py,pp,ppx,ppy,ppz,ffrules,fsv,fsvn},
{p,px,py,pp,ppx,ppy,ppz}=vars;
ffrules=FlasherDefaultFFRules[pp,h,m,dr];
fsv=FlasherFirstSectorVerticesDistinct[pp,r,h];(* vertices *)
fsvn=fsv/.ffrules;(* desired values *)
Flatten[Take[#,2]&/@(N[FlasherScalarize[vars,fsv,m]]-fsvn)]]
Module[{r=2,h=1,m=4,dr=.01,vars,xyfns,ffrules},
vars=FlasherVars[];
xyfns=FlasherXYFns[vars,r,h,m,dr];
ffrules=FlasherDefaultFFRules[pp,h,m,dr];
xyfns/.FlasherDefaultScalarRules[vars,r,h,m,dr]
]//ShowExample
FlasherOuterRingFns[vars_,r_,h_,m_,dr_,dz_:0] :=Module[{p,px,py,pp,ppx,ppy,ppz,verts,ffrules},
{p,px,py,pp,ppx,ppy,ppz}=vars;
verts=FlasherOuterRingSectorVertices[pp,r,h,m,0];
ffrules=FlasherDefaultFFRules[pp,h,m,dr];
Last/@(FlasherScalarize[vars,verts,m]-(1+dz)(verts/.ffrules))]
Module[{r=2,h=1,m=4,dr=.01,dz=.02,vars,ffrules,orfns},
vars=FlasherVars[];
orfns=FlasherOuterRingFns[vars,r,h,m,dr,dz];
PrintThis[orfns];
orfns/.FlasherDefaultScalarRules[vars,r,h,m,dr]
]//ShowExample
Module[{r=2,h=1,m=4,dr=.1},
GraphicsRow[{
Graphics[FlasherLabeledSector["p",p,r,h,m]],
Graphics[FlasherLines[p,r,h,m]],
Graphics3D[FlasherLabeledSector["pp",pp,r,h,m]],
Graphics3D[FlasherLines[pp,r,h,m]]
}/.Join[FlasherDefaultCPRules[p,m],FlasherDefaultFFRules[pp,h,m,0.1]]]
]//ShowExample
Module[{r=2,h=1,m=4},
Length[FlasherFirstSectorVerticesDistinct[p,r,h]]
]//ShowExample
Module[{r=3,h=3,m=4,dr=.05,vars,nverts,nisos,nxys,ndwns,norrngs},
vars=FlasherVars[];
Print[GraphicsRow[{
Graphics[FlasherLabeledSector["p",p,r,h,m]],
Graphics[FlasherLines[p,r,h,m]],
Graphics3D[FlasherLabeledSector["pp",pp,r,h,m]],
Graphics3D[FlasherLines[pp,r,h,m]]
}/.Join[FlasherDefaultCPRules[p,m],FlasherDefaultFFRules[pp,h,m,0.1]]]];
nverts=Length[FlasherFirstSectorVerticesDistinct[p,r,h]];
Print["number of vertices = ",nverts];
Print["number of variables = ",5*nverts];
Print["number of CP position constraints = ",1];
nisos=Length[FlasherIsometryFns[vars,r,h,m]];
Print["number of all isometries = ",nisos];
nxys=Length[FlasherXYFns[vars,r,h,m,dr]];
Print["number of xyfns = ",nxys];
norrngs=Length[FlasherOuterRingFns[vars,r,h,m,dr,0]];
Print["number of norrngs = ",norrngs];
Print["Remaining DOF = ",5 * nverts-(1+nisos+nxys+norrngs)];
]//ShowExample
FlasherLabeledCPSectorGraphics::usage="FlasherLabeledCPSectorGraphics is a property of a flasher TObj that gives a labeled representation of the first sector of the crease pattern.";
FlasherLabeledFFSectorGraphics3D::usage="FlasherLabeledFFSectorGraphics3D is a property of a flasher TObj that gives a labeled representation of the first sector of the folded form.";
FlasherCPGraphics::usage="FlasherCPGraphics is a property of a flasher TObj that gives a styled representation of the crease pattern.";
FlasherFFGraphics3D::usage="FlasherFFGraphics3D is a property of a flasher TObj that gives a styled representation of the folded form.";
FlasherDetails::usage="FlasherDetails is a property of a flasher TObj that gives a list of additional data about the flasher.";
MakeFlasher::badiso="Warning: isometry equations could not be satisfied. Residual error is `1.`";
MakeFlasher[r_,h_,m_,dr_,opts___]:=Module[{vars,p,px,py,pp,ppx,ppy,ppz,dz,eqnfns,srules,allvars,newvars,fwd,bkd,args,soln,vertrules,isovals,cpsg,cplg,ffsg,fflg,picdia,pccdia,cpccdia,orverts,ffverts,oph,opw,cpicdia,ffdia,ffh,cpedges,ffedges,btedges,verts,edges,verts3d,tobj,msgs},

(* PART I: solve for the flasher *)

vars={p,px,py,pp,ppx,ppy,ppz};
eqnfns=Join[
FlasherCPFns[vars,m],
FlasherIsometryFns[vars,r,h,m,opts],
FlasherXYFns[vars,r,h,m,dr],
FlasherOuterRingFns[vars,r,h,m,dr,dz],(* dz is now a variable *)
{Subscript[ppz, 0,0]}(* forces central polygon to z=0 *)
];
srules=Append[FlasherDefaultScalarRules[vars,r,h,m,dr],dz->0];allvars=First/@srules;
newvars=Table[Unique[],{Length[allvars]}];fwd=MapThread[#1->#2&,{allvars,newvars}];bkd=MapThread[#2->#1&,{allvars,newvars}];args={eqnfns/.fwd,Transpose[{newvars,allvars/.srules}]};
soln=Check[(FindRoot@@args),Abort[],{}];
soln = soln /. bkd;
vertrules=FlasherVertexRules[vars,m,soln];
isovals=Abs/@FlasherIsometryFns[vars,r,h,m,opts]/.soln;
If[Plus@@isovals>10^-6,Message[MakeFlasher::badiso,isovals]];

(* PART II: compute graphical bits and diagnostic info *)

(* graphical images, sector & pattern, cp & ff *)
cpsg=Graphics[FlasherLabeledSector["p",p,r,h,m,opts]]/.vertrules;
cplg=Graphics[FlasherLines[p,r,h,m,opts]]/.vertrules;
ffsg=Graphics[FlasherLabeledSector["pp",pp,r,h,m,opts]]/.vertrules;
fflg=Graphics[FlasherLines[pp,r,h,m,opts]]/.vertrules;
(* central polygon incircle diameter *)
picdia=1;
(* central polygon circumcircle diameter *)
pccdia=2*Mag[Subscript[p, 0,0,0]/.vertrules];
(* cp outermost vertices *)
orverts=FlasherOuterRingSectorVertices[p,r,h,m,0]/.vertrules;
(* crease pattern incircle diameter *)
cpicdia=2*Min[Mag/@orverts];
(* crease pattern circumcircle diameter *)
cpccdia=2*Max[Mag/@(orverts/.vertrules)];
(* outermost panel height *)
oph=Mag[(Subscript[p, r*h,r*h,0]-Subscript[p, r*h,(r-1)*h,0])/.vertrules];
(* outermost panel width *)
opw=Mag[(Subscript[p, r*h,r*h,0]-Subscript[p, r*h-1,r*h,0])/.vertrules];
(* outermost vertices in ff *)
ffverts=FlasherFirstSectorVerticesDistinct[pp,r,h]/.vertrules;
(* folded form circumcircle diameter *)
ffdia=2*Max[Mag[Take[#,2]]&/@ffverts];
(* folded form height *)
ffh=Max[Last/@ffverts]-Min[Last/@ffverts];

(* PART III: construct a TGraph3DAssigned *)

(* lists of point pairs for both cp and ff *)
cpedges=First/@Cases[FlasherLines[p,r,h,m,opts],_Line,{0,\[Infinity]}]/.vertrules;
ffedges=First/@Cases[FlasherLines[pp,r,h,m,opts],_Line,{0,\[Infinity]}]/.vertrules;
(* ordered 5-tuples, for indexification *)
btedges=MapThread[Join,{cpedges,ffedges},2];
{verts,edges}=Indexify[btedges,2];
verts3d=Take[#,-3]&/@verts;
verts=Take[#,2]&/@verts;
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d]//RecalcFoldAngles//ReassignGraph3D[#,opts]&;
(* add the additional properties *)
tobj//AddProperties[{
FlasherLabeledCPSectorGraphics->cpsg,
FlasherLabeledFFSectorGraphics3D->ffsg,
FlasherCPGraphics->cplg,
FlasherFFGraphics3D->fflg,
 FlasherDetails->{
"central polygon incircle diameter"->picdia,
"central polygon circumcircle diameter"->pccdia,
"crease pattern incircle diameter"->cpicdia;
"crease pattern circumcircle diameter"->cpccdia,
"crease pattern incircle diameter"->cpicdia,
"folded form circumcircle diameter"->ffdia,
"outermost panel height"->oph,
"outermost panel width"->opw
}}]]
Module[{r=1,h=1,m=4,dr=.0,tobj},
tobj=MakeFlasher[r,h,m,dr,TypeMinimumAngle->10.\[Degree]];
Print[tobj[FlasherDetails]//ColumnForm];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]
Module[{r=2,h=2,m=5,dr=.1,tobj},
tobj=MakeFlasher[r,h,m,dr,FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesZ, TypeMinimumAngle->10.\[Degree]];
Print[tobj[FlasherDetails]//ColumnForm];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Clear[HexFlasherGraph3DAssigned];
AddTGraphExample[HexFlasherGraph3DAssigned,
Module[{r=2,h=2,m=6,dr=.05},
MakeFlasher[r,h,m,dr,FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesZ, TypeMinimumAngle->10.\[Degree]]]];
Module[{tobj},
tobj=HexFlasherGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
ImageWidth::usage="ImageWidth is an option to ExportPerforatedScoring that specifies the desired width of the score pattern.";
ImageHeight::usage="ImageHeight is an option to ExportPerforatedScoring that specifies the desired height of the score pattern.";
Options[ExportPerforatedScoring]={
ImageWidth->None,
ImageHeight->None,
GapLength->1.5,
DashPattern->{{1.7,False},{0.3,True}},
ScoreLineThickness->0.216,
ShowProgress->False
};
ExportPerforatedScoring::badsize="You must specify either ImageWidth or ImageHeight.";
ExportPerforatedScoring[file_String, tobj_TObj,opts___]:=Module[{iw,ih,gl,dp,sp,slt,cp,scale,w,h,g},
AssertClasses[tobj,{TGraph,TAssigned},ExportPerforatedScoring];
iw=ImageWidth/.{opts}/.Options[ExportPerforatedScoring];
ih=ImageHeight/.{opts}/.Options[ExportPerforatedScoring];
gl=GapLength/.{opts}/.Options[ExportPerforatedScoring];
dp=DashPattern/.{opts}/.Options[ExportPerforatedScoring];
sp=ShowProgress/.{opts}/.Options[ExportPerforatedScoring];
slt=ScoreLineThickness/.{opts}/.Options[ExportPerforatedScoring];
cp=CreasePatternGraphics[tobj];
{w,h}=GraphicsExtent[cp];
If[!(iw===None),scale=iw/w;ih=scale h,
If[!(ih===None),scale=ih/h;iw=scale w,
Message[ExportPerforatedScoring::badsize];Abort[]]];
cp=ScaleLines[cp,scale];
If[sp,
Print["width = ",iw," pt, ", iw/28.35," cm, ",iw/72.," in"];
Print["height = ",ih," pt, ",ih/28.35," cm, ",ih/72.," in"];
];
g=Graphics[ExtractFracturedStyledLines[cp]];
g=GapifyByStyle[g,{ValleyLine,MountainLine},GapLength->gl];
g=DashifyByStyle[g,{ValleyLine,MountainLine},DashPattern->dp];
If[sp,
Print[Show[g/.ScoringStyle[ScoreLineThickness->1],Frame->True]];
];
Export[file,Show[g/.ScoringStyle[ScoreLineThickness->slt],PlotRangePadding->0],ImageSize->{iw, ih}]]
Module[{verts,edges,faces,types,tobj},
verts={{0,0},{1,0},{2,0},{3,0},{0,1},{1,1},{2,1},{3,1}};
edges={{1,2},{2,3},{3,4},{5,6},{6,7},{7,8},{1,5},{2,6},{3,7},{4,8}};
faces={{1,2,6,5},{2,3,7,6},{3,4,8,7}};
types={B,B,B,B,B,B,B,M,V,B};
tobj=MakeTGraphAssigned[verts,edges,faces,types];
Print[CreasePatternGraphics[tobj]/.OrigamiStyle[]];
ExportPerforatedScoring[ExamplesDir[]<>"ExportPerforatedScoring.eps",tobj,ImageHeight->72 (* 1 in *),ShowProgress->True]
]//ShowExample
VeneerMultiline[{va_,vb_},thickness_,spacing_]:=Module[{n,sp,xv},
n=Ceiling[thickness/spacing]; (* number of divisions *)
If[n==0,
{Line[{va,vb}]},
sp = thickness/n;(* actual spacing to use *)
xv=NormalizeReal[{{0,-1},{1,0}} . (vb-va)];(* transverse unit vector *)
Table[Line[{If[EvenQ[i],va,vb]+(i-n/2)sp xv,If[EvenQ[i],vb,va]+(i-n/2)sp xv}],{i,0,n}]]]
Module[{},
Graphics[VeneerMultiline[{{0,0},{1,1}},0.4,0.07],Frame->True]
]//ShowExample
VeneerMultiline[{va_,vb_},thickness_,spacing_,{{aar_,aal_},{abr_,abl_}}]:=Module[{n,sp,yv,xv,dx,pa,pb},
n=Ceiling[thickness/spacing]; (* number of divisions between lines *)
If[n==0,
{Line[{va,vb}]},
sp = thickness/n;(* actual spacing to use *)
yv=NormalizeReal[vb-va];(* unit vector along the line *)
xv={{0,-1},{1,0}} . yv;(* transverse unit vector *)
Table[
dx=(i-n/2)sp;
pa=va+dx xv+If[i<n/2,-Cot[aal],Cot[aar]]dx yv;
pb=vb+dx xv+If[i<n/2,Cot[abr],-Cot[abl]]dx yv;
Line[{If[EvenQ[i],pa,pb],If[EvenQ[i],pb,pa]}],{i,0,n}]]]
Module[{va,vb},
va={0,0};
vb={1,0};
Graphics[{
Style[Line[{va,vb}],LightGray,AbsoluteThickness[5]],
Style[VeneerMultiline[{va,vb},0.2,0.02,{{22.5\[Degree],67.5\[Degree]},{30\[Degree],60\[Degree]}}],Gray],Style[{Point[va],Text["va",va,{-2,0}]},Red,AbsolutePointSize[5],FontSize->14],
Style[{Point[vb],Text["vb",vb,{2,0}]},Blue,AbsolutePointSize[5],FontSize->14],
Style[{Text["\!\(\*SubscriptBox[\(\[Alpha]\), \(a, r\)]\)",{0.2,0.04}],Text["\!\(\*SubscriptBox[\(\[Alpha]\), \(a, l\)]\)",{0.1,-0.05}],Text["\!\(\*SubscriptBox[\(\[Alpha]\), \(b, r\)]\)",{0.85,-0.04}],Text["\!\(\*SubscriptBox[\(\[Alpha]\), \(b, l\)]\)",{0.9,0.05}]},Black,FontSize->16]
},Frame->True]
]//ShowExample
Module[{},
Graphics[{
VeneerMultiline[{{1,0},{0,0}},0.4,0.05,{{60\[Degree],30\[Degree]},{45\[Degree],45\[Degree]}}],
VeneerMultiline[{{0,1},{0,0}},0.4,0.05,{{60\[Degree],30\[Degree]},{45\[Degree],45\[Degree]}}],
VeneerMultiline[{{-1,0},{0,0}},0.4,0.05,{{60\[Degree],30\[Degree]},{45\[Degree],45\[Degree]}}],
VeneerMultiline[{{0,-1},{0,0}},0.4,0.05,{{60\[Degree],30\[Degree]},{45\[Degree],45\[Degree]}}]
},Frame->True]
]//ShowExample
VeneerThickness::usage="VeneerThickness is an option to VeneerScoringGraphics that specifies the thickness of the material, which, in turn, is used to determine the widths of the kerfs for the valley folds.";
InvertFolds::usage="InvertFolds is an option to VeneerScoringGraphics that specifies to swap mountain and valley assignments in the scoring pattern.";
MultilineSpacing::usage="MultilineSpacing is an option to VeneerScoringGraphics that specifies the spacing between hairlines to use when we create a kerf from a group of lines.";
Options[VeneerScoringGraphics]={
ImageWidth->None,
ImageHeight->None,
VeneerThickness->2.3 ,(* = 32 mil *)
MultilineSpacing->0.5,(* maximum spacing for kerf lines *)
InvertFolds->False,
FoldAngles->Automatic
};
VeneerScoringGraphics::badangles="Length of FoldAngles `1` does not match the number of edges in `2`";
VeneerScoringGraphics::badsize="You must specify either ImageWidth or ImageHeight.";
VeneerScoringGraphics[tobj_TObj,opts___]:=Module[{iw, ih,vt,ls,if,fa,w,h,scale,verts,edges,types,eva,eea,cutangle,th,cbd,va,vb,da,db,angs,vn},
AssertClasses[tobj,{TPlaneGraph,TAssigned},VeneerScoringGraphics];
iw=ImageWidth/.{opts}/.Options[VeneerScoringGraphics];
ih=ImageHeight/.{opts}/.Options[VeneerScoringGraphics];
vt=VeneerThickness/.{opts}/.Options[VeneerScoringGraphics];
ls=MultilineSpacing/.{opts}/.Options[VeneerScoringGraphics];
if=InvertFolds/.{opts}/.Options[VeneerScoringGraphics];
fa=FoldAngles/.{opts}/.Options[VeneerScoringGraphics];
{verts,edges,types,eea} = GetValues[tobj,{Vertices,Edges,EdgeTypes,EdgeEdgeAdjacency}];
If[fa === Automatic,
If[HasPropertyQ[tobj,FoldAngles],
fa=tobj[FoldAngles],
fa=Table[\[Pi],{Length[edges]}]],
If[!(Head[fa]===List),fa=Table[fa,{Length[edges]}]]];If[Length[fa]!=Length[edges],Message[VeneerScoringGraphics::badangles,fa,tobj];Abort[]];
If[if,
types=InvertFoldType[types];
fa=-fa;
];
{w,h}=GraphicsExtent[Point/@verts];
If[!(iw===None),scale=iw/w;ih=scale h,
If[!(ih===None),scale=ih/h;iw=scale w,
Message[VeneerScoringGraphics::badsize];Abort[]]];
verts=scale verts;(* scale to desired image width *)
eva=EdgeVertexAngles[tobj];
(* cutangle[t, s, \[Alpha]] gives the cutback angle for edge thickness t, adjacent edge thickness s, and angle between them \[Alpha]. *)
cutangle[t_,s_,a_]:=Which[
a===Null,0,(* angles outside boundary *)
Abs[a]==\[Pi],\[Pi]/2,(* arises with degree-2 vertices between collinear edges *)
t==0,0,(* zero thickness, e.g., mountain or border line *)
s==0,a,(* adjacent to mountain or border, use the full angle *)
True,ArcCos[(s+t Cos[a])/(\[Sqrt](s^2+t^2+2 s t Cos[a]))](* two valley folds, divvy the angle *)];
(* th[i] gives the desired width of the ith edge for a multiline or 0 for border or ordinary mountain fold *)
th[i_]:= With[{\[Gamma]=N[fa[[i]]]},Which[
\[Gamma]<-\[Pi],2vt(Abs[\[Gamma]]/\[Pi]-1),
\[Gamma]<=0,0,
\[Gamma]<\[Pi],2vt Sin[\[Gamma]/2],
True,2vt(\[Gamma]/\[Pi])]];
(* cbd[j,a] gives the desired cutback distance for adjacent edge j at angle a.*)
cbd[j_,a_]:=If[types[[j]]===V,(th[j]/2)Csc[a],0];
Graphics[Table[
{va,vb}=verts[[edges[[i]]]];(* embedding of current edge *)
vn=NormalizeReal[vb-va];
da=Which[(* cut-back distance for current edge, first vertex *)
types[[i]]===V,0,(* don't cut back valley folds, they get multilines *)
Length[eea[[i,1]]]==1,0,(* don't cut back folds at degree-2 vertices *)
True,Max[cbd[eea[[i,1,1]],eva[[i,1,1]]],cbd[eea[[i,1,-1]],eva[[i,1,-1]]]]]//N;
db=Which[(* cut-back distance for current edge, 2nd vertex *)
types[[i]]===V,0,(* don't cut back valley folds, they get multilines *)
Length[eea[[i,2]]]==1,0,(* don't cut back folds at degree-2 vertices *)
True,Max[cbd[eea[[i,2,1]],eva[[i,2,1]]],cbd[eea[[i,2,-1]],eva[[i,2,-1]]]]]//N;
angs={{cutangle[th[i],th[eea[[i,1,1]]],eva[[i,1,1]]],cutangle[th[i],th[eea[[i,1,-1]]],eva[[i,1,-1]]]},{cutangle[th[i],th[eea[[i,2,1]]],eva[[i,2,1]]],cutangle[th[i],th[eea[[i,2,-1]]],eva[[i,2,-1]]]}}//N;
Print[{types[[i]],edges[[i]],eva[[i]],eea[[i]],angs/\[Degree],{da,db}}]//Hold;(* debugging *)
Switch[types[[i]],
M,Style[Line[{va+da vn,vb-db vn}],MountainLine],
V,Style[VeneerMultiline[{va,vb},th[i],ls,angs],ValleyLine],
U,{},
_,Style[Line[{va+da vn,vb-db vn}],BorderLine] (* border *)
],{i,Length[edges]}],PlotRangePadding->0,Sequence@@FilterRules[{opts},Options[Graphics]]]]
Module[{verts,edges,types,foldangles,tobj,tobj3d},
verts={{-1,-1},{1,-1},{-1,0},{0,0},{1,0},{-1,1},{1,1}};
edges={{1,2},{1,3},{2,4},{2,5},{3,4},{4,5},{3,6},{4,7},{5,7},{6,7}};
types={B,B,V,B,V,M,B,V,B,B};
foldangles={0,0,90\[Degree],0,45\[Degree],-45\[Degree],0,90\[Degree],0,0};
tobj=MakeTGraphAssigned[verts,edges,{},types]//AddTPlaneGraph;
tobj3d=FoldGraph3D[tobj,foldangles];
Print[GraphicsRow[{GraphGraphics[tobj3d],CreasePatternGraphics[tobj3d],FoldedFormGraphics3D[tobj3d]}]/.OrigamiStyle[]];
VeneerScoringGraphics[tobj3d,
ImageWidth->360,
FoldAngles->Automatic,
VeneerThickness->20,
MultilineSpacing->4]/.ScoringStyle[ScoreLineThickness->0.216]
]//ShowExample
Module[{verts,edges,types,foldangles,tobj,tobj3d},
verts={{-1,-1},{1,-1},{-1,0},{0,0},{1,0},{-1,1},{1,1}};
edges={{1,2},{1,3},{2,4},{2,5},{3,4},{4,5},{3,6},{4,7},{5,7},{6,7}};
types={B,B,V,B,V,M,B,V,B,B};
foldangles={0,0,180\[Degree],0,360\[Degree],-180\[Degree],0,180\[Degree],0,0};
tobj=MakeTGraphAssigned[verts,edges,{},types]//AddTPlaneGraph;
tobj3d=tobj//AddProperty[FoldAngles->foldangles];
(*tobj3d=FoldGraph3D[tobj,foldangles];*)
Print[GraphicsRow[{GraphGraphics[tobj3d],CreasePatternGraphics[tobj3d]}]/.OrigamiStyle[]];
VeneerScoringGraphics[tobj3d,
ImageWidth->360,
FoldAngles->Automatic,
VeneerThickness->20,
MultilineSpacing->4]/.ScoringStyle[ScoreLineThickness->0.216]
]//ShowExample
Module[{verts,edges,types,foldangles,tobj,tobj3d},
verts={{0,0},{2,0},{4,0},{6,0},{0,2},{2,2},{4,2},{6,2}};
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8}};
types={B,B,B,B,V,M,B,B,B,B};
foldangles={0,0,0,0,45\[Degree],-90\[Degree],0,0,0,0};
tobj=MakeTGraphAssigned[verts,edges,{},types]//AddTPlaneGraph;
tobj3d=FoldGraph3D[tobj,foldangles];
Print[GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj3d]}]/.OrigamiStyle[]];
Print[VeneerScoringGraphics[tobj,ImageWidth->360,FoldAngles->30\[Degree],PlotLabel->"Single fixed angle"]/.ScoringStyle[ScoreLineThickness->0.216]];
Print[VeneerScoringGraphics[tobj,ImageWidth->360,FoldAngles->foldangles,PlotLabel->"Specified fold angles"]/.ScoringStyle[ScoreLineThickness->0.216]];
Print[VeneerScoringGraphics[tobj,ImageWidth->360,PlotLabel->"Automatic, no FoldAngles"]/.ScoringStyle[ScoreLineThickness->0.216]];
Print[VeneerScoringGraphics[tobj3d,ImageWidth->360,PlotLabel->"Automatic, has FoldAngles"]/.ScoringStyle[ScoreLineThickness->0.216]];
Print[VeneerScoringGraphics[tobj3d,ImageWidth->360,InvertFolds->True,PlotLabel->"Automatic, inverted folds"]/.ScoringStyle[ScoreLineThickness->0.216]]
]//ShowExample
Options[ExportVeneerScoring]={
ShowProgress->False,
ScoreLineThickness->0.216
};
ExportVeneerScoring[file_String,tobj_TObj,opts___]:=Module[{sp,slt,g,w,h},
sp=ShowProgress/.{opts}/.Options[ExportVeneerScoring];
slt=ScoreLineThickness/.{opts}/.Options[ExportVeneerScoring];
g=VeneerScoringGraphics[tobj,opts]/.ScoringStyle[ScoreLineThickness->slt];
{w,h}=GraphicsExtent[g];
If[sp,
Print["width = ",w," pt, ", w/28.35," cm, ",w/72.," in"];
Print["height = ",h," pt, ",h/28.35," cm, ",h/72.," in"];
Print[g];
];
Export[file,g,ImageSize->{w,h}]]
Module[{verts,edges,types,foldangles,tobj,tobj3d},
verts={{0,0},{2,0},{4,0},{6,0},{0,2},{2,2},{4,2},{6,2}};
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8}};
types={B,B,B,B,V,M,B,B,B,B};
foldangles={0,0,0,0,45\[Degree],-90\[Degree],0,0,0,0};
tobj=MakeTGraphAssigned[verts,edges,{},types]//AddTPlaneGraph;
tobj3d=FoldGraph3D[tobj,foldangles];
ExportVeneerScoring[ExamplesDir[]<>"ExportVeneerScoring.eps",tobj3d,ImageWidth->425 ,InvertFolds->True,ShowProgress->True]
]//ShowExample
Module[{pts,tobj,width},
pts={{0,0},{1.5,0},{1.7,.7},{1.7,1.5},{1,2.2},{0.5,2.21}};
tobj=MakeRadialPot[pts,8,1]//RebuildPlaneGraph;
Print[GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]];
width=425;
ExportVeneerScoring[ExamplesDir[]<>"ExportVeneerScoring-pot.eps",tobj,ImageWidth->width ,InvertFolds->True,ShowProgress->True]
]//ShowExample
Options[VeneerScoringCarveGraphics]={
ImageSize->360,(* = 5 in, 12.7 cm *)
ScoreLineThickness->0.216, (* hairline width in Corel Draw *)
VeneerThickness->2.3 ,(* = 32 mil *)
InvertFolds->False
};
VeneerScoringCarveGraphics[tobj_TObj,opts___]:=Module[{is,ht,vt,if,verts,edges,types,foldangles,ll},
AssertClasses[tobj,{TGraph,TAssigned},VeneerScoringCarveGraphics];
is=ImageSize/.{opts}/.Options[VeneerScoringCarveGraphics];
ht=ScoreLineThickness/.{opts}/.Options[VeneerScoringCarveGraphics];
vt=VeneerThickness/.{opts}/.Options[VeneerScoringCarveGraphics];
if=InvertFolds/.{opts}/.Options[VeneerScoringCarveGraphics];
{verts,edges,types,foldangles} = GetValues[tobj,{Vertices,Edges,EdgeTypes,FoldAngles}];
verts=(is/(Max[#]-Min[#])&@(First/@verts))verts;(* scale to desired image width *)
Graphics[Table[
ll=Line[verts[[edges[[i]]]]];
Switch[types[[i]],
If[if,V,M],Style[ll,Blue,AbsoluteThickness[ht]],
If[if,M,V],Style[ll,Red,AbsoluteThickness[Max[ht,2 vt Sin[Abs[foldangles[[i]]]/2]]],CapForm["Butt"]],
U,{},
_,Style[ll,Black,AbsoluteThickness[ht]] (* border *)
],{i,Length[edges]}]]]
Module[{verts,edges,faces,types,foldangles,tobj},
verts={{0,0},{2,0},{4,0},{6,0},{0,2},{2,2},{4,2},{6,2}};
edges={{1,2},{2,3},{3,4},{1,5},{2,6},{3,7},{4,8},{5,6},{6,7},{7,8}};
faces={{1,2,6,5},{2,3,7,6},{3,4,8,7}};
types={B,B,B,B,V,M,B,B,B,B};
foldangles={0,0,0,0,90.\[Degree],-90\[Degree],0,0,0,0};
tobj=MakeTGraphAssigned[verts,edges,faces,types];
tobj=FoldGraph3D[tobj,foldangles];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}]/.OrigamiStyle[]//Print;
VeneerScoringCarveGraphics[tobj]
]//ShowExample
Module[{pts,tobj,size,vsp},
pts={{0,0},{1,0},{1.7,.7},{1.7,1.5},{1,2.2},{.5,2.21}};
tobj=MakeRadialPot[pts,8,0];
size=425;(* 15 cm *)
vsp=VeneerScoringCarveGraphics[tobj,ImageSize->size,InvertFolds->True];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj],vsp}]/.OrigamiStyle[]//Print;
Export[ExamplesDir[]<>"VeneerScoringCarveGraphics.eps",Show[vsp,PlotRangePadding->0],ImageSize->size]
]//ShowExample
Options[MakePolygonalTubeGC]={
RoundingDivisions->5
};
MakePolygonalTubeGC[pts_, r_, opts___]:=Module[{nd,np,closed,verts,faces,cfn,bfn,xp,xn,z,strt,cap,wm,ba,wp,wn,vi,dj,na,da},
nd=RoundingDivisions/.{opts}/.Options[MakePolygonalTubeGC];
np=Length[pts];
closed=(pts[[1]]==pts[[np]]);
verts=faces={};
(* radial position at a vertex *)
cfn[z_,w_,j_]:=With[{\[Theta]=j \[Pi]/nd},r(z Cos[\[Theta]]+w Sin[\[Theta]])];
bfn[z_,w_,j_,x_,\[Phi]_]:=With[{\[Theta]=j \[Pi]/nd},r(z Cos[\[Theta]]+w Sin[\[Theta]]Cos[\[Phi]]+x Sin[\[Theta]]Sin[\[Phi]])];

(* build local coordinates and info for each vertex *)
Do[
(* vector from previous point *)
xp[i]=NormalizeReal[pts[[i]]-If[i==1,If[closed,pts[[np-1]],pts[[2]]],
pts[[i-1]]]];
(* vector to next point *)
xn[i]=NormalizeReal[If[i==np,If[closed,pts[[2]],pts[[np-1]]],pts[[i+1]]]-pts[[i]]];
(* end needs to be capped *)
cap[i]=!closed&&(i==1||i==np);
(* vertical direction *)
z[i] =xp[i]\[Cross] xn[i];
strt[i]=(Mag[z[i]]==0);(* straight vertex *)
z[i]=If[strt[i],Normals3D[xp[i]][[1]],NormalizeReal[z[i]]];
(* bend angle is always to the left relative to z *)
ba[i]=DirectedAngle3D[xp[i],xn[i],z[i]];
(* horizontal vectors *)
wp[i]=z[i]\[Cross]xp[i];
wn[i]=z[i]\[Cross]xn[i];
wm[i]=Which[
!closed&&i==1,wn[i],
!closed&&i==np,wp[i],
True,NormalizeReal[wp[i]+wn[i]]];
(* number of angular divisions *)
na[i]=If[cap[i],nd,If[strt[i],0,Round[nd Abs[ba[i]]/\[Pi]]]];
(* angular change *)
da[i]=If[cap[i],\[Pi]/na[i],If[strt[i]||na[i]==0,0,Abs[ba[i]]/na[i]]]//N;
(* build vertices of cylinders *)
Do[Which[
j==2nd,(* wrap-around in j *)
vi[-1,i,j]=vi[1,i,j]=vi[-1,i,0],
strt[i],(* straight vertex *)
AppendTo[verts,pts[[i]]+cfn[z[i],wm[i],j]];vi[-1,i,j]=vi[1,i,j]=Length[verts],
True,(* bend (to the left) *)
If[j<=nd||cap[i]||na[i]==0,
(* both edges end on angle bisector plane *)
AppendTo[verts,pts[[i]]+cfn[z[i],wm[i],j]];vi[-1,i,j]=vi[1,i,j]=Length[verts],
(* outside of bend, separate edges for previous and next cylinder *)
AppendTo[verts,pts[[i]]+cfn[z[i],wp[i],j]];vi[-1,i,j]=Length[verts];AppendTo[verts,pts[[i]]+cfn[z[i],wn[i],j]];vi[1,i,j]=Length[verts]]]
,{j,0,2nd}]
,{i,np}];

(* build cylindrical faces *)
Do[
(* find the next j-value closest to this vertex's j=0 *)
dj=With[{p0=pts[[i]]+cfn[z[i],wn[i],0]},
Sort[Table[{j,Mag[pts[[i+1]]+cfn[z[i+1],wp[i+1],j]-p0]},{j,0,2nd-1}],#1[[2]]<#2[[2]]&][[1,1]]];
(* add cylindrical faces, splitting each quad along shortest diagonal *)
Do[With[{
p1=vi[1,i,j],
p2=vi[-1,Mod[i+1,np,1],Mod[j+dj,2nd]],
p3=vi[-1,Mod[i+1,np,1],Mod[j+1+dj,2nd]],
p4=vi[1,i,Mod[j+1,2nd]]},
If[Mag[p1-p3]<=Mag[p2-p4],
AppendTo[faces,{p1,p2,p3}];AppendTo[faces,{p1,p3,p4}],
AppendTo[faces,{p1,p2,p4}];AppendTo[faces,{p2,p3,p4}]]]
,{j,0,2nd-1}];
,{i,np-1}];
(* add vertices for rounded connections and end caps *)
Do[

(* create vertices for bends and caps *)
Do[
Which[
j==0||j==nd||j==2nd,(* top or bottom of bend *)
vi[0,i,j,k]=vi[-1,i,j],
k==0&&i==1&&cap[i],(* beginning of bend, first cap *)
vi[0,i,j,k]=vi[-1,i,Mod[-j,2nd,0]],
k==0,(* beginning of bend *)
vi[0,i,j,k]=vi[-1,i,j],
(cap[i]||!strt[i])&&ba[i]>0&&j>nd,(* interior of a bend *)
AppendTo[verts,pts[[i]]+bfn[z[i],wp[i],j,xp[i],-k da[i]]];vi[0,i,j,k]=Length[verts],
k==na[i],(* end of ordinary bend or last cap *)
vi[0,i,j,k]=vi[1,i,j]
],{j,0,2nd},{k,0,na[i]}]
,{i,np}];

(* add faces for bends and caps *)
Do[With[{
p1=vi[0,i,j,k],
p2=vi[0,i,j,k+1],
p3=vi[0,i,j+1,k+1],
p4=vi[0,i,j+1,k]},
Which[
p1==p2,AppendTo[faces,{p1,p3,p4}],
p3==p4,AppendTo[faces,{p1,p2,p3}],
True,
AppendTo[faces,{p1,p2,p3,p4}]]
],{i,np},{j,nd,2nd-1},{k,0,na[i]-1}];

(* debugging *)
Print[Graphics3D[{
Table[Style[Point[verts[[vi[1,i,0]]]],Orange,AbsolutePointSize[10]],{i,np}],
Style[Polygon[verts[[#]]],FaceForm[Green,Red],Opacity[.5]]&/@faces,
Line[pts],
Style[Point/@verts,Green]}]]//Hold;
GraphicsComplex[verts,Polygon/@faces]]
Module[{pts,gc},
pts={{0,0,0},{1,0,0},{1,1,0},{0,1,1},{0,0,0}}//N;
gc=MakePolygonalTubeGC[pts,.3,RoundingDivisions->4];
Graphics3D[Style[gc,FaceForm[Green,Red],Opacity[.5]]]
]//ShowExample
Module[{pts,gc},
pts={{0,0,0},{.667,0,0},{1.333,-.08,0},{2,0,0},{2,1,0},{3,1,1}}//N;
gc=MakePolygonalTubeGC[pts,.3,RoundingDivisions->6];
Graphics3D[Style[gc,FaceForm[Green,Red],Opacity[.5]]]
]//ShowExample
RoundingDivisions::usage="RoundingDivisions is an option to MakePlanarRoundedPlateGC that specifies the number of divisions to use in rounding.";
Options[MakePlanarRoundedPlateGC]={
RoundingDivisions->4
};
MakePlanarRoundedPlateGC::badpoly="Polygon `1` is not a planar convex polygon.";
MakePlanarRoundedPlateGC[poly_, r_,opts___]:=Module[{nd,np,z,verts,faces,cfn,bfn,xp,xn,wp,wn,ba,strt,na,da,vi},
If[!Polygon3DPlanarAndConvexQ[poly],Message[MakePlanarRoundedPlateGC::badpoly,poly];Abort[]];
nd=RoundingDivisions/.{opts}/.Options[MakePlanarRoundedPlateGC];
np=Length[poly];
If[np<3,Return[False]];
z=Normalize[(poly[[1]]-poly[[-1]])\[Cross](poly[[2]]-poly[[1]])];
verts=faces={};
(* cylindrical position function *)
cfn[w_,i_,j_]:=poly[[i]]+r (z Cos[j \[Pi]/nd]+w[i] Sin[j \[Pi]/nd]);
(* bend position function *)
bfn[i_,j_,k_]:=With[{\[Theta]=j \[Pi]/nd,\[Phi]=k da[i]},poly[[i]]+r (z Cos[\[Theta]]+wp[i] Sin[\[Theta]]Cos[\[Phi]]+xp[i]Sin[\[Theta]]Sin[\[Phi]])];
(* data describing each vertex *)
Do[
xp[i]=NormalizeReal[poly[[i]]-poly[[Mod[i-1,np,1]]]];
xn[i]=NormalizeReal[poly[[Mod[i+1,np,1]]]-poly[[i]]];
wp[i]=xp[i]\[Cross]z;(* points to outside of bend, previous edge *)
wn[i]=xn[i]\[Cross]z;(* points to outside of bend, next edge *)
ba[i]=DirectedAngle3D[xp[i],xn[i],z];(* total bend angle *)
na[i]=If[ba[i]==0,0,Ceiling[ba[i]nd/\[Pi]]];
da[i]=If[ba[i]==0,0,ba[i]/na[i]];
,{i,np}];

(* vertices of top and bottom faces *)
Do[AppendTo[verts,poly[[i]]+r z];vi[1,i]=Length[verts],{i,np}];
Do[AppendTo[verts,poly[[i]]-r z];vi[-1,i]=Length[verts],{i,np}];

(* top and bottom faces *)
faces={Range[np],Reverse[Range[np+1,2np]]};

(* vertices of cylindrical faces *)
Do[Which[
j==0,(* top of arc *)
vi[-1,i,j]=vi[+1,i,j]=vi[1,i],
j==nd,(* bottom of arc *)
vi[-1,i,j]=vi[+1,i,j]=vi[-1,i],
True,(* interior of arc *)
AppendTo[verts,cfn[wp,i,j]];vi[-1,i,j]=Length[verts];
AppendTo[verts,cfn[wn,i,j]];vi[1,i,j]=Length[verts];
],{j,0,nd},{i,np}];

(* cylindrical faces themselves *)
Do[AppendTo[faces,{
vi[1,i,j],
vi[1,i,j+1],
vi[-1,Mod[i+1,np,1],j+1],
vi[-1,Mod[i+1,np,1],j]
}],{i,np},{j,0,nd-1}];

(* vertices of bends *)
Do[Which[
j==0,(* top of arc *)
vi[0,i,j,k]=vi[-1,i,j],
j==nd,(* bottom of arc *)
vi[0,i,j,k]=vi[-1,i,j],
k==0,(* begin of bend *)
vi[0,i,j,k]=vi[-1,i,j],
k==na[i],(* end of bend *)
vi[0,i,j,k]=vi[+1,i,j],
True,(* interior of bend *)
AppendTo[verts,bfn[i,j,k]];
vi[0,i,j,k]=Length[verts]
],{i,np},{j,0,nd},{k,0,na[i]}];

(* bend faces *)
Do[With[{
p1=vi[0,i,j,k],
p2=vi[0,i,j+1,k],
p3=vi[0,i,j+1,k+1],
p4=vi[0,i,j,k+1]},
Which[
p1==p2,AppendTo[faces,{p1,p3,p4}],
p3==p4,AppendTo[faces,{p1,p2,p3}],
True,
AppendTo[faces,{p1,p2,p3,p4}]]
],{i,np},{j,0,nd-1},{k,0,na[i]-1}];

Print[Graphics3D[{
Style[Point/@verts,Darker[Green],AbsolutePointSize[5]],
Style[Polygon[verts[[#]]]&/@faces,FaceForm[Green,Red],Opacity[.5]],
{}}]]//Hold;

GraphicsComplex[verts,Polygon/@faces]]
Module[{poly,prp},
poly={{0,0,0},{.5,0,0},{1,0,0},{1.5,.5,0},{1,1,0},{0,1,0}};
prp=MakePlanarRoundedPlateGC[poly,0.2,RoundingDivisions->5];
Graphics3D[Style[prp,FaceForm[Green,Red],Opacity[.5]]]
]//ShowExample
MakePlanarRoundedPlateGCs[expr_,r_,opts___]:=Module[{polys},
polys=First/@Cases[expr,_Polygon,\[Infinity]];
MakePlanarRoundedPlateGC[#,r,opts]&/@polys]
Module[{poly1,poly2,gg},
poly1=Polygon[{{0,0,0},{1,0,0},{1,1,0},{0,1,0}}];
poly2=Polygon[{{1,0,0},{1,1,0},{1,1,-1},{1,0,-1}}];
gg=Graphics3D[Style[{poly1,poly2},FaceForm[Green,Red],EdgeForm[{Thick,Blue}]]];
GraphicsRow[{
gg,
Graphics3D[Style[MakePlanarRoundedPlateGCs[gg,0.25,RoundingDivisions->6],FaceForm[Cyan,Yellow]]]}]
]//ShowExample
Module[{poly1,poly2,ggorig,ggrp},
poly1=Polygon[{{0,0,0},{1,0,0},{1,1,0},{0,1,0}}];
poly2=Polygon[{{1,0,0},{1,1,0},{1,1,-1},{1,0,-1}}];
ggorig=Graphics3D[Style[{poly1,poly2},FaceForm[Green,Red],EdgeForm[{Thick,Blue}]]];
ggrp=Graphics3D[Style[MakePlanarRoundedPlateGCs[ggorig,0.25,RoundingDivisions->6],FaceForm[Cyan,Yellow]]];
GraphicsRow[{ggorig,ggrp}]//Print;
Export[ExamplesDir[]<>"test.stl",ggrp,{"STL","BinaryFormat"-> False}]
]//ShowExample
ExtrudeGC[xypts_List,{z0_,z1_},xyz_List:IdentityMatrix[3]]:=Module[{n,x,y,z,pts},
n=Length[xypts];
{x,y,z}=xyz;
pts=Join[x #[[1]]+y #[[2]]+z z1&/@xypts,x #[[1]]+y #[[2]]+z z0&/@xypts];
GraphicsComplex[pts,Flatten[{
Polygon[Range[n]],
Polygon/@Transpose[{
Range[1,n],
n+Range[1,n],
n+Mod[Range[2,n+1],n,1],
Mod[Range[2,n+1],n,1]}],
Polygon[Reverse[Range[n+1,2n]]]}]]]
Module[{xypts,z0,z1,zex},
xypts={{0,0},{1,0},{1,1},{1,1},{.8,1},{.8,.5},{0,.5}};
{z0,z1}={0,.4};
zex=ExtrudeGC[xypts,{z0,z1}];
Graphics3D[Style[zex,FaceForm[Green,Red]]]
]//ShowExample
ExtrudeTorusGC::badlens="Lists `1` and `1` do not have the same length.";
ExtrudeTorusGC[xyouter_List,xyinner_List,{z0_,z1_},xyz_List:IdentityMatrix[3]]:=Module[{n,x,y,z,pts},
n=Length[xyouter];
If[Length[xyinner]!=n,Message[ExtrudeTorusGC::badlens,xyouter,xyinner];Abort[]];
{x,y,z}=xyz;
pts=Join[x #[[1]]+y #[[2]]+z z1&/@Join[xyouter,xyinner],x #[[1]]+y #[[2]]+z z0&/@Join[xyouter,xyinner]];
GraphicsComplex[pts,Flatten[{
(* top face with hole *)
Polygon/@Transpose[{
Range[1,n],
Mod[Range[1,n]+1,n,1],
n+Mod[Range[1,n]+1,n,1],
n+Range[1,n]}],
(* outer walls *)
Polygon/@Transpose[{
Range[1,n],
2n+Mod[Range[1,n],n,1],
2n+Mod[Range[1,n]+1,n,1],
Mod[Range[1,n]+1,n,1]}],
(* inner walls *)
Polygon/@Transpose[{
n+Range[1,n],
3n+Mod[Range[1,n],n,1],
3n+Mod[Range[1,n]+1,n,1],
n+Mod[Range[1,n]+1,n,1]}//Reverse],
(* bottom face with hole *)
Polygon/@Transpose[{
2n+Range[1,n],
2n+Mod[Range[1,n]+1,n,1],
3n+Mod[Range[1,n]+1,n,1],
3n+Range[1,n]}//Reverse]}]]]
Module[{xyouter,xyinner,z0,z1,zex},
xyouter={{0,0},{3,0},{3,3},{0,3}};
xyinner={{1,1},{2,1},{2,2},{1,2}};
{z0,z1}={0,1};
zex=ExtrudeTorusGC[xyouter,xyinner,{z0,z1}];
Graphics3D[Style[zex,FaceForm[Green,Red]],Axes->True]
]//ShowExample
StackXGC[objs_List]:=Module[{xex,wids,objs1,offs},
xex=First/@BoundingBoxGC/@objs;(* x-extents *)
wids=#[[2]]-#[[1]]&/@xex;(* widths *)
offs=FoldList[Plus,0,wids];(* offsets *)
(* move objects to all start at x=0 *)
Table[FunctionTransform[objs[[i]],#+{offs[[i]]-xex[[i,1]]+xex[[1,1]],0,0}&],{i,Length[objs]}]]
Module[{objs},
objs={ExtrudeGC[{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}],
ExtrudeGC[2{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}],ExtrudeGC[3{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}]};
Print[GraphicsRow[Graphics3D/@objs]];
Graphics3D[StackXGC[objs],Axes->True]
]
StackYGC[objs_List]:=Module[{yex,wids,objs1,offs},
yex=#[[2]]&/@BoundingBoxGC/@objs;(* y-extents *)
wids=#[[2]]-#[[1]]&/@yex;(* widths *)
offs=FoldList[Plus,0,wids];(* offsets *)
(* move objects to all start at y=0 *)
Table[FunctionTransform[objs[[i]],#+{0,offs[[i]]-yex[[i,1]]+yex[[1,1]],0}&],{i,Length[objs]}]]
Module[{objs},
objs={ExtrudeGC[{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}],
ExtrudeGC[2{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}],ExtrudeGC[3{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}]};
Print[GraphicsRow[Graphics3D/@objs]];
Graphics3D[StackYGC[objs],Axes->True]
]
StackZGC[objs_List]:=Module[{zex,hets,objs1,offs},
zex=#[[3]]&/@BoundingBoxGC/@objs;(* z-extents *)
hets=#[[2]]-#[[1]]&/@zex;(* heights *)
offs=FoldList[Plus,0,hets];(* offsets *)
(* move objects to all start at z=0 *)
Table[FunctionTransform[objs[[i]],#+{0,0,offs[[i]]-zex[[i,1]]+zex[[1,1]]}&],{i,Length[objs]}]]
Module[{objs},
objs={ExtrudeGC[{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}],
ExtrudeGC[2{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}],ExtrudeGC[3{{-1,-1},{1,-1},{1,1},{-1,1}},{-1,1}]};
Print[GraphicsRow[Graphics3D/@objs]];
Graphics3D[StackZGC[objs],Axes->True]
]//ShowExample
FuzzSeed::usage="FuzzSeed is an option to FuzzPoints that seeds the randomness of the fuzzing.";
FuzzMethod::usage="FuzzMethod is an option to FuzzPoints that specifies whether fuzzing is individually by vertex or all vertices get the same fuzz.";
FuzzByVertex::usage="FuzzByVertex is an option value that specifies to give each vertex a unique fuzz value.";
FuzzByGroup::usage="FuzzByGroup is an option value that specifies to give each vertex the same fuzz value.";
Options[FuzzPoints]={
FuzzSeed->0,
FuzzMethod->FuzzByVertex
};
FuzzPoints::badmeth="`1` is not a valid option for FuzzMethod.";
FuzzPoints[pts_List,fuzzrad_,opts___]:=Module[{seed,fm,dim,fv},
seed=FuzzSeed/.{opts}/.Options[FuzzPoints];
fm=FuzzMethod/.{opts}/.Options[FuzzPoints];
SeedRandom[Hash[{pts,seed}]];
dim=Length[pts[[1]]];
Switch[fm,
FuzzByVertex,fuzzrad NormalizeReal[Table[RandomReal[{1,-1}],{dim}]]+#&/@pts,
FuzzByGroup,fv=fuzzrad NormalizeReal[Table[RandomReal[{1,-1}],{dim}]];fv+#&/@pts,
_,Message[FuzzPoints::badmeth,fm];Abort[]]]
Module[{pts},
pts={{0,0,0},{1,0,0}};
{FuzzPoints[pts,0],(* no fuzzing *)
FuzzPoints[pts,.1],(* fuzzing, by vertex *)
FuzzPoints[pts,.1,FuzzSeed->1],(* fuzzing by vertex, different seed *)
FuzzPoints[pts,.1,FuzzMethod->FuzzByGroup] (* all same *)
}//ColumnForm
]//ShowExample
FuzzGC[gc_GraphicsComplex, opts___]:=MapAt[FuzzPoints[#,opts]&,gc,{1}]
Module[{gc},
gc=GraphicsComplex[{{0,0},{1,0},{1,1}},Polygon[{1,2,3}]];
GraphicsRow[{
Graphics[gc,Axes->True],(* original *)
Graphics[FuzzGC[gc,.1],Axes->True],(* fuzzed by vertex *)
Graphics[FuzzGC[gc,.1,FuzzMethod->FuzzByGroup],Axes->True](* fuzzed all same *)
}]
]//ShowExample
FuzzGCs[expr_,fuzzrad_,opts___]:=expr/.gc_GraphicsComplex:>FuzzGC[gc,fuzzrad,opts]
Module[{gg},
gg=Graphics3D[{GraphicsComplex[{{0,0,0},{1,1,0},{0,1,0}},{Style[Polygon[{1,2,3}],Lighter[Red]],Style[Line[{1,2,3,1}],Darker[Red]]}],
GraphicsComplex[{{0,0,0},{0,1,0},{0,1,1}},{Style[Polygon[{1,2,3}],Lighter[Green]],Style[Line[{1,2,3,1}],Darker[Green]]}]}];
GraphicsRow[{
gg,
FuzzGCs[gg,.2],
FuzzGCs[gg,.2,FuzzMethod->FuzzByGroup]
}]
]//ShowExample
AssertFileExtension::badext="The file path `1` does not end in extension `2`.";
AssertFileExtension[filepath_String,ext_String]:=Module[{pos},
pos=StringPosition[ToLowerCase[filepath],ToLowerCase[ext]];
If[ListEmptyQ[pos]||StringLength[filepath]!=pos[[-1,2]],Message[AssertFileExtension::badext,filepath,ext];Abort[]];
filepath]
Module[{filepath,ext},
filepath="foo.bar";
AssertFileExtension[filepath,"bar"]
]//ShowExample
Module[{filepath,ext},
filepath="foo.BAR";
AssertFileExtension[filepath,"bar"]
]//ShowExample
Module[{filepath,ext},
filepath="foo.bar";
AssertFileExtension[filepath,"baz"]
]//ShowErrorExample
ReplaceFileExtension::noext="The file path `1` does not contain an extension.";
ReplaceFileExtension[filepath_String, ext_String]:=Module[{pos},
pos=StringPosition[filepath,"."];
If[ListEmptyQ[pos],Message[ReplaceFileExtension::noext,filepath];Abort[]];
StringTake[filepath,pos[[-1,1]]]<>ext]
ReplaceFileExtension["foo.bar","baz"]//ShowExample
ReplaceFileExtension["foobar","baz"]//ShowErrorExample
NewPath::usage="NewPath is an option to file converter functions that specifies a new destination for the converted file.";
GetPaths[dirpath_String,ext_String]:=Module[{n,filenames},
n=StringLength[dirpath];
filenames=FileNames["*."<>ext,dirpath];
{dirpath,StringTake[#,{n+1,StringLength[#]}]}&/@filenames]
Module[{dirpath,ext},
dirpath=ExamplesDir[];
Print["ExamplesDir[] = ",dirpath];
ext="fold";
GetPaths[dirpath,ext];
]//ShowExample
MatlabOutputForm::usage="MatlabOutputForm is an option to VectorToMatlab and MatrixToMatlab that specifies the formatter for numerical values.";
Options[VectorToMatlab]={
MatlabOutputForm->(ToString[If[IntegerQ[#],#,NumberForm[N[#],10,ExponentFunction->(Null&)]]]&)
};
VectorToMatlab::badvec="List `1` is not a vector.";
VectorToMatlab[v_List,opts___]:=Module[{of},
of=MatlabOutputForm/.{opts}/.Options[VectorToMatlab];
If[!VectorQ[v],Message[VectorToMatlab::badvec,v];Abort[]];
StringRiffle[of/@v,{"[",",","]"}]]
Module[{v},
v={1,2,-3,-4};
VectorToMatlab[v]
]//ShowExample
Module[{v},
v={1,\[Sqrt]2,-N[\[Pi]],-4,5.0*10^-15};
VectorToMatlab[v]
]//ShowExample
MatlabMatrixByRow::usage="MatlabMatrixByRow is an option to MatrixToMatlab that specifies whether matrices are output one row per line or in one big block.";
Options[MatrixToMatlab]={
MatlabOutputForm->(ToString[If[IntegerQ[#],#,NumberForm[N[#],10,ExponentFunction->(Null&)]]]&),
MatlabMatrixByRow->True
};
MatrixToMatlab::badmat="List `1` is not a matrix or list of lists.";
MatrixToMatlab[m_List,opts___]:=Module[{of,br},
of=MatlabOutputForm/.{opts}/.Options[MatrixToMatlab];
br=MatlabMatrixByRow/.{opts}/.Options[MatrixToMatlab];
If[!And@@(ListQ[#]&&Length[Dimensions[#]]==1&/@m),Message[MatrixToMatlab::badmat,m];Abort[]];
StringRiffle[(StringRiffle[of/@#,","]&/@m),{"[",If[br,"\n",";"],"]"}]]
Module[{m},
m={{1,2},{3,4}};
MatrixToMatlab[m]
]//ShowExample
Module[{m},
m={{1,\[Sqrt]2},{-N[\[Pi]],-4}};
MatrixToMatlab[m,MatlabMatrixByRow->False]
]//ShowExample
Options[ShowTGraphExample]={
PlotLabel->None
};
ShowTGraphExample[tobj_TObj,opts___]:=Module[{pl,gg},
pl=PlotLabel/.{opts}/.Options[ShowTGraphExample];
gg={};
If[HasClassQ[tobj,TGraph3D],
If[HasClassQ[tobj,TAssigned],
AppendTo[gg,FoldedFormGraphics3D[tobj]],AppendTo[gg,Graph3DGraphics3D[tobj]]]];
If[HasClassQ[tobj,TGraph2D],
If[HasClassQ[tobj,TAssigned],PrependTo[gg,VisibleFoldedFormGraphics[tobj]],PrependTo[gg,Graph2DGraphics[tobj]]]];
If[HasClassQ[tobj,TAssigned],
PrependTo[gg,CreasePatternGraphics[tobj]],PrependTo[gg,GraphGraphics[tobj]]];
If[!(pl===None),GraphicsRow[gg,PlotLabel->pl],GraphicsRow[gg]]/.OrigamiStyle[]]
ShowTGraphExample[RandlettBirdGraph3DAssigned,PlotLabel->"RandlettBirdGraph3DAssigned"]//ShowExample
ShowTGraphExample::badnam="`1` is not the name of a TGraph object.";
ShowTGraphExample[name_String]:=Module[{tobj},
tobj=ToExpression[name];
If[!HasClassQ[tobj,TGraph],Message[ShowTGraphExample::badnam,name];Abort[]];
ShowTGraphExample[tobj,PlotLabel->name]]
ShowTGraphExample["SingleVertexGraph3DAssigned"]//ShowExample
Module[{},
Print[ShowTGraphExample[#]]&/@$TGraphExamples;
]//ShowExample
Module[{},
Print[$TClasses];
Print[$TClassInheritance];
Print[TClassGraphics[]];
]//ShowExample
$TGraphExamples//ColumnForm//ShowExample
Tessellatica::loadtime="Tessellatica took `1` seconds to load.";
$TessellaticaLoadEndTime=SessionTime[];
Message[Tessellatica::loadtime,NumberForm[$TessellaticaLoadEndTime-$TessellaticaLoadStartTime,4]];
Sound[Sound[SoundNote[#,{0,0.05},"Piano"]]&/@{0,4,7,12,16,19,24,28,31,36}]//EmitSound
Block[{x,y,f},(x^2+y^2)/(4f)];
FlasherRotation2D[k_,m_]:={{Cos[2\[Pi] k/m],-Sin[2\[Pi] k/m]},{Sin[2\[Pi] k/m],Cos[2\[Pi] k/m]}}
FlasherRotation3D[k_,m_]:={{Cos[2\[Pi] k/m],-Sin[2\[Pi] k/m],0},{Sin[2\[Pi] k/m],Cos[2\[Pi] k/m],0},{0,0,1}}
FlasherWrapRules[v_]:=Subscript[v, -1,j_,k_]:>Subscript[v, j,0,k-1]
FlasherDefaultCPRules[p_,m_]:={Subscript[p, i_,j_,k_]:>FlasherRotation2D[k,m] . N[(1/2){Cot[\[Pi]/m],1}+If[i+1>=j,(i+1) U[\[Pi]/2+(2\[Pi])/m]+Tan[\[Pi]/m]j U[(2\[Pi])/m],j U[\[Pi]/2]-Tan[\[Pi]/m](i+1)U[0]]]}
Block[{p},
FlasherDefaultCPRules[p,4]
]//ShowExample
Module[{p},
Subscript[p, 0,0,0]/.FlasherDefaultCPRules[p,4]
]//ShowExample
FlasherDefaultDPRules[p_,m_,f_]:={Subscript[p, i_,j_,k_]:>FlasherRotation3D[k,m] . Module[{r,z},
r=(1/2){Cot[\[Pi]/m],1}+If[i+1>=j,(i+1) U[\[Pi]/2+(2\[Pi])/m]+Tan[\[Pi]/m]j U[(2\[Pi])/m],j U[\[Pi]/2]-Tan[\[Pi]/m](i+1)U[0]];
z=r . r/(4f);
N[Append[r,z]]]}
Block[{p},
FlasherDefaultDPRules[p,4,10]
]//ShowExample
Module[{p},
Subscript[p, 0,0,0]/.FlasherDefaultDPRules[p,4,10]
]//ShowExample
FlasherBorderFold:=Black
FlasherSharpFold[f_]:=If[Mod[f,2]==0,RGBColor[1,0,0],RGBColor[0,0,1]]
FlasherMedFold[f_]:=If[Mod[f,2]==0,RGBColor[1,.7,.7],RGBColor[.6,.6,1]]
FlasherLightFold := GrayLevel[.85]
FlasherVertexLabel[u_,Subscript[v_, i_,j_,k_]]:=Text[Subscript[Style[u,Bold], i,j,k],Subscript[v, i,j,k]/.FlasherWrapRules[v]]
Block[{p},
FlasherVertexLabel["p",Subscript[p, 0,0,0]]
]//ShowExample
Block[{p},
FlasherVertexLabel["p",Subscript[p, -1,2,4]]
]//ShowExample
FlasherFirstSectorAllVerticesLabels[u_,v_,n_]:=Style[Table[FlasherVertexLabel[u,Subscript[v, i,j,0]],{i,-1,n},{j,0,n}],Black]
Module[{p,n=3,m=5},Graphics[FlasherFirstSectorAllVerticesLabels["p",p,n]/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorQuads[v_,r_,h_,k_]:=Module[{n,i,j,quad},
n=r*h;(* total number of radial increments *)
Flatten[{
(* major region *)
Table[{j=h*ig;
If[Min[j+h,i]>j,quad[Subscript[v, i,j,k],Subscript[v, i-1,j,k],Subscript[v, i-1,Min[j+h,i],k],Subscript[v, i,Min[j+h,i+1],k]],{}]
},{ig,0,r-1},{i,h*ig,n}],
(* minor region *)
Table[{i=h*ig-1;
If[Min[i+h,j-2]>i,quad[Subscript[v, i,j,k],Subscript[v, i,j-1,k],Subscript[v, Min[i+h,j-2],j-1,k],Subscript[v, Min[i+h,j-1],j,k]],{}]
},{ig,0,r-1},{j,h*ig+1,n}]
}]/.quad->List/.FlasherWrapRules[v]]
Module[{p,r=3,h=2,m=5,fsq,fspolys},
fsq=FlasherSectorQuads[p,r,h,0];
fspolys=MapIndexed[With[{ctr=Plus@@#1/4},{Style[Polygon[ctr+0.8(#1-ctr)],LightGray],Style[Text["q"<>ToString[#2[[1]]],ctr],Darker[Green]]}]&,fsq];
Graphics[{fspolys,FlasherFirstSectorAllVerticesLabels["p",p,r*h]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorTriangles[v_,r_,h_,k_]:=Module[{n,i,j,quad},
n=r*h;(* total number of radial increments *)
Flatten[{
(* major region *)
Table[{j=h*ig;
If[Min[j+h,i]==j,quad[Subscript[v, i,j,k],Subscript[v, i-1,j,k],Subscript[v, i,Min[j+h,i+1],k]],{}]
},{ig,0,r-1},{i,h*ig,n}],
(* minor region *)
Table[{i=h*ig-1;
If[Min[i+h,j-2]==i,quad[Subscript[v, i,j,k],Subscript[v, i,j-1,k],Subscript[v, Min[i+h,j-1],j,k]],{}]
},{ig,0,r-1},{j,h*ig+1,n}]
}]/.quad->List/.FlasherWrapRules[v]]
Module[{p,r=3,h=2,m=5,fsq,fspolys},
fsq=FlasherSectorTriangles[p,r,h,0];
fspolys=MapIndexed[With[{ctr=Plus@@#1/3},{Style[Polygon[ctr+0.8(#1-ctr)],LightGray],Style[Text["q"<>ToString[#2[[1]]],ctr],Darker[Green]]}]&,fsq];
Graphics[{fspolys,FlasherFirstSectorAllVerticesLabels["p",p,r*h]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorFoldedFoldLines[v_,r_,h_,k_]:=Module[{n,i,j},
n=r*h;(* total number of radial increments *)
Flatten[{
(* major region *)
Table[{j=h*ig;
Style[Line[{Subscript[v, i,j,k],Subscript[v, i-1,j,k]}],FlasherSharpFold[ig]],(* bottom of quadrant *)
Style[Line[{Subscript[v, i,j,k],Subscript[v, i,Min[j+h,i+1],k]}],If[i==n,FlasherBorderFold,FlasherMedFold[ig]]](* left of quadrant *)
},{ig,0,r-1},{i,h*ig,n}],
Style[Line[{Subscript[v, n,h*r,k],Subscript[v, n-1,h*r,k]}],FlasherBorderFold],(* extra segment at corner *)
(* diagonal *)
Table[{i=h*ig+j;
Style[Line[{Subscript[v, i-1,i,k],Subscript[v, i,i+1,k]}],FlasherSharpFold[ig+1]]
},{ig,0,r-1},{j,0,h-1}],
(* minor region *)
Table[{i=h*ig-1;
If[ig!=0,Style[Line[{Subscript[v, i,j,k],Subscript[v, i,j-1,k]}],FlasherSharpFold[ig]],{}],(* bottom of quadrant *)
Style[Line[{Subscript[v, i,j,k],Subscript[v, Min[i+h,j-1],j,k]}],If[j==n,FlasherBorderFold,FlasherMedFold[ig+1]]](* left of quadrant *)
},{ig,0,r-1},{j,h*ig+1,n}]
}]/.FlasherWrapRules[v]]
Module[{p,r=3,h=2,n,m=5,k=0},
n=r*h;
Graphics[{
FlasherSectorFoldedFoldLines[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]
}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorDiagFoldLinesX[v_,r_,h_,k_]:=Module[{fsq,nmajor,nminor,qmajor,qminor,qrmajor,qrminor,n},
fsq=FlasherSectorQuads[v,r,h,k];
nmajor=(Length[fsq]+r)/2;(* number in first row of major region *)
nminor=nmajor-r;(* number in first row of minor region *)
qmajor=Take[fsq,nmajor];(* the major quads *)
qminor=Take[fsq,-nminor];(* the minor quads *)
(* now partition into individual rows *)
qrmajor = {};n=r*h;(* number of elements in major row *)
While[n>0,AppendTo[qrmajor,Take[qmajor,n]];qmajor=Drop[qmajor,n];n-=h];
qrminor={};n=r*h-1;(* number of elements in 1st minor row *)
While[n>0,AppendTo[qrminor,Take[qminor,n]];qminor=Drop[qminor,n];n-=h];
Flatten[Join[MapIndexed[Style[Line[If[Mod[#2[[2]]+(h-1)*(#2[[1]]-1)+1,2]==0,#1[[{1,3}]],#1[[{2,4}]]]],FlasherLightFold]&,qrminor,{2}],
MapIndexed[Style[Line[If[Mod[#2[[2]]+(h-1)*(#2[[1]]-1)+1,2]==0,#1[[{1,3}]],#1[[{2,4}]]]],FlasherLightFold]&,qrmajor,{2}]]]/.FlasherWrapRules[v]]
Module[{p,r=3,h=2,n,m=5,k=0},
n=r*h;
Graphics[{
FlasherSectorFoldedFoldLines[p,r,h,k],
FlasherSectorDiagFoldLinesX[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]
}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorDiagFoldLinesY[v_,r_,h_,k_]:=Module[{fsq},
fsq=FlasherSectorQuads[v,r,h,k];
Style[Line[#[[{1,3}]]],FlasherLightFold]&/@fsq/.FlasherWrapRules[v]]
Module[{p,r=3,h=2,n,m=5,k=0},
n=r*h;
Graphics[{
FlasherSectorFoldedFoldLines[p,r,h,k],
FlasherSectorDiagFoldLinesY[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]
}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorDiagFoldLinesZ[v_,r_,h_,k_]:=Module[{fsq},
fsq=FlasherSectorQuads[v,r,h,k];
Style[Line[#[[{2,4}]]],FlasherLightFold]&/@fsq/.FlasherWrapRules[v]]
Module[{p,r=3,h=2,n,m=5,k=0},
n=r*h;
Graphics[{
FlasherSectorFoldedFoldLines[p,r,h,k],
FlasherSectorDiagFoldLinesZ[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]
}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherSectorDiagFoldLines::usage="FlasherSectorDiagFoldLines is an option to FlasherSectorFoldLines that specifies which set of diagonal folds to use in the pattern.";
Options[FlasherSectorFoldLines]={
FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesY
};
FlasherSectorFoldLines[v_,r_,h_,k_,opts___]:=Module[{fsdfl},
fsdfl=FlasherSectorDiagFoldLines/.{opts}/.Options[FlasherSectorFoldLines];
Join[FlasherSectorFoldedFoldLines[v,r,h,k],fsdfl[v,r,h,k]]]
Module[{p,r=4,h=1,n,m=5,k=0},
n=r*h;
Graphics[{FlasherSectorFoldLines[p,r,h,k],
FlasherFirstSectorAllVerticesLabels["p",p,n]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
Module[{p,r=4,h=1,n,m=5,k=0},
n=r*h;
Graphics[{FlasherSectorFoldLines[p,r,h,k,FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesZ],
FlasherFirstSectorAllVerticesLabels["p",p,n]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherFirstSectorVertices[v_,r_,h_]:=Union[Cases[{FlasherSectorFoldLines[v,r,h,0]},Subscript[v, ___],\[Infinity]]]
Block[{p,r=2,h=2},
FlasherFirstSectorVertices[p,r,h]
]//ShowExample
Module[{p,r=2,h=2,n,m=5},
n=r h;
GraphicsRow[{Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherFirstSectorAllVerticesLabels["p",p,n]}],Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherVertexLabel["p",#]&/@FlasherFirstSectorVertices[p,r,h]}]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherFirstSectorVerticesDistinct[v_,r_,h_]:=Union[Cases[{FlasherSectorFoldLines[v,r,h,0]},Subscript[v, _,_,0],\[Infinity]]]
Block[{p,r=2,h=2},
FlasherFirstSectorVerticesDistinct[p,r,h]
]//ShowExample
Module[{p,r=2,h=2,n,m=5},
n=r h;
GraphicsRow[{Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherFirstSectorAllVerticesLabels["p",p,n]}],Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherVertexLabel["p",#]&/@FlasherFirstSectorVerticesDistinct[p,r,h]}]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherAllVerticesDistinct[v_,r_,h_,m_]:=Module[{fsvd},
fsvd=FlasherFirstSectorVerticesDistinct[v,r,h];
Flatten[Table[fsvd/.{Subscript[v, i_,j_,_]->Subscript[v, i,j,k]},{k,0,m-1}],1]]
Block[{p,r=2,h=2},
FlasherAllVerticesDistinct[p,r,h,4]
]//ShowExample
FlasherOuterRingSectorVertices[v_,r_,h_,m_,k_] :=Join[Table[Subscript[v, r*h,j*h,k],{j,0,r}],Table[Subscript[v, i*h-1,r*h,k],{i,r}]]
Block[{p,r=3,h=3},
FlasherOuterRingSectorVertices[p,r,h,5,0]
]//ShowExample
FlasherLabeledSector[u_,v_,r_,h_,m_,opts___]:={FlasherSectorFoldLines[v,r,h,0,opts],FlasherVertexLabel[u,#]&/@FlasherFirstSectorVertices[v,r,h]}
Module[{p,r=2,h=2,m=5},
Graphics[{FlasherLabeledSector["p",p,r,h,m]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
FlasherLines[v_, r_,h_,m_,opts___]:=Table[FlasherSectorFoldLines[v,r,h,k,opts],{k,0,m-1}]
Module[{p,r=2,h=2,m=5},
Graphics[{FlasherLines[p,r,h,m]}/.FlasherDefaultCPRules[p,m]]
]//ShowExample
Module[{p,r=2,h=2,m=5},
Graphics3D[{FlasherLines[p,r,h,m]}/.FlasherDefaultDPRules[p,m,4],Method->{"ShrinkWrap"->True}]
]//ShowExample
FlasherFFPointRotation[i_,j_]:=If[j<=i+1,i+1,j]
Module[{},
Graphics[Table[Text[{i,j}->FlasherFFPointRotation[i,j],{-i,j}],{i,0,4},{j,0,4}]]
]//ShowExample
FlasherFFPointRadialOffset[i_,j_]:=If[j<=i+1,i(i+1)+j,j(j+1)-(i+1)]
Module[{},
Graphics[Table[Text[{i,j}->FlasherFFPointRadialOffset[i,j],{-i,j}],{i,0,4},{j,0,4}]]
]//ShowExample
FlasherFFPointDiscreteHeight[i_,j_,h_]:=Abs[Mod[Min[i+1,j]-h,2h,0]-h]
Module[{},
Graphics[Table[Text[{i,j}->FlasherFFPointDiscreteHeight[i,j,2],{-i,j}],{i,0,4},{j,0,4}]]
]//ShowExample
FlasherDefaultFFRules[pp_,h_,m_,dr_:.1]:={Subscript[pp, i_,j_,k_]:>N[FlasherRotation3D[k+FlasherFFPointRotation[i,j],m] . ((1/2)(1+dr FlasherFFPointRadialOffset[i,j]/h){Cot[\[Pi]/m],1,0}+{0,0, FlasherFFPointDiscreteHeight[i,j,h]Tan[\[Pi]/m]})]}
Block[{pp},
FlasherDefaultFFRules[pp,1,4]
]//ShowExample
Module[{pp},
Subscript[pp, 0,0,0]/.FlasherDefaultFFRules[pp,1,4]
]//ShowExample
Module[{pp,r=3,h=3,m=4,dr=.01},
Graphics3D[FlasherSectorFoldLines[pp,r,h,0]/.FlasherDefaultFFRules[pp,h,m,dr],Axes->True]
]//ShowExample
FlasherVars[]={p,px,py,pp,ppx,ppy,ppz};
FlasherScalarize[vars_,obj_,m_]:=Module[{p,px,py,pp,ppx,ppy,ppz},
{p,px,py,pp,ppx,ppy,ppz}=vars;
obj/.{FlasherWrapRules[p],FlasherWrapRules[pp]}/.{
Subscript[p, i_,j_,k_]:>FlasherRotation2D[k,m] . {Subscript[px, i,j],Subscript[py, i,j]},
Subscript[pp, i_,j_,k_]:>FlasherRotation3D[k,m] . {Subscript[ppx, i,j],Subscript[ppy, i,j],Subscript[ppz, i,j]}}]
Module[{},
FlasherScalarize[FlasherVars[],{Subscript[p, 1,2,0]},4]
]//ShowExample
Module[{},
FlasherScalarize[FlasherVars[],{Subscript[pp, 1,2,0],Subscript[pp, 1,2,1],Subscript[pp, -1,2,1]},4]
]//ShowExample
FlasherScalarizeDP[vars_,obj_,m_,f_]:=Module[{p,px,py,pp,ppx,ppy,ppz},
{p,px,py,pp,ppx,ppy,ppz}=vars;
obj/.{FlasherWrapRules[p],FlasherWrapRules[pp]}/.{
Subscript[p, i_,j_,k_]:>FlasherRotation3D[k,m] . {Subscript[px, i,j],Subscript[py, i,j],(Subscript[px, i,j]^2+Subscript[py, i,j]^2)/(4f)},
Subscript[pp, i_,j_,k_]:>FlasherRotation3D[k,m] . {Subscript[ppx, i,j],Subscript[ppy, i,j],Subscript[ppz, i,j]}}]
Module[{},
FlasherScalarizeDP[FlasherVars[],{Subscript[p, 1,2,0]},4,10]
]//ShowExample
Module[{},
FlasherScalarizeDP[FlasherVars[],{Subscript[pp, 1,2,0],Subscript[pp, 1,2,1],Subscript[pp, -1,2,1]},4,10]
]//ShowExample
FlasherDefaultScalarRules[vars_,r_,h_,m_,dr_]:=Module[{p,px,py,pp,ppx,ppy,ppz,cprules,ffrules,fsv,svars,vals},
{p,px,py,pp,ppx,ppy,ppz}=vars;
cprules=FlasherDefaultCPRules[p,m];
ffrules=FlasherDefaultFFRules[pp,h,m,dr];
fsv=Join[FlasherFirstSectorVerticesDistinct[p,r,h],FlasherFirstSectorVerticesDistinct[pp,r,h]];
svars=Flatten[FlasherScalarize[vars,fsv,m]];
vals=Flatten[fsv/.Join[cprules,ffrules]];
MapThread[#1->#2&,{svars,vals}]]
Module[{vars=FlasherVars[],r=2,h=1,m=4,dr=.01},
FlasherDefaultScalarRules[vars,r,h,m,dr]
]//ShowExample
FlasherVertexRules[vars_,m_,srules_]:=Module[{p,px,py,pp,ppx,ppy,ppz},{
{p,px,py,pp,ppx,ppy,ppz}=vars;
Subscript[p, i_,j_,k_]:>(FlasherRotation2D[k,m] . {Subscript[px, i,j],Subscript[py, i,j]}/.srules),
Subscript[pp, i_,j_,k_]:>(FlasherRotation3D[k,m] . {Subscript[ppx, i,j],Subscript[ppy, i,j],Subscript[ppz, i,j]}/.srules)
}]
FlasherVertexRulesDP[vars_,m_,f_,srules_]:=Module[{p,px,py,pp,ppx,ppy,ppz},{
{p,px,py,pp,ppx,ppy,ppz}=vars;
Subscript[p, i_,j_,k_]:>(FlasherRotation3D[k,m] . {Subscript[px, i,j],Subscript[py, i,j],(Subscript[px, i,j]^2+Subscript[py, i,j]^2)/(4f)}/.srules),
Subscript[pp, i_,j_,k_]:>(FlasherRotation3D[k,m] . {Subscript[ppx, i,j],Subscript[ppy, i,j],Subscript[ppz, i,j]}/.srules)
}]
FlasherCPFns[vars_, m_]:=Module[{p,px,py,pp,ppx,ppy,ppz},
{p,px,py,pp,ppx,ppy,ppz}=vars;
{FlasherScalarize[vars,Subscript[p, 0,0,0],m] . FlasherRotation2D[1,4] . (Subscript[p, 0,0,0]/.FlasherDefaultCPRules[p,m])}]
Block[{vars=FlasherVars[],r=2,h=1,m=4,dr=.01,cpfns},
cpfns=FlasherCPFns[vars,m];
PrintThis[cpfns];
cpfns/.FlasherDefaultScalarRules[vars,r,h,m,dr]
]//ShowExample
FlasherIsometryFns[vars_,r_,h_,m_,opts___]:=Module[{p,px,py,pp,ppx,ppy,ppz,v,fs,lp,dfn,dp,dpp},
{p,px,py,pp,ppx,ppy,ppz}=vars;
(* first sector of flasher, symbolic variable v *)
fs=FlasherSectorFoldLines[v,r,h,0,opts];
(* all line segment vertex pairs in the first sector *)
lp=First/@Flatten[Cases[fs,Line[_],\[Infinity]]];
(* distance fn that takes a list of point pairs *)
dfn=Mag[Subtract@@#]&;
(* Scalarize cp pairs and compute length *)
dp=dfn/@N[FlasherScalarize[vars,lp/.v->p,m]];
(* Scalarize ff pairs and compute length^2 *)
dpp=dfn/@N[FlasherScalarize[vars,lp/.v->pp,m]];
(* return difference between lengths *)
dpp-dp]
Module[{r=2,h=1,m=4,dr=.01,vars,ifns,srules},
vars=FlasherVars[];
ifns=FlasherIsometryFns[vars,r,h,m];
srules=FlasherDefaultScalarRules[vars,r,h,m,dr];
ifns/.srules
]//ShowExample
FlasherIsometryDPFns[vars_,r_,h_,m_,f_,opts___]:=Module[{p,px,py,pp,ppx,ppy,ppz,v,fs,lp,dfn,dp,dpp},
{p,px,py,pp,ppx,ppy,ppz}=vars;
(* first sector of flasher, symbolic variable v *)
fs=FlasherSectorFoldLines[v,r,h,0,opts];
(* all line segment vertex pairs in the first sector *)
lp=First/@Flatten[Cases[fs,Line[_],\[Infinity]]];
(* distance fn that takes a list of point pairs *)
dfn=Mag[Subtract@@#]&;
(* Scalarize cp pairs and compute length *)
dp=dfn/@N[FlasherScalarizeDP[vars,lp/.v->p,m,f]];
(* Scalarize ff pairs and compute length^2 *)
dpp=dfn/@N[FlasherScalarizeDP[vars,lp/.v->pp,m,f]];
(* return difference between lengths *)
dpp-dp]
Module[{r=2,h=1,m=4,f=10,dr=.01,vars,ifns,srules},
vars=FlasherVars[];
ifns=FlasherIsometryDPFns[vars,r,h,m,f];
srules=FlasherDefaultScalarRules[vars,r,h,m,dr];
ifns/.srules
]//ShowExample
Module[{r=2,h=1,m=4,f=10^6,dr=.01,vars,ifns,srules},
vars=FlasherVars[];
ifns=FlasherIsometryDPFns[vars,r,h,m,f];
srules=FlasherDefaultScalarRules[vars,r,h,m,dr];
ifns/.srules
]//ShowExample
FlasherXYFns[vars_,r_,h_,m_,dr_]:=Module[{p,px,py,pp,ppx,ppy,ppz,ffrules,fsv,fsvn},
{p,px,py,pp,ppx,ppy,ppz}=vars;
ffrules=FlasherDefaultFFRules[pp,h,m,dr];
fsv=FlasherFirstSectorVerticesDistinct[pp,r,h];(* vertices *)
fsvn=fsv/.ffrules;(* desired values *)
Flatten[Take[#,2]&/@(N[FlasherScalarize[vars,fsv,m]]-fsvn)]]
Module[{pp,r=2,h=1,m=4,dr=.01,vars,xyfns,ffrules},
vars=FlasherVars[];
xyfns=FlasherXYFns[vars,r,h,m,dr];
ffrules=FlasherDefaultFFRules[pp,h,m,dr];
xyfns/.FlasherDefaultScalarRules[vars,r,h,m,dr]
]//ShowExample
FlasherOuterRingFns[vars_,r_,h_,m_,dr_,dz_:0] :=Module[{p,px,py,pp,ppx,ppy,ppz,verts,ffrules},
{p,px,py,pp,ppx,ppy,ppz}=vars;
verts=FlasherOuterRingSectorVertices[pp,r,h,m,0];
ffrules=FlasherDefaultFFRules[pp,h,m,dr];
Last/@(FlasherScalarize[vars,verts,m]-(1+dz)(verts/.ffrules))]
Block[{r=2,h=1,m=4,dr=.01,dz=.02,vars,ffrules,orfns},
vars=FlasherVars[];
orfns=FlasherOuterRingFns[vars,r,h,m,dr,dz];
PrintThis[orfns];
orfns/.FlasherDefaultScalarRules[vars,r,h,m,dr]
]//ShowExample
Module[{p,pp,r=2,h=1,m=4,dr=.1},
GraphicsRow[{
Graphics[FlasherLabeledSector["p",p,r,h,m]],
Graphics[FlasherLines[p,r,h,m]],
Graphics3D[FlasherLabeledSector["pp",pp,r,h,m]],
Graphics3D[FlasherLines[pp,r,h,m]]
}/.Join[FlasherDefaultCPRules[p,m],FlasherDefaultFFRules[pp,h,m,0.1]]]
]//ShowExample
Block[{p,r=2,h=1,m=4},
Length[FlasherFirstSectorVerticesDistinct[p,r,h]]
]//ShowExample
Module[{p,pp,r=3,h=3,m=4,dr=.05,vars,nverts,nisos,nxys,ndwns,norrngs},
vars=FlasherVars[];
Print[GraphicsRow[{
Graphics[FlasherLabeledSector["p",p,r,h,m]],
Graphics[FlasherLines[p,r,h,m]],
Graphics3D[FlasherLabeledSector["pp",pp,r,h,m]],
Graphics3D[FlasherLines[pp,r,h,m]]
}/.Join[FlasherDefaultCPRules[p,m],FlasherDefaultFFRules[pp,h,m,0.1]]]];
nverts=Length[FlasherFirstSectorVerticesDistinct[p,r,h]];
Print["number of vertices = ",nverts];
Print["number of variables = ",5*nverts];
Print["number of CP position constraints = ",1];
nisos=Length[FlasherIsometryFns[vars,r,h,m]];
Print["number of all isometries = ",nisos];
nxys=Length[FlasherXYFns[vars,r,h,m,dr]];
Print["number of xyfns = ",nxys];
norrngs=Length[FlasherOuterRingFns[vars,r,h,m,dr,0]];
Print["number of norrngs = ",norrngs];
Print["Remaining DOF = ",5 * nverts-(1+nisos+nxys+norrngs)];
]//ShowExample
FlasherR::usage="FlasherR is a property of a flasher TObj that specifies the number of reversed rings in the flasher.";
FlasherH::usage="FlasherH is a property of a flasher TObj that specifies the height (i.e., the number of turns it takes for a diagonal to get to the top of the flasher).";
FlasherM::usage="FlasherM is a property of a flasher TObj that specifies the rotational symmetry of the flasher.";
FlasherLabeledCPSectorGraphics::usage="FlasherLabeledCPSectorGraphics is a property of a flasher TObj that gives a labeled representation of the first sector of the crease pattern.";
FlasherLabeledFFSectorGraphics3D::usage="FlasherLabeledFFSectorGraphics3D is a property of a flasher TObj that gives a labeled representation of the first sector of the folded form.";
FlasherCPGraphics::usage="FlasherCPGraphics is a property of a flasher TObj that gives a styled representation of the crease pattern.";
FlasherFFGraphics3D::usage="FlasherFFGraphics3D is a property of a flasher TObj that gives a styled representation of the folded form.";
FlasherDetails::usage="FlasherDetails is a property of a flasher TObj that gives a list of additional data about the flasher.";
FlasherIJKMap::usage="FlasherIJKMap is a property of a flasher TObj that gives a map from {i,j,k} indices to indices into the Vertices of the TObj.";
MakeFlasher::badiso="Warning: isometry equations could not be satisfied. Residual error is `1.`";
MakeFlasher[r_,h_,m_,dr_,opts___]:=Module[{vars,p,px,py,pp,ppx,ppy,ppz,dz,eqnfns,srules,allvars,newvars,fwd,bkd,args,soln,vertrules,isovals,cpsg,cplg,ffsg,fflg,picdia,pccdia,cpccdia,orverts,ffverts,oph,opw,cpicdia,ffdia,ffh,cpedges,ffedges,btedges,verts,edges,verts3d,tobj,allverts,allvinds,ijkmap,msgs},

(* PART I: solve for the flasher *)

vars={p,px,py,pp,ppx,ppy,ppz};
eqnfns=Join[
FlasherCPFns[vars,m],
FlasherIsometryFns[vars,r,h,m,opts],
FlasherXYFns[vars,r,h,m,dr],
FlasherOuterRingFns[vars,r,h,m,dr,dz],(* dz is now a variable *)
{Subscript[ppz, 0,0]}(* forces central polygon to z=0 *)
];
srules=Append[FlasherDefaultScalarRules[vars,r,h,m,dr],dz->0];allvars=First/@srules;
newvars=Table[Unique[],{Length[allvars]}];fwd=MapThread[#1->#2&,{allvars,newvars}];bkd=MapThread[#2->#1&,{allvars,newvars}];args={eqnfns/.fwd,Transpose[{newvars,allvars/.srules}]};
soln=Check[(FindRoot@@args),Abort[],{}];
soln = soln /. bkd;
vertrules=FlasherVertexRules[vars,m,soln];
isovals=Abs/@FlasherIsometryFns[vars,r,h,m,opts]/.soln;
If[Plus@@isovals>10^-6,Message[MakeFlasher::badiso,isovals]];

(* PART II: compute graphical bits and diagnostic info *)

(* graphical images, sector & pattern, cp & ff *)
cpsg=Graphics[FlasherLabeledSector["p",p,r,h,m,opts]]/.vertrules;
cplg=Graphics[FlasherLines[p,r,h,m,opts]]/.vertrules;
ffsg=Graphics[FlasherLabeledSector["pp",pp,r,h,m,opts]]/.vertrules;
fflg=Graphics[FlasherLines[pp,r,h,m,opts]]/.vertrules;
(* central polygon incircle diameter *)
picdia=1;
(* central polygon circumcircle diameter *)
pccdia=2*Mag[Subscript[p, 0,0,0]/.vertrules];
(* cp outermost vertices *)
orverts=FlasherOuterRingSectorVertices[p,r,h,m,0]/.vertrules;
(* crease pattern incircle diameter *)
cpicdia=2*Min[Mag/@orverts];
(* crease pattern circumcircle diameter *)
cpccdia=2*Max[Mag/@(orverts/.vertrules)];
(* outermost panel height *)
oph=Mag[(Subscript[p, r*h,r*h,0]-Subscript[p, r*h,(r-1)*h,0])/.vertrules];
(* outermost panel width *)
opw=Mag[(Subscript[p, r*h,r*h,0]-Subscript[p, r*h-1,r*h,0])/.vertrules];
(* outermost vertices in ff *)
ffverts=FlasherFirstSectorVerticesDistinct[pp,r,h]/.vertrules;
(* folded form circumcircle diameter *)
ffdia=2*Max[Mag[Take[#,2]]&/@ffverts];
(* folded form height *)
ffh=Max[Last/@ffverts]-Min[Last/@ffverts];

(* PART III: construct a TGraph3DAssigned *)

(* lists of point pairs for both cp and ff *)
cpedges=First/@Cases[FlasherLines[p,r,h,m,opts],_Line,{0,\[Infinity]}]/.vertrules;
ffedges=First/@Cases[FlasherLines[pp,r,h,m,opts],_Line,{0,\[Infinity]}]/.vertrules;
(* ordered 5-tuples, for indexification *)
btedges=MapThread[Join,{cpedges,ffedges},2];
{verts,edges}=Indexify[btedges,2];
verts3d=Take[#,-3]&/@verts;
verts=Take[#,2]&/@verts;
tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d]//RecalcFoldAngles//ReassignGraph3D[#,opts]&;

(* Create a table of all vertices with symbolic values *)
allverts=FlasherAllVerticesDistinct[p,r,h,m];
allvinds=Take[Indexify[Join[verts,allverts/.vertrules]][[2]],-Length[allverts]];
ijkmap=MapThread[{#1/.{Subscript[p, i_,j_,k_]:>{i,j,k}},#2}&,{allverts,allvinds}];


(* add the additional properties *)
tobj//AddProperties[{
FlasherR->r,
FlasherH->h,
FlasherM->m,
FlasherLabeledCPSectorGraphics->cpsg,
FlasherLabeledFFSectorGraphics3D->ffsg,
FlasherCPGraphics->cplg,
FlasherFFGraphics3D->fflg,
 FlasherDetails->{
"central polygon incircle diameter"->picdia,
"central polygon circumcircle diameter"->pccdia,
"crease pattern incircle diameter"->cpicdia;
"crease pattern circumcircle diameter"->cpccdia,
"crease pattern incircle diameter"->cpicdia,
"folded form circumcircle diameter"->ffdia,
"outermost panel height"->oph,
"outermost panel width"->opw
},
FlasherIJKMap->ijkmap}]
]
Module[{r=2,h=2,m=4,dr=.05,tobj},
tobj=MakeFlasher[r,h,m,dr,TypeMinimumAngle->10.\[Degree]];
Print[tobj[FlasherDetails]//ColumnForm];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{r=2,h=2,m=5,dr=.1,tobj},
tobj=MakeFlasher[r,h,m,dr,FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesZ, TypeMinimumAngle->10.\[Degree]];
Print[tobj[FlasherDetails]//ColumnForm];
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{r=2,h=2,m=4,dr=.05,tobj,verts,ijkmap,labels},
tobj=MakeFlasher[r,h,m,dr,TypeMinimumAngle->10.\[Degree]];
verts=tobj[Vertices];
ijkmap=tobj[FlasherIJKMap];
labels=Text[#[[1]],verts[[#[[2]]]],{0,2}]&/@ijkmap;
Show[{CreasePatternGraphics[tobj],Graphics[{labels}]}/.OrigamiStyle[]]
]//ShowExample
Clear[HexFlasherGraph3DAssigned];
AddTGraphExample[HexFlasherGraph3DAssigned,
Module[{r=2,h=2,m=6,dr=.05},
MakeFlasher[r,h,m,dr,FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesZ, TypeMinimumAngle->10.\[Degree]]]];
Module[{tobj},
tobj=HexFlasherGraph3DAssigned;
GraphicsRow[{CreasePatternGraphics[tobj],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]]//ShowExample
FlasherF::usage="FlasherF is a property of a paraboloidal flasher TObj that gives the focal length of the deployed paraboloid.";
FlasherDPGraph3D::usage="FlasherDPGraph3D is a property of a paraboloidal flasher TObj that gives a TGraph3DAssigned of the deployed paraboloid.";
MakeFlasherDP::badiso="Warning: isometry equations could not be satisfied. Residual error is `1.`";
MakeFlasherDP[r_,h_,m_,f_,dr_,opts___]:=Block[{vars,p,px,py,pp,ppx,ppy,ppz,dz,eqnfns,srules,allvars,newvars,fwd,bkd,args,soln,vertrules,isovals,cpsg,cplg,ffsg,fflg,picdia,pccdia,cpccdia,orverts,ffverts,oph,opw,cpicdia,ffdia,ffh,dpedges,ffedges,btverts,btedges,verts,edges,verts3d,tobj,vertsdp,tobjdp,allverts,allvinds,ijkmap,msgs},

(* PART I: solve for the flasher *)

vars={p,px,py,pp,ppx,ppy,ppz};
eqnfns=Join[
FlasherCPFns[vars,m],
FlasherIsometryDPFns[vars,r,h,m,f,opts],
FlasherXYFns[vars,r,h,m,dr],
FlasherOuterRingFns[vars,r,h,m,dr,dz],(* dz is now a variable *)
{Subscript[ppz, 0,0]}(* forces central polygon to z=0 *)
];
srules=Append[FlasherDefaultScalarRules[vars,r,h,m,dr],dz->0];
allvars=First/@srules;
newvars=Table[Unique[],{Length[allvars]}];fwd=MapThread[#1->#2&,{allvars,newvars}];bkd=MapThread[#2->#1&,{allvars,newvars}];args={eqnfns/.fwd,Transpose[{newvars,allvars/.srules}]};
soln=Check[(FindRoot@@args),Abort[],{}];
soln = soln /. bkd;
vertrules=FlasherVertexRulesDP[vars,m,f,soln];
isovals=Abs/@FlasherIsometryDPFns[vars,r,h,m,f,opts]/.soln;
If[Plus@@isovals>10^-6,Message[MakeFlasherDP::badiso,isovals]];

(* PART II: compute graphical bits and diagnostic info *)

(* graphical images, sector & pattern, dp & ff *)
cpsg=Graphics3D[FlasherLabeledSector["p",p,r,h,m,opts]]/.vertrules;
cplg=Graphics3D[FlasherLines[p,r,h,m,opts]]/.vertrules;
ffsg=Graphics3D[FlasherLabeledSector["pp",pp,r,h,m,opts]]/.vertrules;
fflg=Graphics3D[FlasherLines[pp,r,h,m,opts]]/.vertrules;

(* central polygon incircle diameter *)
picdia=1;
(* central polygon circumcircle diameter *)
pccdia=2*Mag[Take[Subscript[p, 0,0,0]/.vertrules,2]];
(* deployed paraboloid outermost vertices *)
orverts=FlasherOuterRingSectorVertices[p,r,h,m,0]/.vertrules;
(* deployed paraboloid incircle diameter *)
cpicdia=2*Min[Mag[Take[#,2]]&/@orverts];
(* deployed paraboloid circumcircle diameter *)
cpccdia=2*Max[Mag[Take[#,2]]&/@orverts];
(* outermost panel vertical(ish) edge length (approximately, height) *)
oph=Mag[(Subscript[p, r*h,r*h,0]-Subscript[p, r*h,(r-1)*h,0])/.vertrules];
(* outermost panel horizontal(ish) edge length (approximately width) *)
opw=Mag[(Subscript[p, r*h,r*h,0]-Subscript[p, r*h-1,r*h,0])/.vertrules];
(* outermost vertices in ff *)
ffverts=FlasherFirstSectorVerticesDistinct[pp,r,h]/.vertrules;
(* folded form circumcircle diameter *)
ffdia=2*Max[Mag[Take[#,2]]&/@ffverts];
(* folded form height *)
ffh=Max[Last/@ffverts]-Min[Last/@ffverts];

(* PART III: construct a TGraph3DAssigned *)

(* lists of point pairs for both cp and ff *)
dpedges=First/@Cases[FlasherLines[p,r,h,m,opts],_Line,{0,\[Infinity]}]/.vertrules;
ffedges=First/@Cases[FlasherLines[pp,r,h,m,opts],_Line,{0,\[Infinity]}]/.vertrules;
(* ordered 6-tuples, for indexification *)
btedges=MapThread[Join,{dpedges,ffedges},2];
{btverts,edges}=Indexify[btedges,2];
verts=Take[#,2]&/@btverts;
vertsdp =Take[#,3]&/@btverts;
verts3d=Take[#,{4,6}]&/@btverts;

(* Show wire frames of the CP, DP, and FF *)
GenericGraphGraphics[verts,edges,{},Frame->True]//Hold;
GenericGraphGraphics3D[verts3d,edges]//Hold;
GenericGraphGraphics3D[vertsdp,edges]//Hold;

(* Print the distinct vertices of the first sector *)
Graphics[{FlasherSectorFoldLines[p,r,h,0],FlasherVertexLabel["p",#]&/@FlasherAllVerticesDistinct[p,r,h,m]}]/.FlasherDefaultCPRules[p,m]//Hold;

(* Find any short edges by vertex coordinates *)
Sort[Mag[Subtract@@#]&/@dpedges]//Hold;
Module[{minlen,fl,flvr,flijk,fllen,flpairs,short},
minlen=0.1;(* test value for minimum-length edge *)
(* as symbolic vertices *)
fl=First/@Cases[FlasherLines[p,r,h,m,opts],_Line,{0,\[Infinity]}];
(* as numeric vertices *)
flvr=fl/.vertrules;
(* as {i,j,k} triples *)
flijk=fl/.{Subscript[p, i_,j_,k_]:>{i,j,k}};
(* lengths *)
fllen=Mag[Subtract@@#]&/@flvr;
(* pair ijk values with lengths *)
flpairs=MapThread[Append,{flijk,fllen}];
short=Select[flpairs,#[[-1]]<minlen&];
If[Length[short]>0,
Print["Too-short edges as {{i1,j1,k1},{i2,j2,k2},len}: ",short];
Abort[]];
];

(* Find any zero-length edges by index *)
Module[{zle},
zle=Select[edges,#[[1]]==#[[2]]&];
If[!ListEmptyQ[zle],Print["Zero-length edges: ",zle]]]//Hold;

(* Find vertex pairs that are close in the CP *)
Module[{vi,vj},
Do[vi=verts[[i]];
Do[vj=verts[[j]];
If[Mag[vi-vj]<0.2,
Print["Close vertex pair: i=",i,", j=",j,", \!\(\*SubscriptBox[\(\[CapitalDelta]\), \(verts\)]\)=",Mag[vi-vj],", \!\(\*SubscriptBox[\(\[CapitalDelta]\), \(btverts\)]\)=",Mag[btverts[[i]]-btverts[[j]]]]
],{j,i+1,Length[verts]}];
,{i,Length[verts]}];
]//Hold;

tobj=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[verts3d]//RecalcFoldAngles//ReassignGraph3D[#,opts]&;
(* Create another TGraph3D of the deployed state *)
tobjdp=MakeTGraph[verts,edges]//AddTPlaneGraph//AddTGraph3D[vertsdp]//RecalcFoldAngles//ReassignGraph3D[#,opts]&;
(* As a check on isometry, compute all the edge lengths in the deployed paraboloid and the folded form (stowed) and then compare their differences. *)
(Mag[Subtract@@verts3d[[#]]]&/@edges)-
(Mag[Subtract@@vertsdp[[#]]]&/@edges)//Chop//Hold;

(* Create a table of all vertices with symbolic values. Note that we need to use the deployed 3D vertex coordinates, rather than those of the CP. *)
allverts=FlasherAllVerticesDistinct[p,r,h,m];
allvinds=Take[Indexify[Join[vertsdp,allverts/.vertrules]][[2]],-Length[allverts]];
ijkmap=MapThread[{#1/.{Subscript[p, i_,j_,k_]:>{i,j,k}},#2}&,{allverts,allvinds}];

(*Indexify[obj, levspec, opts] takes an objectobjthat has points (lists of real numbers) at levellevpecand returns a list {pts, obj1} whereptsis a list of all unique points in the object andobj1is the same asobjbut with each point replaced by its index intopts.If you don't supplylevspec,level 1 is assumed.Options are:SamePtTolerance\[Rule]tol,wheretolis the distance tolerance passed to SamePtQ (when we use as the default comparison function).SameTest\[Rule]test,wheretestis the test for whether two points are the same.SamePtQ is the default,but we can also use Equal[] to compare algebraic point descriptions.StartPoints\[Rule]list,wherelistis a set of initial points to choose from.Use this if you already have a list and want to preserve the order.*)


(* add the additional properties *)
tobj//AddProperties[{
FlasherR->r,
FlasherH->h,
FlasherM->m,
FlasherF->f,
FlasherDPGraph3D->tobjdp,
FlasherLabeledCPSectorGraphics->cpsg,
FlasherLabeledFFSectorGraphics3D->ffsg,
FlasherCPGraphics->cplg,
FlasherFFGraphics3D->fflg,
 FlasherDetails->{
"central polygon incircle diameter"->picdia,
"central polygon circumcircle diameter"->pccdia,
"deployed paraboloid incircle diameter"->cpicdia,
"deployed paraboloid circumcircle diameter"->cpccdia,
"folded form circumcircle diameter"->ffdia,
"outermost panel height"->oph,
"outermost panel width"->opw
},
FlasherDetails2->{picdia,pccdia,cpicdia,cpccdia,ffdia,oph,opw},
FlasherIJKMap->ijkmap,
Allverts -> allverts,
Allvinds->allvinds,
Btverts -> btverts,
Verts -> verts,
Vertsdp -> vertsdp,
Verts3d -> verts3d,
Btedges -> btedges,
Edges -> edges}]]
Module[{r=2,h=2,m=4,f=6,dr=.05,tobj,tobjdp},
tobj=MakeFlasherDP[r,h,m,f,dr,TypeMinimumAngle->10.\[Degree]];
tobjdp=tobj[FlasherDPGraph3D];
Print[tobj[FlasherDetails]//ColumnForm];
GraphicsRow[{
CreasePatternGraphics[tobj],
Show[FoldedFormGraphics3D[tobjdp],Graphics3D[Style[Point[{0,0,f}],Red,PointSize[.02]]]],
FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{r=2,h=2,m=4,f=10^6,dr=.05,tobj,tobjdp},
tobj=MakeFlasherDP[r,h,m,f,dr,TypeMinimumAngle->10.\[Degree]];
tobjdp=tobj[FlasherDPGraph3D];
Print[tobj[FlasherDetails]//ColumnForm];
GraphicsRow[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobjdp],
FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{r=2,h=2,m=5,f=6,dr=.1,tobj,tobjdp},
tobj=MakeFlasherDP[r,h,m,f,dr,FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesZ, TypeMinimumAngle->10.\[Degree]];
tobjdp=tobj[FlasherDPGraph3D];
Print[tobj[FlasherDetails]//ColumnForm];
GraphicsRow[{
CreasePatternGraphics[tobj],
Show[FoldedFormGraphics3D[tobjdp],Graphics3D[Style[Point[{0,0,f}],Red,PointSize[.02]]]],
FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
Module[{r=2,h=3,m=6,f=5,dr=.2,tobj,tobjdp},
tobj=MakeFlasherDP[r,h,m,f,dr,TypeMinimumAngle->20.\[Degree]];
tobjdp=tobj[FlasherDPGraph3D];
Print[tobj[FlasherDetails]//ColumnForm];
GraphicsRow[{
Show[FoldedFormGraphics3D[tobjdp],Graphics3D[Style[Point[{0,0,f}],Red,PointSize[.02]]]],FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]
]//ShowExample
CutFlasherDP[tobj_TObj,opts___]:=Module[{tobjdp,r,h,m,f,verts,edges,faces,ijkmap,n,vi,cutedges,cutlines,labels,cverts,cedges,cfaces,fsverts,tobjcf},
tobjdp=tobj[FlasherDPGraph3D];
{r,h,m,f,verts,edges,faces,ijkmap}=GetValues[tobj,{FlasherR,FlasherH,FlasherM,FlasherF,Vertices,Edges,Faces,FlasherIJKMap}];
n = r h;
(* Lookup function for vertex index from {i,j,k} indices *)
vi[i_,j_,k_]:=Module[{pos},
pos=Position[First/@ijkmap,{i,j,k}];
If[ListEmptyQ[pos],0,ijkmap[[pos[[1,1]],2]]]];
(* Build list of cut edges as index pairs *)
cutedges={};
Do[
 (* bottoms *)
Do[AppendTo[cutedges,{vi[i,0,k],vi[i+1,0,k]}],{i,0,n-1}];
 (* diags *)
Do[AppendTo[cutedges,{vi[i,i+1,k],vi[i+1,i+2,k]}],{i,0,n-2}];
(* left axials *)
Do[Do[AppendTo[cutedges,{vi[i,h l,k],vi[i,Min[i+1,h l+h],k]}],{i,h l,n-1}],{l,1,r-1}];
(* right axials *)
Do[Do[AppendTo[cutedges,{vi[h l-1,j,k],vi[Min[j-1,h l-1+h],j,k]}],{j,h l+1,n-1}],{l,1,r-1}];
,{k,0,m-1}];
(* Change cutedges to be indices into edges *)
cutedges=Flatten[Join[Position[edges,#],Position[edges,Reverse[#]]]&/@cutedges];
(* Show the crease pattern with our cut lines *)
labels=Text[#[[1]],verts[[#[[2]]]],{0,2}]&/@ijkmap;
cutlines=Line[verts[[edges[[#]]]]]&/@cutedges;
Show[{CreasePatternGraphics[tobj],Graphics[{Style[cutlines,Red,Thickness[.015]],labels}]}/.OrigamiStyle[]]//Hold;
(* Cut the crease pattern along these edges *)
{cverts,cedges,cfaces}=SplitEdges[tobjdp, cutedges];
(* Create a face-shrunken version. *)
fsverts=FaceShrink[verts[[cverts]],cfaces,FaceShrinkage->0.2];
(* Debugging, show both the pre-cut and face-shrunk post-cut graphs *)
GraphicsRow[{GenericGraphGraphics[verts,edges,faces,VertexLabels->None,EdgeLabels->None,FaceLabels->None],GenericGraphGraphics[fsverts,cedges,cfaces,VertexLabels->None,EdgeLabels->None,FaceLabels->None]}]//Hold;
(* Build a new TPlaneGraph using the face-shrunk vertices for planarization, then using cverts as a key to build the true CP and DP. *)
tobjcf=MakeTGraph[fsverts,cedges]//AddTPlaneGraph//AddTGraph3D[tobjdp[Vertices3D][[cverts]]]//RecalcFoldAngles//ReassignGraph3D[#,opts]&;
FoldedFormGraphics3D[tobjcf]/.OrigamiStyle[]//Hold;
tobjcf=tobjcf//UnfoldGraph3D;
CreasePatternGraphics[tobjcf]/.OrigamiStyle[]//Hold;
tobjcf]
Module[{r=2,h=2,m=5,f=3,dr=.10,tobj,tobjdp,tobjcf},
tobj=MakeFlasherDP[r,h,m,f,dr,TypeMinimumAngle->20.\[Degree],FlasherSectorDiagFoldLines->FlasherSectorDiagFoldLinesZ];
tobjdp=tobj[FlasherDPGraph3D];
(* Show all three versions *)
GraphicsRow[{
CreasePatternGraphics[tobj],
FoldedFormGraphics3D[tobjdp],
FoldedFormGraphics3D[tobj]}/.OrigamiStyle[]]//Print;
(* Build the cut version *)
tobjcf=CutFlasherDP[tobj,TypeMinimumAngle->\[Pi]];
(* Show the crease pattern and deployed form of the cut version *)
GraphicsRow[{
CreasePatternGraphics[tobjcf],
FoldedFormGraphics3D[tobjcf]}/.OrigamiStyle[]]
]//ShowExample

(* Main Code *)
in = Import["in.csv"];

INM = in[[1, 1]];
INH = in[[1, 2]];
INR = in[[1, 3]];
INDR = in[[1, 4]];


(*INM = 5;
INH = 2;
INR = 2;
INDR = .10;*)

Module[{r=INR,h=INH,m=INM,f=10^6,dr=INDR,tobj,tobjdp},

tobj=MakeFlasherDP[r,h,m,f,dr,TypeMinimumAngle->10.\[Degree]];
tobjdp=tobj[FlasherDPGraph3D];

(*constraint definitions*)
FFboxwidth = tobj[FlasherDetails2][[5]];
FFboxheight = tobj[FlasherDetails2][[6]];
(*SF = 12/FFboxheight*.0254;*)
SF = 1;

(*
(*find limiting dimension*)
limdim = Max[FFboxwidth/22,FFboxheight/12]; (*limdim with normalization*)
if[limdim = FFboxwidth/22,SF = 22/limdim*.0254, SF = 12/limdim*.0254]; (*units in meters*)
"Folded Form Box Width"\[Rule] FFboxwidth/12*SF*1000/25.4 " inches",
"Folded Form Box Height" \[Rule] FFboxheight/22*SF*1000/25.4 " inches",
*)

(*scaling of specs*)
SFD = tobj[FlasherDetails2]*SF;
Sdr = dr *SF/2; 
NP = (h*(r^2 + r) + r)*m+1;
SCC = tobj[FlasherDetails2][[4]]*SF;
SIC = tobj[FlasherDetails2][[3]]*SF;

(*Display output values*)
(*Print[tobj[FlasherDetails]//ColumnForm];*)

Print[{"Normalized Values:",
"Folded form box width" -> FFboxwidth,
"Folded form box height" -> FFboxheight,
"",
"Scaled Values:",
"Folded Form Box Width"-> FFboxwidth*SF*1000/25.4 " inches",
"Folded Form Box Height" -> FFboxheight*SF*1000/25.4 " inches",
"Scaled Polygon Incircle Diameter" -> SFD[[1]] " meters",
"Deployed CC"-> SCC " meters",
"Deployed IC"-> SIC " meters",
"Thickness (dr * polygon length)" -> dr * SFD[[1]] * 100 " centimeters",
(*"Scaled dr" \[Rule] Sdr*1000/25.4 " inches",*)
"",
"General Info:",
"m" -> m,
"h" -> h,
"r" -> r,
"Number of Panels" -> NP,
"SFD Vector:" [SFD]}//ColumnForm];

Export["out.csv", SFD];

(* Other info
Print all coordinates of a flasher gore;
Print[tobj[FlasherIJKMap]];
Print[tobj[Allverts]];
Print[tobj[Allvinds]];
Print[tobj[Btverts]];
Print[tobj[Verts]];
Print[tobj[Vertsdp]];
Print[tobj[Verts3d]];
Print[tobj[Btedges]];
Print[tobj[Edges]];
*)
]



